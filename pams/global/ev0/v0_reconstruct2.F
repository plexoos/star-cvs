      INTEGER FUNCTION V0_RECONSTRUCT2(trak_h,trak,
     +     ev0par_h,ev0par,
     +     vertex_h,vertex,
     +     ev0out_h,ev0out,
     +     bfield)
 

      IMPLICIT NONE
C     Functional Description : Search for secondary vertices. 
C     K_0_short and Lambda particles
C     and anti-particles are 
C     considered. Only charged decay modes.
C     Created  MARCH-1994	  S. Margetis
C     Error conditions	: None-Yet
C     Status		: Tested with svt_hits
C                       :  JUNE-1997  H. Caines 
C                          Order in which calcs/tests were made was altered to
C                          improve speed of search
C
C     Modifications:
C         1.  Removed use of obsolete table evr_privert; L.Ray, 8/19/98
C----------------------------------------------------------------------
#include "PAM.inc"
#include "StDetectorId.inc"
#include "StVertexId.inc"
#include "dst_vertex.inc"
#include "dst_v0_vertex.inc"
#include "ev0_ev0par2.inc"
#include "ev0_track2.inc"
C---------------
  
      RECORD/ table_head_st/ ev0par_h
      RECORD/ ev0_ev0par2_st/ ev0par(*)
      RECORD/ table_head_st/ vertex_h
      RECORD/ dst_vertex_st/ vertex(*)
      RECORD/ table_head_st/ ev0out_h
      RECORD/ dst_v0_vertex_st/ ev0out(*)
      RECORD/ table_head_st/ trak_h
      RECORD/ ev0_track2_st/ trak(*)
    
      INTEGER 	ok
      INTEGER  	jk,det_id_i,det_id
      INTEGER   jkk
      INTEGER   ll,iflag,iflag1
      INTEGER   i,j,index
      
      REAL	mass1(3),mass2(3),pst1(3)
      REAL	rv,pst2(3)
      REAL	pdotp,ndotp,pv0,pv0sq,ppar,npar,pper
      REAL	trk1(6),trk2(6)
      REAL      trk1sav(6),trk2sav(6)
      REAL      xn1sav(2),xn2sav(2),x2,y2,z2,x1,y1,z1,check
      REAL	xcom(2),ycom(2),inv_mass,rmin
      REAL	xp(2),xn1(2),xn2(2),rd,xpp(3),massl(2),pp(3)
      REAL      env0,bv0,gv0,ep,ppar_cm,mainv(3),rap
      real      rdcheck(2),open,dot, bfield(3)! wkw
      real      temp ! gvb
      LOGICAL	first, updated
      DATA MASS1/0.139567,.93828,.139567/
      DATA MASS2/0.139567,.139567,.93828/
*
*
*-----executable statements--------------------------------------------

CC:  Load Primary vertex position coordinates:


      mainv(1) = 0.0
      mainv(2) = 0.0
      mainv(3) = 0.0
         do i = 1,vertex_h.nok
            if(vertex(i).vtx_id .eq. kEventVtxId
     +           .and. vertex(i).iflag .eq. 1) then
               mainv(1) = vertex(i).x
               mainv(2) = vertex(i).y
               mainv(3) = vertex(i).z
               go to 100
            end if
         end do
100      continue

*-----steering routine------------------------------------------------
*     
        
        ok=0
        first = .true.
        DO 10 i=1,trak_h.nok
*     First track is a positive
           
           IF(trak(i).q .lt. 0) GOTO 10
           
*    
           
C--   calculate impact parameter at main vertex--- wkw
           
           call ev0_project_track(trak(i).xc,trak(i).rc,mainv,xn1)
           
*           pv0 = trak(i).dca
           trak(i).dca=sqrt((xn1(1)-mainv(1))**2.+(xn1(2)-mainv(2))**2.)
*           if( abs(pv0-trak(i).dca) .gt. 0.5) then
*              write(6,*) '***',pv0, trak(i).dca
*           endif
           

C--   skip all tracks with impact parameter .lt. dcapnmin
           if( trak(i).det_id .eq. kTpcId )then
                 det_id_i = 1
           elseif( trak(i).det_id .eq. kSvtId .or.
     +                trak(i).det_id .eq.  kSsdSvtId .or.
     )                trak(i).det_id .eq. kSsdId )then
                 det_id_i = 2
           else
                 det_id_i = 3
           endif
           IF( (trak(i).dca.le.ev0par(det_id_i).dcapnmin)) GO TO 10 
C******************
C-- skip all SVT only tracks
c           if(det_id_i.eq.2)go to 10
C******************
           call ev0_track_mom(trak(i).r0,trak(i).rc,0,pst1,bfield(3))
           trak(i).p=sqrt(pst1(1)*pst1(1)+pst1(2)*pst1(2)
     +          +pst1(3)*pst1(3))
*     
*-----reject all tracks that are compatible with vertex within dr-----
*     
           
           DO 20 j=1,trak_h.nok

*     second track is a negative
              IF(trak(j).q .gt.0) GOTO 20
              if( trak(j).det_id .eq. kTpcId )then
                 det_id = 1
              elseif( trak(j).det_id .eq. kSvtId .or.
     +                trak(j).det_id .eq.  kSsdSvtId .or.
     +                trak(j).det_id .eq. kSsdId )then
                 det_id = 2
              else
                 det_id = 3
              endif

C******************
C-- skip all SVT only tracks
c           if(det_id.eq.2)go to 20
C******************

              if( first ) then

C--   I only have to calculate impact parameter ---
C--    and total mom for trak(j) first time I see it---
              

                 call ev0_project_track(trak(j).xc,trak(j).rc,mainv,xn2)
                 trak(j).dca=sqrt((xn2(1)-mainv(1))**2.+(xn2(2)-mainv(2))**2.)

C--   skip all tracks with impact parameter .lt. dcapnmin
                IF((trak(j).dca.gt.ev0par(det_id).dcapnmin)) then 

                 call ev0_track_mom(trak(j).r0,trak(j).rc,0,
     +                pst2,bfield(3))
                 trak(j).p=sqrt(pst2(1)*pst2(1)+pst2(2)*pst2(2)
     +                +pst2(3)*pst2(3))

                endif
              endif
                 
                 
C--   skip all tracks with impact parameter .lt. dcapnmin
                IF((trak(j).dca.le.ev0par(det_id).dcapnmin)) GO TO 20 


              if( det_id_i .eq. 1 .or. det_id .eq. 1)then
                 det_id = 1
              elseif( det_id_i .eq. 2 .or. det_id .eq. 2)then
                 det_id = 2
              endif
              xcom(1)=0
              xcom(2)=0
              ycom(1)=0
              ycom(2)=0
              iflag1=0
              call ev0_vzero_geom(ev0par(det_id).dca**2,
     +             trak(i).xc,trak(j).xc,
     +             trak(i).rc,trak(j).rc,xcom,ycom,iflag1)
              IF(iflag1.eq.5) GOTO 20
               
C---- two possible intersection points ---------------------------
c     Modified by wkw to pick the one which minimizes rd
c     
              rdcheck(1) = 9999999.0
              rdcheck(2) = 9999990.0
              updated = .false.

              DO jk=1,2
                 xp(1)=xcom(jk)
                 xp(2)=ycom(jk)
             
                 call ev0_project_track(trak(i).xc,trak(i).rc,xp,xn1)
                 call ev0_update_track_param(trak(i).xc,trak(i).rc,
     +                xn1,trak(i).r0,trk1,bfield(3))

C Test for "fake" vertex -> tracks heading away from vertex
                 call ev0_track_mom(trk1,trak(i).rc,0,
     +                pst1,bfield(3))
                 x1 = xn1(1)-mainv(1)
                 y1 = xn1(2)-mainv(2)
                 z1 = trk1(3)-mainv(3)
                 check=(x1*pst1(1))+(y1*pst1(2))+(z1*pst1(3))
                 IF(check.lt.0.0)then
                   trk1(3) = 99999.0
                   go to 11
                 endif

                 call ev0_project_track(trak(j).xc,trak(j).rc,xp,xn2)    
                 call ev0_update_track_param(trak(j).xc,trak(j).rc,
     +                xn2,trak(j).r0,trk2,bfield(3))

C Test for "fake" vertex -> tracks heading away from vertex
                 call ev0_track_mom(trk2,trak(j).rc,0,
     +                pst2,bfield(3))
                 x2 = xn2(1)-mainv(1)
                 y2 = xn2(2)-mainv(2)
                 z2 = trk2(3)-mainv(3)
                 check=(x2*pst2(1))+(y2*pst2(2))+(z2*pst2(3))
                 IF(check.lt.0.0)then
                   trk2(3) = 99999.0
                   go to 11
                 endif

 11              continue
                 if( trk1(3) .lt. 99990.0 .and. 
     +                trk2(3) .lt. 99990.0) then
                    rdcheck(jk)=(xn1(1)-xn2(1))**2+(xn1(2)-xn2(2))**2
     +                   +(trk1(3)-trk2(3))**2
                    updated = .true.
                 endif

              if(jk.eq.1)then
C               save current point so that no swimming back is necessary
                trk1sav(1)=trk1(1)
                trk2sav(1)=trk2(1)
                trk1sav(2)=trk1(2)
                trk2sav(2)=trk2(2)
                trk1sav(3)=trk1(3)
                trk2sav(3)=trk2(3)
                trk1sav(4)=trk1(4)
                trk2sav(4)=trk2(4)
                trk1sav(5)=trk1(5)
                trk2sav(5)=trk2(5)
                trk1sav(6)=trk1(6)
                trk2sav(6)=trk2(6)
                xn1sav(1)=xn1(1)
                xn2sav(1)=xn2(1)
                xn1sav(2)=xn1(2)
                xn2sav(2)=xn2(2)
              endif 
                 if( iflag1 .eq. 3) goto 12
              enddo
 12           continue
              if (rdcheck(1).lt.rdcheck(2) ) then ! go back to it
                 xp(1)=xcom(1)
                 xp(2)=ycom(1)
C restore first point so that no swimming back is necessary
              trk1(1)=trk1sav(1)
              trk2(1)=trk2sav(1)
              trk1(2)=trk1sav(2)
              trk2(2)=trk2sav(2)
              trk1(3)=trk1sav(3)
              trk2(3)=trk2sav(3)
              trk1(4)=trk1sav(4)
              trk2(4)=trk2sav(4)
              trk1(5)=trk1sav(5)
              trk2(5)=trk2sav(5)
              trk1(6)=trk1sav(6)
              trk2(6)=trk2sav(6)
              xn1(1)=xn1sav(1)
              xn2(1)=xn2sav(1)
              xn1(2)=xn1sav(2)
              xn2(2)=xn2sav(2)
 
C                 call ev0_project_track(trak(i).xc,trak(i).rc,xp,xn1)
C                 call ev0_update_track_param2(trak(i).xc,trak(i).rc,
C     +                xn1,trak(i).r0,trk1,bfield(3))
C                 call ev0_project_track(trak(j).xc,trak(j).rc,xp,xn2)
C                 call ev0_update_track_param2(trak(j).xc,trak(j).rc,
C     +                xn2,trak(j).r0,trk2,bfield(3))
              endif

              if( updated) then 

CC---------This part is added by Hui Long in order to include
CC-------  the 3D calculation of the v0_dca
                 call ev0_track_mom(trk1,trak(i).rc,0,
     +                pst1,bfield(3))
                 call ev0_track_mom(trk2,trak(j).rc,0,
     +                pst2,bfield(3))
                 temp = 1/trak(i).p
                 pst1(1)=pst1(1)*temp
                 pst1(2)=pst1(2)*temp
                 pst1(3)=pst1(3)*temp
                 temp = 1/trak(j).p
                 pst2(1)=pst2(1)*temp
                 pst2(2)=pst2(2)*temp
                 pst2(3)=pst2(3)*temp
                 rd=(trk1(3)-trk2(3))**2
                 call ev0_3D_dca(rd,pst1,pst2,trk1,trk2,xn1,
     +                xn2,trak(i).rc,trak(j).rc)
                 
                 call ev0_update_track_param(trak(i).xc,trak(i).rc,
     +                xn1,trak(i).r0,trk1,bfield(3))
                 
                 call ev0_update_track_param(trak(j).xc,trak(j).rc,
     +                xn2,trak(j).r0,trk2,bfield(3))  


CC  ----------------------------------------------------------------------
CC  -----------------------------------------------------------------------

C                rd=(xn1(1)-xn2(1))**2+(xn1(2)-xn2(2))**2
C     +                +(trk1(3)-trk2(3))**2
              else
                 rd = ev0par(det_id).dca**2 + 1.0
              endif
              IF( (rd.le.ev0par(det_id).dca**2)) then 
                 xpp(1)=(xn1(1)+xn2(1))/2.
                 xpp(2)=(xn1(2)+xn2(2))/2.            
                 xpp(3)=(trk1(3)+trk2(3))/2.
                 rv=sqrt((xpp(1)-mainv(1))**2+
     +                (xpp(2)-mainv(2))**2+(xpp(3)-mainv(3))**2)
*     
*---  decide here if it is a good candidate
*  
                 if(  (rv .gt. ev0par(det_id).dlen) ) THEN
                    massl(1)=mass1(1)
                    massl(2)=mass2(1)
                    call ev0_track_mom(trk1,trak(i).rc,0,pst1,bfield(3))
                    call ev0_track_mom(trk2,trak(j).rc,0,pst2,bfield(3))
C---- calculate the momentum components of the primary-----------
                    pp(1)  =pst1(1)+pst2(1)
                    pp(2)  =pst1(2)+pst2(2)
                    pp(3)  =pst1(3)+pst2(3)
                    pv0sq = pp(1)**2+pp(2)**2+pp(3)**2
C---- find square of impact param of reconstructed particle------
                    call ev0_v0_impact_param(mainv,xpp,pp,pv0sq,rmin
     +                   ,iflag)
                   
                    IF((rmin.le.ev0par(det_id).dcav0**2).and.
     +                   (iflag.ne.2)) THEN
                       ok=ok+1
                       
                       ev0out_h.nok= ev0out_h.nok+1
                       vertex_h.nok = vertex_h.nok +1
                       if (ok.ge.ev0out_h.maxlen .or.
     +                      vertex_h.nok .gt.  vertex_h.maxlen) then
                          call StWarning('Too many v0s')
                          return ! wkw
                       endif
                       vertex(vertex_h.nok).x=xpp(1)
                       vertex(vertex_h.nok).y=xpp(2)
                       vertex(vertex_h.nok).z=xpp(3)
                       vertex(vertex_h.nok).iflag = 0
                       vertex(vertex_h.nok).det_id = 
     +                      (100*trak(i).det_id)+trak(j).det_id
                       vertex(vertex_h.nok).vtx_id= kV0VtxId
                       vertex(vertex_h.nok).covar(1) = 0
                       vertex(vertex_h.nok).covar(2) = 0
                       vertex(vertex_h.nok).covar(3) = 0
                       vertex(vertex_h.nok).id_aux_ent= ok
                       vertex(vertex_h.nok).id = vertex_h.nok
                       vertex(vertex_h.nok).n_daughters = 2
                       vertex(vertex_h.nok).chisq(1) = 0
                       vertex(vertex_h.nok).chisq(2) = 0
                       vertex(vertex_h.nok).covar(1) = 0
                       vertex(vertex_h.nok).covar(2) = 0
                       vertex(vertex_h.nok).covar(3) = 0
                       vertex(vertex_h.nok).covar(4) = 0
                       vertex(vertex_h.nok).covar(5) = 0
                       vertex(vertex_h.nok).covar(6) = 0

                       ev0out(ok).id=ok
                       ev0out(ok).id_vertex= vertex_h.nok                    
                       ev0out(ok).dcap = trak(i).dca
                       ev0out(ok).dcan = trak(j).dca
                       ev0out(ok).dcapn = sqrt(rd)
                       ev0out(ok).dcav0=sqrt(rmin)
                       ev0out(ok).idpos=trak(i).id
                       ev0out(ok).idneg=trak(j).id
C--   calculate Armenteros variables---
                       ev0out(ok).pos_px = pst1(1)
                       ev0out(ok).pos_py = pst1(2)
                       ev0out(ok).pos_pz = pst1(3)
                       ev0out(ok).neg_px = pst2(1)
                       ev0out(ok).neg_py = pst2(2)
                       ev0out(ok).neg_pz = pst2(3)
                       
                       pdotp=pst1(1)*pp(1)+pst1(2)*pp(2)+pst1(3)*pp(3) !dot product of p+ and p(v0) 
                       ndotp=pst2(1)*pp(1)+pst2(2)*pp(2)+pst2(3)*pp(3) !dot product of p- and p(v0)
                       pv0  = sqrt(pv0sq) 
                       ppar= pdotp/pv0
                       npar= ndotp/pv0
                       temp = trak(i).p*trak(i).p-ppar*ppar
                       if( temp .lt.0 ) then
C                          write(6,*) 'Found one'
                          pper = 0.
                       else
                          pper = sqrt(temp)
                       endif
C                       ev0out(ok).pt = pper
C                       ev0out(ok).alpha = (ppar-npar)/(ppar+npar)
                       if( pper .gt. ev0par(det_id).ptarm_max  
     +                     .or.  abs((ppar-npar)/(ppar+npar)) .gt. 
     +                      ev0par(det_id).alpha_max) then
                          ok=ok-1
                          ev0out_h.nok= ev0out_h.nok-1
                          vertex_h.nok = vertex_h.nok -1
                          goto 20
                       endif
C                       ev0out(ok).sagitta_pos = trak(i).sagitta
C                       ev0out(ok).sagitta_neg = trak(j).sagitta
                       
                       
c     Opening angles: wkw
C                       dot=pst1(1)*pst2(1)+pst1(2)*pst2(2)
C     +                      +pst1(3)*pst2(3)
C                       open=(dot/(trak(i).p*trak(j).p))
C                       if( open .gt. 1.0) then
C                          open = 1.0
C                       elseif( open .lt. -1.) then
C                          open = -1.0
C                       endif
C                       ev0out(ok).theta = acosd(open)
*     
*---  if blind run test all mass hypothesis
*     
                       
C                       DO ll=1,3
C                          massl(1)=mass1(ll)
C                          massl(2)=mass2(ll)
C                          index=ll
                          
C                          call ev0_inv_mass(trak(i).p,trak(j).p,massl,
C     +                         pv0sq,pp(3),inv_mass,env0,ep,rap)
                          
C                          if( index .eq. 1) then
C                             ev0out(ok).inv_mass_k0=inv_mass
C                             ev0out(ok).rapidity_k0 = rap
C-- calculate proper lifetime assuming that particle originated at main vertex
C                             ev0out(ok).tau_k0=inv_mass*rv/pv0
C                          elseif( index .eq. 2) then
C                             ev0out(ok).inv_mass_la=inv_mass
C                             ev0out(ok).rapidity_la = rap
C-- calculate proper lifetime assuming that particle originated at main vertex
C                             ev0out(ok).tau_la=inv_mass*rv/pv0
C                          elseif( index .eq. 3) then
C                             ev0out(ok).inv_mass_lb=inv_mass
C                             ev0out(ok).rapidity_lb = rap
C-- calculate proper lifetime assuming that particle originated at main vertex
C                             ev0out(ok).tau_lb=inv_mass*rv/pv0
C                          endif
                                 
C                    ev0out(ok).tmin(index)=inv_mass*ev0par(det_id).dlen/pv0 
c--   calculate cos(theta_c.m.)
C                          bv0  =pv0/env0
C                          gv0  =env0/inv_mass
C                          ppar_cm=gv0*(ppar-bv0*ep)
C                          ev0out(ok).cos_th_cm(index)=
C     +                         cos(atan2(pper,ppar_cm))
c     
c                          WRITE(6,*) rd,rv,rmin,inv_mass
C                          
C                       ENDDO
                       GOTO 30  !next j
*                    else
*                       if( j.eq. i+1 ) then
c                        write(6,*) 'rmin =',rmin,i,j,trak(i).id,
c     >                         trak(j).id,trak(i).r0,trak(j).r0
*                       endif
                    ENDIF       !rmin and iflag check
*                 else
*                    if( j.eq. i+1 ) then
c                      write(6,*) 'rv =',rv,i,j,trak(i).p,trak(j).p
*                    endif
                 ENDIF          !rv check      
*              else
*                 if( j.eq. i+1 ) then
c                    write(6,*) 'rd =',rd,i,j,trak(i).id,trak(j).id
c     >                   ,trak(i).z0,trak(j).z0,xn1(1),xn1(2),
c     >                   xn2(1),xn2(2),trk1(3),trk2(3)
*                    trak(i).q = 100.
*                    trak(j).q = 100.0
*                 endif  

              endif ! rd check
              
              IF(iflag1.eq.3) GOTO 30 !touching circles-loop once
              
 30           CONTINUE
              
 20        CONTINUE

           first = .false.

 10     CONTINUE	
        
          
 999    RETURN
        END
      

