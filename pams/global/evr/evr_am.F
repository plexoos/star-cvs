CC:>--------------------------------------------------------------------
CC: FILE:       evr_am.F
CC: HISTORY:    
CC:           see below
CC:<--------------------------------------------------------------------

      INTEGER*4 FUNCTION EVR_AM(
     1            evrpar_h,            evrpar ,
     2           globtrk_h,           globtrk ,
     3           privert_h,           privert ) 
      IMPLICIT NONE
#include "evr_am.inc"
#include "math_constants.inc"
#include "phys_constants.inc"
#include "StDetectorId.inc"
#include "StVertexId.inc"
#include "StTrackMethod.inc"

CC:>----------------------------------------------------------------------
CC: ROUTINE:    EVR
CC: DESCRIPTION: Vertex fit, least square method with outlier removal
CC: AUTHOR:     S. Margetis  Created  MARCH-1992
CC: ARGUMENTS:
CC:          IN:
CC:	       	evrpar   = Parameters controlling vertex finding
CC:       	globtrk  = Track information from egr package; uses the
CC:                        first instance of the global track table
CC:                        corresponding to the fit or refit of only the
CC:                        space points from the tracking detectors.
CC:	       	privert  = Information on fixed vertex, if any. For a fixed
CC:                        primary vertex, the value of both chisq=-1.0.
CC:         OUT:
CC:	       	privert  = Primary Vertex Information
CC:      UPDATE:
CC:             globtrk.id_start_vertex -- used to indicate primary
CC:                        track candidates based on 3D DCA cut from
CC:                        the found primary vertex; also used to indicate
CC:                        which tracks were used in the final primary
CC:                        vertex fit (see following explanation of
CC:                        packing algorithm).
CC:             globtrk.impact -- Three dimensional distance of closest
CC:                               approach (3D DCA) to the final primary
CC:                               vertex for all good global tracks (i.e.
CC:                               those with iflag > 0) which have
CC:                               TPC and/or SVT and/or SSD space points
CC:                               (not FTPC tracks).
CC:
CC:     Output variables in table privert:
CC:     ----------------------------------
CC:     privert().id        = Primary key; value of privert_h.nok when
CC:                           row is filled
CC:               iflag     = +yx1 for normal, successfully found primary vertex
CC:                                during the 3rd iteration
CC:                         = -yx3 for initial seed value
CC:                         = -yx2 for first iteration value
CC:                         = -yx1 for second iteration value
CC:                         = -yx4 for failed fit with Determinant of G = 0.0,
CC:                                occuring during any iteration.
CC:                         = -yx5 for failed error covariance matrix evaluation
CC:                                during fit with Determinant of E = 0.0,
CC:                                occuring during any iteration.
CC:                         = -yx6 for failed vertex finding due to too few
CC:                                tracks occuring anytime after the initial
CC:                                vertex seed has been found.
CC:                         = -yx7 for failed vertex finding due to too low
CC:                                a fraction of selected tracks relative
CC:                                to the total number of global tracks in seed
CC:                                occuring anytime after the initial vertex
CC:                                seed has been found.
CC:                         = -yx8 for failed vertex finding due to both of
CC:                                the previous two conditions occuring anytime
CC:                                after the initial vertex seed has been
CC:                                found.
CC:                            x is the event vertex id (for pileups). Zero
CC:                              means one vertex, x=1 is the next one etc.
cc:                            y is the det_id for prevertex finding only. 
cc:                            y=0 is not prevertex, y=1 TPC prevertex, 
cc:                            y=2 SVT, y=3 FTPC etc. det_id compliments this info.
CC:               det_id    = Detectors contributing to all tracks used for
CC:                           primary vertex finding/fitting:
CC:                           This quantity, based on the definitions in
CC:                           $STAR/pams/global/inc/StDetectorDefinitions.h,
CC:                           indicates the full
CC:                           list of tracking detectors which contributed
CC:                           to all the tracks used in determinig the primary
CC:                           vertex.  This might include the SVT, SSD and
CC:                           TPC.  The FTPCs are not included in this, nor
CC:                           in the primary vertex finding process.  The
CC:                           tracks from the initial global track selection
CC:                           loop (do 20 loop) are used for this determination.
CC:                           The 'det_id' from this initial, selected set of
CC:                           tracks is reported for each primary vertex
CC:                           iteration. The following algorithm is used:
CC:                           
CC:                           Detectors contributing        Value assigned to
CC:                              to tracks used             privert().det_id
CC:                           -----------------------------------------------
CC:                           TPC only                      kTpcId
CC:                           SVT only                      kSvtId
CC:                           SSD only (nonsense case)      kSsdId
CC:                           TPC & SVT, not SSD            kTpcSvtId
CC:                           TPC & SSD, not SVT            kTpcSsdId
CC:                           SSD & SVT, not TPC            kSsdSvtId
CC:                           SVT, SSD and TPC              kTpcSsdSvtId
CC:                           -----------------------------------------------
CC:               vtx_id    = kEventVtxId (defined in $STAR/pams/global/inc/
CC:                           StVertexDefinitions.h),
CC:                           indicates the primary vertex
CC:             n_daughters = number of tracks used at each iteration in the
CC:                           fit; only good global tracks with SVT and/or
CC:                           SSD, and/or TPC segments are used and counted.
CC:                           FTPC tracks are not used and are not counted.
CC:             x,y,z       = Primary vertex coords in STAR global c.s. (cm)
CC:          covar(1,2...6) = Covariance error matrix for vrtx position (cm^2)
CC:                           defined in DST document for table dst_vertex.
CC:                chisq(2) = Chi-Square of fit per d.o.f. (number of tracks
CC:                           used minus number of varied quantities, the latter
CC:                           corresponds to one vertex position, so #d.o.f. =
CC:                           ntrks-used - 1).  The second value is the 
CC:                           probability of chi-square calculated using the
CC:                           CERNLIB function PROB(X,N).
CC:            id_aux_ent   = 0; used by ev0 for auxiliary vertex table
CC:                              reference, not used by evr.
CC:
CC:     Update variables in table globtrk:
CC:     ---------------------------------
CC:         id_start_vertex = {0, if track is not used in final vertex fit;
CC:                           OR 1, if track is used in final vertex fit}
CC:                           + {10 * privert(final prim. vrtx row#).id,
CC:                              if track passes 3D DCA cut}
CC:                           
CC:                           This marks all global tracks with respect to
CC:                           usage in final primary vertex fit and with
CC:                           respect to a 3D DCA cut from the found primary
CC:                           vertex using the distance cut in
CC:                           evrpar(1).vcut.
CC:         impact          = Three dimensional distance of closest
CC:                           approach (3D DCA) to the final primary
CC:                           vertex for all good global tracks (i.e.
CC:                           those with iflag > 0) which have
CC:                           TPC and/or SVT and/or SSD space points
CC:                           (not FTPC tracks).
CC:                           
CC: RETURNS:    STAF Condition Value
CC:     The code returns one of the following condition values:
CC:
CC:          STAFCV_OK      - indicates normal, successful completion of
CC:                           vertex finding all the way to the final, third
CC:                           fit iteration; indicates to the calling
CC:                           program that event processing should continue.
CC:                           
CC:          STAFCV_BAD     - The following error conditions will result
CC:                           in evr_am returning this STAF condition value:
CC:                           (1) The number of selected tracks for vertex 
CC:                               finding is less than ntrkcut (=3) during
CC:                               any iteration.
CC:                           (2) The ratio of the number of selected global
CC:                               tracks to total number of global tracks
CC:                               with DCA points within the Z-DCA sequence
CC:                               and beam pipe volume is less than the
CC:                               volumetric ratio of a sphere of radius
CC:                               sqrt(3)*sigma(Z_DCA seq.) [corresponding to
CC:                               to the final track cut, dca_cut3] to the
CC:                               sequence-beam pipe volume or, if these have
CC:                               problematic values, less than the default
CC:                               value 'ntrkratiocut' (set to 0.1) during
CC:                               any iteration.
CC:                           (3) The primary vertex table, 'privert', is
CC:                               already filled to its maximum length and
CC:                               cannot have new vertex information added.
CC:                           (4) The detector ID code numbers from 
CC:                               $STAR/pams/global/inc/StDetectorDefinitions.h
CC:                               are out of the assumed range from 1 to 30.
CC:                           (5) The vertex seed z-position lies outside the
CC:                               detector fiducial as specified by parameter
CC:                               'zrange' (=200 cm).
CC:                           (6) The number of tracks associated with the
CC:                               Z-DCA sequence, 'ntracks_seq', is .lt.
CC:                               ntrkratiocut*(globtrk_h.nok - 50).  This
CC:                               eliminates bad events which have mostly
CC:                               garbage tracks.
CC:                           
CC: ERROR CONDITIONS	: None-Yet
CC: STATUS		: Tested
CC: MODIFIED TO WORK IN TAS : E. G. Judd, November 1993
CC:   Added switches so the vertex finder can use TPC, SVT or global tracks.
CC:         Also added cuts on pt, and whether or not the track has been
CC:         matched, to improve track selection : E. G. Judd, April 1994
CC: MODIFIED TO WORK IN STAF : S. Margetis, November 1996
CC:
CC:  Modified for greater accepted range in z for vertex position; array
CC:  bounds checking; unused array cleanup; and bug fixes by L. Ray on
CC:  Feb. 22, 1999
CC:
CC:  Following modifications by R.L.Ray during May, 1999:
CC:  (1)  Include optional re-calculation of helix track projection and
CC:       distance of closest approach (DCA) determination for new
CC:       vertex position at each iteration.
CC:  
CC:  (2)  Save initial vertex seed position as well as iterations 1 and 2
CC:       values in privert table with iflag values set as noted above.
CC:  
CC:  (3)  Compute primary vertex covariance matrix and save diagonal
CC:       components in table privert.
CC:       CHANGE July 1999: Save complete primary vertex position covariance
CC:                         matrix in privert().covar[6]
CC:  
CC:  (4)  Estimate multiple Coulomb scattering (MCS) error contribution to
CC:       the uncertainty (sigma) in the extrapolated track position at the
CC:       DCA point.  Use in vertex fit.  Assumes all tracks are TPC only
CC:       and that MCS in TPC inner field cage is dominant effect.  Uses
CC:       spatial rms MCS angle.  Assumes pion mass for MCS angle calculation
CC:       for all tracks.
CC:
CC:       NOTE:  This part will need to be generalized when global tracks
CC:              include SVT tracks and SVT-TPC matched tracks.
CC:       CHANGE July 1999: code checks for SVT or SSD track segments and
CC:                         if these occur an effective SVT radiation 
CC:                         thickness for the first SVT layer is used to
CC:                         estimate the MCS sigma. 
CC:  
CC:  (5)  Modified/corrected helix projection subroutine.
CC:  
CC:  (6)  Include straight track (no B field case) track projection.
CC:  
CC:  (7)  Modified/corrected 3-D DCA subroutine for special case.
CC:  
CC:  (8)  General cleanup and QA verification.
CC:  
CC:  (9)  Use input global track covariance matrix to calculate the
CC:       track position uncertainty at the extrapolated DCA point.
CC:       Use this as an error (sigma) in the i-th track DCA point
CC:       and add in quadrature with the MCS error.
CC:       CHANGE July 1999: Use the Kalman filter/fitter definition; use
CC:                         new global track table (dst_track) with full
CC:                         track fit covariance matrix; use of old
CC:                         globtrk_aux removed.
CC:
CC: (10)  Compute chi-square per track used in fit and save in
CC:       privert().pchi2
CC:       CHANGE July 1999: Compute chi-square per degree of freedom and
CC:                         probability of chi-square and save in
CC:                         privert().chisq(1,2), respectively.
CC:
CC:  Additional changes made in July 1999 by R. L. Ray:
CC:
CC: (11)  Use Detector ID and Vertex ID codes defined in $STAR/pams/global/inc/
CC:       StDetectorDefinitions.h and StVertexDefinitions.h
CC:
CC: (12)  Modified code for no magnetic field case.  If abs(Bz).le.0.001 kGauss,
CC:       Bz is set to 0.0.  In order to have some estimate of the MCS error
CC:       an arbitary value of pT = 0.4 GeV/c is assumed.  The charge is also
CC:       assumed to be +1 for the no B field runs.
CC:
CC: (13)  Calculate 3D DCA to final primary vertex for all good global tracks
CC:       and load into globtrk().impact.
CC:
CC: (14)  Modified for new global track parameters r0,phi0 - 9/29/99 (L.Ray)
CC:
CC: (15)  Corrected handling of anomalously small values of extrapolated
CC:       track position errors; hard coded pion mass (0.14) in multiple
CC:       Coulomb scattering estimate - R. L. Ray, March, 2000.
CC:
CC: (16)  Revised the event abort criteria and diagnostic output - R. L. Ray,
CC:       April, 2000.
CC:
CC: (17)  Use weighted means for initial seed values for vertex z-position
CC:       and for x,y-positions for the case when the beam-beam axis is not
CC:       coincident with the x = y = 0 axis - R. L. Ray, April, 2000.
CC:
CC: (18)  Replaced math library functions sind and cosd with locally
CC:       defined functions - R. L. Ray, April, 2000.
CC:
CC: (19)  Added extra track selection criteria based on a minimum number of
CC:       space points used in the global track fit - R. L. Ray, April, 2000.
CC:
CC: (20)  Changed most Real variables to Real*8 and used explicit double
CC:       precision functions, e.g. dsin(), etc. - Nov. 2000, G. van Buren.
CC:
CC:  Changes in Feb.-April 2001 - R. L. Ray
CC:
CC: (21)  Include Year 2000 run's beam line coordinates in vertex fit with
CC:       small error in order to constrain the transverse vertex position
CC:       for low multiplicity events.  Numbers are hardwired into code and
CC:       should only be used for production of real Y2K data.
CC:       Use the beamline coordinates from Jamie Dunlop's analysis, Mar. 21,
CC:       2001; see http://www.star.bnl.gov/protected/spectra/dunlop/
CC:       vertex_Mar202001/.  Activate this constraint by setting parameter
CC:       evrpar(1).fitoption = 2; otherwise the error associated with the
CC:       beam line is set to 100. cm which effectively removes it from the
CC:       fitting.  The latter should be done for simulations.
CC:
CC: (22)  Extend vertex search region to include full beam pipe volume out 
CC:       to +/- 6m, but only proceed with vertex fitting if seed is within
CC:       TPC, or if |z_seed| <= 2m.  Also, only tracks with DCA points
CC:       within the sequence of z-bins near the seed are used to determine
CC:       the <x>, <y> of the vertex seed.
CC:
CC: (23)  Use variable DCA binning as determined using parameter values
CC:       in code; but use 2x larger z-DCA bins for low multiplicity events
CC:       where globtrk_h.nok <= 50.
CC:
CC: (24)  Track DCA acceptance for each iteration of the vertex
CC:       fit is based on distance cuts computed from the rms of the
CC:       z distribution in the z-DCA sequence.  Preset DCA cuts are
CC:       no longer used directly but are used to limit the computed cuts.
CC:
CC:       New track acceptance criteria:
CC:        a) For the initial seed finding use all DCA points to the x=y=0
CC:           z-axis that lie within the beampipe volume and |z| <= 6m.
CC:        b) Select and proceed with fitting for seeds with <z> within
CC:           TPC as specified from -zrange to +zrange (zrange = 200 cm).
CC:        c) Check #tracks associated with seed Z-DCA sequence and if
CC:           .lt. ntrkratiocut*(globtrk_h.nok - 50) then STOP vertex find/fit
CC:           and return to calling program with STAFCV_BAD.
CC:        d) Fill x,y DCA histograms for sqrt(x*x+y*y) within beampipe and
CC:           for z within z-DCA sequence range, the latter is nominally
CC:           <z> of seed +/- 'def_seq_range_z' (=2cm).
CC:        e) For First fit iteration:
CC:              select tracks with z-DCA within seed sequence range along
CC:              z-axis and transverse x,y DCAs within the larger of
CC:                 evrpar(1).cutxy OR 3*sqrt(2)*sigmaz,
CC:              but not larger than the beampipe radius, in transverse
CC:              distance from the vertex seed.
CC:        f) For Second fit iteration:
CC:              select tracks with DCA point within 3D distance of the
CC:              larger of 2*sqrt(3)*sigmaz or evrpar(1).cut2, but not
CC:              larger than 2*sqrt(3)*sigdef, where sigdef = 1.0 cm.
CC:        g) For Third (final) fit iteration:                 
CC:              select tracks with DCA point within 3D distance of the   
CC:              larger of sqrt(3)*sigmaz or evrpar(1).cut3, but not
CC:              larger than sqrt(3)*sigdef, where sigdef = 1.0 cm.
CC:
CC:           where  sigmaz = rms of z-DCA sequence
CC:                  sqrt(2)*sigmaz = two-dimensional Gaussian rms
CC:                  sqrt(3)*sigmaz = three-dimensional Gaussian rms
CC:
CC:        h) For primary track candidate marker, use 3D DCA from final
CC:           vertex with evrpar(1).vcut as before.
CC:
CC: (25)  Track fit covariance matrix automatically used if globtrk.method
CC:       is 2**kKalmanFitId (i.e., if the Kalman track fitter was used).
CC:
CC: (26)  Changed minimum track number and track ratio requirements to:
CC:        a) minimum number of tracks at each step must be .ge. ntrkcut (=3)
CC:        b) initial number of selected tracks from DO 20 loop must be
CC:           .ge. ntrkratiocut (=0.1)*(globtrk_h.nok)
CC:        c) for all subsequent iterations the ratio of the number of
CC:           accepted tracks after each cut to the total number in the seed
CC:           z-DCA sequence volume must be .ge. the ratio of the 3D dca_cut3
CC:           volume to the z-DCA sequence volume, where these are given by:
CC:                3D dca_cut3 Vol. = (4*pi/3)*(dca_cut3**3)
CC:                z-DCA seq. Vol.  = pi*(beampipe radius**2)*(length of seq)
CC:           For problematic cases the default 'ntrkratiocut' = 0.1 is used.
CC:
CC: (27)  Reduced the array sizes for local track arrays from 20000 to 5000
CC:       to better match the actual size of RHIC AuAu events.
CC:
CC: (28)  Increased the required number of hits on selected tracks from 10
CC:       to .ge. 25.
CC:
CC:  METHOD:
CC:  Minimization of the perpendicular distances from the vectors to a point.
CC:
CC:  Consider an arbitrary vector Vi, with a unit vector in the direction
CC:  The distance from a point P to the vector Vi is the crossproduct of the 
CC:  unit vector e(Vi)^ with any line connecting P to any point Q on the line.
CC:  Line PQ = (x0-xi)x^+(y0-yi)y^+(z0-zi)z^
CC:	P=(x0,y0,z0)    Q=(xi,yi,zi)
CC:  The distance is: |d|=|PQ X e(Vi)^|
CC:
CC:  A least square minimization employs a merit function (chi square) to 
CC:  assess quality of fit.  The optimum values of the variables are 
CC:  determined by where the partial derivatives of the merit function are
CC:  equal to zero.  For this case, the merit function is the summation of
CC:  the squares of the perpendicular distances from the vectors (Vi) to a 
CC:  point (Xo, Yo, Zo) [divided by the squares of the uncertanty
CC:  errors?] (sumation over vector number).  The partial derivatives are taken
CC:  with respect to x0, y0, and Z0.  We are left with three equations 
CC:  for three unknowns (Xo,Yo,Zo).  The evaluation is done through matrix 
CC:  manipulation.
CC:
CC:>----------------------------------------------------------------------

CC:  Variables in common with Subroutines:
      INTEGER   maxtr
      PARAMETER (maxtr=5000)
      REAL*8    vtrv(6,maxtr)
      COMMON    /FITVERT/ vtrv
      REAL*8    XV,YV,ZV,cov(6),chisq
      COMMON    /VERTEX/ XV,YV,ZV,cov,chisq

CC  Local Variable Type Declarations:
      REAL*8 dr,x0(maxtr),y0(maxtr),z0(maxtr),phi0(maxtr),tanl(maxtr)
      REAL*8 sig,sigma(maxtr),vertex_pass(3,3)
      REAL*8 psi,ppt,xx0,yy0,zz0,tanla
      REAL*8 xp(2),x(4),xxv(3),xa0(3),pa0(3),x3d0(3)
      REAL*8 seed,LIFC,LRAD,LSVT1
      REAL   xlocal(3),bfield(3),b,bfield_min,chisq1
      REAL*8 ptdefault,pptdef
      REAL*8 ntrkratio, ntrkratiocut, sumbin
      REAL*8 zlowercut, zuppercut, sigmaz, zlocal
      REAL*8 dca_cut1, dca_cut2, dca_cut3
      REAL*8 volume_seq, volume_fit3, volume_ratio

      INTEGER   i,j,k,ipnt,ntrk,index,gindex(maxtr),icharge
      INTEGER   fitoption,covariance,ntrkcut
      INTEGER   maxdettypes, k_fit_call, ntracks_seq
      PARAMETER (maxdettypes = 30)
      INTEGER   detIdOK,dettrkcounter(maxdettypes)
      INTEGER   DetectorId, DetectorIdSave
      INTEGER   flagset1, flagset2, bin_max, bin_low, bin_high, maxval

CC  Declare new variables used in track cov() matrix contribution to sigma:
      REAL*8 h(5,5),xsave(3),p(5),pnew(5),del(5),pcall(8)
      REAL*8 deriv(3,5),derrorsq,derror,r0save,phi0save
      REAL*8 sigdef,sigmin,sigmax,sigbig
      INTEGER  ii,jj,ialpha,ibeta

CC  Local Variable Type and Parameter Declarations for quantities used
CC  to define the beampipe volume and binning for the DCA points.
CC
CC     The beampipe volume is assumed to be:
CC        (1) cylinder of radius 6.5 cm from z = -600 to -385 cm
CC        (2) cylinder of radius 4.0 cm from z = -385 to +385 cm
CC        (3) cylinder of radius 6.5 cm from z = +385 to +600 cm
CC     The domains along z are set by parameters:
CC        zlimit1 = 385 (cm)
CC        zlimit2 = 600 (cm)
CC     The beampipe radii are set by parameters:
CC        beampipecut1 = 4.0 (cm)
CC        beampipecut2 = 6.5 (cm)
CC
CC     The distribution of DCA points is binned along the z-axis in 0.5 cm
CC     bins (dz_default) for a total number of 2400 (nbins).  For low
CC     multiplicity events where globtrk_h.nok .le. 50, larger 1.0 cm bins,
CC     1200 total, are used.  The value of dz is set to either dz_default or
CC     2*dz_default, depending on the value of globtrk_h.nok.
CC
CC     The DCA points are binned in x,y in 0.1 cm bins (dxy) for a total of
CC     80 + 1 (for round-off error) bins (nxybins) and is only done within the
CC     z-DCA sequence and then only for seeds within the detector zrange from
CC     z = -200 to +200 cm.
CC
CC     The lower limit in z for the vertex seed search is
CC        zmin = -zlimit2 = -600 cm
CC
CC     The vertex seed sequence is located along the z-axis in bins
CC        centered about the maximum occupied bin +/- 'def_seq_range_z'
CC        which is set to 2 cm.  Similarly, for x,y the range is
CC        'def_seq_range_xy' = 1.5 cm.
CC
CC     The DCA x,y,z histograms are loaded into local integer arrays,
CC        xsum, ysum, zsum

      Integer  nbins, nxybins
      REAL*8   zlimit1, zlimit2, beampipecut1, beampipecut2
      REAL*8   dz, dxy, zmin, dz_default, zrange
      REAL*8   def_seq_range_z, def_seq_range_xy
      Parameter(nbins         = 2400)
      Parameter(nxybins       = 81)
      Parameter(zlimit1       = 385.0)
      Parameter(zlimit2       = 600.0)
      Parameter(beampipecut1  = 4.0)
      Parameter(beampipecut2  = 6.5)
      Parameter(dz_default    = 0.5)
      Parameter(dxy           = 0.1)
      Parameter(zmin          = -600.0)
      Parameter(zrange        = 200.0)
      Parameter(def_seq_range_z = 2.0)
      Parameter(def_seq_range_xy = 1.5)
      Integer  xsum(nxybins), ysum(nxybins), zsum(nbins)

CC  Declare called CERNLIB Function:
      REAL PROB

CC  Load Constants:
CC    DATA LIFC  /0.0133/   ! TPC Inner Field Cage radiation thickness
CC                          ! fraction from STAR CDR (1992).
      DATA LIFC  /0.0055/   ! TPC Inner Field Cage radiation thickness
CC                          ! fraction from GSTAR data (1999).
      DATA LSVT1 /0.017/    ! Effective SVT first layer radiation thickness
CC                          ! to roughly approximate MCS effects on track
CC                          ! DCA position uncertainty with SVT and/or SSD hits.
      DATA ntrkcut  /3/     ! Min. trk # at each step in the finding/fitting
      DATA ntrkratiocut /0.1/! Default min. acceptable track ratio (see above)
      DATA ptdefault /0.4/  ! Default pT value in GeV/c for use in B_field = 0
CC                          ! cases for estimating MCS error contribution to
CC                          ! the uncertainty in the track's DCA to prim. vrtx.
      DATA bfield_min /0.1/ ! Lower cutoff on abs(B_field, z component) in
CC                          ! kGauss, below which this case is taken to be
CC                          ! a zero magnetic field run; b is set to 0.000 .
CC                          ! Same value used in TPC tracking code, tpt.

CC  The following parameters are used for the extrapolated track position
CC  uncertainty (sigma) at the DCA point to the primary vertex due to the
CC  errors in the track helix parameters.
      DATA sigdef  /1.0/    ! Default track position sigma (cm) at DCA point
      DATA sigmin  /0.1/    ! Minimum track position sigma (cm) at DCA point
CC                          ! Changed from 0.01 to 0.1 on Feb. 12, 2001 by
CC                          ! RLR to be compatible with the minimum error
CC                          ! assigned in Subr: EVR_VERTEX_FIT
      DATA sigmax  /10.0/   ! Maximum track position sigma (cm) at DCA point
      DATA sigbig  /100.0/  ! Upper cutoff track position sigma (cm), DCA point
CC  If the computed track position uncertainty ('error') using the helix
CC  parameter covariance matrix is:
CC
CC  (1)  crazy (i.e. 'error'**2 .le. 0.0 OR 'error' .gt. sigbig)
CC       then the track position sigma is set to the default, sigdef.
CC  (2)  less than sigmin, then 'error' is set to sigmin
CC  (3)  between sigmax and sigbig, then 'error' is set to sigmax
CC  (4)  between sigmin and sigmax, then 'error' is set to the computed value.  

CC  Load beam line coordinates in STAR Global coordinate system as obtained
CC  from the summer 2000 run.  These values will change every time STAR is
CC  installed in the WAH.  Eventually these values should be determined by
CC  analysis of central events, then loaded into the STAR run conditions DB,
CC  and later retrieved and used in subsequent reconstruction runs.  For now,
CC  these are hardwired into the code in order to improve the transverse
CC  position determination of the primary vertex for low multiplicity events.
CC  The slopes, azimuthal angle, and tanl are based on the full, measured
CC  distributions from -120 to +120 cm provided by Akio Ogawa.
CC
CC  The parameters are:
CC    - (x,y,z)1 (cm) where the actual beam line intersects the z=0 plane
CC    - (x,y,z)2 (cm) where the actual beam line intersects the z= -100 cm plane
CC    - slope of beam line as seen in projection onto x-z and y-z planes
CC    - azimuthal angle (deg) of beam line as seen in projection onto x-y plane
CC    - beam line's tanl parameter
CC    - the assumed value of sigma (cm) to weight the beam line relative to the
CC        extrapolated tracks in the vertex chi-sq fit; suggested values range
CC        from 0.1 to 0.2 cm such that the beam line has negligible effects
CC        on central events but dominant effect in the transverse fit for
CC        low multiplicity events.
CC

      REAL*8 BeamlineX1, BeamlineY1, BeamlineZ1
      REAL*8 BeamlineX2, BeamlineY2, BeamlineZ2
      REAL*8 Beamlinephi0, Beamlinetanl
      REAL*8 Beamline_xzslope, Beamline_yzslope
      REAL*8 Beamline_sigma
      Parameter(BeamlineX1   = 0.561)
      Parameter(BeamlineY1   = 0.352)
      Parameter(BeamlineZ1   = 0.00)
      Parameter(BeamlineX2   = 0.5854)
      Parameter(BeamlineY2   = 0.3762)
      Parameter(BeamlineZ2   = -100.0)
      Parameter(Beamlinephi0 = 44.76)    ! deg
      Parameter(Beamlinetanl = -2910.)
      Parameter(Beamline_xzslope = -0.000244)
      Parameter(Beamline_yzslope = -0.000242)
CCC      Parameter(Beamline_sigma   = 0.10)

CC  Vertex_pass(i,j) contains the vertex position from the initial
CC  estimate and the first and second passes, where i = pass#, j=x,y,z.

CC  Load control switches (Temporary):
C      fitoption  = 0   !  Turn off when evrpar(1).fitoption available
C      covariance = 0   !  Turn off when evrpar(1).covariance available
CSM    covariance = -1  !  TPC-tracks are used to fit pre-vertex. Simplify!!!
      fitoption  = evrpar(1).fitoption ! Activate when evrpar(1).fitoption ok
      covariance = evrpar(1).covariance ! Activate when evrpar(1).covariance ok

CCC Set Beamline fitting constraint control switch:
      if(fitoption .eq. 2) then
         Beamline_sigma   = 0.10
      else
         Beamline_sigma   = 100.0
      end if

CC  B-field obtained via gufld call
      xlocal(1) = 0.
      xlocal(2) = 0.
      xlocal(3) = 0.

      call gufld(xlocal,bfield)
      if(covariance .eq. -1) then
         write(6,*) 'EVR: (pre-vertex) Using a field of',
     1              bfield(3),' KGauss'
      else
         write(6,*) 'EVR: Using a field of',bfield(3),' KGauss'
      end if
      b = bfield(3)

CC  Check for fixed vertex
      do i = 1,privert_h.nok
	if ((privert(i).chisq(1).eq.-1.0).and.
     1      (privert(i).chisq(2).eq.-1.0)) then
          index = i
	  xxv(1) = privert(i).x
	  xxv(2) = privert(i).y
	  xxv(3) = privert(i).z
	  goto 500
	end if
      end do


CC  Initialize arrays:

      do i = 1,nxybins
         xsum(i) = 0
         ysum(i) = 0
      end do
      do i = 1,nbins
         zsum(i) = 0
      end do
C        CALL VZERO(xsum,81)
C        CALL VZERO(ysum,81)
C        CALL VZERO(zsum,800)
	ntrk = 0
        ntrkratio = 0.0
        do i = 1,maxtr
           gindex(i) = 0
           do j = 1,6
              vtrv(j,i) = 0.0
           end do
           x0(i)    = 0.0
           y0(i)    = 0.0
           z0(i)    = 0.0
           phi0(i)  = 0.0
           tanl(i)  = 0.0
           sigma(i) = 0.0
        end do
        do i = 1,maxdettypes
           dettrkcounter(i) = 0
        end do

CC  Initialize vertex position values:
      xv = 0.0
      yv = 0.0
      zv = 0.0

CC  Verify range of values of Detector ID codes for use in filling
CC  the array 'dettrkcounter,' for track/detector segment counting:
      if(kTpcId       .gt. 0 .and. kTpcId       .le.maxdettypes .and.
     1   kSvtId       .gt. 0 .and. kSvtId       .le.maxdettypes .and.
     2   kSsdId       .gt. 0 .and. kSsdId       .le.maxdettypes .and.
     3   kTpcSsdId    .gt. 0 .and. kTpcSsdId    .le.maxdettypes .and.
     4   kTpcSvtId    .gt. 0 .and. kTpcSvtId    .le.maxdettypes .and.
     5   kTpcSsdSvtId .gt. 0 .and. kTpcSsdSvtId .le.maxdettypes .and.
     6   kSsdSvtId    .gt. 0 .and. kSsdSvtId    .le.maxdettypes) then 
         Continue
      else
         write(6,*) 'EVR: Detector ID values out of range (1,30) - STOP'
         evr_am = STAFCV_BAD
         Return
      end if

CC  Check value of the magnetic field, z-component.
CC  If b .ge. bfield_min (equal to 0.1 kGauss), then proceed with calc.
CC  But, if b .lt. bfield_min, then set b = 0.0 and set the default pT
CC  value to the greater of ptdefault (equal to 0.4 GeV/c) or
CC  evrpar(1).ptmin, the pT minimum cutoff for the initial track acceptance.
CC  The pT value is needed for the no-field case in order to estimate the
CC  MCS contribution to the DCA position error (sigma) for each track.
CC  A finite value .ge. evrpar(1).ptmin is also needed so that tracks will
CC  pass the initial track selection cut in the do-20 loop below.
      if(abs(b) .lt. bfield_min) then
         b = 0.0
         pptdef = ptdefault
         if(pptdef .lt. evrpar(1).ptmin) then
            pptdef = evrpar(1).ptmin
         end if
      end if

CCC  Initial global track selection and setup loop:
C=== use only global tracks, i.e. dst_track instances ====

        ntrk = globtrk_h.nok  
        k = 0

CCC   Check size of global track table; set size of z-DCA bins for
CCC   low multiplicity events:
        if(ntrk .le. 50) then
           dz = 2.0*dz_default
        else
           dz = dz_default
        end if     

CCC   Check for adequate number of tracks:
        if (ntrk.lt.ntrkcut) then
           write(6,*) 'EVR: Not enough initial global tracks to find '
           write(6,*) 'EVR:    the vertex, ntrk=',ntrk
           evr_am = STAFCV_BAD  
           return
        endif

CCC   Select and load global tracks; compute relevant quantities, e.g. DCAs.
        do 20 i = 1,ntrk
           psi = globtrk(i).psi
           icharge = globtrk(i).icharge
           if (globtrk(i).invpt.ne.0.) then
              ppt = 1./abs(globtrk(i).invpt)
           else
              ppt = 99999.
           endif
           if(b.eq.0.0) then
              icharge = 1
              ppt = pptdef
           end if
           tanla = globtrk(i).tanl
           xx0 = globtrk(i).r0*dcosd(dble(globtrk(i).phi0))
           yy0 = globtrk(i).r0*dsind(dble(globtrk(i).phi0))
           zz0 = globtrk(i).z0
           globtrk(i).id_start_vertex = 0
           if(globtrk(i).det_id .eq. kTpcId       .or.
     1        globtrk(i).det_id .eq. kSvtId       .or.
     2        globtrk(i).det_id .eq. kSsdId       .or.
     3        globtrk(i).det_id .eq. kTpcSsdId    .or.
     4        globtrk(i).det_id .eq. kTpcSvtId    .or.
     5        globtrk(i).det_id .eq. kTpcSsdSvtId .or.
     6        globtrk(i).det_id .eq. kSsdSvtId) then
              detIdOK = 1
           else
              detIdOK = 0
           end if
           
           if (ppt.ge.evrpar(1).ptmin .and. ppt.ne. 99999. .and.
     1     detIdOK.eq.1 .and. globtrk(i).iflag.gt.0 .and.
     2     icharge.ne.0 .and. (globtrk(i).n_fit_point.eq.0
     3     .or. globtrk(i).n_fit_point.ge.25)) then
              k = k + 1
              if(k .le. maxtr) then

CC  Fill Detector Type - Track counter array for this global track:
              dettrkcounter(globtrk(i).det_id) =
     1           dettrkcounter(globtrk(i).det_id) + 1

CC  Determine if the track is purely TPC or if it contains SVT and/or SSD
CC  space points; then set the appropriate radiation thickness to use for
CC  estimating the MCS contribution to the extrapolated track position 
CC  uncertainty at the DCA to the primary vertex.
              if(globtrk(i).det_id .eq. kTpcId) then
                 LRAD = LIFC
              else
                 LRAD = LSVT1
              end if

              xp(1) = 0.0
              xp(2) = 0.0
              call evr_project_track(psi,icharge,ppt,tanla,xx0,yy0,
     1                               b,zz0,xp,x,sig,LRAD)
              gindex(k) = i
	      x0(k) = x(1)
	      y0(k) = x(2)
	      z0(k) = x(3)
              phi0(k)= x(4)
              tanl(k) = tanla
              sigma(k) = sig

CCC  Include track fit error covariance matrix contributions to the
CCC  track position uncertainty at the DCA point:

              derror = 0.0
              if(covariance .eq. 1 .OR.
     1           globtrk(i).method .eq. (2**kKalmanFitId)) then
                 xsave(1) = x(1)
                 xsave(2) = x(2)
                 xsave(3) = x(3)
CCC  Initialize covariance matrix to zero:
                 do ii = 1,5
                    do jj = 1,5
                       h(ii,jj) = 0.0
                    end do
                 end do
CCC  Load track covariance matrix, first fill diagonal elements:
                 h(1,1) = globtrk(i).covar(1)
                 h(2,2) = globtrk(i).covar(6)
                 h(3,3) = globtrk(i).covar(10)
                 h(4,4) = globtrk(i).covar(13)
                 h(5,5) = globtrk(i).covar(15)
CCC  Load off-diagonal elements:
                 h(2,1) = globtrk(i).covar(2)
                 h(3,1) = globtrk(i).covar(3)
                 h(3,2) = globtrk(i).covar(7)
                 h(4,1) = globtrk(i).covar(4)
                 h(4,2) = globtrk(i).covar(8)
                 h(4,3) = globtrk(i).covar(11)
                 h(5,1) = globtrk(i).covar(5)
                 h(5,2) = globtrk(i).covar(9)
                 h(5,3) = globtrk(i).covar(12)
                 h(5,4) = globtrk(i).covar(14)
                 do ii = 2,5
                    do jj = 1,ii-1
                       h(jj,ii) = h(ii,jj)
                    end do
                 end do
CCC  Calculate derivatives using same track parameters as assumed for
CCC  covariance matrix.  This uses the Kalman filter track covariance
CCC  matrix definition.  See comments for table dst_track.
CCC  Compute the 5 track parameters using the Kalman filter definition:
                 r0save = dsqrt(xx0*xx0 + yy0*yy0)
                 if(r0save.eq.0.0) then
                    phi0save = 0.0
                 else
                    phi0save = DATAN2(yy0,xx0)*180.0/C_PI
                 end if
                 p(1) = r0save*phi0save
                 p(2) = zz0
                 p(3) = tanla
                 p(4) = psi
                 if(icharge.eq.0) then
                    p(5) = 1.0/ppt
                 else
                    p(5) = dble(icharge)/ppt
                 end if
CCC  Set the shifted values of each track parameter needed for calculating
CCC  the partial derivatives numerically.  Use amounts 
CCC  appropriate for SVT, SSD and/or TPC tracks.
                 if(r0save.eq.0.0) then
                    pnew(1) = p(1) + 1.8/C_PI      ! Set r0 = 1 cm
                    pnew(2) = p(2) + 0.01*(1.0 + tanla*tanla)
                 else
                    pnew(1) = p(1) + (1.8/C_PI)*r0save
                    pnew(2) = p(2) + 0.01*r0save*(1.0 + tanla*tanla)
                 end if
                 if((pnew(2)-p(2)).gt.2.0) pnew(2) = p(2) + 2.0
                 pnew(3) = p(3) + 0.01*(1.0 + tanla*tanla)
                 if((pnew(3)-p(3)).gt.0.03) pnew(3) = p(3) + 0.03
                 pnew(4) = p(4) + 1.8/C_PI
                 pnew(5) = 1.01*p(5)
CC  Load parameter differences:
                 do ii = 1,5 
                    del(ii) = pnew(ii) - p(ii)
                 end do
CC  Compute partial derivatives:
                 do ii = 1,5
                    do jj = 1,5
                       pcall(jj) = p(jj)
                    end do
                    pcall(ii) = pnew(ii)
                    if(icharge.eq.0) then          ! Get pcall(8) = pt
                       pcall(8) = 1.0/pcall(5)
                    else
                       pcall(8) = dble(icharge)/pcall(5)
                    end if
                    if(r0save.eq.0.0) then         ! Get pcall(6,7)=x0,y0
                       if(ii.eq.1) then
                          pcall(6) = dcosd(pcall(1)) ! use shifted r*phi
                          pcall(7) = dsind(pcall(1))
                       else
                          pcall(6) = 0.0           ! use original x0,y0    
                          pcall(7) = 0.0
                       end if
                    else
                       pcall(6) = r0save*dcosd(pcall(1)/r0save)
                       pcall(7) = r0save*dsind(pcall(1)/r0save)
                    end if
                    Call evr_project_track(pcall(4),icharge,pcall(8),
     1                   pcall(3),pcall(6),pcall(7),b,pcall(2),
     2                   xp,x,sig,0.0)
                    do jj = 1,3
                       deriv(jj,ii) = (x(jj)-xsave(jj))/del(ii)
                    end do
                 end do
                 derrorsq = 0.0
                 do ialpha = 1,5
                    do ibeta = 1,5
                       do jj = 1,3
                          derrorsq = derrorsq + deriv(jj,ialpha)*
     1                               deriv(jj,ibeta)*h(ialpha,ibeta)
                       end do
                    end do
                 end do

CC  Do sanity check on error results from track fit covariance matrix and
CC  limit values if necessary.

                 if(derrorsq .le. 0.0) then
                    write(6,*) 'EVR: Track position error-sq .le. 0.0 ',
     1                 'using covar()-USE Default:',derrorsq
                    derror = sigdef
                 else
                    derror = dsqrt(derrorsq)
                    if(derror.eq.0.0.or.derror.gt.sigbig) then
                       derror = sigdef
                    else if(derror.gt.0.0 .and.
     1                      derror.lt.sigmin) then
                       derror = sigmin
                    else if(derror.gt.sigmax .and.
     1                      derror.le.sigbig) then
                       derror = sigmax
                    end if
                 end if
              end if   !  END Track covariance matrix option
             
CCC   Assign final error (sigma) to extrapolated track position:
              if(sigma(k).eq.0.0 .and. derror.eq.0.0) then
                 sigma(k) = sigdef
              else
                 sigma(k) = dsqrt(sigma(k)*sigma(k) + derror*derror)
              end if

              if((dabs(z0(k)).le.zlimit1 .and. dsqrt(x0(k)*x0(k)
     1           + y0(k)*y0(k)) .le. beampipecut1) .OR.
     2           (dabs(z0(k)).lt.zlimit2 .and. dabs(z0(k)).gt.
     3           zlimit1 .and. dsqrt(x0(k)*x0(k) + y0(k)*y0(k))
     4           .le. beampipecut2)) then
                 zsum(int((z0(k)+zlimit2)/dz)+1) =      
     1           zsum(int((z0(k)+zlimit2)/dz)+1) + 1   
              endif
              else if (k.gt.maxtr) then
                 k = maxtr
                 GO TO 21     ! Jump out of DO 20 track selection loop;
CC                            ! the remainder of tracks are skipped.
              endif   ! END local array overflow check, maxtr
           endif      ! END track selection cut option
20      continue      ! END initial global track selection and setup loop
21      continue      ! GO TO point for # tracks.gt.maxtr skip out from Do20

        ntrk = k

CC  Determine most complete list of detectors which contribute space points
CC  to all the tracks selected in the initial pass (DO 20 Loop):
        DetectorIdSave = DetectorId(maxdettypes,dettrkcounter)

CCC   Check for adequate number of tracks:
        if(globtrk_h.nok .ne. 0) then
           ntrkratio = dble(ntrk)/dble(globtrk_h.nok)
        else
           ntrkratio = 0.0
        end if
        if (ntrk.lt.ntrkcut) then
           write(6,*) 'EVR: Not enough global tracks after DO-20'
           write(6,*) 'EVR:    track selection loop (e.g. ptmin,DetID,'
           write(6,*) 'EVR:    iflag,etc.) to find the vertex:' 
           write(6,*) 'EVR:    ntrk,ntrkratio = ',ntrk,ntrkratio
           evr_am = STAFCV_BAD
           return
        endif
        if (ntrkratio .lt. ntrkratiocut) then
           write(6,*) 'EVR: Ratio of accepted to total global tracks'
           write(6,*) 'EVR:    too low after DO-20 track selection'
           write(6,*) 'EVR:    loop (e.g. ptmin,DetID,iflag,etc.)'
           write(6,*) 'EVR:    to find the vertex:'
           write(6,*) 'EVR:    ntrk,ntrkratio = ',ntrk,ntrkratio
           evr_am = STAFCV_BAD
           return
        endif

CCC   Determine the initial, rough x,y,z location of the primary vertex
CCC   using weighted means for selected x,y,z bins of DCA positions which
CCC   are near the peak bin.  Find bin with maximum number of DCA points
CCC   for z-coordinate, then for x and y.
CCC
CCC      z-coordinate seed value:
        bin_max = 0
        maxval = 0
        do i = 1,nbins
           if (zsum(i) .gt. maxval) then
              maxval = zsum(i)
              bin_max = i
           end if
        end do
        bin_low  = bin_max - int(def_seq_range_z/dz + 0.0001)
        bin_high = bin_max + int(def_seq_range_z/dz + 0.0001)
        if(bin_low .lt. 1) bin_low = 1
        if(bin_high .gt. nbins) bin_high = nbins
        seed = 0.0
        sumbin = 0.0
        do i = bin_low,bin_high
           sumbin = sumbin + dble(zsum(i))
           seed = seed + (dz*dble(i)-(zlimit2+0.5*dz))*dble(zsum(i))
        end do
        if(sumbin .gt. 0.0) then
           seed = seed/sumbin
        else
           seed = dz*dble(bin_max) - (zlimit2+0.5*dz)
        end if
        zv = seed

CCC   Determine if vertex seed is within detector fiducial volume (zrange)
CCC   and if so continue, but if not, then output vertex seed and return
CCC   with STAFCV_BAD:

        if(dabs(zv) .gt. zrange) then

CCC   Load the out-of-range seed value into table privert:
           index = privert_h.nok + 1
           if(index.le.privert_h.maxlen) then
              privert_h.nok = index
              privert(index).id = index
              privert(index).iflag = -3
              if(covariance.eq.-1) privert(index).iflag =
     +           privert(index).iflag - 100
              privert(index).det_id = DetectorIdSave
              privert(index).vtx_id = kEventVtxId
              privert(index).n_daughters = int(sumbin)
              privert(index).x           = 0.0
              privert(index).y           = 0.0
              privert(index).z           = zv
              do i = 1,6
                 privert(index).covar(i) = 0.0
              end do
              privert(index).chisq(1) = 0.0
              privert(index).chisq(2) = 0.0
              privert(index).id_aux_ent  = 0
           else
           write(6,*) 'EVR:Privert table is full - cannot load vertex:',
     1                 index
              evr_am = STAFCV_BAD
              Return
           end if
           write(6,*) 'EVR: Vertex seed is outside detector range'
           evr_am = STAFCV_BAD
           Return
        else   ! Proceed with vertex finding and fitting  

CCC   Set z-range for vertex seed, or sequence of bins:
           zlowercut = dz*dble(bin_low) - zlimit2 - dz
           zuppercut = dz*dble(bin_high) - zlimit2

CCC   Save the total number of tracks with DCAs within the vertex seed
CCC   sequence z-range; used for later track ratio cuts:
           ntracks_seq = int(sumbin)

CCC   Bad event rejection:
           if(ntracks_seq .lt. ntrkratiocut*(globtrk_h.nok - 50)
     1        .OR. ntracks_seq .le. 0) then
              write(6,*) 'EVR: Ratio of number of tracks associated'
              write(6,*) 'EVR:   with seq to globtrk_h.nok too small'
              write(6,*) 'EVR:   ntracks_seq,globtrk_h.nok=',
     1                    ntracks_seq,globtrk_h.nok
              evr_am = STAFCV_BAD
              Return
           end if

           if(ntracks_seq .le. 0) ntracks_seq = globtrk_h.nok

CCC   Compute the rms of the z-DCA sequence:
           sigmaz = 0.0
           do i = bin_low,bin_high
              zlocal = dz*dble(i) - (zlimit2 + 0.5*dz)
              sigmaz = sigmaz + (zlocal-zv)*(zlocal-zv)*dble(zsum(i))
           end do
           if(sumbin .gt. 0.0) then
              sigmaz = dsqrt(sigmaz/sumbin)
           else
              sigmaz = sigdef
           end if

CCC   Set transverse and 3D DCA distance cuts for fits 1,2,3:
           dca_cut1 = 3.0*dsqrt(2.D0)*sigmaz
           if(dca_cut1 .lt. evrpar(1).cutxy)
     1        dca_cut1 =    evrpar(1).cutxy
           if(dca_cut1 .gt. beampipecut1) dca_cut1 = beampipecut1
           dca_cut2 = 2.0*dsqrt(3.D0)*sigmaz
           if(dca_cut2 .lt. evrpar(1).cut2)
     1        dca_cut2 =    evrpar(1).cut2
           if(dca_cut2 .gt. 2.0*dsqrt(3.D0)*sigdef)
     1        dca_cut2 =    2.0*dsqrt(3.D0)*sigdef
           dca_cut3 = dsqrt(3.D0)*sigmaz
           if(dca_cut3 .lt. evrpar(1).cut3)
     1        dca_cut3 =    evrpar(1).cut3
           if(dca_cut3 .gt. dsqrt(3.D0)*sigdef)
     1        dca_cut3 =    dsqrt(3.D0)*sigdef

CCC   Compute the acceptance volumes and ratio for min. track ratio cuts:
           volume_seq = C_PI*beampipecut1*beampipecut1*
     1        (zuppercut - zlowercut)
           volume_fit3 = (4.0*C_PI/3.0)*(dca_cut3**3)
           if(volume_seq .gt. 0.0) then
              volume_ratio = volume_fit3/volume_seq
              if(volume_ratio .ge. 1.0) then
                 volume_ratio = ntrkratiocut
              end if
           else
              volume_ratio = ntrkratiocut
           end if

CCC   Fill x,y DCA histograms for DCAs in z-DCA sequence and inside
CCC   beam pipe:
           do k = 1,ntrk
              if(z0(k).ge.zlowercut .and. z0(k).le.zuppercut
     1           .and. dsqrt(x0(k)*x0(k) + y0(k)*y0(k)) .le.
     2           beampipecut1) then
                 xsum(int((x0(k) + beampipecut1)/dxy)+1) =
     1           xsum(int((x0(k) + beampipecut1)/dxy)+1) + 1
                 ysum(int((y0(k) + beampipecut1)/dxy)+1) =
     1           ysum(int((y0(k) + beampipecut1)/dxy)+1) + 1
              end if
           end do
        end if

CCC     x-coordinate seed value:
        bin_max = 0
        maxval = 0
        do i = 1,nxybins-1
           if (xsum(i) .gt. maxval) then
              maxval = xsum(i)
              bin_max = i
           end if
        end do
        bin_low  = bin_max - int(def_seq_range_xy/dxy + 0.0001)
        bin_high = bin_max + int(def_seq_range_xy/dxy + 0.0001)
        if(bin_low .lt. 1) bin_low = 1
        if(bin_high .gt. (nxybins-1)) bin_high = nxybins-1
        seed = 0.0
        sumbin = 0.0
        do i = bin_low,bin_high
           sumbin = sumbin + dble(xsum(i))
           seed = seed
     1       +(dxy*dble(i)-(beampipecut1+0.5*dxy))*dble(xsum(i))
        end do
        if(sumbin .gt. 0.0) then
           seed = seed/sumbin
        else
           seed = dxy*dble(bin_max) - (beampipecut1+0.5*dxy)
        end if
        xv = 2.0*seed
        if(dabs(xv) .gt. beampipecut1) xv = seed

CCC     y-coordinate seed value:
        bin_max = 0
        maxval = 0
        do i = 1,nxybins-1
           if (ysum(i) .gt. maxval) then
              maxval = ysum(i)
              bin_max = i
           end if
        end do
        bin_low  = bin_max - int(def_seq_range_xy/dxy + 0.0001)
        bin_high = bin_max + int(def_seq_range_xy/dxy + 0.0001)
        if(bin_low .lt. 1) bin_low = 1
        if(bin_high .gt. (nxybins-1)) bin_high = nxybins-1
        seed = 0.0
        sumbin = 0.0
        do i = bin_low,bin_high
           sumbin = sumbin + dble(ysum(i))
           seed = seed
     1       +(dxy*dble(i)-(beampipecut1+0.5*dxy))*dble(ysum(i))
        end do
        if(sumbin .gt. 0.0) then
           seed = seed/sumbin
        else
           seed = dxy*dble(bin_max) - (beampipecut1+0.5*dxy)
        end if
        yv = 2.0*seed
        if(dabs(yv) .gt. beampipecut1) yv = seed

CC  Save vertex seed value:
        vertex_pass(1,1) = xv
        vertex_pass(1,2) = yv
        vertex_pass(1,3) = zv

CCC  Load initial seed value into table privert:
        index = privert_h.nok + 1
        if(index.le.privert_h.maxlen) then
           privert_h.nok = index
           privert(index).id = index
           privert(index).iflag = -3
           if(covariance.eq.-1) privert(index).iflag =
     +          privert(index).iflag - 100
           privert(index).det_id = DetectorIdSave
           privert(index).vtx_id = kEventVtxId
           privert(index).n_daughters = ntracks_seq
           privert(index).x           = vertex_pass(1,1)
           privert(index).y           = vertex_pass(1,2)
           privert(index).z           = vertex_pass(1,3)
           do i = 1,6
              privert(index).covar(i) = 0.0
           end do
           privert(index).chisq(1) = 0.0
           privert(index).chisq(2) = 0.0
           privert(index).id_aux_ent  = 0
        else
           write(6,*) 'EVR:Privert table is full - cannot load vertex:',
     1                 index
           evr_am = STAFCV_BAD
           Return
        end if

CCC  Re-Calculate selected track extrapolation parameters for initial
CCC  estimate of vertex position if it is off the x=y=0 axis:
        if (xv.ne.0.0 .or. yv.ne.0.0) then
           do i = 1,ntrk
              k = gindex(i)
              psi = globtrk(k).psi
              if(b.ne.0.0) then
                 icharge = globtrk(k).icharge
                 ppt = 1.0/abs(globtrk(k).invpt)
              else if (b.eq.0.0) then
                 icharge = 1
                 ppt = pptdef
              end if
              tanla = globtrk(k).tanl
              xx0 = globtrk(k).r0*dcosd(dble(globtrk(k).phi0))
              yy0 = globtrk(k).r0*dsind(dble(globtrk(k).phi0))
              zz0 = globtrk(k).z0
              xp(1) = xv
              xp(2) = yv
              Call evr_project_track(psi,icharge,ppt,tanla,xx0,yy0,
     1                               b,zz0,xp,x,sig,LIFC)
              x0(i) = x(1)
              y0(i) = x(2)
              z0(i) = x(3)
              phi0(i) = x(4)
              tanl(i) = tanla
           end do
        end if

CCC  Select tracks based on transverse x-y and z cuts and load
CCC  track parameters into temporary arrays:
	k=0
	do 10 i=1,ntrk
	   dr=dsqrt((x0(i)-xv)**2 + (y0(i)-yv)**2 )
	   if(dr.lt.dca_cut1) then
	      if(z0(i).ge.zlowercut.and.z0(i).le.zuppercut) then
	         k=k+1
	         vtrv(1,k)=phi0(i)
	         vtrv(2,k)=tanl(i)
	         vtrv(4,k)=x0(i)
	         vtrv(5,k)=y0(i)
	         vtrv(6,k)=z0(i)
                 vtrv(3,k)=sigma(i)
	      endif
	   endif
10	continue

CCC   Include beam line in EVR_VERTEX_FIT:
        k_fit_call = k
        if(k.lt.maxtr) then
           k_fit_call = k + 1
           vtrv(1,k+1) = Beamlinephi0
           vtrv(2,k+1) = Beamlinetanl
           vtrv(4,k+1) = Beamline_xzslope*vertex_pass(1,3) + BeamlineX1
           vtrv(5,k+1) = Beamline_yzslope*vertex_pass(1,3) + BeamlineY1
           vtrv(6,k+1) = vertex_pass(1,3)
           vtrv(3,k+1) = Beamline_sigma
        end if

CCC   Check for adequate number of tracks:
        if(ntracks_seq .ne. 0) then
           ntrkratio = dble(k)/dble(ntracks_seq)
        else
           ntrkratio = 0.0
        end if
        if (k.lt.ntrkcut) then
           write(6,*) 'EVR: too few trks for EVR_VERTEX_FIT'
           write(6,*) 'EVR:    after dca_cut1,z-range; k,ratio='
     1                 ,k,ntrkratio
           flagset1 = -6
        else
           flagset1 = 0
        end if
        if(ntrkratio .lt. volume_ratio) then
           write(6,*) 'EVR: Ratio of accepted to # glb trk in seed'
           write(6,*) 'EVR:    too low after dca_cut1,z-range;'
           write(6,*) 'EVR:    k,ratio=',k,ntrkratio
           flagset2 = -7
        else
           flagset2 = 0
        end if
        if(flagset1.ne.0 .or. flagset2.ne.0) then
           index = privert_h.nok + 1
           if(index.le.privert_h.maxlen) then
              privert_h.nok = index
              privert(index).id = index
              if(flagset1.ne.0 .and. flagset2.eq.0) then
                 privert(index).iflag = flagset1
              else if(flagset1.eq.0 .and. flagset2.ne.0) then
                 privert(index).iflag = flagset2
              else
                 privert(index).iflag = -8
              end if
              if(covariance.eq.-1) privert(index).iflag =
     1           privert(index).iflag - 100
              privert(index).det_id = privert(index-1).det_id
              privert(index).vtx_id = privert(index-1).vtx_id
              privert(index).n_daughters = privert(index-1).n_daughters
              privert(index).x      = privert(index-1).x
              privert(index).y      = privert(index-1).y
              privert(index).z      = privert(index-1).z
              do i = 1,6
                 privert(index).covar(i) = privert(index-1).covar(i)
              end do
              privert(index).chisq(1) = privert(index-1).chisq(1)
              privert(index).chisq(2) = privert(index-1).chisq(2)
              privert(index).id_aux_ent = privert(index-1).id_aux_ent
           else
              write(6,*) 'EVR: Privert is full - cannot load vertex:',
     1                    index
              evr_am = STAFCV_BAD
              Return
           end if
           evr_am = STAFCV_BAD
           Return
        end if

CCC   Do first iteration of vertex finding:
	CALL EVR_VERTEX_FIT(k_fit_call)
        xxv(1)=xv
        xxv(2)=yv
        xxv(3)=zv

CC  Save first pass vertex:
        vertex_pass(2,1) = xv
        vertex_pass(2,2) = yv
        vertex_pass(2,3) = zv

CCC  Load first iteration vertex value into table privert:
        index = privert_h.nok + 1
        if(index.le.privert_h.maxlen) then
           privert_h.nok = index
           privert(index).id = index
           if(xv .eq. -99999.) then
              privert(index).iflag = -4
           else if(yv .eq. -99999.) then
              privert(index).iflag = -5
           else
              privert(index).iflag = -2
           end if
           if(covariance.eq.-1) privert(index).iflag =
     +          privert(index).iflag - 100
           privert(index).det_id = DetectorIdSave
           privert(index).vtx_id = kEventVtxId
           privert(index).n_daughters = k
           privert(index).x           = vertex_pass(2,1)
           privert(index).y           = vertex_pass(2,2)
           privert(index).z           = vertex_pass(2,3)
           do i = 1,6
              privert(index).covar(i) = 0.0
           end do
           privert(index).chisq(1) = chisq/dble(k-1)
           privert(index).chisq(2) = 0.0
           privert(index).id_aux_ent  = 0
        else
           write(6,*) 'EVR:Privert table is full - cannot load vertex:',
     1                 index
           evr_am = STAFCV_BAD
           Return
        end if

CC  Optional Re-calculation of helix track projection to new vertex position:

        if(fitoption .eq. 1) then
           do i = 1,ntrk
              k = gindex(i)
              psi = globtrk(k).psi
              if(b .ne. 0.0) then
                 icharge = globtrk(k).icharge
                 ppt = 1.0/abs(globtrk(k).invpt)
              else if(b .eq. 0.0) then
                 icharge = 1
                 ppt = pptdef
              end if
              tanla = globtrk(k).tanl
              xx0 = globtrk(k).r0*dcosd(dble(globtrk(k).phi0))
              yy0 = globtrk(k).r0*dsind(dble(globtrk(k).phi0))
              zz0 = globtrk(k).z0
              xp(1) = xxv(1)
              xp(2) = xxv(2)
              Call evr_project_track(psi,icharge,ppt,tanla,xx0,yy0,
     1                               b,zz0,xp,x,sig,LIFC)
              x0(i) = x(1)
              y0(i) = x(2)
              z0(i) = x(3)
              phi0(i) = x(4)
              tanl(i) = tanla
C              sigma(i) = sig    !  Do not update track position error
           end do
        end if

CCC  Select tracks based on tighter 3D DCA cut (dca_cut2) and load
CCC  track parameters into temporary arrays:
	k=0
	do 105 i=1,ntrk
        xa0(1)=x0(i)
        xa0(2)=y0(i)
        xa0(3)=z0(i)
C** straight line tracks, i.e. can put e.g. pt=1 then
        pa0(1)=dcosd(phi0(i))
        pa0(2)=dsind(phi0(i))
        pa0(3)=tanl(i)
        call ThreeD_dca(xxv,xa0,pa0,x3d0)
	dr=dsqrt( (x3d0(1)-xv)**2+(x3d0(2)-yv)**2+(x3d0(3)-zv)**2 )
	if(dr.lt.dca_cut2) then
	k=k+1
	vtrv(1,k)=phi0(i)
	vtrv(2,k)=tanl(i)
	vtrv(4,k)=x0(i)
	vtrv(5,k)=y0(i)
	vtrv(6,k)=z0(i)
        vtrv(3,k)=sigma(i)
	endif
105	continue

CCC   Include beam line in EVR_VERTEX_FIT:
        k_fit_call = k
        if(k.lt.maxtr) then
           k_fit_call = k + 1
           vtrv(1,k+1) = Beamlinephi0
           vtrv(2,k+1) = Beamlinetanl
           vtrv(4,k+1) = Beamline_xzslope*vertex_pass(1,3) + BeamlineX1
           vtrv(5,k+1) = Beamline_yzslope*vertex_pass(1,3) + BeamlineY1
           vtrv(6,k+1) = vertex_pass(1,3)
           vtrv(3,k+1) = Beamline_sigma
        end if

CCC   Check for adequate number of tracks:
        if(ntracks_seq .ne. 0) then
           ntrkratio = dble(k)/dble(ntracks_seq)
        else
           ntrkratio = 0.0
        end if
        if (k.lt.ntrkcut) then
           write(6,*) 'EVR: too few trks for EVR_VERTEX_FIT'
           write(6,*) 'EVR:    after dca_cut2; k,ratio=',
     1                 k,ntrkratio
           flagset1 = -6
        else
           flagset1 = 0
        end if
        if(ntrkratio .lt. volume_ratio) then
           write(6,*) 'EVR: Ratio of accepted to # glb trks in seed'
           write(6,*) 'EVR:    too low after dca_cut2;'
           write(6,*) 'EVR:    k,ratio=',k,ntrkratio
           flagset2 = -7
        else
           flagset2 = 0
        end if
        if(flagset1.ne.0 .or. flagset2.ne.0) then
           index = privert_h.nok + 1
           if(index.le.privert_h.maxlen) then
              privert_h.nok = index
              privert(index).id = index
              if(flagset1.ne.0 .and. flagset2.eq.0) then
                 privert(index).iflag = flagset1
              else if(flagset1.eq.0 .and. flagset2.ne.0) then
                 privert(index).iflag = flagset2
              else
                 privert(index).iflag = -8
              end if
              if(covariance.eq.-1) privert(index).iflag =
     1           privert(index).iflag - 100
              privert(index).det_id = privert(index-1).det_id
              privert(index).vtx_id = privert(index-1).vtx_id
              privert(index).n_daughters = privert(index-1).n_daughters
              privert(index).x      = privert(index-1).x
              privert(index).y      = privert(index-1).y
              privert(index).z      = privert(index-1).z
              do i = 1,6
                 privert(index).covar(i) = privert(index-1).covar(i)
              end do
              privert(index).chisq(1) = privert(index-1).chisq(1)
              privert(index).chisq(2) = privert(index-1).chisq(2)
              privert(index).id_aux_ent = privert(index-1).id_aux_ent
           else
              write(6,*) 'EVR: Privert is full - cannot load vertex:',
     1                    index
              evr_am = STAFCV_BAD
              Return
           end if
           evr_am = STAFCV_BAD
           Return
        end if

CCC   Do second iteration of vertex finding:
	CALL EVR_VERTEX_FIT(k_fit_call)
        xxv(1)=xv
        xxv(2)=yv
        xxv(3)=zv

CC  Save second pass vertex:
        vertex_pass(3,1) = xv
        vertex_pass(3,2) = yv
        vertex_pass(3,3) = zv

CCC  Load second iteration vertex value into table privert:
        index = privert_h.nok + 1
        if(index.le.privert_h.maxlen) then
           privert_h.nok = index
           privert(index).id = index
           if(xv .eq. -99999.) then
              privert(index).iflag = -4
           else if(yv .eq. -99999.) then
              privert(index).iflag = -5
           else
              privert(index).iflag = -1
           end if
           if(covariance.eq.-1) privert(index).iflag =
     +          privert(index).iflag - 100
           privert(index).det_id = DetectorIdSave
           privert(index).vtx_id = kEventVtxId
           privert(index).n_daughters = k
           privert(index).x           = vertex_pass(3,1)
           privert(index).y           = vertex_pass(3,2)
           privert(index).z           = vertex_pass(3,3)
           do i = 1,6
              privert(index).covar(i) = 0.0
           end do
           privert(index).chisq(1) = chisq/dble(k-1)
           privert(index).chisq(2) = 0.0
           privert(index).id_aux_ent  = 0
        else
           write(6,*) 'EVR:Privert table is full - cannot load vertex:',
     1                 index
           evr_am = STAFCV_BAD
           Return
        end if

CC  Optional Re-calculation of helix track projection to new vertex position:

        if(fitoption .eq. 1) then
           do i = 1,ntrk
              k = gindex(i)
              psi = globtrk(k).psi
              if(b .ne. 0.0) then
                 icharge = globtrk(k).icharge
                 ppt = 1.0/abs(globtrk(k).invpt)
              else if(b .eq. 0.0) then
                 icharge = 1
                 ppt = pptdef
              end if
              tanla = globtrk(k).tanl
              xx0 = globtrk(k).r0*dcosd(dble(globtrk(k).phi0))
              yy0 = globtrk(k).r0*dsind(dble(globtrk(k).phi0))
              zz0 = globtrk(k).z0
              xp(1) = xxv(1)
              xp(2) = xxv(2)
              Call evr_project_track(psi,icharge,ppt,tanla,xx0,yy0,
     1                               b,zz0,xp,x,sig,LIFC)
              x0(i) = x(1)
              y0(i) = x(2)
              z0(i) = x(3)
              phi0(i) = x(4)
              tanl(i) = tanla
C              sigma(i) = sig    !  Do not update track position error
           end do
        end if

CCC  Final track selection based on 3D DCA cut (dca_cut3) and loading
CCC  track parameters into temporary arrays:
	k=0
	do 205 i=1,ntrk
        xa0(1)=x0(i)
        xa0(2)=y0(i)
        xa0(3)=z0(i)
C** straight line tracks, i.e. can put e.g. pt=1 then
        pa0(1)=dcosd(phi0(i))
        pa0(2)=dsind(phi0(i))
        pa0(3)=tanl(i)
        call ThreeD_dca(xxv,xa0,pa0,x3d0)
	dr=dsqrt( (x3d0(1)-xv)**2+(x3d0(2)-yv)**2+(x3d0(3)-zv)**2 )
	if(dr.lt.dca_cut3) then
	k=k+1
        globtrk(gindex(i)).id_start_vertex = 1  ! mark global tracks used
CC                                              ! in final vertex fit
	vtrv(1,k)=phi0(i)
	vtrv(2,k)=tanl(i)
	vtrv(4,k)=x0(i)
	vtrv(5,k)=y0(i)
	vtrv(6,k)=z0(i)
        vtrv(3,k)=sigma(i)
	endif
205	continue

CCC   Include beam line in EVR_VERTEX_FIT:
        k_fit_call = k
        if(k.lt.maxtr) then
           k_fit_call = k + 1
           vtrv(1,k+1) = Beamlinephi0
           vtrv(2,k+1) = Beamlinetanl
           vtrv(4,k+1) = Beamline_xzslope*vertex_pass(1,3) + BeamlineX1
           vtrv(5,k+1) = Beamline_yzslope*vertex_pass(1,3) + BeamlineY1
           vtrv(6,k+1) = vertex_pass(1,3)
           vtrv(3,k+1) = Beamline_sigma
        end if

CCC   Check for adequate number of tracks:
        if(ntracks_seq .ne. 0) then
           ntrkratio = dble(k)/dble(ntracks_seq)
        else
           ntrkratio = 0.0
        end if
        if (k.lt.ntrkcut) then
           write(6,*) 'EVR: too few trks for EVR_VERTEX_FIT'
           write(6,*) 'EVR:    after dca_cut3; k,ratio=',
     1                 k,ntrkratio
           flagset1 = -6
        else
           flagset1 = 0
        end if
        if(ntrkratio .lt. volume_ratio) then
           write(6,*) 'EVR: Ratio of accepted to # glb trks in seed'
           write(6,*) 'EVR:    too low after dca_cut3;'
           write(6,*) 'EVR:    k,ratio=',k,ntrkratio
           flagset2 = -7
        else
           flagset2 = 0
        end if
        if(flagset1.ne.0 .or. flagset2.ne.0) then
           index = privert_h.nok + 1
           if(index.le.privert_h.maxlen) then
              privert_h.nok = index
              privert(index).id = index
              if(flagset1.ne.0 .and. flagset2.eq.0) then
                 privert(index).iflag = flagset1
              else if(flagset1.eq.0 .and. flagset2.ne.0) then
                 privert(index).iflag = flagset2
              else
                 privert(index).iflag = -8
              end if
              if(covariance.eq.-1) privert(index).iflag =
     1           privert(index).iflag - 100
              privert(index).det_id = privert(index-1).det_id
              privert(index).vtx_id = privert(index-1).vtx_id
              privert(index).n_daughters = privert(index-1).n_daughters
              privert(index).x      = privert(index-1).x
              privert(index).y      = privert(index-1).y
              privert(index).z      = privert(index-1).z
              do i = 1,6
                 privert(index).covar(i) = privert(index-1).covar(i)
              end do
              privert(index).chisq(1) = privert(index-1).chisq(1)
              privert(index).chisq(2) = privert(index-1).chisq(2)
              privert(index).id_aux_ent = privert(index-1).id_aux_ent
           else
              write(6,*) 'EVR: Privert is full - cannot load vertex:',
     1                    index
              evr_am = STAFCV_BAD
              Return
           end if
           evr_am = STAFCV_BAD
           Return
        end if

CCC   Do third and final iteration of vertex finding:
	CALL EVR_VERTEX_FIT(k_fit_call)
        xxv(1)=xv
        xxv(2)=yv
        xxv(3)=zv
C
C save results
C

CC  Load final iteration vertex value into table privert:

        index=privert_h.nok + 1  
      if(index.le.privert_h.maxlen) then
        privert_h.nok = index    
        privert(index).id = index 
        if(xv .eq. -99999.) then
           privert(index).iflag = -4
        else if(yv .eq. -99999.) then
           privert(index).iflag = -5
        else
           privert(index).iflag = 1       ! Final primary vertex marker
        end if
        if(covariance.eq.-1)
     1     privert(index).iflag = privert(index).iflag + 100
        privert(index).det_id = DetectorIdSave ! global reconstruction
        privert(index).vtx_id  = kEventVtxId   ! primary vertex indicator
        privert(index).n_daughters  = k 
        privert(index).x = xv
        privert(index).y = yv
        privert(index).z = zv

CC  Fill covariance error matrix in units of cm^2:
        if(cov(1) .gt. 0.0) then
           privert(index).covar(1)  = cov(1)
        else
           if (DetectorIdSave.eq.kTpcId) then
              privert(index).covar(1)  = (0.0150)**2
           else
              privert(index).covar(1)  = (0.0050)**2
           end if
        end if

        if(cov(3) .gt. 0.0) then
           privert(index).covar(3)  = cov(3)
        else
           if (DetectorIdSave.eq.kTpcId) then
              privert(index).covar(3)  = (0.0150)**2
           else
              privert(index).covar(3)  = (0.0050)**2
           end if
        end if

        if(cov(6) .gt. 0.0) then
           privert(index).covar(6)  = cov(6)
        else
           if (DetectorIdSave.eq.kTpcId) then
              privert(index).covar(6)  = (0.0200)**2
           else
              privert(index).covar(6)  = (0.0050)**2
           end if
        end if

        chisq1=chisq
        privert(index).covar(2) = cov(2)
        privert(index).covar(4) = cov(4)
        privert(index).covar(5) = cov(5)
        privert(index).chisq(1) = chisq/dble(k-1)
        privert(index).chisq(2) = PROB(chisq1,k-1)
        privert(index).id_aux_ent  = 0
      else
           write(6,*) 'EVR:Privert table is full - cannot load vertex:',
     1                 index
           evr_am = STAFCV_BAD
           Return
      end if

C--mark default primary tracks if valid primary vertex has been found
CC:  Also load 3D DCA into globtrk().impact.
CC:  NOTE: This only marks tracks that have pT .ne. 99999.
CC:        AND detIdOK.eq.1 (see below)  AND iflag .gt. 0

500   if(privert(index).iflag .eq. 1 .and.
     1   privert(index).vtx_id .eq. kEventVtxId) then
        j = 0   ! Count tracks with pT.ne. 99999.  AND 
C               ! detIdOK.eq.1  AND iflag .gt. 0 AND
C               ! DCA to primary vertex .lt.evrpar(1).vcut
        do i = 1,globtrk_h.nok  
           psi = globtrk(i).psi
           icharge = globtrk(i).icharge
           if (globtrk(i).invpt.ne.0.) then
              ppt = 1./abs(globtrk(i).invpt)
           else
              ppt = 99999.
           endif
           if(b .eq. 0.0) then
              icharge = 1
              ppt = pptdef
           end if
           tanla = globtrk(i).tanl
           xx0 = globtrk(i).r0*dcosd(dble(globtrk(i).phi0))
           yy0 = globtrk(i).r0*dsind(dble(globtrk(i).phi0))
           zz0 = globtrk(i).z0
           if(globtrk(i).det_id .eq. kTpcId       .or.
     1        globtrk(i).det_id .eq. kSvtId       .or.
     2        globtrk(i).det_id .eq. kSsdId       .or.
     3        globtrk(i).det_id .eq. kTpcSsdId    .or.
     4        globtrk(i).det_id .eq. kTpcSvtId    .or.
     5        globtrk(i).det_id .eq. kTpcSsdSvtId .or.
     6        globtrk(i).det_id .eq. kSsdSvtId) then
              detIdOK = 1
           else
              detIdOK = 0
           end if
           
           if (ppt.ne. 99999. .and. detIdOK .eq. 1
     1        .and. globtrk(i).iflag .gt. 0) then
              xp(1) = xxv(1)
              xp(2) = xxv(2)
              Call evr_project_track(psi,icharge,ppt,tanla,xx0,yy0,b,
     1                               zz0,xp,x,sig,LIFC)
              xa0(1) = x(1)
              xa0(2) = x(2)
              xa0(3) = x(3)
              pa0(1) = dcosd(x(4))
              pa0(2) = dsind(x(4))
              pa0(3) = tanla
              Call ThreeD_dca(xxv,xa0,pa0,x3d0)
              dr = dsqrt((x3d0(1)-xxv(1))**2 + (x3d0(2)-xxv(2))**2
     1                 +(x3d0(3)-xxv(3))**2)
              globtrk(i).impact = dr
              if(dr .lt. evrpar(1).vcut) then
                 j = j + 1
                 globtrk(i).id_start_vertex =
     1           globtrk(i).id_start_vertex + 10*privert(index).id
              end if
           end if
        end do

CCC  Write out the counted number of primary track candidates:
        write(6,*) 'EVR: #primary track candidates = ',j

      end if

        evr_am = STAFCV_OK   

      RETURN
      END


C----------------------------------------------------------------------
      SUBROUTINE EVR_PROJECT_TRACK(psi,q,pt,tanl,x0,y0,bfld,z0,xp,x,
     1           sigma,LIFC)
      IMPLICIT NONE

#include "phys_constants.inc"

CC-----------------------------------------------------------------------
C
C     Input Arguments:
C
C          psi  = azimuthal angle for pt at first point (degrees)
C          q    = particle charge in units of (e)
C          pt   = transverse momentum (GeV/c)
C          tanl = tangent of dip angle at first point
C          x0   = x coordinate of first point (cm)
C          y0   = y coordinate of first point (cm)
C          z0   = z coordinate of first point (cm)
C          bfld = z-component of magnetic field (kilo-gauss)
C          xp   = x & y coordinates of line (parallel to z-axis) to be
C                 approached (cm)
C          LIFC = Radiation length fraction of TPC Inner Field Cage
C                 OR other (e.g. effective SVT first layer) for cases
C                 with SVT and/or SSD space points.
C
C     Output Arguments:
C
C          x(1,2,3,4) = x,y,z coordinates of position on track
C                       corresponding to the distance of closest approach
C                       to the line thru point xp(1),xp(2);
C                       x(4) is the azimuthal angle of pt at this point
C                       in degrees.
C          sigma      = Track position uncertainty estimate at DCA pt. (cm)
C
C     Description:
C
C          This short driver routine determines track curvature and
C          calls the appropriate routine for (sufficiently) curved
C          or straight tracks as needed.  It also estimates the extrap-
C          olated track position uncertainty (sigma) for use in the
C          fitting and error estimate.  This uses the variable trans_pathL
C          where:
C
C          trans_pathL= Transverse (i.e. in x-y plane) path length (cm) along
C                       trajectory from initial point back to the DCA pt.
C
C     Author:   May 1999; R. L. Ray
C     Modified:
C     Error Condition:
C     Status:  Testing (May 99), Done
C
CC-----------------------------------------------------------------------

CC  Local Variable Type Declarations:

      REAL    bfld,ka
      REAL*8  psi,pt,tanl,x0,y0,z0,trans_pathL,LIFC
      REAL*8  xp(2),x(4),epsq,R,RMAX,xc(2),xi
      REAL*8  sigma, sigma_estimate
      INTEGER  q

C      DATA ka  /0.000299792458/
      DATA RMAX /1.0D+05/

      ka = C_D_CURVATURE
CC    Compute epsq = charge*B_z

      epsq = dble(q)*bfld

      if(epsq .eq. 0.0) then    ! If neutral and/or B_z = 0 
         Call PROJECT_ST_TRACK(psi,tanl,x0,y0,z0,xp,x)
         trans_pathL = dsqrt((x0-x(1))**2 + (y0-x(2))**2)
         sigma = sigma_estimate(pt,x0,y0,psi,tanl,trans_pathL,LIFC)
      else
         R = pt/dabs(ka*epsq)
         if(R .le. RMAX) then
            Call PROJECT_HELIX(psi,q,pt,tanl,x0,y0,z0,bfld,xp,x
     1                         ,R,xc,xi)
            trans_pathL = dabs(R*xi)
            sigma = sigma_estimate(pt,x0,y0,psi,tanl,trans_pathL,LIFC)
        else
            Call PROJECT_ST_TRACK(psi,tanl,x0,y0,z0,xp,x)
            trans_pathL = dsqrt((x0-x(1))**2 + (y0-x(2))**2)
            sigma = sigma_estimate(pt,x0,y0,psi,tanl,trans_pathL,LIFC)
         end if
      end if

      Return
      END

C------------------------------------------------------------------------
      SUBROUTINE PROJECT_HELIX(psi,q,pt,tanl,x0,y0,z0,bfld,xp,x
     1                         ,R,xc,xi)  
C------------------------------------------------------------------------
      implicit none
#include "math_constants.inc"
#include "phys_constants.inc"

CC-----------------------------------------------------------------------
C
C     Input Arguments:
C
C          psi  = azimuthal angle for pt at first point (degrees)
C          q    = particle charge in units of (e)
C          pt   = transverse momentum (GeV/c)
C          tanl = tangent of dip angle at first point
C          x0   = x coordinate of first point (cm)
C          y0   = y coordinate of first point (cm)
C          z0   = z coordinate of first point (cm)
C          bfld = z-component of magnetic field (kilo-gauss)
C          xp   = x & y coordinates of line (parallel to z-axis) to be
C                 approached (cm)
C
C     Output Arguments:
C
C          x(1,2,3,4) = x,y,z coordinates of position on helical track
C                       corresponding to the distance of closest approach
C                       to the line thru point xp(1),xp(2);
C                       x(4) is the azimuthal angle of pt at this point
C                       in degrees.
C          R          = radius of circle projection of helix onto x-y plane (cm)
C          xc(1,2)    = x,y coordinates of center of circle (cm)
C          xi         = phase angle from initial point to DCA point (radians)
C
C     Description:
C
C          This code finds the position along an arbitrary helix defined
C          by the input parameters (psi,q,pt,tanl,x0,y0,z0,bfld) which
C          is closest to an arbitrary line parallel to the z-axis going
C          thru a point at x=xp(1), y=xp(2).  It is assumed that the DCA
C          point on the helix occurs when the DCA (x,y) point is first
C          reached in going backwards along the helix trajectory from
C          the initial point on the track.  The center of the circle
C          (projection of helix onto x-y plane) is found first, then
C          the DCA point in x,y is located, then the phase angle in the
C          x-y plane from the initial point back to the DCA point is 
C          evaluated, then the z-coord at the DCA point is computed,
C          and finally the azimuthal angle for the pt momentum direction
C          in the x-y plane at the DCA point (i.e. x(4)) is calculated.
C
C     Author:   May 1999; R. L. Ray
C     Modified:
C     Error Condition:
C     Status:  Testing (May 99), Done
C
CC-----------------------------------------------------------------------

CC  Local Variable Type Declarations:

      REAL    bfld,ka
      REAL*8  psi,pt,tanl,x0,y0,z0
      REAL*8  xp(2),x(4),xc(2)
      REAL*8  R,a,b,c,invc,signa,signb,cut,a1,b1
      REAL*8  phi0,phiDCA,xi,epsq
      INTEGER  q

      DATA cut /1.0D-03/
C      DATA ka  /0.000299792458/

      ka = C_D_CURVATURE
CC    Compute epsq = sign of charge*B_z

      epsq = dble(q)*bfld
      if(epsq .eq. 0.0) then    ! If neutral or B_z = 0 then return defaults
         x(1) = 0.0
         x(2) = 0.0
         x(3) = 0.0
         x(4) = 0.0
         RETURN
      else
         epsq = epsq/dabs(epsq)
      end if

CC    Find radius of helix, center of circle projection onto x-y plane,
CC    and x,y coordinates of DCA point on helix.

      R     = pt/dabs(ka*dble(q)*bfld)
      xc(1) = x0 + R*dcosd(psi - epsq*90.0)
      xc(2) = y0 + R*dsind(psi - epsq*90.0)
      a = xp(1) - xc(1)
      b = xp(2) - xc(2)
      a1 = dabs(a)
      b1 = dabs(b)
      if(a1 .eq. 0.0 .and. b1 .eq. 0.0) then          ! Line coincides
C                                                     ! with axis of helix
C                                                     ! Return initial pt.
         x(1) = x0
         x(2) = y0
         x(3) = z0
         x(4) = psi
         xi   = 0.0
         RETURN
      else if(b1 .eq. 0.0 .and. a1 .gt. 0.0) then
         signa = a/a1
         x(1) = xc(1) + signa*R
         x(2) = xc(2)
      else if(a1 .eq. 0.0 .and. b1 .gt. 0.0) then
         signb = b/b1
         x(1) = xc(1)
         x(2) = xc(2) + signb*R
      else
         c = a/b
         invc = b/a
         signa = a/a1
         signb = b/b1
         x(2) = xc(2) + signb*R/dsqrt(1.0 + c*c)
         if(dabs(invc) .le. cut) then
            x(1) = xc(1) +signa*R*(1.0 - 0.5/(1.0 + c*c))
         else
            x(1) = xc(1) + c*(x(2) - xc(2))
         end if
      end if

CC    Find the phase angle to go from initial point back to the DCA point x;
CC    then calculate the azimuthal direction angle of p_T at the DCA point x.

      phi0 = DATAN2(y0-xc(2),x0-xc(1))
      phiDCA = DATAN2(x(2)-xc(2),x(1)-xc(1))
      xi   = epsq*(phi0 - phiDCA)
      if(xi .gt. 0.0) then
         xi = xi - C_2PI
      end if
      x(3) = z0 + R*tanl*xi
      x(4) = phiDCA*180.0/C_PI - epsq*90.0

      RETURN
      END

C------------------------------------------------------------------------
      SUBROUTINE PROJECT_ST_TRACK(psi,tanl,x0,y0,z0,xp,x)
C------------------------------------------------------------------------
      implicit none

CC-----------------------------------------------------------------------
C
C     Input Arguments:
C
C          psi  = azimuthal angle for pt at first point (degrees)
C          tanl = tangent of dip angle at first point
C          x0   = x coordinate of first point (cm)
C          y0   = y coordinate of first point (cm)
C          z0   = z coordinate of first point (cm)
C          xp   = x & y coordinates of line (parallel to z-axis) to be
C                 approached (cm)
C
C     Output Arguments:
C
C          x(1,2,3,4) = x,y,z coordinates of position on (straight) track
C                       corresponding to the distance of closest approach
C                       to the line thru point xp(1),xp(2);
C                       x(4) is the azimuthal angle of pt at this point
C                       which for straight tracks is identical to psi.
C
C     Description:
C
C          This code finds the position along an arbitrary straight line
C          defined by coordinates x0,y0,z0 and direction determined by
C          psi and tanl, which is closest to an arbitrary line parallel to
C          the z-axis going thru a point at x=xp(1), y=xp(2).
C
C     Author:   Mar 1999; R. L. Ray
C     Modified:
C     Error Condition:
C     Status:  Testing (Mar 99), Done
C
CC-----------------------------------------------------------------------

CC  Local Variable Type Declarations:

      REAL*8  psi,tanl,x0,y0,z0,xp(2),x(4)
      REAL*8  px,py,cut,d,m1,m2,pdu
      DATA cut /1.0D-7/

CC  Determine if special cases apply:

      px = dcosd(psi)
      py = dsind(psi)

      if(abs(px) .le. cut) then
         x(1) = x0
         x(2) = xp(2)
         x(3) = z0 + py*(x(2) - y0)*tanl

      else if (abs(py) .le. cut) then
         x(1) = xp(1)
         x(2) = y0
         x(3) = z0 + px*(x(1) - x0)*tanl

      else
         m2 = py/px           ! slope of pt in x-y plane
         m1 = -1.0/m2         ! slope of line from xp->x @ dca (perp.)
         x(1) = (m1*xp(1)-m2*x0-xp(2)+y0)/(m1-m2)
         x(2) = (m1*m2*(xp(1)-x0) + m1*y0 - m2*xp(2))/(m1-m2)
         d = dsqrt((x(1)-x0)**2 + (x(2)-y0)**2)
         if(d .gt. cut) then
            pdu = px*(x(1)-x0)/d + py*(x(2)-y0)/d
            if(dabs(dabs(pdu)-1.0) .gt. 100.0*cut) then
               if(pdu .ge. 0.0) then
                  pdu = 1.0
               else
                  pdu = -1.0
               end if
            end if

            if(dabs(dabs(pdu)-1.0) .gt. 0.0001) then
               write(6,*) 'EVR: Direction cosines .ne. +/-1,=',pdu
            end if

            x(3) = z0 + pdu*d*tanl
         else
            x(3) = z0
         end if
      end if

CC    For straight tracks:

      x(4) = psi

      Return
      END


C------------------------------------------------------------------------
      Real*8 Function sigma_estimate(pt,x0,y0,psi,tanl,trans_pathL,LIFC)
C------------------------------------------------------------------------
      Implicit none
#include "math_constants.inc"
#include "phys_constants.inc"

CC-----------------------------------------------------------------------
C
C     Input Arguments:
C
C          pt   = transverse momentum (GeV/c)
C          x0   = x coordinate of first point (cm) 
C          y0   = y coordinate of first point (cm) 
C          psi  = azimuthal angle for pt at first point (degrees)
C          tanl = tangent of dip angle at first point
C          trans_pathL = transverse path length (cm) of trajectory
C                        from initial point back to the DCA point.
C          LIFC = Radiation length fraction of TPC Inner Field Cage
C                 OR other, e.g. effective SVT first layer.
C
C     Output:   sigma_estimate = estimated sigma (cm) of position
C                                uncertainty of projected track at
C                                DCA point.
C
C     Description:
C
C          This code assumes all tracks are either:
C             (1) pure TPC space points only, or
C             (2) have SVT - SSD points.
C          For the former the algorithm assumes the TPC only track  
C          starts near the TPC IFC and that MCS in the TPC-IFC is the
C          dominant effect on the projected track position uncertainty
C          at the DCA point.  This neglects the SVT-SSD contribution
C          to MCS if this detector material is present.  This could be
C          of order half the position error squared from the TPC-IFC.
C          The beam pipe contribution is negligible for a beryllium pipe. 
C          
C          For tracks with SVT and/or SSD space points the algorithm
C          assumes the track's first point is in the first layer of the
C          SVT and uses an effective radiation length fraction of one-third
C          of the total of 5% (latter amount from GSTAR geometry and material
C          plots - 1999).  The beam pipe contribution is negligible
C          for a beryllium pipe.  The actual path length from the initial
C          point on the track (in any SVT layer or in the SSD 4th layer)
C          to the extrapolated DCA point is used however.
C          
C          In both cases the position uncertainty is assumed to be the
C          spatial rms MCS angle uncertainty [sqrt(2.0)*theta_0] times
C          the path length.
C
C     Author:   May 1999; R. L. Ray
C     Modified: Physics and Math constants added July 1999, R.L.Ray
C     Error Condition:
C     Status:  Testing (May 99), Done
C
CC-----------------------------------------------------------------------

CC  Local Variable Type Declarations:

      REAL*8 pt,x0,y0,psi,tanl,trans_pathL
      REAL*8 fac,ptot,phi0,cospr,Leff,LIFC
      REAL*8 theta_mcs
      REAL   sqrt2
C      DATA sqrt2  /1.4142135/

      sqrt2 = C_SQRT2
      fac = dsqrt(1.0 + tanl*tanl)
      ptot = pt*fac
      phi0 = DATAN2(y0,x0)
      cospr = dcos(psi*C_PI/180.0 - phi0)/fac
c     cospr = (dcosd(psi)*dcos(phi0) + dsind(psi)*dsin(phi0))/fac

      if(cospr .eq. 0.0) then
         sigma_estimate = trans_pathL*fac*sqrt2*
     1         theta_mcs(0.14,1.0,ptot,LIFC,1.0,1)
      else
         Leff = LIFC/dabs(cospr)
         sigma_estimate = trans_pathL*fac*sqrt2*
     1         theta_mcs(0.14,1.0,ptot,Leff,1.0,1)
      end if

      Return
      END
 
C---------------------------------------------------------------------- 
      Real*8 Function theta_mcs(mass,charge,momentum,L,LR,
     1       formula_type)
      implicit none
C----------------------------------------------------------------------

CCC   Calculation of the Multiple Coulomb Scattering rms planar angle theta0
C     using the formula in the Particle Data Group's article in Phys. Lett.
C     B204 (1988), pg. 65; or the alternate formula by the Particle Data
C     Group in "Particle Physics Booklet," AIP Press, July 1996, p. 167.
C
C     INPUT:
C
C          formula_type = 0 to use the Phys. Lett. formula given by
C
C                         theta0 = (14.1 MeV/c /(p*beta)) Z_inc sqrt{L/LR}
C                                * [1 + (1/9)log10(L/LR)] in radians
C                       where (1/9)log10(x) = 0.048254ln(x)
C
C          formula_type = 1 to use the Particle Physics Booklet version,
C
C                         theta0 = (13.6 MeV/c /(p*beta)) Z_inc sqrt{L/LR}
C                                * [1 + 0.038 ln(L/LR)] in radians
C          Note: the default is set to 1.
C
C          mass     - particle mass in GeV.
C          charge   - particle charge in |e|.
C          momentum - particle momentum relative to medium in GeV/c.
C          L        - path length thru medium in cm.
C          LR       - radiation length for medium in cm.
C
C     OUTPUT:
C
C          theta_mcs = theta0, rms angle in plane in radians.
CCC

CCC   Variable Declarations:

      real   mass,charge,LR
      real*8 momentum,L
      real*8 theta_fac0, theta_fac1, LOGFAC0, LOGFAC1
      real*8 E, gamma, beta, LFAC
      integer*4 formula_type

      parameter(theta_fac0 = 14.1)
      parameter(theta_fac1 = 13.6)
      parameter(LOGFAC0    = 0.048254)
      parameter(LOGFAC1    = 0.038)

CCC   Begin Calculation, if L or LR = 0.0, set theta_mcs to zero and return:

      if(L .le. 0.0 .or. LR .le. 0.0) then
         theta_mcs = 0.0
      else
         LFAC = L/LR
         E = dsqrt(momentum**2 + mass**2)
         gamma = E/mass
         beta = dsqrt(1.0 - 1.0/(gamma**2))

         if(formula_type .eq. 0) then
            theta_mcs = theta_fac0*abs(charge)*dsqrt(LFAC)
     1      *(1.0 + LOGFAC0*dlog(LFAC))/(1000.0*momentum*beta)
         else
            theta_mcs = theta_fac1*abs(charge)*dsqrt(LFAC)
     1      *(1.0 + LOGFAC1*dlog(LFAC))/(1000.0*momentum*beta)
         end if

      end if

      Return
      END 

C-------------------------------------------------------------------
	SUBROUTINE EVR_VERTEX_FIT(NT)
	IMPLICIT NONE
CC:>--------------------------------------------------------------------
CC:Passed parameters:  NT = number of tracks involved in the fit
CC:returned param:    
CC:		      Xv,Yv,Zv = the vertex co-ordinants
CC:		      NT = number of tracks used for the vertex fitting
CC:			   (note this variable is passed and returned.)
CC:		       the pointer list is reordered to reflect which
CC:		       tracks were used in the fit
CC:
CC:Description: It performs the least square fit to find a common vertex
CC:for NT tracks whose parameters are stored in the /fitvert/ common.
CC:The vertex information is returned as coordinants.
CC:
CC:Written by Daniel Cebra
CC:Modified for STAR by S. Margetis
CC: Modified by R. L. Ray, May 1999, add errors and clean-up unused 
CC: stuff.  Add calculation of error covariance matrix for 3D vertex
CC: position.  The cov(1,2...6) matrix is defined by:
CC:
CC:           cov(#) |   x   y   z
CC:           ----------------------
CC:              x   |   1
CC:              y   |   2   3
CC:              z   |   4   5   6
CC:           ----------------------
CC:
CC: Also the Chi-Square of the fit is computed and returned to the
CC: calling program via the common block /VERTEX/.
CC:
CC:   Status:   Testing in May, 1999, Done.
CC:>--------------------------------------------------------------------

	integer ngmx
	PARAMETER (NGMX=5000)
	REAL*8 vtrv(6,ngmx)
	common /fitvert/ vtrv
	real*8 Xv,Yv,Zv,cov(6),chisq
	COMMON /VERTEX/XV,YV,ZV,cov,chisq
c  passed parameters:
	integer NT

c  Local variables:
	integer i,j,k
	real*8 x0,y0,z0
	real*8 sinV,cosV,sinL,cosL
	real*8 sigma(3,3),H(3),G(3,3),Txx,Txy,Txz,Tyy,Tyz,Tzz,G_inv(3,3)
	real*8 sigma2,det
        real*8 E(3,3),Exx,Exy,Exz,Eyy,Eyz,Ezz,E_inv(3,3),detE
        real*8 Sigxv,Sigyv,Sigzv
        real*8 ex,ey,ez

c  Convention: L=angle lambda, V=angle phi

200	do i=1,3			! Clear the transformation matrices
	  H(i)=0.0
	  do j=1,3
	    G(i,j)=0.0
            E(i,j)=0.0
	  end do
	end do

CC  Initialize all output quantities:
        xv = 0.0
        yv = 0.0
        zv = 0.0
        chisq = 0.0
        do i = 1,6
           cov(i) = 0.0
        end do

      if(nt.le.0) then
         xv = -99999.
         Return
      end if

	do k=1,nt			! Master loop over tracks
	  sinV=dsind(vtrv(1,k))
	  cosV=dcosd(vtrv(1,k))
	  cosL=1.0/(dsqrt(1.0 + vtrv(2,k)**2))
	  sinL=cosL*vtrv(2,k)

	  X0= vtrv(4,k)
	  Y0= vtrv(5,k)
	  Z0= vtrv(6,k)
          sigma2 = vtrv(3,k)*vtrv(3,k)
CCC   Fix sigma**2 lower limit at (0.1 cm)**2, based on test runs & optimization
CCC   study, April 3-11, 2000 at UT.
          if(sigma2.lt.0.01) sigma2 = 0.01

c  Calculate the matrix elements of Ti (individual transformation matrices)
c  in the document Mi is the same as Ti
	  Txx= sinL**2+(sinV*cosL)**2
	  Txy=-cosL*cosL*cosV*sinV
	  Txz=-cosV*cosL*sinL
	  Tyy= sinL**2+(cosL*cosV)**2
	  Tyz=-cosL*sinL*sinV
	  Tzz= cosL*cosL
          Txx = Txx/sigma2
          Txy = Txy/sigma2
          Txz = Txz/sigma2
          Tyy = Tyy/sigma2
          Tyz = Tyz/sigma2
          Tzz = Tzz/sigma2
c  Compute inverse of covariance matrix:
          Exx = (1.0 - (cosV*cosL)**2)/sigma2
          Eyy = (1.0 - (sinV*cosL)**2)/sigma2
          Ezz = (1.0 - sinL**2)/sigma2
          Exy = Txy
          Exz = Txz
          Eyz = Tyz
c  The G matrix is the summations of the individual transformation matrices 
	  G(1,1)=G(1,1)+Txx
	  G(1,2)=G(1,2)+Txy
	  G(1,3)=G(1,3)+Txz
	  G(2,2)=G(2,2)+Tyy
	  G(2,3)=G(2,3)+Tyz
	  G(3,3)=G(3,3)+Tzz
c  sum the inverse covariance matrix:
          E(1,1) = E(1,1) + Exx
          E(1,2) = E(1,2) + Exy
          E(1,3) = E(1,3) + Exz
          E(2,2) = E(2,2) + Eyy
          E(2,3) = E(2,3) + Eyz
          E(3,3) = E(3,3) + Ezz
c  The H vector is the summation of the Qi times Ti
	  H(1)=H(1)+X0*Txx+Y0*Txy+Z0*Txz
	  H(2)=H(2)+X0*Txy+Y0*Tyy+Z0*Tyz
	  H(3)=H(3)+X0*Txz+Y0*Tyz+Z0*Tzz
	end do
c  assign the reflexive elements
	G(2,1)=G(1,2)
	G(3,1)=G(1,3)
	G(3,2)=G(2,3)
        E(2,1)=E(1,2)
        E(3,1)=E(1,3)
        E(3,2)=E(2,3)
c  Invert the G matrix and calculate the determinant
c  Calcualate the determinant
	det=G(1,1)*(G(2,2)*G(3,3)-G(2,3)*G(3,2))-
     >      G(2,1)*(G(1,2)*G(3,3)-G(1,3)*G(3,2))+
     >      G(3,1)*(G(1,2)*G(2,3)-G(1,3)*G(2,2))
	IF(abs(DET).LT.1.0E-25) THEN
	    write(6,*) 'EVR: V_F: determinant too small, det=',det
	    write(6,*) 'EVR:', (G(1,k),k=1,3)
	    write(6,*) 'EVR:', (G(2,k),k=1,3)
	    write(6,*) 'EVR:', (G(3,k),k=1,3)
            xv = -99999.    !  Identify this as a failed fit attempt
	    GO TO 999
	END IF
	G_inv(1,1)=+(G(2,2)*G(3,3)-G(2,3)*G(3,2))/det
	G_inv(1,2)=-(G(1,2)*G(3,3)-G(1,3)*G(3,2))/det
	G_inv(1,3)=+(G(1,2)*G(2,3)-G(1,3)*G(2,2))/det
	G_inv(2,1)=-(G(2,1)*G(3,3)-G(2,3)*G(3,1))/det
	G_inv(2,2)=+(G(1,1)*G(3,3)-G(1,3)*G(3,1))/det
	G_inv(2,3)=-(G(1,1)*G(2,3)-G(1,3)*G(2,1))/det
	G_inv(3,1)=+(G(2,1)*G(3,2)-G(2,2)*G(3,1))/det
	G_inv(3,2)=-(G(1,1)*G(3,2)-G(1,2)*G(3,1))/det
	G_inv(3,3)=+(G(1,1)*G(2,2)-G(1,2)*G(2,1))/det

c  The vertex vector = The inverted G matrix times the H vector

	Xv=G_inv(1,1)*H(1)+G_inv(1,2)*H(2)+G_inv(1,3)*H(3)
	Yv=G_inv(2,1)*H(1)+G_inv(2,2)*H(2)+G_inv(2,3)*H(3)	
	Zv=G_inv(3,1)*H(1)+G_inv(3,2)*H(2)+G_inv(3,3)*H(3)	
        write(6,*) 'EVR: Estimated Vertex:',Xv,Yv,Zv

CC  Compute Chi-Square of fit to vertex, return the total chi-square value:
        do k = 1,nt
           sinV = dsind(vtrv(1,k))
           cosV = dcosd(vtrv(1,k))
           cosL = 1.0/dsqrt(1.0 + vtrv(2,k)**2)
           ex = cosV*cosL
           ey = sinV*cosL
           ez = vtrv(2,k)*cosL
           X0 = vtrv(4,k)
           Y0 = vtrv(5,k)
           Z0 = vtrv(6,k)
           sigma2 = vtrv(3,k)*vtrv(3,k)
           if(sigma2 .eq. 0.0) sigma2 = 1.0
           chisq = chisq
     1           + (((YV - Y0)*ez - (ZV- Z0)*ey)**2
     2           +  ((XV - X0)*ey - (YV- Y0)*ex)**2
     3           +  ((ZV - Z0)*ex - (XV- X0)*ez)**2)/sigma2
        end do
C        chisq = chisq/dble(nt)   !  Return the Total Chi Square

c  Invert the E matrix and calculate the determinant
c  Calcualate the determinant
       detE=E(1,1)*(E(2,2)*E(3,3)-E(2,3)*E(3,2))-
     >      E(2,1)*(E(1,2)*E(3,3)-E(1,3)*E(3,2))+
     >      E(3,1)*(E(1,2)*E(2,3)-E(1,3)*E(2,2))
        IF(abs(detE).LT.1.0E-25) THEN
            write(6,*) 'EVR: COV determinant too small, det=',detE
            write(6,*) 'EVR:', (E(1,k),k=1,3)
            write(6,*) 'EVR:', (E(2,k),k=1,3)
            write(6,*) 'EVR:', (E(3,k),k=1,3)
            yv = -99999.  !  Identify this as a failed fit for the
CCC                       !  covariance matrix calculation.
            GO TO 999
        END IF
        E_inv(1,1)=+(E(2,2)*E(3,3)-E(2,3)*E(3,2))/detE
        E_inv(1,2)=-(E(1,2)*E(3,3)-E(1,3)*E(3,2))/detE
        E_inv(1,3)=+(E(1,2)*E(2,3)-E(1,3)*E(2,2))/detE
        E_inv(2,1)=-(E(2,1)*E(3,3)-E(2,3)*E(3,1))/detE
        E_inv(2,2)=+(E(1,1)*E(3,3)-E(1,3)*E(3,1))/detE
        E_inv(2,3)=-(E(1,1)*E(2,3)-E(1,3)*E(2,1))/detE
        E_inv(3,1)=+(E(2,1)*E(3,2)-E(2,2)*E(3,1))/detE
        E_inv(3,2)=-(E(1,1)*E(3,2)-E(1,2)*E(3,1))/detE
        E_inv(3,3)=+(E(1,1)*E(2,2)-E(1,2)*E(2,1))/detE

CC  Load the covariance matrix elements:

        cov(1) = E_inv(1,1)
        cov(2) = E_inv(2,1)
        cov(3) = E_inv(2,2)
        cov(4) = E_inv(3,1)
        cov(5) = E_inv(3,2)
        cov(6) = E_inv(3,3)
        Sigxv = 0.0
        Sigyv = 0.0
        Sigzv = 0.0
        if(cov(1) .ge. 0.0) Sigxv = dsqrt(cov(1))
        if(cov(3) .ge. 0.0) Sigyv = dsqrt(cov(3))
        if(cov(6) .ge. 0.0) Sigzv = dsqrt(cov(6))
        write(6,*) 'EVR: Diagonal Errors:', Sigxv,Sigyv,Sigzv
        write(6,*) 'EVR: COV=',cov(1),cov(2),cov(3),cov(4),cov(5),cov(6)
999	Return
	END

C----------------------------------------------------------------------
      SUBROUTINE ThreeD_dca(xv,x,p,x0)
C----------------------------------------------------------------------
      IMPLICIT NONE
C   Input arguments     xv      ! 3-dimensional position vector 
C                               ! of the main vertex
C                       x       ! 3-dimensional position vector 
C                               ! of the secondary track
C                       p       ! 3-dimensional momentum vector of the 
C                               ! reconstructed secondary particle
C   Output arguments :  x0      ! coordinates of closest approach
C
C   Functional Description:     Finds the coordinates of the point of
C                               closest approach from the main vertex
C                               The input vectors must be calculated
C                               at a point close to the vertex.
C   Created  JUN-1992  S.Margetis
C   Modified: 4/2/99 R.L.Ray
C             Nov. 2000 G. van Buren - optimized algebra
C   Error conditions            : Error for p(1)=0 fixed (4/2/99 RLR)
C   Status                      : Tested
C----------------------------------------------------------------------
      REAL*8    xv(3),x(3),p(3),x0(3),nom,cut,det
      REAL*8    p1sq,p2sq,p3sq,temp
      DATA  cut /1.0D-06/
*----------------------------------------------------------------------

        p1sq = p(1)**2
        p2sq = p(2)**2
        p3sq = p(3)**2
        nom=(p2sq+p3sq)*x(1)-(x(2)*p(2)+x(3)*p(3))*p(1) 
        nom=nom+(xv(1)*p(1)+xv(2)*p(2)+xv(3)*p(3))*p(1)
        x0(1)=nom/( p1sq+p2sq+p3sq )

C       IF(p(1).ne.0.) THEN
        IF(dabs(p(1)) .gt. cut) THEN              ! RLR (4/99)
         temp=(x0(1)-x(1))/p(1)
         x0(2)=x(2)+p(2)*temp
         x0(3)=x(3)+p(3)*temp
        ELSE
         temp = p(2)*p(3)
         det = p2sq + p3sq                       ! RLR (4/99)
         x0(2)=(x(2)*p3sq+xv(2)*p2sq+            ! RLR (4/99)
     1         (xv(3)-x(3))*temp)/det            ! RLR (4/99)
         x0(3)=(x(3)*p2sq+xv(3)*p3sq+            ! RLR (4/99)
     1         (xv(2)-x(2))*temp)/det            ! RLR (4/99)

C        x0(3)=p(2)*(x(3)*p(2)-x(2)*p(3))/(p(2)*p(2)+p(3)*p(3))
C               IF(p(2).eq.0.) THEN
C                x0(2)=x(2)
C               ELSE
C                x0(2)=-x0(3)*p(3)/p(2)
C               ENDIF

        ENDIF

      RETURN
      END

C----------------------------------------------------------------------
      INTEGER*4 FUNCTION DetectorId(ndim,D)
C----------------------------------------------------------------------
      IMPLICIT NONE
#include "StDetectorId.inc"

CC   This function determines the complete list of detectors among
CC   the TPC, SVT and SSD (not FTPC) that contribute hits to all the 
CC   tracks selected in the initial track selection loop.  The return
CC   value indicates the detectors used via the Detector ID definitions
CC   in StDetectorDefinitions.h

      INTEGER ndim
      INTEGER D(ndim)

CC   TPC tracks only:
      if(D(kTpcId) .gt. 0 .and. D(kSvtId)       .eq. 0
     1                    .and. D(kSsdId)       .eq. 0
     2                    .and. D(kTpcSsdId)    .eq. 0
     3                    .and. D(kTpcSvtId)    .eq. 0
     4                    .and. D(kTpcSsdSvtId) .eq. 0
     5                    .and. D(kSsdSvtId)    .eq. 0) then
         DetectorId = kTpcId
         Return

CC   SVT tracks only:
      else if(D(kSvtId) .gt. 0 .and. D(kTpcId)       .eq. 0
     1                         .and. D(kSsdId)       .eq. 0
     2                         .and. D(kTpcSsdId)    .eq. 0
     3                         .and. D(kTpcSvtId)    .eq. 0
     4                         .and. D(kTpcSsdSvtId) .eq. 0
     5                         .and. D(kSsdSvtId)    .eq. 0) then
         DetectorId = kSvtId
         Return

CC   SSD tracks only (nonsensical case but who knows, maybe ?):
      else if(D(kSsdId) .gt. 0 .and. D(kTpcId)       .eq. 0
     1                         .and. D(kSvtId)       .eq. 0
     2                         .and. D(kTpcSsdId)    .eq. 0
     3                         .and. D(kTpcSvtId)    .eq. 0
     4                         .and. D(kTpcSsdSvtId) .eq. 0
     5                         .and. D(kSsdSvtId)    .eq. 0) then
         DetectorId = kSsdId
         Return

CC   SVT-TPC tracks:
      else if(((D(kTpcId).gt.0 .and. D(kSvtId).gt.0) .or.
     1   D(kTpcSvtId).gt.0)    .and. D(kSsdId)       .eq. 0
     2                         .and. D(kTpcSsdId)    .eq. 0
     3                         .and. D(kTpcSsdSvtId) .eq. 0
     4                         .and. D(kSsdSvtId)    .eq. 0) then
         DetectorId = kTpcSvtId
         Return

CC   SSD-TPC tracks:
      else if(((D(kTpcId).gt.0 .and. D(kSsdId).gt.0) .or.
     1   D(kTpcSsdId).gt.0)    .and. D(kSvtId)       .eq. 0
     2                         .and. D(kTpcSvtId)    .eq. 0
     3                         .and. D(kTpcSsdSvtId) .eq. 0
     4                         .and. D(kSsdSvtId)    .eq. 0) then
         DetectorId = kTpcSsdId
         Return

CC   SSD-SVT tracks:
      else if(((D(kSsdId).gt.0 .and. D(kSvtId).gt.0) .or.
     1   D(kSsdSvtId).gt.0)    .and. D(kTpcId)       .eq. 0
     2                         .and. D(kTpcSsdId)    .eq. 0
     3                         .and. D(kTpcSvtId)    .eq. 0
     4                         .and. D(kTpcSsdSvtId) .eq. 0) then
         DetectorId = kSsdSvtId
         Return

CC   TPC-SSD-SVT tracks:
      else if((D(kTpcId).gt.0 .and. D(kSsdId).gt.0 .and.
     1         D(kSvtId).gt.0)
     2   .or. (D(kTpcId).gt.0 .and. D(kSsdSvtId).gt.0)
     3   .or. (D(kSsdId).gt.0 .and. D(kTpcSvtId).gt.0)
     4   .or. (D(kSvtId).gt.0 .and. D(kTpcSsdId).gt.0)
     5   .or. (D(kTpcSsdSvtId).gt.0)) then
         DetectorId = kTpcSsdSvtId
         Return

      else
         DetectorId = kUnknownId
         Return
      end if

      END

