* $Id: tpt_helix_fit.F,v 1.9 2000/11/14 22:29:08 genevb Exp $
* $Log: tpt_helix_fit.F,v $
* Revision 1.9  2000/11/14 22:29:08  genevb
* Switched from float to double in many places
*
* Revision 1.8  2000/03/10 05:27:42  sakrejda
* Track length calculation fixed. Was not going past 90 deg before.
*
* Revision 1.7  2000/01/21 07:55:46  sakrejda
* Calculation of track length along the helix improved. Makes chisq and residuals symmetric.
*
* Revision 1.6  1999/09/14 00:53:13  liq
* add tpt_mxdim.inc, use tpt_track_pointers.inc instead of tpt_pointers.inc in order to used by C++ codes
*
* Revision 1.5  1999/07/19 19:15:54  genevb
* Use StMessMgr
*
* Revision 1.4  1999/03/30 15:55:01  love
*  Spelling.  make_segment_uv removed doubling of tolerance on row skip.
*  row_sect_point remove check on sector z position
*
* Revision 1.3  1998/05/26 04:15:13  sakrejda
* message type set to E to limit printing
*
* Revision 1.2  1998/01/27 00:35:47  fisyak
* Split sources
*
      INTEGER FUNCTION TPT_HELIX_FIT(ipt,trk,xcir,ycir,zcir,
     >                               wcir,wlin,ncir,tpar_h,tpar,ipass)
C>----------------------------------------------------------------------
C
C TPT_HELIX_FIT
C<----------------------------------------------------------------------

      IMPLICIT NONE
C     
C     Input arguments
C     ipt - track id
C     xcir - x coordinates of the hits
C     ycir - y coordinates of the hits
C     zcir - z coordinates of the hits
C     wcir - weights for the circle fit
C     wlin - weights for the linear regresion fit
C     ncir - number of points included in fit
C
C     Output arguments
C     trk - track parameters
C
C     Functional description
C     Circle fit in the x-y plane and the linear regression in s-z
C
C___________________________________________________________________
#include "PAM.inc"

#include "tpt_pars.inc"
#include "tpt_mxdim.inc"
#include "tpt_track_pointers.inc"
#include "math_constants.inc"
C____________________________________________________________________
      RECORD /tpt_track_pointers_st/ trk(*)
      RECORD /table_head_st/    tpar_h
      RECORD /tpt_pars_st/    tpar(*)
      
      INTEGER ier,ncir,ipt,utcfit,ks,lswlf,circov
      REAL    sgn, rad, phi0, x0, y0, z0, tanl, chit, chil
      REAL    acent,bcent,scir(mxpnt),rr,zint
      REAL    dtanl,dzint
      REAL    xcir(*),ycir(*),wcir(*),zcir(*),wlin(*)
      REAL*8  refx,refy,refmod,curx,cury,curmod
      REAL*8  dangle,dpsi,charge,h(3,3)
      LOGICAL good
      CHARACTER*80 m80
      INTEGER ier1,ipass
C___________________________________________________________________
      DATA ier1 /0/
C___________________________________________________________________
      tpt_helix_fit =  STAFCV_OK
      ier = 0
      sgn = 0
      rad = 0
      phi0 = 0
      x0 = 0
      y0 = 0
      z0 = 0
      tanl = 0
      chit = 999999.0
      chil = 999999.0
C
      ier =utcfit(xcir,ycir,wcir,ncir,sgn,rad,acent,bcent,chit)
      if(ier.ne.0) then
          if(tpar(ipass).debug(2).eq.1) then
             call StInfo('TPT_HELIX_FIT - out with error')
          endif
          tpt_helix_fit =  STAFCV_BAD
      else
C        evaluate charge
         if(tpar(ipass).debug(2).eq.1) then
            call StInfo('TPT_HELIX_FIT - out from utcfit - no error')
         endif
         charge = (acent-xcir(ncir/2))*(ycir(ncir/2)-ycir(ncir/2-1))
     >          - (bcent-ycir(ncir/2))*(xcir(ncir/2)-xcir(ncir/2-1))
         if(charge.gt.0) sgn = 1.0
         if(charge.lt.0) sgn = -1.0
C        evaluate errors
         ier = circov(xcir,ycir,wcir,ncir,acent,bcent,rad,h)
         refx=xcir(1)-acent
         refy=ycir(1)-bcent
         refmod=dsqrt(refx**2+refy**2)
         phi0 = datan2(refy,refx)
         scir(1)=0.
         rr=abs(rad)
         ks=1
         good = .true.
         do while(ks.lt.ncir.and.good)
             ks = ks + 1
             curx=xcir(ks)-acent
             cury=ycir(ks)-bcent
             curmod=dsqrt(curx**2+cury**2)
             dpsi = dabs(-refx*cury+refy*curx)/(refmod*curmod)
             dangle = dasin(dpsi)
             scir(ks) = rr*dangle
             if(ks.gt.1.and.scir(ks).lt.scir(ks-1))then
                 scir(ks)= rr*(C_PI-dangle)
             endif 
C
         end do
         chil = 999999.0
         if(ncir.ge.3)then
            ier =lswlf(scir,zcir,wlin,ncir,tanl,zint,chil,dtanl,dzint) 
         else
            ier = 1
            tpt_helix_fit = STAFCV_BAD
         endif
         if(ier.ne.0) then
             tpt_helix_fit =  STAFCV_BAD 
             if(tpar(ipass).debug(2).eq.1) then
             write(m80,'(a50,i5)') 
     >    'TPT_HELIX_FIT-E1 linear fit error, track',ipt
             call message(m80, 1, ier1)
             endif
         else
C            calculate parameters of the first fitted point
             if(tpar(ipass).debug(2).eq.1) then
               write(m80,*) 'TPT_HELIX_FIT - initialising track', ipt,ncir
               call StInfo(m80)
               write(m80,*) chil,trk(ipt).nhit
               call StInfo(m80)
             endif
             trk(ipt).flag=1
             trk(ipt).p(1) = 1
             trk(ipt).p(2) = sgn*rr
             trk(ipt).p(3) = acent
             trk(ipt).p(4) = bcent
             trk(ipt).p(5) = phi0
             trk(ipt).p(6) = zint
             trk(ipt).p(7) = tanl
             trk(ipt).p(8) = chit
             trk(ipt).p(9) = chil
             trk(ipt).dpar(1) = h(1,1)
             trk(ipt).dpar(2) = h(1,2)
             trk(ipt).dpar(3) = h(1,3)
             trk(ipt).dpar(4) = h(2,2)
             trk(ipt).dpar(5) = h(2,3)
             trk(ipt).dpar(6) = h(3,3)
             trk(ipt).dpar(7) = 0.0
             trk(ipt).dpar(8) = dtanl
             trk(ipt).dpar(9) = dzint
         endif
      endif

      end
