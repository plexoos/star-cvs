
  The Search/Sort routines currently available are:
  
<UL>
<LI>      tls_Zero_Row( el1, el2 )
<LI>      tls_Id_Offsets( nrows, iel1, iel2, index, isize )

<LI>      tls_Index_Sort_i( nrows, iel1, iel2, index, ind_size )
<LI>      tls_Index_Sort_r( nrows, rel1, rel2, index, ind_size )

<LI>      tls_Quick_Sort_i( nrows, iel1, iel2, table )
<LI>      tls_Quick_Sort_r( nrows, rel1, rel2, table )

<LI>      tls_Search_i( nrows, iel1, iel2, key, j_table_off, k_rows )
<LI>      tls_Search_r( nrows, rel1, rel2, key, j_table_off, k_rows )

<LI>      tls_Search_Index_i( nrows, iel1, iel2, ikey,
                              j_table_off, k_rows, index, j_index_off )
<LI>      tls_Search_Index_r( nrows, rel1, rel2, rkey,
                              j_table_off, k_rows, index, j_index_off )

<LI>      tls_Search_Near_i( nrows, iel1, iel2, ikey, j_table_off, k_rows )
<LI>      tls_Search_Near_r( nrows, rel1, rel2, rkey, j_table_off, k_rows )

<LI>      tls_Search_Near_Index_i( nrows, iel1, iel2, ikey,
                                   j_table_off, k_rows, index, j_index_off )
<LI>      tls_Search_Near_Index_r( nrows, rel1, rel2, rkey,
                                   j_table_off, k_rows, index, j_index_off )

</UL>

  Each routine is documented in the source code
(<a href=tls_src/tls_sort_routines.F>tls_sort_routines.F</a>
in .../sys/tls/src). All routines are INTEGER FUNCTIONS and return SCV
values which can be used
to determine if there may have been a problem.
If you have problems with any of these routines please
contact me (prindle@npl.washington.edu).
A simple example of how you might use these routines can be found
<A HREF="sort_example.F">here</A>.<p>

  As you can see there is a quick-sort routine that actually re-orders
a table, and index-sort routine that leaves the table alone and returns
an index which lets you access the table in order, a binary search routine
that assumes a sorted table and a binary search routine that uses an
index-sorted table. There are also versions of the binary search routines
that are faster if you are near to the item you are searching for.
For example if you just found track 879 and are looking for track 880.<p>

The routines listed assume that the item in the table being sorted/searched
is INTEGER*4 (_i) or REAL*4 (_r). There are plans for I*1, I*2, I*8
and R*8 versions, but I had hoped to postpone their implementation
until after I re-write these in Fortran 90. If you need to sort/search
on one of the other data types let me know.<p>

When these routines are implemented in Fortran 90 I plan to define generic
routines:

<UL>
<LI>      INTEGER FUNCTION tls_Index_Sort
<LI>      INTEGER FUNCTION tls_Quick_Sort
<LI>      INTEGER FUNCTION tls_Search
</UL>
      
The compiler will be able to pick out the correct routine to use
depending on whether the arguments ar I*1, I*2, I*4, I*8, R*4 or R*8.
Also depending on the presence of optional arguments the correct
Search, Search_Index, Search_Near or Search_Near_Index routine will
be called.
