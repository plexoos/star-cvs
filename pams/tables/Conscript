#!/usr/local/bin/perl
Import qw ( env INCLUDE LIB BIN EXPORT BUILD OBJ);
$my_env = $env->clone(
		    'DEBUG'      => ' '
		    );
my $Dir = "pams";                           print "Build Tables for $Dir\n";
my @idl = find_idl($Dir); # print "@idl\n"; 
my @idlT = ();
my %idl    = ();
my @sources = (); 
my $src;
my $DIR = cwd();# print "DIR = $DIR\n";
my $obj = $OBJ . "/pams/tables"; 
my $share  = "#.share/tables";# print "share = $share\n";
Link $obj =>  $share; print "Link $obj =>  $share\n";
my $SO_PKG = "St_Tables.so";
foreach my $idl (@idl) {#  print "$idl\n";
  if (! grep (/\/idl\//,$idl)) {next;} 
  my $IDL =  $DIR . '/' . $Dir . "/" . $idl;# print "i=",$i++," idl = $idl IDL=$IDL\n";
  push @idlT, $IDL; 
  my $stem = basename ($IDL, ".idl");# print "stem = $stem\n";
  $idl{$stem} = $IDL;
}# print "idlT = @idlT\n";
Install $my_env $share, @idlT;
#___________________________________
(my $build = $obj) =~ s/\#//g;  #print "OBJ = $OBJ build = $build MAIN = $MAIN\n";
my($cscanner) = find scan::cpp($env->{_cwd}, $env->{CPPPATH});
my $CPPPATH = $cscanner->iflags;#  print "CPPPATH = $CPPPATH\n";
foreach my $stem (sort keys %idl) { 
  my $idll = ($idl{$stem});# print "stem = $stem; idll: $idl{$stem}\n";
  my $dir  = dirname ($idll); #print "dir = $dir\n"; 
  my $idl  = basename ($idl{$stem});
  my $idlH = $share . "/" . $stem . ".h"; 
  my $idlI = $share . "/" . $stem . ".inc"; 
  (my $Dir = $dir) =~ s/\#//g; #print "Dir = $Dir\n";
  my @Deps = ($idll);# print "Deps: $Deps[0]\n";
  Command $my_env [$idlH, $idlI], @Deps, qq (cd %>:d  &&  stic -H -q %1 );
  my $idlHH = $obj . "/St_" . $stem . "_Table.h";# print "idlHH: $idlHH\n";
  TableH   $my_env $idlHH, Conscript; 
  my $idlCXX = $obj . "/St_" . $stem . "_Table.cxx";# print "idlCXX: $idlCXX\n";
  TableCXX $my_env $idlCXX, Conscript, 
  Install $my_env  $share, $idlHH;
  push @sources, $idlCXX;
  my $idlcintC = "St_" . $stem . "_TableCint.cxx";
  my $idlCintC = $obj . "/" . $idlcintC;   
  my $idlCintH = $obj . "/St_" . $stem . "_TableCint.h"; 
  my $idlhh    = basename($idlHH);
  (my $idlHHH = $idlHH) =~ s/$obj/$share/g;
  my $LinkDef = $build . "/" . $stem . "LinkDef.h";# print "LinkDef = $LinkDef\n";
  TableLinkDef $env $LinkDef, Conscript;
  @Deps = ($idlHHH);
  push @Deps, $idlH;
  push @Deps, $idlI;
  Command $my_env [$idlCintC, $idlCintH], @Deps,  qq (cd %>:d && rootcint -f $idlcintC -c $CPPPATH %1:f);
  push @sources, $idlCintC; 
}
LinkedModule $my_env $SO_PKG, @sources;
Install $my_env $LIB, $SO_PKG;
#________________________________________
sub cons::TableH {
#  my($env, $dst, $src) = shift;
  my $env = shift;
  (my $dst = shift) =~ s/^\#//g; 
  my $dir = dirname($dst);
  script::rmkdir($dir);
  (my $stem = basename($dst,"_Table.h")) =~ s/^St_//g;# print "cons::TableH stem = $stem\n";
  open (OUT,">$dst") or die "Can't open $dst\n";
  print OUT "#ifndef STAF_St_$stem_Table\n";
  print OUT "#define STAF_St_$stem_Table\n";
  print OUT "\n";
  print OUT "#include \"St_Table.h\"\n";
  print OUT "\n";
  print OUT "#include \"$stem.h\"\n";
  print OUT "\n";
  print OUT "class St_$stem : public St_Table\n";
  print OUT "{\n";
  print OUT "protected:\n";
  print OUT "  static St_tableDescriptor *fgColDescriptors;\n";
  print OUT "  virtual St_tableDescriptor *GetRowDescriptors() const { return fgColDescriptors?fgColDescriptors:(fgColDescriptors=GetTableDescriptors());}\n";
  print OUT "  virtual void  SetRowDescriptors(St_tableDescriptor *list) { fgColDescriptors = list;}\n";
  print OUT "public:\n";
  print OUT "  St_$stem() : St_Table(\"$stem\",sizeof($stem_st)) {SetType(\"$stem\");}\n";
  print OUT "  St_$stem(Text_t *name) : St_Table(name,sizeof($stem_st)) {SetType(\"$stem\");}\n";
  print OUT "  St_$stem(Int_t n): St_Table(\"$stem\",n,sizeof($stem_st)) {SetType(\"$stem\");}\n";
  print OUT "  St_$stem(Text_t *name,Int_t n): St_Table(name,n,sizeof($stem_st)) {SetType(\"$stem\");}\n";
  print OUT "  $stem_st *GetTable(){ return ($stem_st *)s_Table;}\n";
  print OUT "\n";
  print OUT "  ClassDef(St_$stem,0) // class particle STAF tables\n";
  print OUT "};\n";
  print OUT "\n";
  print OUT "#endif\n";
  close (OUT);
}
#________________________________________
sub cons::TableCXX {
  my $env = shift;
  (my $dst = shift) =~ s/^\#//g; 
  (my $stem = basename($dst,"_Table.cxx")) =~ s/^St_//g;# print "cons::TableCXX stem = $stem\n";
  my $dir = dirname($dst);
  script::rmkdir($dir);
  open (OUT,">$dst") or die "Can't open $dst\n";
  print OUT "#include \"St_$stem_Table.h\"\n";
  print OUT "/////////////////////////////////////////////////////////////////////////\n";
  print OUT "//\n";
  print OUT "//  Class St_$stem wraps the STAF table $stem\n";
  print OUT "//  It has been generated \"by automatic\". Please don't change it \"by hand\"\n";
  print OUT "//\n";
  print OUT "/////////////////////////////////////////////////////////////////////////\n";
  print OUT "\n";
  print OUT "#include \"Stypes.h\"\n";
  print OUT "St_tableDescriptor *_NAME2_(St_,$stem)::fgColDescriptors = 0;\n";
  print OUT "TableImp($stem)\n";
  print OUT "TableStreamerImp($stem)\n";
  close (OUT);
}
#________________________________________
sub cons::TableLinkDef {
  my $env = shift;
  my $dst = shift; 
  my $stem = basename($dst,"LinkDef.h");#  print "cons::TableLinkDef : $dst\n";
  my $dir = dirname($dst);
  script::rmkdir($dir);
  open (OUT,">$dst") or die "Can't open $dst\n";
  print OUT "#ifdef __CINT__\n";                      #print "#ifdef __CINT__\n";
  print OUT "#pragma link off all globals\n";         #print "#pragma link off all globals\n";
  print OUT "#pragma link off all classes\n";         #print "#pragma link off all classes\n";
  print OUT "#pragma link off all functions\n";       #print "#pragma link off all functions\n";
  print OUT "#pragma link C++ class St_$stem-\n";     #print "#pragma link C++ class St_$stem-\n";
  print OUT "#pragma link C++ class $stem_st-!\n";    #print "#pragma link C++ class $stem_st-!\n";
  print OUT "#endif\n";                               #print "#endif\n";
  close (OUT);
}
#________________________________________
sub script::find_idl {
  if (defined($AFS)) {$File::Find::dont_use_nlink;}
  @search_files   = ();
  &File::Find::find(\&wanted_idl, @_);
  for my $dir (@_) {
    my $i = 0;
    for ($i=0;$i<=$#search_files;$i++) {
      #      print "i = ",$i, "src =", $search_files[$i],"\n";
      my $file = $search_files[$i];
      $file =~ s/$dir\///g;
      $search_files[$i] = $file;
    }
  }
  #  print "find_source found $#search_files + 1 files\n";
  return @search_files;
}
#________________________________________
sub script::wanted_idl {
  #  print "wanted ",$_,"\n";
  ($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_);
  if ( -d $_ &&
       (/^CVS$/ ||
	/^exa$/ ||
	/^inc$/ ||
	/^doc$/ ||
	/^run$/ ||
	/^examples$/ ||
	/^local$/ ||
	/^hold$/ ||
	/^wrk$/)
     ) {$prune = 1; return;}
  if (/^.*\.idl$/) {#print "$name\n";
    push @search_files, $name; 
  }
}
#________________________________________
