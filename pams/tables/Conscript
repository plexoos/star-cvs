#!/usr/local/bin/perl
Import qw ( env INCLUDE LIB BIN EXPORT BUILD OBJ);
my $DIR = DirPath;                           print "Build in $DIR\n";
(my $Dir = SourcePath($DIR)) =~ s/\/$DIR//;# print "new Dir = $Dir\n";
my @idl = find_idl($Dir); #print "@idl\n"; 
my @idlT = ();
my @tgt_idlT = ();
my %idl    = ();
my @sources = ();
my $src;
my $obj = $OBJ . "/tables"; 
my $share  = "#.share/tables"; #print "share = $share\n";
Link $obj =>  $share; print "Link $obj =>  $share\n";
my $SO_PKG = "St_Tables.so";
for my $idl (@idl) {#  print "$idl \n";
  if (! grep (/\/idl\//,$idl)) {next;} #  if (! grep (/vpd\//,$idl)) {next;}
  push @idlT, $idl; #print "i=",$i++," idl = ",$idl,"\n";
  my $export_idl = $share . "/" . basename ($idl); #print "export_idl = $export_idl\n";
  push @tgt_idlT, $export_idl;
  my $stem = basename ($export_idl, ".idl"); #print "stem = $stem\n";
  $idl{$stem} = $export_idl;
}
Install $env $share, @idlT;
#___________________________________
(my $build = $obj) =~ s/\#//g;  #print "OBJ = $OBJ build = $build MAIN = $MAIN\n";
my $CPPFLAGS = cppflags($env);
foreach my $stem (sort keys %idl) { 
  my $idll = ($idl{$stem}); #print "@idll\n";
  my $dir  = dirname ($idll); #print "dir = $dir\n"; 
  my $idl  = basename ($idl{$stem});
  my $idlH = $dir . "/" . $stem . ".h"; 
  my $idlI = $dir . "/" . $stem . ".inc"; 
  (my $Dir = $dir) =~ s/\#//g; #print "Dir = $Dir \n";
  my @Deps = ();
  push  @Deps, $idll;
  Command $env [$idlH, $idlI], @Deps, qq (cd $Dir; stic -H -q $idl );
  my $idlHH = $obj . "/St_" . $stem . "_Table.h"; 
  push @Deps, $idlH;
  push @Deps, $idlI;
  Command $env [$idlHH], @Deps, 
  qq (
      echo "#ifndef STAF_St_"$stem"_Table">%>
      echo "#define STAF_St_"$stem"_Table">>%>
      echo "#include \\"St_Table.h\\"">>%>
      echo "#include \\""$stem".h\\"">>%>
      echo "class St_"$stem" : public St_Table">>%>
      echo "{">>%>
      echo "protected:">>%>
      echo "  static St_tableDescriptor *fgColDescriptors;">>%>
      echo "  virtual St_tableDescriptor *GetRowDescriptors() const">>%>
      echo "{ return fgColDescriptors?fgColDescriptors:(fgColDescriptors=GetTableDescriptors());}">>%> 
      echo "  virtual void  SetRowDescriptors(St_tableDescriptor *list) { fgColDescriptors = list;}">>%>
      echo "public:">>%>
      echo "  St_"$stem"() : St_Table(\\""$stem"\\",sizeof("$stem"_st)) {SetType(\\""$stem"\\");}">>%>
      echo "  St_"$stem"(Text_t *name) : St_Table(name,sizeof("$stem"_st)) {SetType(\\""$stem"\\");}">>%>
      echo "  St_"$stem"(Int_t n): St_Table(\\""$stem"\\",n,sizeof("$stem"_st)) {SetType(\\""$stem"\\");}">>%>
      echo "  St_"$stem"(Text_t *name,Int_t n): St_Table(name,n,sizeof("$stem"_st)) {SetType(\\""$stem"\\");}">>%>
      echo "  "$stem"_st *GetTable(){ return ("$stem"_st *)s_Table;}">>%>
      echo "  ClassDef(St_"$stem",0) // class particle STAF tables  ">>%>
      echo "};">>%>
      echo "#endif">>%>
     );
  Install $env  $share, $idlHH;
  my $idlCXX = $obj . "/St_" . $stem . "_Table.cxx"; 
  Command $env [$idlCXX], @Deps, 
  qq (
      echo "#include \\"St_"$stem"_Table.h\\"">%>
      echo "/////////////////////////////////////////////////////////////////////////">>%>
      echo "//">>%>
      echo "//  Class St_"$stem" wraps the STAF table "$stem>>%>
      echo "//  It has been generated "by automatic". Please don't change it \\"by hand\\"">>%>
      echo "//">>%>
      echo "/////////////////////////////////////////////////////////////////////////">>%>
      echo "">>%>
      echo "#include \\"Stypes.h\\"">>%>
      echo "St_tableDescriptor *_NAME2_(St_,"$stem")::fgColDescriptors = 0;">>%>
      echo "TableImp("$stem")">>%>
      echo "TableStreamerImp("$stem")">>%>
     );
  push @sources, $idlCXX;
  my $idlcintC = "St_" . $stem . "_TableCint.cxx";
  my $idlCintC = $obj . "/" . $idlcintC;   
  my $idlCintH = $obj . "/St_" . $stem . "_TableCint.h"; 
  my $idlhh    = basename($idlHH);
  (my $idlHHH = $idlHH) =~ s/$obj/$share/g;
  push @Deps, $idlHHH;
  my $cmdCint = "cd $build; rm -f LinkDef.h;"; 
     $cmdCint.= "echo \"#ifdef __CINT__\" > LinkDef.h;";
     $cmdCint.= "echo \"#pragma link off all globals;\" >> LinkDef.h;";
     $cmdCint.= "echo \"#pragma link off all classes;\" >> LinkDef.h;";
     $cmdCint.= "echo \"#pragma link off all functions;\" >> LinkDef.h;";
     $cmdCint.= "echo \"#pragma link C++ class St_\"$stem\"-;\" >> LinkDef.h;";
     $cmdCint.= "echo \"#pragma link C++ class \"$stem\"_st-!;\" >> LinkDef.h;";
     $cmdCint.= "echo \"#endif\" >> LinkDef.h;";
     $cmdCint.= " rootcint -f $idlcintC -c $CPPFLAGS  $idlhh LinkDef.h;"; #print "$cmdCint\n";
  Command $env [$idlCintC, $idlCintH], @Deps,  qq ($cmdCint);
  push @sources, $idlCintC; 
}
LinkedModule $env $SO_PKG, @sources;
Install $env $LIB, $SO_PKG;
#________________________________________
sub script::find_idl {
  if (defined($AFS)) {$File::Find::dont_use_nlink;}
  @search_files   = ();
  &File::Find::find(\&wanted_idl, @_);
  for my $dir (@_) {
    my $i = 0;
    for ($i=0;$i<=$#search_files;$i++) {
      #      print "i = ",$i, "src =", $search_files[$i],"\n";
      my $file = $search_files[$i];
      $file =~ s/$dir\///g;
      $search_files[$i] = $file;
    }
  }
  #  print "find_source found $#search_files + 1 files\n";
  return @search_files;
}
#________________________________________
sub script::wanted_idl {
  #  print "wanted ",$_,"\n";
  ($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_);
  if ( -d $_ &&
       (/^CVS$/ ||
	/^exa$/ ||
	/^inc$/ ||
	/^doc$/ ||
	/^run$/ ||
	/^examples$/ ||
	/^local$/ ||
	/^hold$/ ||
	/^wrk$/)
     ) {$prune = 1; return;}
  if (/^.*\.idl$/) {#print "$name\n";
    push @search_files, $name; 
  }
}
#________________________________________
