\documentstyle[epsfig,10pt]{cernart}
% \parindent0pt
\setlength{\unitlength}{1cm}
\newcommand  {\g}  {{\it geant     }}
\newcommand  {\as} {{\it Atlsim    }}
\newcommand  {\asi} {{\it Atlsim } interface }
\newcommand  {\s}  {$ \Rightarrow $}
\newcommand  {\p}  {\put}
\newcommand  {\mup}{\multiput}
\newcommand  {\f}  {\framebox}
\newcommand  {\m}  {\makebox}
\renewcommand{\l}  {\line}
\renewcommand{\v}  {\vector}
\newcommand  {\bp} {\begin{picture}}
\newcommand  {\ep} {\end{picture}}

\begin{document}
 
\docnum{ATLAS-SOFT/95-14a}
\date{22 March 1995}
\title{DICE-95}
\author{A.Artamonov, A.Dell'Acqua, D.Froidevaux, M.Nessi, P.Nevski, G.Poulard}
\maketitle
 
\begin{abstract}
A modified DICE framework 
% is presented. It
includes a novel ATLAS geometry description, 
supported by a preprocessor and a dedicated library.
It automates the detector response,
simplifies the digitisation coding 
and provides a data handling mechanism 
with a build-in documentation and database support.
\end{abstract}
 

\section{Introduction}
 
 In 1995, the ATLAS collaboration have to made 
a number of detector choices on the basis of  
the detailed detector MC simulation.
  A fast and reliable way to implement these versions in DICE
is to use a dedicated \g parser (Fortran preprocessor) 
which is supported by a
ATLAS-GEANT interface library called \as. 
  Maintaining the GEANT specific tables of 
materials, volumes,  hits descriptions, etc 
and insuring the internal consistency of most of
the actual parameters of the GEANT routines,
 it significantly reduces the amount of information
the user should care of 
and improves  the robustness of the program.
 Here we describe the main rules and  features of this program.
 
\section{GEOMETRY DESCRIPTION}
 
  The geometry of each ATLAS detector in DICE-95 is described 
in a single {\bf module}.
  Modules are written in the \g language and translated by the parser
into conventional, well commented  Fortran subroutines
compiled and linked with the rest of DICE. 
   A  module  consists of the module header,
the data definition part and of a number of blocks, 
each describing one GEANT elementary volume and its content.
 
\subsection{\g language}
 
  The \g language is a Fortran extension oriented to the GEANT application.
Apart from standard Fortran statements, it contains a number of
\g {\bf statements} in the form:
 
  \begin{center}
      OPERATOR NAME [ $keyword_1$={\it value}  ...  $keyword_n$={\it value} ]
  \end{center}
  where the { OPERATOR } defines a specific service  to be
  performed by the \as interface. 
  Apart from the declarations and data handling operators, 
  described in sections 2.4 and 2.5,
  there are 9 GEANT dedicated operators and 3 control operators 
  in the \g language.
 For these operators:
\begin{itemize}
\item
  NAME is the  name of a GEANT volume or of a volume shape (4 letters),
  or a material or medium name (up to 20 letters). 
  A Fortran string variable is generated by the parser 
  by converting the NAME into
  upper-case letters.
\item
  Keywords (left parts of assignment) are variables
  {\bf  used in the GEANT3 manual \cite{geant} }
  to describe the parameters of the corresponding GEANT3 routine
  \footnote{
    Few deviations from this rule where the manual names
    are ambiguous will be mentioned later}.
\item
  Their values (right parts of assignment) are any legal Fortran expression.
\end{itemize}
 
  The language is neither case nor  position sensitive.
  A \g statement can be continued on the next line only  using  a comma or 
  an  underscore at the end of a line as a continuation sign.
  A comma can also be used between keywords to improve the readability.
  All \g comments mentioned below are mandatory.
  A list of keywords with their values is called below a  {\bf definition}.

%  The \g language contains 12 operators to decribe GEANT volumes
%  and their relations, 5 data definition and 2 data handling operators.

 
\subsection{Volume description}
%------------------------------ 

\subsubsection{General structure}

Any  GEANT volume  in a module is described as a {\bf block}.
A block consists of two parts - the description of its own properties
and  the description of its content - and has the following structure
(last column shows the corresponding GEANT3 routine)~:
 
\begin{center}   \begin{tabular}{|cl||cl|}             \hline
           & {\bf BLOCK} NAME comment                &           & \\ % \hline
           & \hspace{.5cm} MATERIAL  name definition & \s GSMATE & \\ 
or few     & \hspace{.5cm} COMPONENT name definition & $\Downarrow$ &  \\
followed by& \hspace{.5cm} MIXTURE   name definition & \s GSMIXT & \\
           & \hspace{.5cm} MEDIUM    name definition & \s GSTMED & \\
           & \hspace{.5cm} ATTRIBUTE name definition & \s GSATT  & \\
           & \hspace{.5cm} SHAPE     name definition & \s GSVOLU & \\  
           & \hspace{.5cm}                           & \s GSDV(*)& \\ \hline
a number of& \hspace{.5cm} {\bf CREATE}  name        & & \\ %  content part  \\
followed by& \hspace{.5cm} POSITION  name definition & \s GSPOS(P)& \\ % \hline
           & \hspace{.5cm} HITS      name definition & \s GSDET(*)& \\ % \hline
           & \hspace{.5cm} DIGI      name definition & \s GSDET(*)& \\ % \hline
           & {\bf ENDBLOCK}                          &            & \\   \hline
\end{tabular}   \end{center}
 
BLOCK, ENDBLOCK and CREATE are control operators because they affect
the execution order:  CREATE is   executed as a jump  to
the requested BLOCK code and the return back when its ENDBLOCK is reached.
All other are GEANT dedicated operators  and   are substituted by a call
to one or few GEANT routines via the \as interface.
  
\vspace{0.5cm}   Example 1:
\begin{verbatim}
   Block     GAAS   is GaArsenid forward tracker
     Material   Air
     Medium     gaas_mother   Ifield=1,   FieldM=2,  TmaxFd=3,   Epsil=0.001,
                              SteMax=0.001   DeeMax=0.05   StMin=0.001
     Shape      TUBE          Rmin=10    Rmax=50   dz=200
     do idisc = 1,nint(gaag_Ndisc)
        Create     GDSi
        Position   GDSi   z=+gdsi_Zdisc
        Position   GDSi   z=-gdsi_Zdisc  ThetaZ=180
     enddo
   endblock
\end{verbatim}
 
 
The \as interface maintains GEANT tables of materials, mediums, volumes
and rotation matrices.
After checking that the requested name already exists
in the corresponding table or having created a new table entry,
the interface provides the entry number to the GEANT routines.
 
 The only mandatory operator inside a block is its SHAPE, 
others can be omitted.  
  In this case the volume properties are inherited from it's mother volume,
  and position definitions are assumed to be default (x=y=z=0, no rotation).

If needed,  material, medium and attribute operators should be defined before the
SHAPE operator.

\subsubsection{More on SHAPE}

 The {\it name} argument of the SHAPE operator contains a name 
of any of the 16 legal GEANT shapes described in the manual.
 Keywords in the definition part are the names of parameters, 
used in the GEANT manual (section GEOM 050) to describe these shapes.
 The only exception are multiple $z,Rmin$ and $Rmax$ parameters 
of the  PCON and PGON shapes, which should be supplied 
as vectors  named  {\it Zi, Rmn } and  {\it Rmx},
defined in one of the following  two forms:
\begin{center}
    \hspace{1.2cm} $vector=\{val_1,val_2 ... val_n\}$ \\
               or  $vector=\{A(i_1:i_2)\}$
\end{center}
where a $vector$ stands for  $Zi, Rmn$  or $Rmx$,
$val_i$ are any Fortran expressions,
and A is a Fortran array.

    As the parameters are transmitted to the GSVOLU routine 
via the \as interface, they can be provided 
in any order or be inherited from the mother volume.

\vspace{0.3cm} Example 2: the PCON specification from the GEANT manual
(GEOM 050, figure 23) may look like:
 
\begin{verbatim}
    SHAPE PCON  phi1=180  dphi=279  Nz=4  Zi={-400,-300,300,400},
                Rmn={50,50,50,50}   Rmx={250,100,100,250}
\end{verbatim}
 
The GEANT divisions are in the \g language particular cases of 
the SHAPE operator.
The actual division mechanism is automatically selected by the
\as interface dependent on the parameters supplied.
 
\vspace{0.3cm} Example 3: this will create divisions of a TUBE in 
$\phi$ using GSDVN (GEOM 130):
\begin{verbatim}
   ....
   Shape  TUBE       Rmin=Rj  Rmax=Rj+Dr  Dz=D/2
   Create GDij
   ....
Block     GDij    is a sector containing one counter
   Shape  DIVIsion   Iaxis=2  Ndiv=Ndv
   Create ....
endblock
\end{verbatim}
 
\subsubsection{Inheritance rules}

Unless defined explicitly,
parameters of the MATERIAL, MIXTURE, MEDIUM, and SHAPE operators
in a new block 
are inherited from the block creating this one.
Normally this is also its mother volume
\footnote{ The exception is done only for the mentioned above
vectors  $Zi, Rmn, Rmx$ of the PGON and PCON shapes.}.
If no material or medium are defined in a new block at all,
the are inherited from the mother block.
A MATERIAL or a MEDIUM operator without parameters
can be used to get parameters of already defined materials 
(mixtures) or media.
If no material or medium are defined in a new block at all,
the are inherited from the mother block.

A new GEANT medium, which combines both material and tracking parameters,
is introduced not only after a MEDIUM
operator re-defines any of the tracking parameters,
but also if a material has been changed by a MATERIAL or MIXTURE
operators.

A MATERIAL or a MEDIUM operator without parameters
can be used to refer to an already defined material (mixture) or
medium.

\subsection{Volume positioning}

Unless defined explicitly, the parameters of a POSITION operators 
have the default values: 
\begin{center}
 $x=y=z=0$, KONLY='ONLY, unit rotation matrix.
\end{center}

If the volume being positioned has been defined with all parameters
equal to zero, the GSPOSP routine will be called, 
otherwise the GSPOS is used. 
In case of the GSPOSP call, the actual parameters of the volume shape
supplied in the POSITION operator still follow the inheritance rules
for the SHAPE operator.

If a rotation should be defined when positioning a volume,
it is possible to define it in two ways:
\begin{itemize}
\item
Providing up to 6 parameters of the GEANT rotation matrix (GEOM 200).
The parameter names 
\footnote{Names are modified comparing to the GEANT manual 
$1 \rightarrow x$, $2 \rightarrow y$, $3 \rightarrow z$ 
to clarify their meaning.}
and their default values defining the unit matrix are
\begin{center}
$ThetaX=90^o, PhiX=0^o, ThetaY=90^o, PhiY=90^o, ThetaZ=0^o, PhiZ=0^o$ 
\end{center}
Only those parameters which are different from 
the default unit matrix should be given.

Example: ThetaZ=180 in the example 1 in the second POSITION operator
makes  the second copy of the GDSi volume to be positioned 
as a mirror reflection of the first one.

\item
A rotation around {\bf one} of the $x,y,z$ axis can be introduced 
simply by defining {\bf one} of the following  parameters:
\begin{center}
$AlphaX, AlphaY$ or $AlphaZ$.
\end{center}

\end{itemize}

Rotation parameters are not inherited from one POSITION operator 
to another.
 
\subsection{Volume naming mechanism}
% ------------------------------------- 
  All volumes in DICE-95 are referenced by their  {\bf generic} names,
 consisting of 4 upper-case letters~\footnote{
  The ATLAS convention is to have the same first letter
  for any block within a whole module}.
 When the real dimensions of the same generic volume are variable, 
the supporting
\as library provides an automatic and transparent mechanism which,
for physically different volumes with the same generic name,
generates {\bf nicknames } used by GEANT,
by changing last letters of the generic name
into numbers or lower-case letters.
These volumes with different nicknames
are considered as instances of the same generic object.
The original generic name is also kept in each instance
together with its nickname.
 
The positioning of all volumes is done using their generic names,
the latest generated instance of the object been actually used.
When positioned in the same mother volume such instances
will be made different also  by their  GEANT {\it copy numbers}.
If a volume instance has been defined with all parameters equal to zero,
it will be  positioned by the \as interface using
the GSPOSP routine with the dimensions,
defined in the POSITION operator.
 
This mechanism provides a simple and effective way
to automatically generate the unique path to each
GEANT volume, needed for the HIT package,
without an additional user code.
 
 
 
\subsection{Module header}
 
 The module header in DICE-95 is used to provide the  Fortran
 declarations as well as the program maintenance information.
 It consists of the following \g {\bf declarations}~:
 
\begin{center}   \begin{tabular}{|ll|}               \hline
  MODULE NAME    & comment                      \\
  AUTHOR         & author list                  \\
  CREATED        & date or version              \\
  CONTENT        & list of GEANT volume used    \\
  STRUCTURE NAME & \{ list of variables \}      \\
  +CDE,...       & list of the KEEPs used.      \\
 Other Fortran   declarations  &             \\      \hline
\end{tabular}   \end{center}
 
Note that:
\begin{itemize}
\item
   The first line should be the MODULE declaration,
  the order of other statements is irrelevant.
  The module name consists of a 4-letter ATLAS detector code 
  plus the module type code (GEO, DIG etc). 
  It is also used to identify  module input and output data
  structures (GEANT hits and digits, DETM structure of SLUG etc).
\item
  The format of comment,  author list and creation date is arbitrary,
  but their presence is  mandatory.
\item
  The CONTENT declaration should list {\bf all} blocks used in the module.
\item
  The STRUCTURE declaration groups together real variables 
  or one-dimensional arrays, which are subject to potential change 
  using datacards
  or should be accessible from  external routines, 
  for example at the reconstruction stage.
  Their usage is described in the next section.
\end{itemize}
 
\vspace{0.3cm}  Example:
\begin{verbatim}
      MODULE  GAASGEO  is the Geometry of the GaArsenid forward tracker
      Author      Rene Brun, Pavel Nevski
      Created     23 sept 94
      Content     GAAS, GDSi, GSij, GHij, GDij, GSUB, GASS, GELE, GSUP
      Structure   GAAG { Version, Ndisc, DrCounter, DfCounter, DzCounter,
                         TCKsubs, TCKsupp, DXele, DYele, Dzele  }
      Structure   GDSi { Disc, RIdisc, ROdisc, ZDisc }
      Real        Zdel,Rj,Zk,DR
      Integer     Idisc,j,k,N,ndv
+CDE,AGECOM,GCONST.
\end{verbatim}
 
\subsection{Data structure handling}
% --------------------------------------
 
A group of logically linked variables,
which are declared  in a  STRUCTURE operator,
is  defined  using the FILL statement:
 
\begin{center}   \begin{tabular}{|cll|}                            \hline
FILL & NAME                  &  ! bank comment                   \\
     & $variable_1=value_1$  &  ! explanation of $variable_1$    \\
     &   . . .        &                                          \\
     & $variable_n=value_n$  &  ! explanation of $variable_n$    \\  \hline
\end{tabular}   \end{center}
Note that:
\begin{itemize} 
\item
The structure name consists of 4 letters  and  is used as the
ZEBRA bank name and as the prefix of its variables in the Fortran code.
\item
The order of assignments is irrelevant, but comments and
explanations are mandatory.
\item
Other comment lines cannot interleave with FILL assignements.
\item
$value_i$ are Fortran expressions in case of a simple $variable$ or
a vector in the form $ \{ val_1, ... val_k \} $ for an array.
\item
When the FILL statement is executed by the \as interface, 
the data are saved as a bank in the DETM structure \cite{slug}.
% and the variable names and comments are saved 
% in the appropriate documentation banks for DZDOC package \cite{dzdoc}.
% The corresponding record will also be sent to the 
% supporting database.
\end{itemize}
 
There may be two levels of data structures (banks) defined 
and used in a module:
the structure name,  defined by the first FILL operator,  
becomes the high level structure name. 
All  structures with other names are considered as
lower level structures associated to it.

Each of these structures may be a linear chain of similar banks,
created by sequential FILL operators with the same name.
They all are considered as instances of the same generic object, so
at any moment only one selected copy of each structure is available.
A typical usage of the high level structure is to provide different
geometry versions of the same detector,
the actual version been selected using the datacard input.
Instances of the  low level structures  can be used
to provide parameters for different components  of the
of the same detector.
 
\vspace{0.5cm}  Example:
\begin{verbatim}
 Fill  GAAG                    !  geometry description
            version   = 3        !  Annecy layout
            Ndisc     = 2        !  Nr. of discs (on each side)
            DrCounter = 5.3      !  DX (Dr) of a counter
            DfCounter = 2.6      !  DY (Dphi) of a counter
            DzCounter = .02      !  DZ (Thickness) of a counter
            TCKsubs   = .01      !  Thickness of the substrate
            TCKsupp   = 0.8      !  Thickness of the support
            DXele     = 3.       !  DX (Dr) of the electronics board
            DYele     = 2.       !  DY (Dphi) of the electronics board
            DZele     = .06      !  DZ (Thickness) of the electronics board
 Fill  GDSi                    ! individual disc parameters
            Disc = 1             !  disc  number
            RIdisc    = 20.      !  inner Radius
            ROdisc    = 35.      !  outer Radius
            Zdisc     = 156.     !  Position along Z
 Fill  GDSi                    ! idem for next disc
            Disc = 2             !  second disc
            RIdisc    = 25.      !  inner Radius
            ROdisc    = 40.      !  outer Radius
            ZDisc     = 185.5    !  Position along Z
\end{verbatim}
 
% \newpage
\vspace{0.3cm} Example: data structures  % documentation record 
produced by the previous example:
 
\setlength{\unitlength}{1cm}
 
 \bp(14, 5)(0,9) \thicklines {\small \sf
\p( 4.59,13.13){\f(  .88,  .44){ }}
\p( 5.03,13.34){\m(0,0)[c] {  NONE }}
\p( 4.59,13.34){\l(-1, 0){ 3.72}}
\p(  .88,13.34 ){\v( 0,-1){  .66}}
\p(  .66,12.25){\f( 1.09,  .44){ }}
% \mup(  .66,12.30)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 1.75,12.25){\f( 4.81,  .44){ }}
\p( 4.16,12.47){\m(0,0)[c] {  Detector main bank }}
\p( 6.56,12.71){\m(0,0)[br]{  ND=50 }}
\p( 1.09,12.73){\m(0,0)[bl]{  NID 1 }}
\p( 1.20,12.47){\m(0,0)[c] {  DETM  }}
\p( 1.53,11.38){\f( 1.09,  .44){ }}
% \mup( 1.53,11.43)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 2.63,11.38){\f( 4.81,  .44){ }}
\p( 5.03,11.59){\m(0,0)[c] {  GaArsenid forward tracker }}
\p( 7.44,11.83){\m(0,0)[br]{  ND=15 }}
\p( 1.97,11.86){\m(0,0)[bl]{  NID 1 }}
\p( 2.08,11.59){\m(0,0)[c] {  GAAS  }}
\p(  .44,12.25){\f(  .22,  .44){ }}
\p(  .55,12.47){\m(0,0)[c] { 1 }}
\p(  .55,12.25){\l( 0,-1){  .22}}
\p(  .55,12.03){\l( 1, 0){ 1.20}}
\p( 1.75,12.03 ){\v( 0,-1){  .22}}
\p( 2.41,10.50){\f( 1.09,  .44){ }}
% \mup( 2.41,10.55)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 3.50,10.50){\f( 4.81,  .44){ }}
\p( 5.91,10.72){\m(0,0)[c] {  GEOMETRY DESCRIPTION }}
\p( 8.31,10.96){\m(0,0)[br]{  ND=12  }}
\p( 2.84,10.98){\m(0,0)[bl]{  NID 1  }}
\p( 2.95,10.72){\m(0,0)[c] {  GAAG   }}
\p( 1.31,11.38){\f(  .22,  .44){ }}
\p( 1.42,11.59){\m(0,0)[c] { 1 }}
\p( 1.42,11.38){\l( 0,-1){  .22}}
\p( 1.42,11.16){\l( 1, 0){ 1.20}}
\p( 2.63,11.16 ){\v( 0,-1){  .22}}
\p( 3.28, 9.63){\f( 1.09,  .44){ }}
% \mup( 3.28, 9.68)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 4.38, 9.63){\f( 4.81,  .44){ }}
\p( 9.19, 9.63){\l( 1, 0){  .66}}
\p( 9.84, 9.63){\l( 2, 1){  .44}}
\p(10.28, 9.84){\l(-2, 1){  .44}}
\p( 9.84,10.06){\l(-1, 0){  .66}}
\p( 9.19,10.06){\l( 0,-1){  .44}}
\p( 9.63, 9.84){\m(0,0)[c] {   GDSI     }}
\p( 6.78, 9.84){\m(0,0)[c] {   INDIVIDUAL DISC PARAMETERS }}
\p( 9.19,10.08){\m(0,0)[br]{   ND=6     }}
\p( 3.72,10.11){\m(0,0)[bl]{   NID 1    }}
\p( 3.83, 9.84){\m(0,0)[c] {   GDSI     }}
\p( 2.19,10.50){\f(  .22,  .44){ }}
\p( 2.30,10.72){\m(0,0)[c] {   1        }}
\p( 2.30,10.50){\l( 0,-1){  .22}}
\p( 2.30,10.28){\l( 1, 0){ 1.20}}
\p( 3.50,10.28 ){\v( 0,-1){  .22}}
 } \ep 
 
One can select the actual copy of the structure to be used by the program
(an instance of the data structure) with the help of the USE statement~:
 
\begin{center}    USE NAME $variable=value$  \end{center}
 
Any variable from the corresponding structure can be used to select
the current instance of the bank.
The {\it value} may be any Fortran expression.
Once the top level bank is selected with
the USE operator, the descendent lower level banks are selected
only within the same  branch.
Selected banks are re-linked at the first position of their
top level banks, so that they always become default banks 
for any further selection. 
Also at that moment their content is changed by the 
standard datacard input.

 
Once selected with the USE operator, variables from the data
structure can be referenced by the program in the form
{\it     BankName\_Variable}.
In this way they are easy to recognize among the other
program variables (see first example).
 
This mechanism provides an easy and flexible way of the geometry
versioning within each module.
% It is supported by the appropriate  DZDOC interface which
% updates automatically in a transparent way
% the ATLAS documentation file \cite{pavel}.
% It will  also interface the HEPDB system to maintain the ATLAS
% geometry data base \cite{boris}.
 
\section{CREATING GEANT HITS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In DICE-95 user does not need to write a detector specific routine 
to create GEANT hit structure and to fill it with a useful information. 
Instead, a  \g statements  with the {\bf HITS} operator,
called in a block describing a sensitive volume, 
is used to produce a relevant GEANT hit definitions
and to steer their filling at the tracking time.
This statement generates all necessary GEANT calls (see GSDET
and GSDETH routines, HIT 100)
with their parameters as follows:

\begin{itemize}
\item  The {\it set name} is defined by the first 4 letters 
       of the {  module name}; 
\item  The {\it detector name} is the name of the \g { block} ;
\item  Following the DICE standard, IDTYPE is taken as the ATLAS
       detector number;
\item  The {\it name} argument of the HITS operator, (hit {\bf address})
       is the name of the volume used to identify  the hit, 
       usually the sensitive detector itself.
       The \as interface finds the path to the selected volume 
       using generic names of all higher level volumes 
       and builds the NAMESV array.
       It also defines the number of branchings and 
       the number of bits required at all levels (NBITSV array)
       to uniquely describe the path to each instance of the
       selected volume;
\item  For memory allocation defaults values of NHWI, NWDI = 1000 are used.
\end{itemize}
 
The definition part of the { HITS}  operator contains a list
of information quantities, {\bf measurement}s, 
which should be saved in each GEANT hit, and their packing
in one of the form
\begin{center}
{ \hspace{0.4cm}  $measurement:N_{bit}:(min,max)$ \\
              or  $measurement:bin:(min,max)$   }
\end{center}

For a {\it measurement}, $N_{bit}$ or $bin$ are mandatory 
and limits are optional.
At present the following variables are known as $measurement$s 
to the \as interface
(the track point means here the middle point of the track 
segment producing the hit):
 
\begin{itemize}
\item  $x,y,z$ - local Descartes coordinates of the track point 
               in the sensitive volume;
\item  $theta, phi, R(or RR)$  - local cylindrical (or polar) coordinates 
               of this point;
\item  $Cx, Cy, Cz$  - local direction cosines of the track segment;
\item  $Ct$  - cosine of the angle between the track segment and the
               radius pointing to its center;
\item  TDR   - closest approach of the track segment to the local z-axis;
\item  STEP  - the length of track segment producing the hit;
\item  ELOS  - the energy lost at this step;
\item  BIRK  - equivalent energy of the calorimeter response (see PHYS 337);
\item  TOF   - time of flight for this hit;
\item  ETOT  - particle energy in the current point;
\item  LGAM  - $log_{10}$ of the particle Lorentz factor;
\item  ETA   - pseudorapidity of the track point;
\item  USER  - the hit quantity is calculated in a user function.
\end{itemize}


An integer number, following a $measurement$ variable, is interpreted as
$N_{bit}$ - the number of bits for packing the variable values.
 0 means  that the value is a  cumulative sum, occupying a full computer word.
 Due to the GEANT limitation 0 can be used only in last elements 
of the { HITS} statement.

 If a  $measurement$ variable is followed by a real expression,
it is interpreted as the packing bin size, and the number of bits,
required for packing, will be calculated by the \as interface. 
% In both cases, the displacement (ORIG) and the scale factor (FACT), 
% used to pack the variable value into the GEANT hit, are calculated 
% by the interface taken into account all GEANT specific rules.

If the user does not provide the limits explicitly, $min$ and/or $max$ 
are determined  by the \as interface using  the volume dimensions.

\vspace{0.3cm}  Example: 
\begin{center}  HITS  GASS   X:12: Y:11: ELOSS:0:  \end{center}
 
In case of the USER element, a subroutine {\it XXXXSTEP(pointer,hit) }, 
where XXXX is the volume name, will be called to provide the $measurement$.
This subroutine should be described as EXTERNAL in the module header.
Its integer input argument {\it pointer} is the address
of the hit description array (10 words, real) in the GEANT memory
and it returns in $hit$ the measurement.
The format of this description can be found in the Appendix.

This option violates the data encapsulation principle as
a user gets a direct access to the GEANT memory.
It is not needed at present in DICE-95 and
users are discouraged to use it until they are sure they really need it.


\section{DIGITISATION}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Detector response description}
%---------------------------------------------

The detector {\bf digitisation }, i.e.
simulation of the response of individual elements of a 
given detector after tracking of a compete event, 
is done in a separate \g module. 

A digitisation module has the  header 
and the data handling part similar to a  geometry module,
but instead of  blocks, describing detector geometry,
it describes how a specific detector response 
in each separate element is produced, 
taken into account multiple hit overlap,
noises, thresholds etc.

The  content of the digitised information piece,  the {\it digit}, 
should be described in the detector digitization module
using the {\bf DIGI} operator.
This operator,  similar to the HITS operator,
creates necessary banks in the GEANT JSET structure.
% The definition part of the DIGI operator can be re-defined
% in the digitisation module itself, changing 
% measurement limits, granularities and the number of packing bits.
% The $address$ part and the list of $measurements$ 
% can not be changed at that moment.

DICE-95 creates digits in the \as format, 
which is similar to the format of hits, 
but different from the one  used for the standard GEANT digits. 
The difference is summarised below:

\begin{itemize}
\item
The amount of  memory used by the \as digits  in average is twice less
then the one consumed by the standard GEANT digits.

\item
The transformation of the digitized measurements into integer numbers,
representing packing bins, is done internally by the corresponding 
routines in the \as library in the simular way as  GEANT makes it for hits.
When a user  reads these digitised measurements 
back at the reconstruction stage, 
he  gets them in the same coordinate system where they were ``measured''.
This feature free the user from the necessity to transfer the 
packing constants to the reconstruction routines in a user code
and eliminates one of the importrant source of the reconstruction errors.


\item
It is possible to introduce cumulative digitisations in the same way
as the GEANT cumulative hits. If a non positive number was defined as
the number of packing bits for a measurement, its value and the values
of subsequent measurements will be summed, 
provided that the other digit parameters 
(track number,volume address,non-cumulative measurements)
are the same.

\end{itemize}


\subsection{Collecting all hits in a detector element}
%----------------------------------------------------

The \as interface contains 4 integer functions
(AgFHIT0, AgFHIT1, AgSDIG0, AgSDIG1) which provide 
the hit access and the digitisation storage service.
Their execution and the print verbosity are controlled
by the datacards in a way described later.
If the operation was successful, the functions
return the {\bf OK flag} (0 value).

To select a hit set to be analyzed,
a AgFHIT0(Cset,Cdet) function should be called,
where Cset and Cdet are 4-letter names
of an   ATLAS system and its sensitive detector.
The function returns OK, % (0 value), 
if the  selected set contains hits 
and the digitisation of this ATLAS
system has been requested by  control cards,
otherwise the digitisation should be abandoned.

If the address part of the DIGI set 
coincides  with the address of the HIT set
(same volume used as their address),
this call also defines the output DIGI bank.
Otherwise, if the $HITS$ and $DIGI$ detectors are different
\footnote{ This is the case, for example, in the tile calorimeter, 
   where hits are registered and stored per tiles with certain (r,z) position, 
   or in the integrated forward calorimeter, which contains tubes
   arranged in a certain (x,y) grid, but where the DIGITs should 
   be stored per $\Delta \eta \times \Delta \phi $ bins.},
the AgSDIG0(Cset,Cdet) function should be called.
% Them meaning of its return values is the same  as for AgFHIT0.

After these initialization calls are successfully done,
the \as interface is ready to provide you sequentially 
with all hits in each detector element by performing
the {\bf AGFHIT1}(IH,ITRA,NUMBV,HITS) function.
Here the output arguments are~:
\begin{itemize}
\item
$abs$(IH) will be on output the sequential hit number 
in the current detector element. 
A negative IH is used to signal the last hit
in the detector element.
\item
NUMBV is an integer array, that will contain on output the list of volume
copy numbers which identify  the path to this detector element.
\item
HITS is a real array  which will contains
the measurements belonging to this hit.
\item
$abs$(ITRA) will be the track number having produced
this hit. The negative ITRA
is used to signal that other particles also
contributed to this detector element. 
\end{itemize}
The function itself returns OK  until all hits
in the selected set are used.
 
In this way in the digitization routine the user does not need 
neither to introduce arrays to accumulate the information 
from different detector elements in parallel, 
nor even to know the full number of the detector elements.
Moreover, if a user needs to know the space position of a hit,
he can simply use the GEANT routine GDTOM
to translate a point in the current detector element to the
Master Reference System, as the content of the necessary common 
blocks is restored by the \as interface.

Finally, when all hits in one detector element are received, 
the {\bf AGSDIG1}(ITRA,NUMBV,DIGI) function should be called
to store the simulated digitisation.
Here  the input arguments are:
\begin{itemize}
\item 
ITRA is the number of the track that has produced this digit.
A negative ITRA will be stored as zero.
\item
NUMBV is the address of volume to which this digitisation belongs.
\item 
DIGI is a {\bf real } array containing the digitised measurements. 
\end{itemize}

Below you will find as an example  a part of
the ATLAS forward calorimeter digitisation routine.
It gets energy deposited in a set of tubes 
with arbitrary geometry and produce the  digitisations
as the energy sum in a standard $\eta,\phi$ presentation. 
% The full FWDC digitisation module is shown in the appendix.

\vspace{0.3cm} Example: FWDC digitization loop:
\begin{verbatim}
    If (AgFHIT0('FWDC','FWAI') .ne. OK) Return
    If (AgSDIG0('FWDC','FWDC') .ne. OK) Return
    DO While (AgFHIT1(IH,ITRA,NUMBV,HITS) .eq. Ok)
       If (abs(IH) .eq. 1)  then  ! a new tube
          Esum=0
       endif
*      Accumulate energy just in one tube
       Esum = Esum+Hits(1)
       If (IH .le. 0) then        ! all hits in one tube received
*         translate NVL -> x,y,z -> eta,phi
          call GDTOM(zero,xyz,1)
          theta =  acos(xyz(3)/vmod(xyz,3))
          Eta   = -log(tan(theta/2))
          Phi   =  atan2(xyz(2),xyz(1))
          If (Phi .lt. 0) Phi = Phi + 2*pi
          DIGI(1)=Eta
          DIGI(2)=phi
          DIGI(3)=Esum
          If (AGSDIG1(ITRA,NUMBV,DIGI) .ne. OK)  Return
       Endif
    EndDO
\end{verbatim}

A complete digitisation module of the tile calorimeter 
is shown in the appendix 3 as an example.

\section{INTERACTIVE {\it ATLSIM } VERSION}
%================================

The \as library linked with an iteractive GEANT
provides a unique possibility to study, modify and  to debug
the description of the ATLAS geometry.
A special macro-command, mgeom.kumac 
\footnote{version kindly provided for the HP UNIX by R.Brun},
compiles and executes dynamically in a stand-along mode (and very fast!)
any selected geometry module, extracted from the CMZ file 
in a separate file with the .g extension.

Using this program  one can perform in particular the following
operations  with a single geometry module or with a complete
ATLAS detector:

\begin{itemize}
\item
EXEC MGEOM {\it module-name} - 
to compile, link and execute
interactively a module written in a separate file.
The name of the file should be the same as the module name
with the extension {\it .g} .     
\item
DEBUG ON - 
to execute following  modules in the debugging mode, 
with an increasing level of the \as printouts.
Most of the parameters of the created materials,
media, rotation matrices and volumes  will be printed.
\item
RZ/FILE 1 atlas.geom I -
to read in a geometry file of the Atlas detector from
the current directory.
\item
DRAW ... or DCUT ...  - to draw different views 
of the selected system or its parts using GEANT graphics.
In the debug mode (after DEBUG ON command) an isometric
view of the system is drawn automatically.
\item
DTREE ... - 
to draw the logical tree of the GEANT volumes 
with their generated nicknames and dimensions.
\item 
DISP detm detm.rz - 
to survey the tree  of  the created data structures, 
to navigate through them, to see the actual content
of each created bank with its description, 
extracted from the module by the \as interface.
\end{itemize}
For more details the user is referred to
 the XINT section of the GEANT3 manual.

\section{DATACARD CONTROL}
%===========================

\subsection{Program control}

Usual flags from the *MODE datacards are used by the \asi
to control the geometry building (GEOM), hit saving 
in sensitive detector (SIMU), switching on/off of the magnetic
field (MFLD), to allow detector digitisation (DIGI)
or reconstruction (RECO). 
The control is done in a transparent way, 
so a user does not need to analyse this flags himself.
The only interesting flag is GEOM, which is used also
to select the detector version. This flag is available 
in a geometry module as \%IGEOM variable.

The verbosity of the printout is also controlled by datacards.
As the print requirements may be different 
not only from detector to detector, 
but also for different  {\it stages} of the program execution,
the actual print level is always produced as a product 
of the detector print flag, 
defined in the { detector } data card:
\begin{center} *MODE 'XXXX' 'PRIN' $L_d$ . . . \end{center}
and of the current stage print flag,
defined in the {\it stage} data card:
\begin{center} *MODE 'YYYY' 'PRIN' $L_s$ . . . \end{center}
where XXXX are conventional ATLAS detector system codes and 
stage codes YYYY can be 'GEOM', 'SIMU', 'DIGI', 'RECO' etc.

\subsection{Print control}

In general the action of the resulting print level $L=L_d*L_s$ 
is defined by the following strategy:
\begin{itemize}
\item  0 - no printout at all (same for L negative);
\item  1 - minimal printout (not more than once per event);
\item  2 - still reasonable amount of prints (up to 10 lines per event);
\item  3 - you can tolerate it for a dozen events;
\item  4 and more - debugging to find a problem. 
\end{itemize} 
Some particular cases for different stages are explained below.

\subsubsection{GEOM - Geometry building stage}

The print level decreases by one each time the program 
makes a jump into a next level block.  
So with small L you will get only general detector dimension, 
and with higher L you will get parameters of smaller detector pieces.
 
\subsubsection{SIMU - Simulation stage} 

The printout, tracing particles, is done by the GEANT routine GDEBUG.
This routines operates under the control of DEBUG and ISWIT data cards 
(see section BASE 400) and may produce a very abundant printout.

In addition, the \asi provides a possibility to tracing particles
only in selected ATLAS detector systems.
A detector *MODE 'XXXX' 'DEBU' D  data card is used 
to limit the maximal volume insertion level, 
where a call to GDEBUG is done.
So with D=1 one will get the tracing only the system mother volume,
and with higher D from its internal volumes.
The total number of volume levels, where the tracing is done,
is defined by the detector print level.

\subsubsection{DIGI - digitisation stage}

The detector *MODE 'XXXX' 'DIGI' d 'PRIN' L data card defines weither
this detector will be digitized (d=1) or not (d=0).
At the print level 3 and more, the total number of digitised hits will be printed
for each event.
If the print level is 4 and more, the output digi set will be dumped.
If it  is 5 and more, the input hit set is dumped.

\subsection{Parameter input}

The content of a data structure, defined in any module of DICE95,
can be modified by a *DETP datacard. To modify a variable, user has to
provide the name of the detector, the name and the value of the ``use''
selector of the desirable bank, and then  names and new values
of variables in the selected bank. All modification for the same
detector should be done on the same *DETP datacard, which
can be continued an several lines following the FFREAD rules.

Example. To modify the ``Dx of the electronics board'' in the example
on page 5 on can use the following datacard:
\begin{center}
*DETP 'GAAS' 'GAAG='3. 'Dxele='3.1
\end{center}
Note that dots are mandatory,
but identificators are case unsensitive.

\section{DOCUMENTATION AND DATABASE SUPPORT}

As it has been already mentioned,
when the FILL statement is executed by the \as interface,
the data are saved as a bank in the DETM structure \cite{slug}.
At the same time the \as interface creates
the appropriate documentation banks for DZDOC package \cite{dzdoc}.
For each bank in the DETM structure the documentation banks contain
the creation date, authorship information,
the variable names and comments 
as well as the full information on the bank relationship.

All this information is maintained in a RZ-file detm.rz
which can be analysed by the DZDOC package.  % \cite{dzdoc}.
Running its interactive version DZEDIT, 
users can get the full information on the
created banks as well as to print 
a hardcopy of the current ATLAS input data structure 
description.
As the documentation RZ-file is updated automatically
each time the program has been changed,
this description is always up-todate.

The work is now in progress to interface the \as library
to the HEPDB package \cite{hepdb}.
When this option will be implemented, the FILL operator
will be able to send the the corresponding records 
with the bank content to supporting database \cite{boris}.

It will become possible to get with the USE operator
not only versions of banks, defined directly in the module,
but also to read them from the ATLAS geometry data base,
supported centrally.
  
 
\section*{Acknowledgments}

Many people participated in discussions..
Authors want to thank Maxim Potekhin
and Serguey Baranov, who
were the first ``test'' users of the \as  package,
Rob Veenhov and Sasha Vanyashin for 
many valuable comments
on the draft of this paper.
We are grateful to Rene Brun, 
who has initiated the present modification of DICE,
and was extremely helpful to find 
a global view on its development.


\begin{thebibliography}{99}
\bibitem{geant} GEANT - Detector Description and Simulation Tool.
                CERN Program W5013. Geneva, 1994.

\bibitem{slug}  R.DeWolf, P.Nevski,
                Geometry saving and user input in SLUG.
                ATLAS internal note SOFT-NO-001, 13.07.93.

% \bibitem{pavel} M.Nessi, P.Nevski, G.Poulard,
%                 ATLAS reconstruction banks.
%                 ATLAS internal note SOFT-NO-003, 07.10.93.
                
\bibitem{dzdoc} DZDOC - Bank documentation tools.
                In ZEBRA, CERN Program Q100/Q101. Geneva, 1993.

\bibitem{hepdb} HEPDB - Database Management Package.
                CERN Program Q180, Geneva, 1993.

\bibitem{boris} B.Khomenko, Minutes of the Wednesday Software meetings 
                on 18/01/95.                
\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage 
\section*{Appendix 1: Description of the hit/digi banks used in DICE-95.}

\vspace{1cm}
Hits and digitisations are stored in two symmetric sets. 
Internal names of sets, containing hits, end with H,
 while internal names of digitisation sets end with D. 
This is transparent to a user who always address them 
with the sub-system name. 
This allows to have different detector parameter banks (SEJD) for hits 
and digitisations.

\vspace{1cm}

\bp(14, 5)(0, 9)
{\small \sf 
\p(0.1, 9){\f(14, 5)[bl]{SEJD}}
\p( 5.91,13.13){\f(  .88,  .44){ }}
\p( 6.34,13.34){\m(0,0)[c] { SETS }}
\p( 5.80,13.45){\m(0,0)[br]{  1   }}
\p( 5.91,13.34){\l(-1, 0){ 3.72}}
\p( 2.19,13.34 ){\v( 0,-1){  .66}}
\p( 1.97,12.25){\f( 1.09,  .44){ }}
% \mup( 1.97,12.30)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 3.06,12.25){\f( 4.81,  .44){ }}
\p( 5.47,12.47){\m(0,0)[c] { GEANT detector parameters  }}
\p( 7.88,12.71){\m(0,0)[br]{ ND=100 }}
\p( 2.52,12.47){\m(0,0)[c] { SEJD }}
\p( 2.84,11.38){\f( 1.09,  .44){ }}
% \mup( 2.84,11.43)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 3.94,11.38){\f( 4.81,  .44){ }}
\p( 6.34,11.59){\m(0,0)[c] { Hit parameters (by GSDETH) }}
\p( 8.75,11.83){\m(0,0)[br]{ ND=4 }}
\p( 3.39,11.59){\m(0,0)[c] { SJDH }}
\p( 1.75,12.25){\f(  .22,  .44){ }}
\p( 1.86,12.47){\m(0,0)[c] { 1 }}
\p( 1.86,12.25){\l( 0,-1){  .22}}
\p( 1.86,12.03){\l( 1, 0){ 1.20}}
\p( 3.06,12.03 ){\v( 0,-1){  .22}}
\p( 2.84,10.50){\f( 1.09,  .44){ }}
% \mup( 2.84,10.55)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 3.94,10.50){\f( 4.81,  .44){ }}
\p( 6.34,10.72){\m(0,0)[c] { Digit parameters (by GSDETD) }}
\p( 8.75,10.96){\m(0,0)[br]{ ND=2 }}
\p( 3.39,10.72){\m(0,0)[c] { SJDD }}
\p( 1.53,12.25){\f(  .22,  .44){ }}
\p( 1.64,12.47){\m(0,0)[c] { 2 }}
\p( 1.64,12.25){\l( 0,-1){ 1.09}}
\p( 1.64,11.16){\l( 1, 0){ 1.42}}
\p( 3.06,11.16 ){\v( 0,-1){  .22}}
\p( 2.84, 9.63){\f( 1.09,  .44){ }}
% \mup( 2.84, 9.68)(0.,0.05){  8}{\l(1,0){ 1.09}}
\p( 3.94, 9.63){\f( 4.81,  .44){ }}
\p( 6.34, 9.84){\m(0,0)[c] { Atlas Hit/Digit description }}
\p( 8.75,10.08){\m(0,0)[br]{ ND=200 }}
\p( 3.39, 9.84){\m(0,0)[c] { SJDU }}
\p( 1.31,12.25){\f(  .22,  .44){ }}
\p( 1.42,12.47){\m(0,0)[c] { 3 }}
\p( 1.42,12.25){\l( 0,-1){ 1.97}}
\p( 1.42,10.28){\l( 1, 0){ 1.64}}
\p( 3.06,10.28 ){\v( 0,-1){  .22}}
}
\ep
 
\rule{15cm}{.05cm}   
             
{\large \bf \sf SEJD GEANT detector parameters }
\begin{verbatim}
 ---------------------------------------------- entered file at 13-Dec-94 14:59
 Bank IDH  SEJD     GEANT detector parameters (filled by GSDET)                           
 Author             R. Brun                                                     
 Version            3.01                                                        
 Store              /GCBANK/ 
 Division           Constant 
 NL                   4                                                             
 NS                   4                                                             
 ND                 100                                                             
 Up        SETS     -1                                                          
 IO-Charac          10I / 1H 1I                                                 
              ---------- Description of the links  ----------
 1         SJDH     - pointer to hit parameters                                 
 2         SJDD     - pointer to digitisation parameters                        
 3         SJDU     - pointer to users parameters                               
              ---------- Description of the data words   ----------
 1         Nwv      Number of words to store packed hit descriptors               
 2         Nv       Number of hit descriptors (Volumes + non-cumulative elements)
 3         Nwh      Number of words per packed hit part                         
 4         Nh       Number of cumulative elements per hit  
 5         Nwd      Number of words per packed digit part                       
 6         Nd       Number of cumulative elements per digitisation  
 7         NWHI     primary size of hit bank                                    
 8         NWDI     primary size of digitisation bank                           
 9         Npath    Number of paths through JVOLUM tree; (-1) after GsDETV call                    
 10        Idm      For aliases only, IDET of mother detector                   
 --REP level=1   Nv times                                                        
     11      NameVol  Name of a volume or a non-cumulative element
     12      NbitVol  Number of bits for packing its number                     
 --REP level=1 -- End --                                                        
\end{verbatim}

\newpage
\rule{15cm}{.05cm} 

{\large \bf \sf SJDH Hit parameters (by GSDETH)}
\begin{verbatim}
 ---------------------------------------------- entered file at 13-Dec-94 14:59
 Bank IDH  SJDH     Hit parameters (filled by GSDETH)                                  
 ND                 4 - per each hit element                                           
 Up        SEJD     -1                                                          
 IO-Charac          / 1H 1I 2F                                                  
              ---------- Description of the data words   ----------
 --REP level=1  Nh times :                                                        
     1       NameHit  Name of a cumulative element 
     2       NbitHit  Number of bits for its packing                            
     3       origin   displacement for packing
     4       factor   scale for packing
\end{verbatim}

\rule{15cm}{.05cm} 

{\large \bf \sf SJDD Digit parameters (by GSDETD)}
\begin{verbatim}
 ---------------------------------------------- entered file at 13-Dec-94 14:59
 Bank IDH  SJDD     Digit parameters (by GSDETD)                                
 ND                 2 - per each digi element                                          
 Up        SEJD     -2                                                          
 IO-Charac          / 1H 1I                                                     
              ---------- Description of the data words   ----------
 --REP level=1   Nd times :                                                         
     1       NameDig  Name of the digit descriptor                              
     2       NbitDig  Number of bits for its packing                            
\end{verbatim}

\rule{15cm}{.05cm} 

{\large \bf \sf SJDU Atlas Hit/Digit description}
\begin{verbatim}
 ---------------------------------------------- entered file at 10-Jan-95 10:44
 Bank IDH  SJDU     Atlas Hit/Digit description                                 
 Author             Pavel Nevski                                                
 ND                 200                                                             
 Up        SEJD     -3                                                          
 IO-Charac          -F                                                          
              ---------- Description of the data words   ----------
 1         Iadr1    displacement for hit description part = 10                  
 2         Nha      Number of hit descriptors (both in non- and cum. parts)     
 3         Iadr2    displacement for volume description part = 10+10*Nh         
 4         Nva      number of all volume descriptors (branching or not)         
 5         Iadr3    displacement for the free space = 10+10*Nh+3*Nv             
 6         Nvb      number of real volume branchings for NUMBV                       
 7         option   1 - single step hit option (S in any hit element)                                                             
 8         serial   sensitive volume serial number for this table                                                             
 9         IdType   ATLAS detector number                                       
 10        Iprin    current print flag both for HITS and DIGI                   
 --REP level=1  Nha times, j=10*ih
     j+1      hit      encoded hit name                                          
     j+2      option   encoded hit option (R-rounding)                                       
     j+3      Nb       number of bit requested                                   
     j+4      Fmin     hit lower limit                                             
     j+5      Fmax     hit upper limit                                           
     j+6      Origin   Geant origin                                              
     j+7      Factor   Geant factor                                              
     j+8      Nbit     number of bit allocated                                   
     j+9      Iext     address of the Geant user step routine                    
     j+10     Ifun     hit function code (1-18 at present)                       
 --REP level=1  Nva times, k=10+10*Nha+3*iv 
     k+1      Ivol     Volume of branching (pointer in JVOLUM)                   
     k+2      Ncopy    number of branchings                                      
     k+3      Nb       number of bit needed                                      
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage 
\section*{Appendix 2: example of a  geometry module.}
\vspace{0.3cm}
\begin{verbatim}
*********************************************************************
MODULE     GAASGEO  is the  Geometry of the GaArsenid forward tracker
*********************************************************************
Author     Rene Brun, Pavel Nevski
Created    23 sept 94
+CDE,AGECOM,GCONST.
    Content   GAAS, GDSi, GSij, GHij, GDij, GSUB, GASS, GELE, GSUP
    Structure GAAG { Version, Ndisc, DrCounter, DfCounter, DzCounter,
                     TCKsubs, TCKsupp, DXele, DYele, Dzele  }
    Structure GDSi { Disc, RIdisc, ROdisc, ZDisc }
    Real      Zdel,Rj,Zk,DR
    Integer   Idisc,j,k,N,ndv
* -------------------------------------------------------------------
 Fill  GAAG                      ! geometry description
            version   = 3        !  layout version (1-Cosiner,2-Panel,3-Annecy)
            Ndisc     = 2        !  Nr. of discs (on each side)
            DrCounter = 5.3      !  DX (Dr) of a counter
            DfCounter = 2.6      !  DY (Dphi) of a counter
            DzCounter = .02      !  DZ (Thickness) of a counter
            TCKsubs   = .01      !  Thickness of the substrate
            TCKsupp   = 0.8      !  Thickness of the support
            DXele     = 3.       !  DX (Dr) of the electronics board
            DYele     = 2.       !  DY (Dphi) of the electronics board
            DZele     = .06      !  DZ (Thickness) of the electronics board
 Fill  GDSi                      ! individual disc parameters
            Disc = 1             !  disc  number
            RIdisc    = 20.      !  inner Radius
            ROdisc    = 35.      !  outer Radius
            Zdisc     = 156.     !  Position along Z
 Fill  GDSi                      ! same
            Disc = 2             !  second disc
            RIdisc    = 25.      !  inner Radius
            ROdisc    = 40.      !  outer Radius
            ZDisc     = 185.5    !  Position along Z
*
     USE         GAAG   version=3
*    ---
     Create      GAAS
     call GSPOS('GAAS',1,'INNE',0.,0.,0., 0, 'MANY')
* ---------------------------------------------------------------------
Block     GAAS   is GaArsenid forward tracker
     Material   Air
     Medium     Atlas
     Attribute  gaas         seen=0
     Shape      TUBE         Rmin=10     Rmax=50    dz=200
     Zdel = max(gaag_DZele,gaag_DZcounter+gaag_TCKsubs)  ! used later

     do idisc = 1,nint(gaag_Ndisc)
*
        USE        GDSi   Disc =idisc
*       ---
        Create     GDSi
        Position   GDSi   z=+gdsi_Zdisc             "forward"
        Position   GDSi   z=-gdsi_Zdisc  ThetaZ=180 "backward reflected"
     enddo
endblock
* ---------------------------------------------------------------------
Block     GDSi   is one dics of GaArsenid

   Attribute  gdsi   seen=0
   Shape      TUBE   Rmin = gdsi_RIdisc                                     _
                     Rmax = sqrt((gdsi_ROdisc+gaag_DXele)**2+gaag_DYele**2) _
                     dz   = (gaag_TCKsupp+8*Zdel)/2
 
   Create and Position  GSUP  dz=gaag_TCKsupp/2
 
      DR = 0
      n  = nint( (gdsi_ROdisc-gdsi_RIdisc)/gaag_DRcounter )
      if (n>1) DR=(gdsi_ROdisc-gdsi_RIdisc-gaag_DRcounter)/(n-1)

      do j=1,n                    !  make radial divisions
         Rj = gdsi_RIdisc+(j-1)*DR      
         Create       GSij
         do k=1,2
            zk=-gaag_TCKsupp/2-Zdel*(1+2*mod(j,2))+(k-1)*(gaag_TCKsupp+4*Zdel)
            Position  GSij    z=zk
         enddo
      enddo

endblock
* ---------------------------------------------------------------------
Block     GSij   is a sub-disc - one ring of overlapping counters
   Shape  TUBE   Rmin = Rj                                                    _
                 Rmax = sqrt((Rj+gaag_DRcounter+gaag_DXele)**2+gaag_DYele**2) _
                 dz   = Zdel

   Ndv = int (2*pi / atan(gaag_DFcounter/(Rj+gaag_DRcounter)/2)/4+1)
   Create      GHij
   position    GHij   z=-Zdel/2
   position    GHij   z=+Zdel/2    AlphaZ=360.0/(2*Ndv)
endblock
* ---------------------------------------------------------------------
Block     GHij   is a half of the ring - one plane of counters
   Shape       TUBE   DZ=Zdel/2
   Create      GDij
endblock
* ---------------------------------------------------------------------
Block     GDij   is a sector containing one counter
   Shape                DIVIsion   Iaxis=2  Ndiv=Ndv

   Create and Position  GSUB       x = Rj + gaag_DRcounter/2
   Create and Position  GELE       x = Rj + gaag_DRcounter + gaag_DXele/2
endblock
* ---------------------------------------------------------------------
Block     GSUB   is a GAAS substrate plus sensitive counter
   Component  H              A=1    Z=1   W=8
   Component  C              A=12   Z=6   W=5
   Component  O              A=16   Z=8   W=2
   mixture    Plexiglass     Dens=1.10
   Attribute  GSUB           SEEN=1   COLO=3
   Shape      BOX            dx=gaag_DRcounter/2   dy=gaag_DFcounter/2  _
                             dz=(gaag_DZcounter  + gaag_TCKsubs)/2

   Create and Position GASS  z=-gaag_TCKsubs/2
endblock
* ---------------------------------------------------------------------
Block     GASS   is a sensitive layer of the Ga Arsenid counter
   Component  GA           A=69.7  Z=31  W=1
   Component  AS           A=74.9  Z=33  W=1
   Mixture    GaArsenid    Dens=5.307
   Medium     sensitive    SteMax=gaag_DzCounter/5  Isvol=1
   Attribute  GASS         SEEN=1   COLO=4
   Shape      BOX          dz=gaag_DZcounter/2
*  - - - - - - - - - - - - - - - - - - - - - - - - 
   HITS       GASS         x:11:  y:10:  El:0:
*  - - - - - - - - - - - - - - - - - - - - - - - - 
endblock
* ---------------------------------------------------------------------
Block     GELE   is an electronic board for one counter
   Material   silicon      A=28.09  Z=14  Dens=2.33  RadL=9.36  AbsL=45.5
   Attribute  GELE         SEEN=1   COLO=5
   Shape      BOX          dx=gaag_DXele/2  dy=gaag_DYele/2  dz=gaag_DZele/2
endblock
* ---------------------------------------------------------------------
Block     GSUP   is a support for a whole GaAs disc
   Component  F            A=14.1   Z=7   W=.95
   Component  C            A=12.01  Z=6   W=.05
   Mixture    C_whiskers   Dens=.24
   Attribute  GSUP         SEEN=1  COLO=7
   Shape      TUBE         Rmin=0  Rmax=0  dz=0
endblock

end
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage 
\section*{Appendix 3: example of a digitisation module.}
\vspace{0.3cm}
\begin{verbatim}
*************************************************************************
Module     TILEDIG   is the  DIGITIZATION routine OF THE TILE calorimeter
*************************************************************************
Author     Marzio Nessi
Created    10 Jan 94
Structure  Tdig      { Version,Scale,Emax,Etamax,Deta,Dphi}
+CDE,AGECOM,GCONST,GCUNIT.
*
   INTEGER    NV,NH,ND
   PARAMETER  (NV=10,NH=10,ND=10)
   INTEGER    NVL(NV), AgFHIT0,AgFHIT1,AgSDIG0,AgSDIG1, LTRA,IH,IR
   REAL       VMOD, HITS(NH),DIGI(ND), Esum,The,Eta,Phi,E,
              zero(3)/3*0./, xyz(3)
*  ----------------------------------------------------------------------
*
   If (FIRST) then
      Fill TDIG                 ! Digitization parameters
         Version= 1             !  version
         Scale  = 1.e6          !  ADC scale factor
         Emax   = 100           !  Max energy
         etamax = 3.0           !  rapidity limit
         deta   = 0.025         !  eta granularity
         dphi   = 2*pi/256      !  phi garnularity

      DIGI TBMA   eta:tdig_Deta:(-3,3),   phi:tdig_Dphi:(0,2*pi),
                  Eloss:0:(0,tdig_Emax)
      FIRST = .false.
  endif
*  ----------------------------------------------------------------------
    If (AgFHIT0('TILE','TBSA') # ok) Return
    If (AgSDIG0('TILE','TBMA') # ok) Return

    DO While (AgFHIT1(IH,LTRA,NVL,HITS) .eq. Ok)

       If (abs(IH) = 1)  then  ! a new tile
          Esum=0
       endif
*     Accumulate just energy in one tile
       E    = Hits(1)
       Esum = Esum+E
*                                         all hits in this tile received ?
       If (IH<=0) then
*                                         translate NVL -> x,y,z -> eta,phi
          call GDTOM(zero,xyz,1)
          the = acos(xyz(3)/vmod(xyz,3))
          Eta = -log(tan(the/2))
          Phi = atan2(xyz(2),xyz(1))
          If (Phi < 0.) Phi = 2*pi + Phi
          DIGI(1) = Eta
          DIGI(2) = phi
          DIGI(3) = Esum
          If (AGSDIG1(LTRA,NVL,DIGI) # ok)  Return
       Endif

    EndDO

END
\end{verbatim}

\end{document}



