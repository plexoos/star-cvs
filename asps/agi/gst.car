+PATCH,MAIN. ==================================================================
*CMZ :  1.00/01 27/10/94  01.44.00  by  Pavel Nevski
+DECK,acmain,T=CC,If=CC. ------------------------------------------------------
/*CMZ :          22/03/98  19.27.39  by  Pavel Nevski*/
/*-- Author :    Pavel Nevski   28/11/97*/
/*****************************************************/
/*                    m a i n                        */
/*****************************************************/
#include <string.h>
#include <math.h>
static int        Margc=0;
static char **    Margv=NULL;
extern "C"  int   agmain_ ();
+SELF,IF=HPUX.
extern "C"  void  FTN_INITRAP();
+SELF.
extern "C"  int   getarg_ (int*, char*, int);
extern "C"  void  k_setar (int , char** );
 
int main    (int argc, char *argv[])
{ Margc=argc;  Margv=argv;  k_setar(argc,argv);
+SELF,IF=HPUX.
  FTN_INITRAP();  fpsetmask(0);
+SELF.
  agmain_();
}
 
int getarg_ (int *k, char *args, int n)
{ int i=0;   if (*k<Margc) i=strlen(Margv[*k]);  if (i>n) i=n;
  strncpy(args,Margv[*k],i);   memset (args+i,' ',n-i); return 0;
}
 
+DECK,afmain,IF=-CC.
*CMZ :          06/12/97  11.46.00  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/12/97
       program afmain
       call agmain
       end
+PATCH,COMIS. =================================================================
*CMZ :  1.30/00 25/01/97  03.42.29  by  Pavel Nevski
+DECK,CSINIT. -----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.30/00 22/04/97  15.56.15  by  Pavel Nevski
*-- Author : V.Berezhnoi
         SUBROUTINE CSINIT(NW)
***---------------------------
+SEQ,CSLUN.
         COMMON/CSCONT/LCONT
+SEQ,CSPAR.
+SEQ,MDPOOL.
+SEQ,COMIS.
+SEQ,CSBUF.
+SEQ,CSREC.
+SEQ,CSTAB.
+SEQ,CSPNTS.
+SEQ,CSSYSD.
+SEQ,CSDPVS.
+SEQ,CSKEYS.
+SEQ,CSCBWL.
+SEQ,CSICHV.
+SEQ,CSKUCS.
+SELF,IF=SHL.
+SEQ, CSHLNM.
+SELF,IF=PAW.
+SEQ, CSHFILL.
+SELF.
      COMMON /MPLIST/ INDP
         EXTERNAL MDEXP, CSMBIT
         EXTERNAL CSOFIL,CSOLOG,CSOMAP,CSLIB
         EXTERNAL CGCONT,CSCOMX,CSEXTX,CSPTFS
         EXTERNAL CSNPAR,CSKPAR,CSIPAR,CSRPAR,CSLPAR,
     +            CSTPAR,CSCPAR,CSSPAR
         CHARACTER KWORDS*22
      DATA KWORDS/'ENDIFITHENELSEIFENDDOD'/
      COMMON /CSDEBUG/ ICSDEBUG
 
      INDP      = 0
      CALL MDINIT(LHP,MDEXP)
      CALL MHDEF (LHP-6,MDEXP)
      LAST      = MAX0(NW,LASTK)-2
      IBASE     = 0
      IPC       = 0
      ITA       = 0
      IDP       = 0
      IFORS     = 1
      NCBARR    = 0
      NTRACE    = 1
      NPARAM    = 1
      IBSEM     = MHLOC(LSSTK)
      ITS       = IBSEM
      ILSEM     = LSSTK+IBSEM
      LIMPL     = 17
      IBIMPL    = MHLOC(LIMPL)
      IQ(IBIMPL)= 0
      LBB       = 10
      NBB       = 0
      NBG       = 0
      IBB       = MHLOC(LBB)-1
      IPMCAD    = 0
      IPGB      = 0
      IPGP      = 0
      IPGI      = 0
      IPLI      = 0
      IPLL      = 0
      LDATA     = 0
      IEXTGB    = 0
      LCONT     = 0
      NUMST     = 0
      JTCH      = MJCHAR(IBUF(1))
      NCHS      = LCSTK*NBYTPW
      JID       = MJCHAR(IDEN(1))
      JTOPA     = LOCF(IA(1))-1
      JPMB      = 0
      JPMC      = 0
      JMB       = JTCH
      JMC       = JMB
      NMC       = 0
      NMB       = NCHS
      JFI1      = MJSCHA(KWORDS)
      JFI2      = JFI1+4
      JTHEN     = JFI2+2
      JELSE     = JTHEN+4
      JOD1      = JELSE+6
      JOD2      = JOD1+4
      JSR       = MJSCHA(REC)
      JSR1      = MJSCHA(REC1)
      JSMAIN    = MJSCHA(MAINPR)
      JB4       = MJCHAR(IB(4))
      PROMPT(1) = 'CS>'
      PROMPT(2) = 'FSD>'
      PROMPT(3) = 'MND>'
      PROMPT(4) = 'PAU>'
      PROMPT(5) = '???>'
      KEYRD     = 0
      LIBRD     = 0
      KEYC      = 0
      IRECU     = 1-LRECU
      LUNINP    = 5
      ISTPM     = 0
      ICBWL     = 0
      LISTCL    = 0
      ICHLA     = ICHAR('A')
      ICHLZ     = ICHAR('Z')
      ICHD0     = ICHAR('0')
      ICHD9     = ICHAR('9')
      ICHSUSC   = ICHAR('_')
      ICHSX     = ICHAR('#')
      ICHSE     = ICHAR('!')
      ICHBLN    = ICHAR(' ')
      CALL UCTOH('    ',KBLN,4,4)
      ICHQUO    = ICHAR('''')
      ICHSSC    = ICHAR(';')
      ICHSEQ    = ICHAR('=')
      ICHBRA    = ICHAR('(')
      ICHKET    = ICHAR(')')
      ICHMINU   = ICHAR('-')
      ICHPLUS   = ICHAR('+')
      ICHCOMM   = ICHAR(',')
+SELF,IF=PAW.
      CALL CSPAWI
      MODHFI    = 0
+SELF,IF=-PAW.
      JKUVBS    =-1
+SELF.
      CHPATH='/tmp/'
+SELF,IF=HPUX,IF=SHL.
      CHF77 ='f77 -c +z +ppu -K -O'
      CHCC  ='cc -c +z -O'
+SELF,IF=AIX,IF=SHL.
      CHF77 ='xlf -qextname -qrndsngl -qcharlen=32767 -c'
      CHCC  ='cc -c'
+SELF,IF=SUN,MSDOS,IF=SOLARIS,IF=SHL.
* increase some internal tables: up to 100 nested control statements,
* 200 continuation lines, 10000 identifier names per module
      CHF77 ='/opt/SUNWspro/bin/f77 -Nc100 -Nl200 -Nn10000 -c -pic'
      CHCC  ='/opt/SUNWspro/bin/cc -c -K pic'
+SELF,IF=SUN,IF=-SOLARIS,IF=SHL.
      CHF77 ='f77 -c -pic'
      CHCC  ='cc -c -pic'
+SELF,IF=SGI,IF=SHL.
      CHF77 ='f77 -c'
      CHCC  ='cc -cckr -c'
+SELF,IF=ALPHA_OSF,IF=SHL.
      CHF77 ='f77 -c'
      CHCC  ='cc -c'
+SELF,IF=LINUX,IF=SHL.
* pn, 29.10.97: not clear yet, may be '-pic' not needed
      CHF77 ='f77 -c -PIC'
      CHCC  ='cc -c -PIC'
+SELF.
      RETURN
      END
 
+DECK,CSLINK. -----------------------------------------------------------------
*CMZ :          23/05/97  18.43.27  by  Pavel Nevski
*CMZ :  1.30/00 22/04/97  15.56.16  by  Pavel Nevski
*CMZ :  1.18/14 16/01/95  11.45.29  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSLINK
***------------------------
*     this is comis linker
***------------------------
+SEQ,CSPAR.
+SEQ,MDPOOL.
+SEQ,CSTABPS.
+SEQ,CSTAB.
+SEQ,CSPNTS.
+SEQ,CSLUN.
+SELF,IF=SHL.
      CHARACTER*(KLENID) FNNAME
      INTEGER CS_GET_FUNC
+SELF.
      INTEGER CSPMFS,CSLLIB
      COMMON /CSTBCS/  ITBC,ITBS
      COMMON /CSDEBUG/ ICSDEBUG
      COMMON /CSGSCM/  IGS,JGS,NGS,CSJUNK(3)
*
      if (ICSDEBUG.gt.0) print *,' ===> in CSLINK <=== '
      IF(ISTLIB.EQ.0 .AND. ITBS.EQ.0)RETURN
   2  I=IPGP
   3  IF(I.EQ.0)GO TO  5
      CALL CCOPYA(IQ(I+1),NCIDGP,KSIDP-1)
      IF(IADGP.EQ.0)THEN
        IF(ISTLIB.NE.0)THEN
          JGP=MJCHAR(IQ(I+KSIDP))
          IP=CSLLIB(JGP,NCIDGP)
          IF(IP.NE.0)THEN
             LIBRD=1
             NWIDEN=(NCIDGP+3)/4
             NCIDEN=NCIDGP
             CALL CCOPYA(IQ(I+KSIDP),IDEN(1),NWIDEN)
             CALL CSRD(JGS,NGS)
             IF (NGS .LT. 0) GO TO 5
             KPRO=CSPMFS(IBC)
             LIBRD=0
             KEYRD=0
             GO TO 4
          ENDIF
        ENDIF
*MAP-file
        IF(ITBS.NE.0)THEN
+SELF,IF=VAX.
          IP=MLSEAR(ITBS,IQ(I+KSIDP))
          IF(IP.GT.0)THEN
            IADGP=IQ(IP)
            IFCS=-1
            CALL CSRTGP(I)
          ENDIF
+SELF,IF=SHL.
          CALL CSGTIDP(I,FNNAME,NC)
          CALL CUTOL(FNNAME(1:NC))
          IADGP=CS_GET_FUNC(FNNAME(1:NC)//'_')
          IF(IADGP.NE.0)THEN
            IFCS=-2
            CALL CSRTGP(I)
          ENDIF
+SELF.
          IP=0
        ENDIF
      ENDIF
  4   I=IQ(I)
      GO TO 3
  5   END
 
+DECK,CSMAP. ------------------------------------------------------------------
*CMZ :          31/10/97  13.20.19  by  Pavel Nevski
*CMZ :  1.18/14 19/09/94  10.05.14  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSMAP(NAME)
      CHARACTER*(*) NAME
      COMMON /CSTBCS/ ITBC,ITBS
      CHARACTER *80 LIBNAME,SYMBOL*32
      INTEGER CS_SHL_LOAD,CSLTGP
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSMAP (',name,') <==='
      LIBNAME=NAME
      N=LENOCC(LIBNAME)
      CALL CUTOL(LIBNAME(1:N))
      IF(ITBS.NE.0)THEN
        NS=-1
        CALL CS_SHL_SYMBOLS(LIBNAME(1:N),NS,SYMBOL)
        IF(NS.EQ.-2)GO TO 20
 10     L=LENOCC(SYMBOL)
        IF(SYMBOL(L:L).EQ.'_')L=L-1
        CALL CSCHID(SYMBOL(:L))
        IT=CSLTGP(IPVS)
        IF(IT.GT.0)CALL CSDPRO(IT)
        CALL CS_SHL_SYMBOLS(LIBNAME(1:N),NS,SYMBOL)
        IF(NS.NE.-2)GO TO 10
        CALL CS_SHL_UNLOAD(LIBNAME(1:N))
        ITBS=ITBS-1
 20     CONTINUE
      ENDIF
      IERR=CS_SHL_LOAD(LIBNAME(1:N))
      IF(IERR.EQ.0)THEN
        ITBS=ITBS+1
      ELSE
        CALL CS_SHL_UNLOAD(LIBNAME(1:N))
      ENDIF
      END
 
+DECK,CSFILE. -----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.18/14 20/09/94  14.48.52  by  Fons Rademakers
*-- Author : V.Berezhnoi
************************************************************************
      SUBROUTINE CSFILE(FILENAME)
*                                                                      *
* Description: comis loader top level interface                        *
* Modifications:                                                       *
* pn, 29.10.97 according to the mail from VB (20.09.97):               *
*     FILENAME in concatineted parameters replaced by LIBNAME          *
************************************************************************
      CHARACTER*(*) FILENAME
      COMMON /CSERRNO/ IERR
      COMMON /CSDEBUG/ ICSDEBUG
+SELF,IF=SHL.
+SEQ,CSHLNM.
*     CHPATH='/tmp/' comes from CSHLNM
      CHARACTER  LIBNAME*72,LINE*80,PATH*72,NAME*72,CPID*8,FEXT*8
      INTEGER    SYSTEMF
      LOGICAL    EXIST1
*
      ICASE   = 0
      IERR    = 0
      L       = LENOCC(FILENAME)
      LCHPATH = LENOCC(CHPATH)
      if (ICSDEBUG.gt.0) print *,' ===> in CSFILE (',
     *                                  filename(:L),') <==='
      CALL CSPARSFN(FILENAME(:L),PATH,NAME,FEXT)
      LPATH   = LENOCC(PATH)
      LNAME   = LENOCC(NAME)
 
      LX=LENOCC(FEXT)
      IF (FEXT.EQ.'.csl')THEN
        ICASE = 4
      ELSE IF (FEXT.EQ.'.sl')THEN
        ICASE = 3
      ELSE IF (FEXT.EQ.'.c')THEN
        ICASE = 2
      ELSE IF (FEXT(LX-1:LX).EQ.'77')THEN
        ICASE = 1
        INQUIRE(FILE=FILENAME(:L),EXIST=EXIST1)
        IF (.NOT.EXIST1) FEXT=FEXT(1:LX-2)
      ENDIF
      LEXT    = LENOCC(FEXT)
*
      IF(ICASE.GT.0)THEN
        CALL GETPIDF(IPID)
        CPID    = ' '
        WRITE (CPID,'(I8)') IPID
        LP      = LOG10(REAL(IPID))+1
        CPID    = CPID(9-LP:)
        LIBNAME = CHPATH(:LCHPATH)// NAME(:LNAME) // '_' // CPID(:LP)
        LL      = LENOCC(LIBNAME)
        If (IcsDebug.GT.0) print *,' libname =',LL,libname(:ll)
        If (ICASE.EQ.1) THEN
*---- file...77
          IF (LPATH.GT.0) THEN
            LINE=PATH(:LPATH)//NAME(:LNAME)//FEXT(:LEXT)
          ELSE
            LINE=NAME(:LNAME)//FEXT(:LEXT)
          ENDIF
          CALL CSRMSL(LIBNAME(:LL))
          CALL CSF77 (LINE,LIBNAME(:LL)//'.f',IERR)
          IF (IERR.NE.0) THEN
            PRINT *,' error during conversion to f77::File: ',
     +          FILENAME(:L)
            RETURN
          ENDIF
        ELSE IF (ICASE.EQ.2) THEN
*---- file.c
          LINE = 'cp '//FILENAME(:L)//' '//LIBNAME(:LL)//'.c'
          LE   = LENOCC(LINE)
          IERR = SYSTEMF(LINE(:LE))
          IF (IERR.NE.0) RETURN
          CALL CSRMSL(LIBNAME(:LL))
        ELSE IF (ICASE.EQ.3) THEN
*---- file.sl
          IL = L-3
          LIBNAME = FILENAME(:IL)
          LL = IL
          CALL CSRMSL(LIBNAME(:LL))
*-- ' ' means do not produced output file
*         CALL CSF77 (FILENAME(:IL)//'.f',' ',IERR)
          CALL CSF77 (LIBNAME(:IL) //'.f',' ',IERR)
          IF (IERR.NE.0) THEN
            PRINT *,' error during translation csf77-file: '
     +            ,FILENAME(:L)
            RETURN
          ENDIF
        ELSE IF(ICASE.EQ.4)THEN
*---- file.csl
          IL = L-4
          LIBNAME= FILENAME(:IL)
          LL = IL
          CALL CSRMSL(LIBNAME(:LL))
        ENDIF
        IF (INDEX(LIBNAME(:LL),'/') .EQ. 0) THEN
           LINE = LIBNAME
           LIBNAME = './'//LINE
           LL = LL + 2
        ENDIF
        CALL CSCRSL(LIBNAME(:LL),CPID(:LP),FEXT(:LEXT),IERR)
        IF (IERR.EQ.0) RETURN
      ENDIF
+SELF.
      IERR=0
      CALL CSFILX(LIBNAME)
      END
 
 
+DECK,CSADDR. ----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.18/03 09/06/94  17.55.36  by  Rene Brun
*-- Author : V.Berezhnoi
******************************************************************************
      FUNCTION  CSADDR (CHNAME)
*
*    returns the memory address of a comis-routine
******************************************************************************
      CHARACTER*(*)    CHNAME
      INTEGER          CSADDR,CSLTGP,CSITGP
      CHARACTER*32     NAME
+SEQ,CSTAB.
+SELF,IF=SHL.
      INTEGER          CS_GET_FUNC
      COMMON /CSDEBUG/ ICSDEBUG
*
      NAME = CHNAME
      NC   = LENOCC(NAME)
      if (ICSDEBUG.gt.0) print *,' ===> in CSADDR (',NAME(:NC),') <==='
      CALL CSCHID(NAME(:NC))
      CALL CUTOL (NAME(:NC))
      I    = CSLTGP(IPVS)
      IF(I.GT.0)THEN
        IF(IFCS.EQ.0)THEN
          IADGP=CS_GET_FUNC(NAME(1:NC)//'_')
          IF(IADGP.NE.0)THEN
            IFCS=-2
            CALL CSRTGP(I)
          ELSE
            I=0
          ENDIF
        ENDIF
      ELSE
        IADGP=CS_GET_FUNC(NAME(1:NC)//'_')
        IF(IADGP.NE.0)THEN
          IFCS=-2
          ITYPGP=-2
          I=CSITGP(IPVS)
        ENDIF
      END IF
      CSADDR=I
+SELF,IF=-SHL.
      NAME=CHNAME
      CALL CSCHID(NAME)
      I=CSLTGP(IPVS)
      IF(I.GT.0)THEN
        IF(IFCS.EQ.0)I=0
      END IF
      CSADDR=I
+SELF.
      END
 
+DECK,CSCRSL. -----------------------------------------------------------------
*CMZ :          29/10/97  09.43.10  by  Pavel Nevski
*CMZ :  1.18/02 07/04/94  15.26.09  by  Vladimir Berezhnoi
*-- Author :    Vladimir Berezhnoi   07/01/94
*************************************************************************
      SUBROUTINE       CSCRSL (NAME,CPID,FEXT,IERR)
*                                                                       *
* Description: interface to CS_SHL_LOAD                                 *
* Modifications:                                                        *
* pn, 29.10.97 modified according to the mail from VB (20.09.97):       *
*     NAME in concatineted parameters replaced by CHLINE                *
*                                                                       *
*************************************************************************
      CHARACTER *(*)   NAME,CPID,FEXT
      COMMON /CSTBCS/  ITBC,ITBS
+SELF,IF=SHL.
+SEQ,CSHLNM.
      CHARACTER*72     CHLINE,FEXEC
      INTEGER          SYSTEMF,CS_SHL_LOAD
      COMMON /CSDEBUG/ ICSDEBUG
*--
      if (ICSDEBUG.gt.0) print *,' ===> in CSCRSL (',NAME,') <==='
      LN=LENOCC(NAME)
      LP=LENOCC(CPID)
*c    IF (ITBS.NE.0) CALL CSRMSL(NAME)
 
      IF (FEXT.ne.'.sl' .and. FEXT.ne.'.csl') THEN  ! do the library
        FEXEC=CHPATH(:LENOCC(CHPATH))//'exec_'//CPID//'.exec'
        CALL CSCREXEC(NAME,CPID,FEXT,FEXEC,IERR)
 
        CHLINE='/bin/sh '//FEXEC
        IERR=SYSTEMF(CHLINE(:LENOCC(CHLINE)))
        IF (IERR .NE. 0) RETURN
 
        CHLINE='/bin/rm -f '//FEXEC
        IERR=SYSTEMF(CHLINE(:LENOCC(CHLINE)))
        IF (IERR .NE. 0) RETURN
      endif
 
*c now really load
      CHLINE=NAME(1:LN)
      IERR=CS_SHL_LOAD(CHLINE(1:LN)//'.sl')
      IF (IERR.ne.0) THEN
        CALL CS_SHL_UNLOAD(CHLINE(1:LN)//'.sl')
        return
      ENDIF
      ITBS=ITBS+1
+SELF.
      END
 
+DECK,CSSHLD. -----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.18/01 30/03/94  11.56.54  by  Vladimir Berezhnoi
*-- Author :    Vladimir Berezhnoi   07/01/94
      SUBROUTINE CSSHLD
+SELF,IF=SHL.
+SEQ,CSHLNM.
      COMMON /CSTBCS/ ITBC,ITBS
      CHARACTER *8 CPID
      CHARACTER *80 CHLINE,LIBNAME
      INTEGER  SYSTEMF
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSSHLD <=== '
      CALL GETPIDF(IPID)
      CPID = ' '
      WRITE(CPID,'(I8)')IPID
      LP   = LOG10(REAL(IPID))+1
      CPID = CPID(9-LP:)
      IF(ITBS.EQ.0)GO TO 2
      N=0
 1    CALL CS_SHL_GET(N,LIBNAME)
      IF(LIBNAME.NE.' ')THEN
        LL=LENOCC(LIBNAME)
***        IF(     INDEX(LIBNAME(:LL),  '/tmp/').NE.0
***     +    .AND. INDEX(LIBNAME(:LL),CPID(:LP)).NE.0)
***     +  THEN
        IF(INDEX(LIBNAME(:LL),CPID(:LP)).NE.0)THEN
          CALL CS_SHL_UNLOAD(LIBNAME(:LL))
          ITBS=ITBS-1
          CHLINE='/bin/rm -f '//LIBNAME(:LL)
          L=LENOCC(CHLINE)
          IERR=SYSTEMF(CHLINE(:L))
*          print *,'csshlDELl: ',chline(:l)
        ELSE
*          print *,'csshlkeep: ',libname(:ll)
          N=N+1
        ENDIF
        GO TO 1
      ENDIF
*
*-- delete .f files
*
 2    LPATH  = LENOCC(CHPATH)
      CHLINE = '/bin/rm -f '//CHPATH(:LPATH)//'*_'//CPID(:LP)//'.f'
+SELF,IF=SGI,ALPHA_OSF,IF=SHL.
     +         //' '//CHPATH(:LPATH)//'so_locations'
+SELF,IF=SHL.
      L = LENOCC(CHLINE)
      IERR = SYSTEMF(CHLINE(:L))
+SELF.
      END
 
+DECK,CSHLOPT. ----------------------------------------------------------------
*CMZ :          23/05/97  18.43.27  by  Pavel Nevski
*CMZ :  1.18/01 30/03/94  11.58.04  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSHLOPT(TEXT,CHVAR)
      CHARACTER*(*)TEXT,CHVAR
+SELF,IF=SHL.
+SEQ,CSHLNM.
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSHLOPT <=== '
      CALL CUTOL(CHVAR)
      IF(CHVAR(1:1).EQ.'p')THEN
        CHPATH=TEXT
        IF(CHPATH.EQ.' ')CHPATH='./'
        L=LENOCC(CHPATH)
        IF(CHPATH(L:L).NE.'/')CHPATH=CHPATH(:L)//'/'
      ELSEIF(CHVAR(1:1).EQ.'f')THEN
        CHF77=TEXT
      ELSEIF(CHVAR(1:1).EQ.'c')THEN
        CHCC=TEXT
      ELSEIF(CHVAR(1:1).EQ.' ')THEN
        PRINT *,' PATH=',CHPATH(:LENOCC(CHPATH))
        PRINT *,' FORT=',CHF77(:LENOCC(CHF77))
        PRINT *,'   CC=',CHCC(:LENOCC(CHCC))
      ELSE
        PRINT *,' CS.SET: unknown option:',CHVAR
        PRINT *,' possible options are: path, f77, cc'
      ENDIF
+SELF.
      END
 
+DECK,CSRMSL. ----------------------------------------------------------------
*CMZ :          23/05/97  19.31.06  by  Pavel Nevski
*CMZ :  1.19/01 14/11/94  18.10.10  by  Fons Rademakers
*-- Author :    Vladimir Berezhnoi   07/02/94
      SUBROUTINE CSRMSL(NAME1)
      CHARACTER *(*)NAME1
+SELF,IF=SHL.
+SEQ,CSHLNM.
      COMMON /CSTBCS/ ITBC,ITBS
      CHARACTER *80 LIBNAME,NAME,SYMBOL*32
      INTEGER CSLTGP
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSRMSL (',NAME1,') <=== '
*
*-- match only file names (remove path)
*
      NAME = NAME1
      LN = LENOCC(NAME)
      IF (INDEX(NAME(:LN),'/') .EQ. 0) THEN
         LIBNAME = NAME
         NAME = '/'//LIBNAME
         LN = LN + 1
      ELSE
         DO 5 I = LN, 1, -1
            IF (NAME(I:I) .EQ. '/') THEN
               NAME = NAME(I:)
               LN = LENOCC(NAME)
               GOTO 6
            ENDIF
 5       CONTINUE
      ENDIF
*
 6    CONTINUE
*
      N=0
 1    CALL CS_SHL_GET(N,LIBNAME)
      IF (LIBNAME.NE.' ') THEN
        LL=LENOCC(LIBNAME)
        LS=LL-LN-2
        IF (LS .LT. 1) LS = 1
        IF (LIBNAME(LS:LL) .EQ. NAME(1:LN)//'.sl') THEN
           NS=-1
 10        CALL CS_SHL_SYMBOLS(LIBNAME(1:LL),NS,SYMBOL)
           IF(NS.EQ.-2) GO TO 20
           L=LENOCC(SYMBOL)
           IF(SYMBOL(L:L).EQ.'_') L=L-1
           CALL CLTOU (SYMBOL(:L))
           CALL CSCHID(SYMBOL(:L))
           IT=CSLTGP(IPVS)
           IF(IT.GT.0)CALL CSDPRO(IT)
           go to 10
 
 20        CALL CS_SHL_UNLOAD(LIBNAME(1:LL))
           ITBS=ITBS-1
           RETURN
        ENDIF
        N=N+1
        GOTO 1
      ENDIF
+SELF.
      END
+DECK,CSCREXEC,IF=SHL. -------------------------------------------------------
*CMZ :          10/11/97  11.27.40  by  Pavel Nevski
*CMZ :  1.17/07 10/01/94  16.41.15  by  Vladimir Berezhnoi
*-- Author :    Vladimir Berezhnoi   07/01/94
*************************************************************************
      SUBROUTINE CSCREXEC(NAME,CPID,FEXT,FEXEC,IERR)
*                                                                       *
* Description: comis exec processor                                     *
* Modifications:                                                        *
* PN, 29.10.97 - LINUX version added according to VB mail of 20.09.97   *
*              - system branches cleaned up, USERLIB is a common option *
*************************************************************************
      CHARACTER *(*)      NAME,CPID,FEXT,FEXEC
+SEQ,CSHLNM.
      CHARACTER *256  CHLINE
      CHARACTER *4096 USERLIBS
      COMMON /CSDEBUG/ ICSDEBUG
 
      IERR  = 0
      LN    = LENOCC(NAME)
      LP    = LENOCC(CPID)
      LPATH = LENOCC(CHPATH)
      LEXEC = LENOCC(FEXEC)
      if (ICSDEBUG.gt.0) print *,' ===> in CSCREXEC <=== ',NAME(:LN)
 
**    CALL PALUNF(60,3,LUNOUT)
      CALL CSLUNF(LUNOUT)
      IF (LUNOUT.EQ.0) GO TO 99
      OPEN(LUNOUT,FILE=FEXEC(:LEXEC), STATUS='UNKNOWN',ERR=99)
      WRITE (LUNOUT,'(A)')        '#! /bin/sh'
      WRITE (LUNOUT,'(A)')        'olddir=`pwd`'
*     WRITE (LUNOUT,'(A)')        'cd '//CHPATH(:LPATH)
      CHLINE=                     'cd '//CHPATH(:LPATH)
      L=LENOCC(CHLINE)
      WRITE (LUNOUT,'(A)') CHLINE(:L)
*     WRITE (LUNOUT,'(A)')        '/bin/rm -f '//NAME(:LN)//'.sl'
      CHLINE=                     '/bin/rm -f '//NAME(:LN)//'.sl'
      L=LENOCC(CHLINE)
      WRITE (LUNOUT,'(A)') CHLINE(:L)
      IF(FEXT.EQ.'.c')THEN
*                                 'cc -c .... name.c'
        L=LENOCC(CHCC)
        CHLINE=CHCC(:L)//' '//NAME(:LN)// '.c'
      ELSE
*                                 'f77 -c .... name.f'
        L=LENOCC(CHF77)
        CHLINE=CHF77(:L)//' '//NAME(:LN)// '.f'
      ENDIF
*
      L=LENOCC(CHLINE)
      WRITE(LUNOUT,'(A)') CHLINE(:L)
      WRITE(LUNOUT,'(A)')         'errno=$?'
      WRITE(LUNOUT,'(A)')         'if [ $errno != 0 ]'
      WRITE(LUNOUT,'(A)')         'then'
      WRITE(LUNOUT,'(A)')         '   exit $errno'
      WRITE(LUNOUT,'(A)')         'fi'
*
+SELF,IF=HPUX.
      CHLINE=                     'ld -b -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=AIX.
      CHLINE=                     '/usr/ucb/nm '// NAME(:LN) //
     + '.o | egrep '' [BAD] ''| cut -f3 -d'' '' |sed -e ''s/^#/ #/'' '
     + // '| sort | uniq > '// NAME(:LN) //'.exp'
      L=LENOCC(CHLINE)
      WRITE (LUNOUT,'(A)') CHLINE(:L)
      CHLINE=                     'ld -bE:'// NAME(:LN) //'.exp -o '
     + // NAME(:LN) //'.sl /pathtoimp/aixpawimp.o '// NAME(:LN) //'.o'
     + // ' -bh:4 -T512 -H512'
      L=LENOCC(CHLINE)
      IF(FEXT.EQ.'.c')THEN
        CHLINE= CHLINE(:L)// ' -lc'
      ELSE
        CHLINE= CHLINE(:L)// ' -lxlf90'
      ENDIF
+SELF,IF=SUN,MSDOS,IF=SOLARIS.
      CHLINE=                     '/usr/ccs/bin/ld -G -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=SUN,IF=-SOLARIS.
      CHLINE=                     'ld -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=SGI.
      CHLINE=                     'ld -shared -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=ALPHA_OSF.
      CHLINE=                     'ld -shared -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
     +                    // ' -lUfor -lfor -lFutil -lm -lots -lc'
+SELF,IF=LINUX.
      CHLINE=                     'ld -shared -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF.
*
      USERLIBS=                   '         '
      CALL GETENV('USERLIB',USERLIBS)
      L       = LENOCC(CHLINE)
      LUSRLIB = max(1,LENOCC(USERLIBS))
      WRITE (LUNOUT,'(A)') CHLINE(:L) // USERLIBS(:LUSRLIB)
*
      WRITE(LUNOUT,'(A)')         'errno=$?'
      WRITE(LUNOUT,'(A)')         'if [ $errno != 0 ]'
      WRITE(LUNOUT,'(A)')         'then'
      WRITE(LUNOUT,'(A)')         '   exit $errno'
      WRITE(LUNOUT,'(A)')         'fi'
      CHLINE=                     '/bin/chmod 555 '//NAME(:LN)//'.sl'
      L=LENOCC(CHLINE)
      WRITE(LUNOUT,'(A)')CHLINE(:L)
*?     CHLINE='/bin/rm -f *_'//CPID(:LP)//'.o *_'//CPID(:LP)//'.f'
*      CHLINE=                    '/bin/rm -f *_'//CPID(:LP)//'.o'
      CHLINE=                     '/bin/rm -f '//NAME(:LN)//'.o'
      L=LENOCC(CHLINE)
      WRITE(LUNOUT,'(A)')CHLINE(:L)
      WRITE(LUNOUT,'(A)')         'cd $olddir'
      WRITE(LUNOUT,'(A)')         'exit 0'
      CALL CSCLOS(LUNOUT)
      CLOSE(LUNOUT)
      RETURN
*
 99   PRINT *,' CS: could not open file: ',FEXEC(:LENOCC(FEXEC))
      IERR=1
      IF(LUNOUT.GT.0)CALL CSCLOS(LUNOUT)
      END
+DECK,CSFILX.
*CMZ :          02/12/97  12.36.02  by  Pavel Nevski
*CMZ :  1.18/00 25/01/94  18.26.31  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSFILX(NAME)
***---------------------------------
+SEQ,CSLUN.
+SELF,IF=IBM.
         CHARACTER *80 VMIBM
+SELF.
      CHARACTER *(*) NAME
      IF(ISTFIL.NE.0)THEN
        CLOSE(LUNFIL)
        ISTFIL=0
      ENDIF
+SELF,IF=VAX.
      OPEN( LUNFIL,FILE=NAME,SHARED,READONLY,STATUS='OLD' ,ERR=1)
+SELF,IF=APOLLO,UNIX.
      OPEN( LUNFIL,FILE=NAME,STATUS='OLD' ,ERR=1)
+SELF,IF=IBM,IF=-IBMMVS,IF=-PAW.
      VMIBM=NAME
      L=LENOCC(NAME)
      DO 77 I=1,L
         IF(VMIBM(I:).EQ.'.')VMIBM(I:I)=' '
  77  CONTINUE
      IS=INDEX(VMIBM,'/')
      IF(IS.NE.0)VMIBM(IS:IS)=' '
      OPEN( LUNFIL,FILE='/'//VMIBM,STATUS='UNKNOWN' ,ERR=1)
+SELF,IF=IBM,IF=-IBMMVS,IF=PAW.
      CALL KUOPEN ( LUNFIL, NAME, 'OLD', ISTAT )
      IF ( ISTAT .NE. 0 )               GO TO 1
+SELF,IF=IBMMVS.
      CALL KUOPEN ( LUNFIL, NAME, 'OLD', ISTAT )
      IF ( ISTAT .NE. 0 )               GO TO 1
+SELF.
      ISTFIL=1
  1   RETURN
*      CALL CSSOUT('FILE WAS NOT OPEN')
*      CALL CSSOUT(NAME)
      END
+DECK,csreset.
*CMZ :          22/03/98  20.47.36  by  Pavel Nevski
*-- Author :    Pavel Nevski   22/03/98
*************************************************************************
      SUBROUTINE CSRESET
*************************************************************************
+SEQ, CSPAR.
+SEQ, CSPNTS.
      entry kibres
      IRECU=1-LRECU
*
      END
 
 
 
 
+PATCH,DECCC. ================================================================
*CMZ :  1.30/00 23/07/96  18.37.07  by  Pavel Nevski
+KEEP,dlfcn,IF=AIX,IF=SHL,T=XCC. ---------------------------------------------
/*CMZ :          20/11/97  22.10.22  by  Pavel Nevski*/
/*-- Author :    HELIOS Software GmbH*/
/*
 * @(#)dlfcn.h	1.4 revision of 95/04/25  09:36:52
 * This is an unpublished work copyright (c) 1992 HELIOS Software GmbH
 * 30159 Hannover, Germany
 */
 
#ifndef __dlfcn_h__
#define __dlfcn_h__
 
#ifdef __cplusplus
extern "C" {
#endif
 
/*
 * Mode flags for the dlopen routine.
 */
#define RTLD_LAZY	1	/* lazy function call binding */
#define RTLD_NOW	2	/* immediate function call binding */
#define RTLD_GLOBAL	0x100	/* allow symbols to be global */
 
/*
 * To be able to intialize, a library may provide a dl_info structure
 * that contains functions to be called to initialize and terminate.
 */
struct dl_info {
	void (*init)(void);
	void (*fini)(void);
};
 
#if __STDC__ || defined(_IBMR2)
 void *dlopen(const char *path, int mode);
 void *dlsym(void *handle, const char *symbol);
 char *dlerror(void);
 int dlclose(void *handle);
#else
 void *dlopen();
 void *dlsym();
 char *dlerror();
 int dlclose();
#endif
 
#ifdef __cplusplus
}
#endif
 
#endif /* __dlfcn_h__ */
 
 
 
+DECK,CS_HPSHL,T=XCC,IF=HPUX,IF=SHL. --------------------------------------
/*CMZ :          18/05/97  14.03.45  by  Pavel Nevski*/
/*-- Author :*/
#include <string.h>
#include <stdlib.h>
#include <dl.h>
 
void perror();
int  cs_shl_load_(path, n)
   char *path;
   int n;
{
   shl_t  handle;
   char   lib_name[80];
/* int    flags=BIND_DEFERRED; */
   int    flags=BIND_IMMEDIATE | BIND_VERBOSE;
/* int    flags=BIND_IMMEDIATE | BIND_NONFATAL; */
   long   address=0L;
   extern int errno;
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
   handle = shl_load(lib_name, flags, address);
   return (errno);
}
/****************************************************************************/
long cs_get_func_(sym,n)
   char *sym;
   int n;
{
   shl_t handle;
   short type;
   long  addr;
   char  func_name[80];
 
   strncpy(func_name, sym, n);  func_name[n] = '\0';
 
   handle = NULL;
   if (shl_findsym(&handle,func_name,TYPE_PROCEDURE,&addr) == 0) return(addr);
   else /* printf(" CS: function not found: %s\n",func_name); */ return (0L);
}
/****************************************************************************/
void cs_shl_unload_(path, n)
   char *path;
   int n;
{
   shl_t  handle;
   struct shl_descriptor *desc;
   char   lib_name[80];
   int    index;
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
   /* find handle of shared library using its name */
   index  = 0;
   handle = NULL;
   while (shl_get(index++, &desc) == 0)
   { if (!strcmp(lib_name, desc->filename)) { handle = desc->handle; break; } }
 
   if (!handle)
   {  printf(" CS: Shared library not loaded: %s\n", lib_name);  return; }
 
   if (shl_unload(handle) == -1)
      printf(" CS: Could not unload shared library: %s\n", lib_name);
}
/****************************************************************************/
void cs_shl_symbols_(path, ns, symbol, n)
   char *path, *symbol;
   int  *ns;
   int   n;
{
   shl_t  handle;
   struct shl_descriptor *desc;
   char   lib_name[80];
   int    index, flags;
   short  type;
   static nsym;
   static struct shl_symbol *symbols;
 
   if (*ns == -1)
   {  strncpy(lib_name, path, n);   lib_name[n] = '\0';
 
      /* find handle of shared library using its name */
      index  = 0;
      handle = NULL;
      while (shl_get(index++, &desc) == 0)
      { if (!strcmp(lib_name,desc->filename)) { handle=desc->handle; break; } }
      if (!handle) { *ns = -2; return;  }
 
      nsym = shl_getsymbols(handle, TYPE_PROCEDURE,
                            EXPORT_SYMBOLS|NO_VALUES, malloc, &symbols);
      if (nsym == -1)
      {  printf(" CS: Could not get symbols from shared library: %s\n",
                lib_name);  *ns = -2; return;
      }
      *ns = 0;
   }
   else
   {  if (*ns >= nsym-1) { *ns = -2;  free(symbols);  return; }
      else                (*ns)++;
   }
   memset(symbol, ' ', 32);
   strncpy(symbol, symbols[*ns].name, strlen(symbols[*ns].name));
}
/****************************************************************************/
void cs_shl_get_(ns, symbol, n)
   char *symbol;
   int  *ns;
   int   n;
{  /* find name of ns [ns=0 for first] shared library  */
   struct shl_descriptor *desc;
 
   memset(symbol, ' ', n);
   if (shl_get(*ns, &desc) == 0)
      strncpy(symbol,desc->filename , strlen(desc->filename));
}
 
 
 
+DECK,CS_dlfcn,T=XCC,IF=AIX,IF=SHL. --------------------------------------------
/*CMZ :          06/07/97  15.44.20  by  Pavel Nevski*/
/*-- Author :*/
/*
 * @(#)dlfcn.c	1.11 revision of 96/04/10  20:12:51
 * This is an unpublished work copyright (c) 1992 HELIOS Software GmbH
 * 30159 Hannover, Germany
 *
 * We simulate dlopen() et al. through a call to load. Because AIX has
 * no call to find an exported symbol we read the loader section of the
 * loaded module and build a list of exported symbols and their virtual
 * address.
 *
 * Changes marked with `--jwe' were made on April 7 1996 by John W. Eaton
 * <jwe@bevo.che.wisc.edu> to support g++ and/or use with Octave.
 * This makes my life easier with Octave.  --jwe
 */
 
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ldr.h>
#include <a.out.h>
#include <ldfcn.h>
+cde,dlfcn.
 
typedef struct {
	char		*name;		/* the symbols's name */
	void		*addr;		/* its relocated virtual address */
} Export, *ExportPtr;
 
/*
 * xlC uses the following structure to list its constructors and
 * destructors. This is gleaned from the output of munch.
 */
 
typedef struct {
	void (*init)(void);		/* call static constructors */
	void (*term)(void);		/* call static destructors */
} Cdtor, *CdtorPtr;
 
typedef void (*GccCDtorPtr)(void);
 
/*
 * The void * handle returned from dlopen is actually a ModulePtr.
 */
 
typedef struct Module {
	struct Module	*next;
	char		*name;		/* module name for refcounting */
	int		refCnt;		/* the number of references */
	void		*entry;		/* entry point from load */
	struct dl_info	*info;		/* optional init/terminate functions */
	CdtorPtr	cdtors;		/* optional C++ constructors */
	GccCDtorPtr	gcc_ctor;	/* g++ constructors  --jwe */
	GccCDtorPtr	gcc_dtor;	/* g++ destructors  --jwe */
	int		nExports;	/* the number of exports found */
	ExportPtr	exports;	/* the array of exports */
} Module, *ModulePtr;
 
/*
 * We keep a list of all loaded modules to be able to call the fini
 * handlers and destructors at atexit() time.
 */
static ModulePtr modList;
 
/*
 * The last error from one of the dl* routines is kept in static
 * variables here. Each error is returned only once to the caller.
 */
static char errbuf[BUFSIZ];
static int errvalid;
 
/*
 * The `fixed' gcc header files on AIX 3.2.5 provide a prototype for
 * strdup().  --jwe
 */
#ifndef HAVE_STRDUP
extern char *strdup(const char *);
#endif
static void caterr(char *);
static int readExports(ModulePtr);
static void terminate(void);
static void *findMain(void);
 
void *dlopen(const char *path, int mode)
{
	register ModulePtr mp;
	static void *mainModule;
 
	/*
	 * Upon the first call register a terminate handler that will
	 * close all libraries. Also get a reference to the main module
	 * for use with loadbind.
	 */
	if (!mainModule) {
		if ((mainModule = findMain()) == NULL)
			return NULL;
		atexit(terminate);
	}
	/*
         * SunOS/System V.4 allows handle to be a NULL pointer to refer
         * to the module the call is made from, this is not implemented.
         */
	if (path == NULL) {
                mp = mainModule;
		if (readExports(mp) == -1) {
                printf("can not readExports for mainModule \n");
	 	return NULL;
         	}
                return mp;
        }
	/*
	 * Scan the list of modules if we have the module already loaded.
	 */
	for (mp = modList; mp; mp = mp->next)
		if (strcmp(mp->name, path) == 0) {
			mp->refCnt++;
			return mp;
		}
	if ((mp = (ModulePtr)calloc(1, sizeof(*mp))) == NULL) {
		errvalid++;
		strcpy(errbuf, "calloc: ");
		strcat(errbuf, strerror(errno));
		return NULL;
	}
	if ((mp->name = strdup(path)) == NULL) {
		errvalid++;
		strcpy(errbuf, "strdup: ");
		strcat(errbuf, strerror(errno));
		free(mp);
		return NULL;
	}
	/*
	 * load should be declared load(const char *...). Thus we
	 * cast the path to a normal char *. Ugly.
	 */
	if ((mp->entry = (void *)load((char *)path, L_NOAUTODEFER, NULL)) == NULL) {
		free(mp->name);
		free(mp);
		errvalid++;
		strcpy(errbuf, "dlopen: ");
		strcat(errbuf, path);
		strcat(errbuf, ": ");
		/*
		 * If AIX says the file is not executable, the error
		 * can be further described by querying the loader about
		 * the last error.
		 */
		if (errno == ENOEXEC) {
			char *tmp[BUFSIZ/sizeof(char *)];
			if (loadquery(L_GETMESSAGES, tmp, sizeof(tmp)) == -1)
				strcpy(errbuf, strerror(errno));
			else {
				char **p;
				for (p = tmp; *p; p++)
					caterr(*p);
			}
		} else
			strcat(errbuf, strerror(errno));
		return NULL;
	}
	mp->refCnt = 1;
	mp->next = modList;
	modList = mp;
	if (loadbind(0, mainModule, mp->entry) == -1) {
		dlclose(mp);
		errvalid++;
		strcpy(errbuf, "loadbind: ");
		strcat(errbuf, strerror(errno));
		return NULL;
	}
	/*
	 * If the user wants global binding, loadbind against all other
	 * loaded modules.
	 */
	if (mode & RTLD_GLOBAL) {
		register ModulePtr mp1;
		for (mp1 = mp->next; mp1; mp1 = mp1->next)
			if (loadbind(0, mp1->entry, mp->entry) == -1) {
				dlclose(mp);
				errvalid++;
				strcpy(errbuf, "loadbind: ");
				strcat(errbuf, strerror(errno));
				return NULL;
			}
	}
	if (readExports(mp) == -1) {
		dlclose(mp);
		return NULL;
	}
	/*
	 * If there is a dl_info structure, call the init function.
	 */
	if (mp->info = (struct dl_info *)dlsym(mp, "dl_info")) {
		if (mp->info->init)
			(*mp->info->init)();
	} else
		errvalid = 0;
	/*
	 * If the shared object was compiled using xlC we will need
	 * to call static constructors (and later on dlclose destructors).
	 */
	if (mp->cdtors = (CdtorPtr)dlsym(mp, "__cdtors")) {
		CdtorPtr cp = mp->cdtors;
		while (cp->init || cp->term) {
			if (cp->init && cp->init != (void (*)(void))0xffffffff)
				(*cp->init)();
			cp++;
		}
	/*
	 * If the shared object was compiled using g++, we will need
	 * to call global constructors using the _GLOBAL__DI function,
	 * and later, global destructors using the _GLOBAL_DD
	 * funciton.  --jwe
	 */
	} else if (mp->gcc_ctor = (GccCDtorPtr)dlsym(mp, "_GLOBAL__DI")) {
		(*mp->gcc_ctor)();
		mp->gcc_dtor = (GccCDtorPtr)dlsym(mp, "_GLOBAL__DD");
	} else
		errvalid = 0;
	return mp;
}
 
/*
 * Attempt to decipher an AIX loader error message and append it
 * to our static error message buffer.
 */
static void caterr(char *s)
{
	register char *p = s;
 
	while (*p >= '0' && *p <= '9')
		p++;
	switch(atoi(s)) {
	case L_ERROR_TOOMANY:
		strcat(errbuf, "to many errors");
		break;
	case L_ERROR_NOLIB:
		strcat(errbuf, "can't load library");
		strcat(errbuf, p);
		break;
	case L_ERROR_UNDEF:
		strcat(errbuf, "can't find symbol");
		strcat(errbuf, p);
		break;
	case L_ERROR_RLDBAD:
		strcat(errbuf, "bad RLD");
		strcat(errbuf, p);
		break;
	case L_ERROR_FORMAT:
		strcat(errbuf, "bad exec format in");
		strcat(errbuf, p);
		break;
	case L_ERROR_ERRNO:
		strcat(errbuf, strerror(atoi(++p)));
		break;
	default:
		strcat(errbuf, s);
		break;
	}
}
 
void *dlsym(void *handle, const char *symbol)
{
	register ModulePtr mp = (ModulePtr)handle;
	register ExportPtr ep;
	register int i;
 
	/*
	 * Could speed up the search, but I assume that one assigns
	 * the result to function pointers anyways.
	 */
	for (ep = mp->exports, i = mp->nExports; i; i--, ep++)
		if (strcmp(ep->name, symbol) == 0)
			return ep->addr;
	errvalid++;
	strcpy(errbuf, "dlsym: undefined symbol ");
	strcat(errbuf, symbol);
	return NULL;
}
 
char *dlerror(void)
{
	if (errvalid) {
		errvalid = 0;
		return errbuf;
	}
	return NULL;
}
 
int dlclose(void *handle)
{
	register ModulePtr mp = (ModulePtr)handle;
	int result;
	register ModulePtr mp1;
 
	if (--mp->refCnt > 0)
		return 0;
	if (mp->info && mp->info->fini)
		(*mp->info->fini)();
	if (mp->cdtors) {
		CdtorPtr cp = mp->cdtors;
		while (cp->init || cp->term) {
			if (cp->term && cp->init != (void (*)(void))0xffffffff)
				(*cp->term)();
			cp++;
		}
	/*
	 * If the function to handle global destructors for g++
	 * exists, call it.  --jwe
	 */
	} else if (mp->gcc_dtor) {
	        (*mp->gcc_dtor)();
	}
	result = unload(mp->entry);
	if (result == -1) {
		errvalid++;
		strcpy(errbuf, strerror(errno));
	}
	if (mp->exports) {
		register ExportPtr ep;
		register int i;
		for (ep = mp->exports, i = mp->nExports; i; i--, ep++)
			if (ep->name)
				free(ep->name);
		free(mp->exports);
	}
	if (mp == modList)
		modList = mp->next;
	else {
		for (mp1 = modList; mp1; mp1 = mp1->next)
			if (mp1->next == mp) {
				mp1->next = mp->next;
				break;
			}
	}
	free(mp->name);
	free(mp);
	return result;
}
 
static void terminate(void)
{
	while (modList)
		dlclose(modList);
}
 
/*
 * Build the export table from the XCOFF .loader section.
 */
static int readExports(ModulePtr mp)
{
	LDFILE *ldp = NULL;
	SCNHDR sh, shdata;
	LDHDR *lhp;
	char *ldbuf;
	LDSYM *ls;
	int i;
	ExportPtr ep;
 
	if ((ldp = ldopen(mp->name, ldp)) == NULL) {
		struct ld_info *lp;
		char *buf;
		int size = 4*1024;
		if (errno != ENOENT) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			return -1;
		}
		/*
		 * The module might be loaded due to the LIBPATH
		 * environment variable. Search for the loaded
		 * module using L_GETINFO.
		 */
		if ((buf = malloc(size)) == NULL) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			return -1;
		}
		while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
			free(buf);
			size += 4*1024;
			if ((buf = malloc(size)) == NULL) {
				errvalid++;
				strcpy(errbuf, "readExports: ");
				strcat(errbuf, strerror(errno));
				return -1;
			}
		}
		if (i == -1) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			free(buf);
			return -1;
		}
		/*
		 * Traverse the list of loaded modules. The entry point
		 * returned by load() does actually point to the data
		 * segment origin.
		 */
		lp = (struct ld_info *)buf;
		while (lp) {
			if (lp->ldinfo_dataorg == mp->entry) {
				ldp = ldopen(lp->ldinfo_filename, ldp);
				break;
			}
			if (lp->ldinfo_next == 0)
				lp = NULL;
			else
				lp = (struct ld_info *)((char *)lp + lp->ldinfo_next);
		}
		free(buf);
		if (!ldp) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			return -1;
		}
	}
	if (TYPE(ldp) != U802TOCMAGIC) {
		errvalid++;
		strcpy(errbuf, "readExports: bad magic");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * Get the padding for the data section. This is needed for
	 * AIX 4.1 compilers. This is used when building the final
	 * function pointer to the exported symbol.
	 */
	if (ldnshread(ldp, _DATA, &shdata) != SUCCESS) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot read data section header");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (ldnshread(ldp, _LOADER, &sh) != SUCCESS) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot read loader section header");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * We read the complete loader section in one chunk, this makes
	 * finding long symbol names residing in the string table easier.
	 */
	if ((ldbuf = (char *)malloc(sh.s_size)) == NULL) {
		errvalid++;
		strcpy(errbuf, "readExports: ");
		strcat(errbuf, strerror(errno));
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (FSEEK(ldp, sh.s_scnptr, BEGINNING) != OKFSEEK) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot seek to loader section");
		free(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (FREAD(ldbuf, sh.s_size, 1, ldp) != 1) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot read loader section");
		free(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	lhp = (LDHDR *)ldbuf;
	ls = (LDSYM *)(ldbuf+LDHDRSZ);
	/*
	 * Count the number of exports to include in our export table.
	 */
	for (i = lhp->l_nsyms; i; i--, ls++) {
		if (!LDR_EXPORT(*ls))
			continue;
		mp->nExports++;
	}
	if ((mp->exports = (ExportPtr)calloc(mp->nExports, sizeof(*mp->exports))) == NULL) {
		errvalid++;
		strcpy(errbuf, "readExports: ");
		strcat(errbuf, strerror(errno));
		free(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * Fill in the export table. All entries are relative to
	 * the entry point we got from load.
	 */
	ep = mp->exports;
	ls = (LDSYM *)(ldbuf+LDHDRSZ);
	for (i = lhp->l_nsyms; i; i--, ls++) {
		char *symname;
		char tmpsym[SYMNMLEN+1];
		if (!LDR_EXPORT(*ls))
			continue;
		if (ls->l_zeroes == 0)
			symname = ls->l_offset+lhp->l_stoff+ldbuf;
		else {
			/*
			 * The l_name member is not zero terminated, we
			 * must copy the first SYMNMLEN chars and make
			 * sure we have a zero byte at the end.
			 */
			strncpy(tmpsym, ls->l_name, SYMNMLEN);
			tmpsym[SYMNMLEN] = '\0';
			symname = tmpsym;
		}
		ep->name = strdup(symname);
		ep->addr = (void *)((unsigned long)mp->entry +
					ls->l_value - shdata.s_vaddr);
		ep++;
	}
	free(ldbuf);
	while(ldclose(ldp) == FAILURE)
		;
	return 0;
}
 
/*
 * Find the main modules entry point. This is used as export pointer
 * for loadbind() to be able to resolve references to the main part.
 */
static void * findMain(void)
{
	struct ld_info *lp;
	char *buf;
	int size = 4*1024;
	int i;
	void *ret;
 
	if ((buf = malloc(size)) == NULL) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strcat(errbuf, strerror(errno));
		return NULL;
	}
	while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
		free(buf);
		size += 4*1024;
		if ((buf = malloc(size)) == NULL) {
			errvalid++;
			strcpy(errbuf, "findMain: ");
			strcat(errbuf, strerror(errno));
			return NULL;
		}
	}
	if (i == -1) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strcat(errbuf, strerror(errno));
		free(buf);
		return NULL;
	}
	/*
	 * The first entry is the main module. The entry point
	 * returned by load() does actually point to the data
	 * segment origin.
	 */
	lp = (struct ld_info *)buf;
	ret = lp->ldinfo_dataorg;
	free(buf);
	return ret;
}
 
 
 
+DECK,CS_HLSHL,T=XCC,IF=-HPUX. ===============================================
/*CMZ :          05/11/97  15.53.29  by  Pavel Nevski*/
/*-- Author : Vladimir Berejnoi*/
+SELF,IF=ALPHA_OSF.
#define  ALPHA_OSF
+SELF.
 
#include "dlfcn.h"
#include <string.h>
 
#define MAXLENFL        60
#ifndef RTLD_NOW
#define RTLD_NOW	2	/* immediate function call binding */
#endif
#ifndef RTLD_GLOBAL
#define RTLD_GLOBAL	0x100	/* allow symbols to be global */
#endif
#define RTLD_NOW_CONST (RTLD_NOW || RTLD_GLOBAL)
 
/****************************************************************************/
 
struct procedures
{  char procname[32];
   int  (*funcptr)();
   struct procedures *next;
};
 
struct files
{  char filename[MAXLENFL];
   void              *file_handle;
   struct procedures *first_proc;
   struct files      *next;
};
 
static struct files *first_file = NULL;
static int    debug_level = 0;
 
/****************************************************************************/
struct files *searchfile(filename, f)
  char *filename;
  struct files *f;
{
  while (f != NULL)
  { if (strcmp(filename,f->filename) == 0) return(f);  else f = f->next; }
  return(f);
}
/****************************************************************************/
struct procedures *searchproc(procname, p)
  char *procname;
  struct procedures *p;
{
  while (p != NULL)
  { if (strcmp(procname,p->procname) == 0) return(p);  else p = p->next; }
  return(p);
}
/****************************************************************************/
void Delete_all(f)
struct files *f;
{
 struct procedures *p;
 
 while (f->first_proc != NULL)
 {  p = f->first_proc;  f->first_proc = p->next;  free(p);  }
}
/****************************************************************************/
int  cs_shl_load_(path, n)
   char *path;
   int n;
{
   struct files *f;
   void   *file_handle;
   char   lib_name[MAXLENFL];
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
    if (strcmp(lib_name, "./0.sl") == 0)
    {  file_handle = dlopen( NULL,    RTLD_NOW_CONST); }
    else
    {  file_handle = dlopen(lib_name, RTLD_NOW_CONST); }
    if (file_handle == NULL)
    {  printf("  %s \n",dlerror() );  return 1;        }
 
/*   Add new file to the files list */
 
   f = (struct files *) malloc(sizeof(struct files));
   strcpy(f->filename,lib_name);
   f->file_handle = file_handle;
   f->next        = first_file;
   f->first_proc  = NULL;
   first_file     = f;
   return 0;
}
/****************************************************************************/
void cs_shl_unload_(path, n)
   char *path;
   int n;
{
   struct files *f,  *before;
   char   lib_name[MAXLENFL];
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
   /*       find file    */
 
   f = searchfile(lib_name,first_file);
   if (f == NULL)
   {  if (debug_level > 0) printf("File not found.\n");  return; }
 
   if (f != first_file)
   {  before = first_file;
      while (before->next != f) before = before->next;
      before->next = f->next;
   }
   else
   {  first_file = f->next; }
   Delete_all(f);
 
   if (dlclose(f->file_handle) != 0)
   {  if (debug_level > 0) printf("Error in dlclose()...\n");  return; }
   free(f);
   if (debug_level > 0) printf("Unlink %s file.\n",lib_name);
   return;
}
/****************************************************************************/
void * cs_get_func_(sym,n)
   char *sym;
   int n;
{
   struct procedures *p;
   struct files      *f;
   void   *fill_procaddr;
   char   procname[80];
#ifdef ALPHA_OSF
         int jumpad_();
         unsigned long ptr = (unsigned long)jumpad_;
#endif
   strncpy(procname, sym, n);  procname[n] = '\0';
 
/* --   Search for all files -- */
 
   f = first_file;
   while (f != NULL)
   { p = searchproc(procname, f->first_proc);
     if (p != NULL) return (void *)(p->funcptr);
     fill_procaddr =  dlsym(f->file_handle, procname);
     if (fill_procaddr != (void *) NULL)
     {   p = (struct procedures *) malloc(sizeof(struct procedures));
         strcpy(p->procname, procname);
#ifdef ALPHA_OSF
         ptr = (unsigned long) fill_procaddr - ptr;
         p->funcptr = (int (*) ()) ptr;
#else
         p->funcptr = (int (*) ()) fill_procaddr;
#endif
         p->next = f->first_proc;
         f->first_proc = p;
         return (void *)(p->funcptr);
     }
     f = f->next;
   } /* end while */
  return 0;
}
/****************************************************************************/
void cs_shl_get_(ns, libname, n)
   char *libname;
   int  *ns;
   int   n;
{  /* find name of ns [ns=0 for first] shared library  */
   struct files *f;
   int i=0;
 
   f=first_file;
   while (f != NULL && i < *ns)  { f = f->next;  i++; }
 
   memset(libname, ' ', n);
   if (f != NULL) strncpy(libname, f->filename, strlen(f->filename));
}
/****************************************************************************/
void cs_shl_symbols_(path, ns, symbol, n, nsy)
   char *path, *symbol;
   int  *ns;
   int   n, nsy;
{  char   lib_name[MAXLENFL];
   struct files  *f;
   static struct procedures *p;
 
   if (*ns == -1)
   {  strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
      /* find shared library using its name */
      f = first_file;  *ns = -2;
      while (f != NULL)
      {  if (!strcmp(lib_name, f->filename))  { p = f->first_proc;  break; }
         else f = f->next;
      }
      if (f == NULL) return;
      if (p == NULL)
      { printf(" CS: no symbols in shared library: %s\n",lib_name); return;}
 
     *ns = 0;
   }
   else {  if (p == NULL) { *ns = -2; return; }  }
 
   memset(symbol, ' ', 32);
   strncpy(symbol, p->procname, strlen(p->procname));
   p = p->next;  (*ns)++;
}
 
 
 
+DECK,TRACEQC,T=XCC,IF=HPUX. -------------------------------------------------
/*CMZ :          20/03/98  12.55.44  by  Pavel Nevski*/
/*CMZ :  1.30/00 22/04/97  14.49.55  by  Pavel Nevski*/
/*-- Author :    FR & JZ*/
#include <stdio.h>
void traceqc_()
{  void    U_STACK_TRACE();
  /* printf (" in traceqc   \n"); */
   U_STACK_TRACE();
  /* printf (" traceqc done \n"); */
}
 
+DECK,memget,T=XCC.
/*CMZ :          08/07/97  16.16.29  by  Pavel Nevski*/
/*-- Author :    Mark Hsu 2/1/91 HPCSD, Kingston, NY.*/
/* memget.c: allow dynamic memory allocation from FORTRAN
 * Mark Hsu 2/1/91 HPCSD, Kingston, NY.
 * usage from FORTRAN:    a = memget(n)
 * where n is the number of bytes requested and the value returned
 * in a is the base address. To access the allocation, pass the
 * pointer value as an address by using the val function, e.g.,
 *
 *  iptr = memget(n)
 *  call fsub(n, val(iptr),...)
 *  . . .
 *  subroutine fsub(n,array,...)
 */
/*  char *malloc(); */
memget_(n)
int *n;
{
  /* malloc() requires unsigned arg. FORTRAN passes signed integers */
  unsigned i;
  i = (unsigned)  *n;
  /* malloc() returns a pointer;     memget() returns an integer.   */
  return ( (int) malloc(i) );
}
+DECK,dumsgi6,T=C,IF=SGI6.
/*CMZ :          01/12/97  23.48.16  by  Pavel Nevski*/
/*-- Author :    Pavel Nevski   01/12/97*/
void regcmp () { }
void regex  () { }
+PATCH,GEANT. (GXINT) =========================================================
*CMZ :  1.00/00 19/12/95  10.00.03  by  G. Poulard
+KEEP,TRCOM3.
*CMZ :  1.00/00 26/08/95  00.39.30  by  Pavel Nevski
*-- Author :
      DOUBLE PRECISION A, B, S, TN, T, COSL, SINL, COSP, SINP, COSL1
      INTEGER          NEW
      COMMON /TRCOM3/ A(5,5), B(5,5), S(15),
     +                TN(3), T(5), COSL, SINL, COSP, SINP, COSL1, NEW
*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+DECK,GSNGTR.
*CMZ :  1.30/00 05/03/96  15.55.16  by  Unknown
*CMZ :  1.00/01 02/02/96  10.45.45  by  G. Poulard
*CMZ :  3.21/02 29/03/94  15.41.30  by  S.Giani
*-- Author :
      SUBROUTINE GSNGTR(X,P,IACT,SNEXT,SNXT,SAFE,INSIDE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *    Routine to determine the shortest distance from the point   *
C.    *    X(1-3) to the boundary of the shape of type GTRA defined    *
C.    *    by the parameters P along the vector X(4-6). If INSIDE is   *
C.    *    1 then the point is inside the shape and the distance is    *
C.    *    returned as SNEXT. If INSIDE is 0 then the point is         *
C.    *    outside the shape and if the line hits the shape then       *
C.    *    if the new distance is less than the                        *
C.    *    old value of SNEXT the new distance is returned as SNEXT.   *
C.    *                                                                *
C.    *          Called by : GNEXT, GTNEXT                             *
C.    *          A.C.McPherson   22nd April 1985.                      *
C.    *                                                                *
C.    *   Shekhtman: SL,SL1,SM,SM1 declared as DOUBLE PRECISION        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCUNIT
C
+SELF, IF=-SINGLE
      DOUBLE PRECISION X0,Y0,DXDZ,DYDZ,A,B,C,DISC,X1,X2,X3,SN,CP,SMALL
      DOUBLE PRECISION SL,SL1,SM,SM1
+SELF
      LOGICAL FIRST  / .TRUE. /
      LOGICAL LPRINT / .TRUE. /
!
      PARAMETER (SMALL=1E-10)
C
      DIMENSION X(6),P(30),SN(2,5),IOUT(5),X0(4),Y0(4),DXDZ(4),DYDZ(4)
C.
C.                ---------------------------------------------
C.
C
C               Compute Safety distance
C
      IF(IACT.LT.3) CALL GSAGTR(X,P,SAFE,INSIDE)
      SNXT=BIG
      IF (IACT .EQ. 0) GO TO 999
      IF (IACT .EQ. 1) THEN
        IF (SNEXT .LT. SAFE) GO TO 999
      ENDIF
C
C               First compute the distance along the line to the
C               boundaries.
C
C               The distance to the planes defined by z=+/-P(1).
C
      IF(X(6).EQ.0.0) THEN
          SN(1,1)=BIG
          SN(2,1)=BIG
          GOTO 10
      ENDIF
      SN(1,1)=(-P(1)-X(3))/X(6)
      SN(2,1)=(P(1)-X(3))/X(6)
      IF(X(6).GT.0.0) GO TO 10
      ST=SN(2,1)
      SN(2,1)=SN(1,1)
      SN(1,1)=ST
   10 CONTINUE
C
C               The distance to the remaining four surfaces.
C
      DO 20 I=1,4
      X0(I)=P(I*4+11)
      Y0(I)=P(I*4+12)
      DXDZ(I)=P(I*4+13)
      DYDZ(I)=P(I*4+14)
   20 CONTINUE
C
      DO 65 I=1,4
      J=I+1
      IF(J.EQ.5) J=1
C
      A=(X(4)-DXDZ(I)*X(6))*(DYDZ(J)-DYDZ(I))*X(6) -
     +(X(5)-DYDZ(I)*X(6))*(DXDZ(J)-DXDZ(I))*X(6)
C
      B=(X(4)-DXDZ(I)*X(6))*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X(3)) +
     +(X(1)-X0(I)-DXDZ(I)*X(3))*(DYDZ(J)-DYDZ(I))*X(6) -
     +(X(5)-DYDZ(I)*X(6))*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X(3)) -
     +(X(2)-Y0(I)-DYDZ(I)*X(3))*(DXDZ(J)-DXDZ(I))*X(6)
C
      C=(X(1)-X0(I)-DXDZ(I)*X(3))*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X(3))
     + - (X(2)-Y0(I)-DYDZ(I)*X(3))*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X(3))
C
      IOUT(I+1)=0
      IF(C.GT.0.0) IOUT(I+1)=1
C
C             The solutions are in the normal form:
C             s = (-B+/-SQRT(B*B-4.0*A*C))*0.5/A
C
      SN(1,I+1)=BIG
      SN(2,I+1)=BIG
      IF(ABS(A).GT.1.0E-10) GO TO 30
C
C             A = 0 only one solution.
C
      IF(ABS(B).LT.1.0E-10) GO TO 60
C
      SN(1,I+1)=-C/B
      GO TO 60
C
   30 CONTINUE
      IF(ABS(C).GT.1.0E-10) GO TO 40
      SN(1,I+1)=0.0
      SN(2,I+1)=0.0
      IF(ABS(B).LT.1.0E-10) GO TO 60
      SN(1,I+1)=-C/B
      IF(C.EQ.0.0) SN(1,I+1)=SIGN(SMALL,B)
      SN(2,I+1)=-B/A
      GO TO 50
C
   40 CONTINUE
      DISC=B*B-A*C*4.0
      IF(DISC.LT.0.0) GO TO 60
      IF(DISC.GT.0.0) DISC=SQRT(DISC)
      SN(1,I+1)=(-B-DISC)*0.5/A
      SN(2,I+1)=(-B+DISC)*0.5/A
C
   50 CONTINUE
      IF(SN(2,I+1).GT.SN(1,I+1)) GO TO 60
      ST=SN(2,I+1)
      SN(2,I+1)=SN(1,I+1)
      SN(1,I+1)=ST
C
   60 CONTINUE
C
      DO 65 K=1,2
      IF(ABS(SN(K,I+1)).GT.1.0E+05.OR.ABS(SN(K,I+1)).LT.1.0E-05)
     +GO TO 65
C
      X1=X(1)+SN(K,I+1)*X(4)
      X2=X(2)+SN(K,I+1)*X(5)
      X3=X(3)+SN(K,I+1)*X(6)
      CP=(X1-X0(I)-DXDZ(I)*X3)*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X3)
     + - (X2-Y0(I)-DYDZ(I)*X3)*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X3)
      CP=CP/SQRT((X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X3)**2+
     +   (Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X3)**2)
C
      IF(ABS(CP).LT.0.0001) GO TO 65
      IF(ABS(CP/SN(K,I+1)).LT.1.0E-06) GO TO 65
      IF ( FIRST.AND.LPRINT ) THEN
           IF (First) Print *,' * GSNGTR: corrected version *'
           FIRST = .FALSE.
           WRITE(CHMAIL,1020) I,K,SN(K,I+1)
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1021) X
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1022) X1,X2,X3,CP
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1023) A,B,C,DISC
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1024) INSIDE
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1025) X0
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1026) Y0
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1027) DXDZ
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1028) DYDZ
           CALL GMAIL(0,0)
      ENDIF
 1020 FORMAT('0 GSNGTR ERROR - I,K =',2I2,' SN =',E13.5)
 1021 FORMAT(' X =',6F15.6)
 1022 FORMAT(' X1,X2,X3 =',3F15.6,' CP =',E15.6)
 1023 FORMAT(' A =',E15.6,' B =',E15.6,' C =',E15.6,' DISC =',E15.6)
 1024 FORMAT(' INSIDE =',I3)
 1025 FORMAT('   X0 =',4E15.6)
 1026 FORMAT('   Y0 =',4E15.6)
 1027 FORMAT(' DXDZ =',4E15.6)
 1028 FORMAT(' DYDZ =',4E15.6)
C
   65 CONTINUE
C
C
C             Have computed the two distances for the z planes and
C             the four surfaces. Combine them accordingly as to
C             whether the point is inside or outside the shape.
C
      IF(INSIDE.EQ.0) GO TO 80
C
C             Point is inside shape.
C
      DO 70 I=1,5
      DO 70 J=1,2
      IF(SN(J,I).GT.0.0.AND.SN(J,I).LT.SNXT) SNXT=SN(J,I)
   70 CONTINUE
      GO TO 999
C
   80 CONTINUE
C
C             Point is outside shape.
C
      IOUT(1)=0
      IF(ABS(X(3)).GT.P(1)) IOUT(1)=1
C
C             For each of five sets of SN and IOUT, IOUT(I) equal to 1
C             indicates that the point is outside the shape by the Ith
C             test, SN(1,I) is the distance to the first change in the
C             test and SN(2,I) is the distance to the second change.
C             The remaining logic just attempts to find a distance when
C             the line is inside by all five tests, bearing in mind that
C             for some tests the line can start inside, leave and return
C             inside.
C
      SL=-1.0
      SM=BIG
      SM1=BIG
      DO 100 I=1,5
      IF(IOUT(I).EQ.0) GO TO 90
      IF(SN(2,I).LT.0.0) GO TO 999
      IF(SN(1,I).LT.0.0.AND.SN(2,I).GT.SL) SL=SN(2,I)
      IF(SN(1,I).GT.SL) SL=SN(1,I)
      IF(SN(1,I).GE.0.0.AND.SN(2,I).LT.SM) SM=SN(2,I)
      GO TO 100
   90 CONTINUE
      IF(SN(1,I).LT.0.0.AND.SN(2,I).GE.0.0.AND.SN(2,I).LT.SM) SM=SN(2,I)
      IF(SN(1,I).LT.0.0.OR.SN(1,I).GT.SM1) GO TO 100
      IF(SN(1,I).GE.SN(2,I)) GO TO 100
      SM1=SN(1,I)
      SL1=SN(2,I)
  100 CONTINUE
C
C             SL is the largest of the five distances to the first
C             time the line is inside. SM is the smallest to the
C             last time the point is inside. SM1 is the smallest
C             distance to when the line is temporarily outside
C             one of the tests.
C
      IF(SM.LE.SL) GO TO 999
      IF(SM1.GT.SL) GO TO 130
C
  110 CONTINUE
C
C             In this loop SL is updated by the return after SM1
C             if SM1 is less than SL.
C
      SL=SL1
      IF(SM.LE.SL) GO TO 999
      SM1=SM
C
      DO 120 I=1,5
      IF(IOUT(I).EQ.1) GO TO 120
      IF(SN(2,I).LE.SL.OR.SN(1,I).GT.SM1) GO TO 120
      IF(SN(1,I).GE.SN(2,I)) GO TO 120
      SM1=SN(1,I)
      SL1=SN(2,I)
  120 CONTINUE
C
      IF(SM1.GT.SL) GO TO 130
C
      GO TO 110
  130 CONTINUE
C
      IF(SL.LT.SNXT) SNXT=SL
C
  999 CONTINUE
      END
+DECK,GFLRAD
*CMZ :  1.00/00 25/05/95  03.58.23  by  A. James Cook
*-- Author :
      SUBROUTINE GFLRAD(IAXIS,ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO COMPUTE THE LIMITS IN R FOR THE SHAPE ISH        *
C.    *    DISPLACED BY THE VECTOR DX AND ROTATED BY THE MATRIX IROT.  *
C.    *    IF IAXIS = 4 THE R IS THE XY PLANE R, IF IAXIS = 5 IT IS    *
C.    *    THE 3 DINEMSIONAL SPACE R. THE SHAPE HAS NPAR PARAMETERS    *
C.    *    IN THE ARRAY PARS. THE LOWER LIMIT IS RETURNED IN CL AND    *
C.    *    THE HIGHER IN CH. IF THE CALCULATION CANNOT BE PERFORMED    *
C.    *    IERR IS SET TO 1 OTHERWISE IT IS SET TO 0.                  *
C.    *                                                                *
C.    *    ==>Called by : GFCLIM                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCONSP
+SEQ,GCSHNO
      DIMENSION DX(3),PARS(11),X(3),XT(3)
C.
C.           --------------------------------------------------
C.
      IERR=1
C
C            FIRST CALCULATE THE LENGTH OF THE DISPLACEMENT OF THE
C            ORIGIN.
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(IAXIS.EQ.5) DXS=DXS+DX(3)*DX(3)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C          CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
      CH=0.0
      CL=DXS
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          NOW COMPUTE RMIN = PROJECTED R ON DX AND RMAX = R
C          AND UPDATE LIMITS IF NECESSARY.
C
      R2=(XT(1)+DX(1))**2+(XT(2)+DX(2))**2
      IF(IAXIS.EQ.5) R2=R2+(XT(3)+DX(3))**2
      R=SQRT(R2)
      IF(R.GT.CH) CH=R
C
      IF(CL.LE.0.0) GO TO 30
C
      XPT=DX(1)*XT(1)+DX(2)*XT(2)
      IF(IAXIS.EQ.5) XPT=XPT+DX(3)*XT(3)
      IF(DXS.LE.1.0E-05) GO TO 30
      RMN=DXS+XPT/DXS
      IF(RMN.LT.CL) CL=RMN
C
   30 CONTINUE
C
      IF(CL.LE.0.0) CL=0.0
C
      IERR=0
      GO TO 999
C
   40 CONTINUE
      IF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14)GO TO 80
C
C             TUBES AND CONES.
C
      IP3=3
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14) IP3=1
      DZ=PARS(IP3)
      R=PARS(2)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+R*S1
      ENDIF
**
      IF(ISH.EQ.13) THEN
**
**       APPROXIME TO A CYLINDER WHIT RADIUS
**       EQUAL TO THE ELLIPSE MAJOR AXIS
**
         RMN=0.0
         IF(PARS(1).GT.R) R=PARS(1)
         GOTO 50
      ENDIF
      RMN=PARS(1)
*
      IF(ISH.EQ.14) THEN
        R = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 50
      ENDIF
C
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 50
C
      R=PARS(3)
      IF(PARS(5).GT.R) R=PARS(5)
      RMN=PARS(2)
      IF(PARS(4).LT.RMN) RMN=PARS(4)
C
   50 CONTINUE
C
C          ROTATE THE LOCAL Z AXIS.
C
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          COMPUTE RMIN AND RMAX ASSUMING COMPLETE TUBE HALF
C          LENGTH DZ AND RADIUS R.
C
      CH=DXS+R
      CL=DXS-R
      DO 60 IS=-1,1,2
         R2=(DX(1)+IS*DZ*XT(1))**2+(DX(2)+IS*DZ*XT(2))**2
         IF(IAXIS.EQ.5) R2=R2+(DX(3)+IS*DZ*XT(3))**2
         R1=SQRT(R2)
         CH=MAX(CH,R1+R)
         CL=MIN(CL,R1-R)
   60 CONTINUE
      IF(CL.LT.0.0) CL=0.0
      IF(IROT.EQ.0.AND.DXS.LT.1.0E-05) CL=RMN
      IERR=0
C
      GO TO 999
C
   80 CONTINUE
      IF(ISH.GT.9) GO TO 999
C
C           SPHERE.
C
      CL=DXS-PARS(2)
      IF(CL.LT.0.0) CL=0.0
      CH=DXS+PARS(2)
      IF(IAXIS.EQ.5.AND.DXS.LT.1.0E-05) CL=PARS(1)
      IERR=0
C
  999 CONTINUE
      END
+DECK,GGORDQ.
*CMZU:  1.00/01 25/01/96  14.17.49  by  A. DellAcqua
*CMZ :  3.21/02 29/03/94  15.41.28  by  S.Giani
*-- Author :
      SUBROUTINE GGORDQ (IVO)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    Find and order the boundaries of the contents of the       *
C.    *    IVOth volume, with respect to coordinate IAX :             *
C.    *           IAX = 1    X Axis                                   *
C.    *           IAX = 2    Y Axis                                   *
C.    *           IAX = 3    Z Axis                                   *
C.    *           IAX = 4    Rxy                                      *
C.    *           IAX = 5    Rxyz                                     *
C.    *           IAX = 6    PHI   (PHI=0 => X axis)                  *
C.    *           IAX = 7    THETA (THETA=0 => Z axis)                *
C.    *    All values of IAX will be tried and then that value is     *
C.    *    chosen, that results in the smallest number of volumes per *
C.    *    division.                                                  *
C.    *    Called by : GGCLOS                                         *
C.    *    Author: Stephan Egli (large parts are copies of GGORD)     *
C.    *                                                               *
C.    *****************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
*
 
      DIMENSION CLOW(500),CHIGH(500),CORD(1000),ITYPE(1000),
     +ICONT(500),ICON(1000),ICONS(500)
      EQUIVALENCE (CLOW(1),WS(1)),(CHIGH(1),WS(501))
      EQUIVALENCE (CORD(1),WS(1001)),(ITYPE(1),WS(2001))
      EQUIVALENCE (ICONT(1),WS(3001)),(ICON(1),WS(3501))
      EQUIVALENCE (ICONS(1),WS(4501))
C
      CHARACTER*4 NAME
 
C.    ------------------------------------------------------------------
*
      JVO = LQ(JVOLUM-IVO)
      CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
      NIN = Q(JVO+3)
      IAXNOW = 0
      IF(IQ(JVO-2).EQ.NIN+2) THEN
*
* *** This is to allow re-entry in the routine from the interactive
* *** version.
         JNEAR = LQ(JVO-NIN-1)
         IF(JNEAR.GT.0) THEN
            JSB = LQ(JNEAR)
            IF(JSB.GT.0) THEN
               IAXNOW = Q(JSB+1)
            ENDIF
         ENDIF
      ENDIF
      IF(IAXNOW.EQ.0) THEN
         IAXNOW=-Q(JVO+1)
      ENDIF
*   assume that ordering can not be done unless proven otherwise
      Q(JVO+1)=0.
      RBEST=1.E9
 
* try all possible axes
 
      DO 1 IAX=1,7
 
*   count number of additional words needed and total number of volumes
*   in all divisions
 
      NCOALL=0
*
* *** Find the upper and lower coordinates of each content
*
      DO 50 IN = 1,NIN
         CALL GFCLIM (JVO, IN, IAX, CLOW(IN), CHIGH(IN), IERR)
         IF (IERR.NE.0) GOTO 1
   50 CONTINUE
*
* *** Order the coordinate limits, keeping track of the associated
*           content number
*
      CALL GFCORD (NIN, CLOW, CHIGH, CORD, ITYPE, ICON)
      NC = NIN*2
*
*  **   Count and load up the distinct boundaries
*
      IBO = 0
      DO 60 IC = 1,NC
         IBO = IBO +1
         IF (IBO.EQ.1) GO TO 60
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) IBO = IBO -1
   60 CONTINUE
      NDIV  = IBO -1
      IF (IAX.EQ.6) NDIV = IBO
 
*   *   Load up number of contents in each section
*
      IDIV    = 0
      NCONT   = 1
      ICONT(1)= ICON(1)
      IF (IAX.NE.6) GO TO 70
      NCONT   = 0
      NSTOR   = 0
      ICONT(1)= 0
      DO 65 IN = 1,NIN
         IF (CHIGH(IN).GT.CLOW(IN)) GO TO 65
*           (this content straddles PHI=0.)
         NSTOR = NSTOR +1
         ICONS(NSTOR) = IN
         IF (ICON(1).EQ.IN) GO TO 65
*           (IN is in 1st division as well)
         NCONT = NCONT +1
         ICONT(NCONT) = IN
   65 CONTINUE
*
      IF (ITYPE(1).EQ.2) GO TO 70
*            (first boundary is a low, add the new content)
      NCONT = NCONT +1
      ICONT(NCONT) = ICON(1)
*
   70 CONTINUE
*
      DO 130 IC = 2,NC
         IDIV = IDIV +1
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) GO TO 90
*
*          New division, load up last division
*
         IF (NCONT.LE.0) GO TO 100
         NCOALL=NCOALL+NCONT
         GO TO 100
   90    CONTINUE
         IDIV = IDIV -1
*
  100    CONTINUE
*
*         Update contents of current division
*
         IF (ITYPE(IC).EQ.1) GO TO 120
*
*         This boundary was a high, so one less content
*
         ICP = 0
         DO 110 ICNT = 1,NCONT
            IF (ICONT(ICNT).EQ.ICON(IC)) ICP=1
         IF (ICP.EQ.1) ICONT(ICNT) = ICONT(ICNT+1)
  110    CONTINUE
         NCONT = NCONT -1
         GO TO 130
*
  120    CONTINUE
*
*          This boundary was a low, so one extra content
*
         NCONT = NCONT +1
         ICONT(NCONT) = ICON(IC)
*
  130 CONTINUE
*
      IF(IAX.EQ.6) NCOALL = NCOALL+NSTOR
      RNOW=FLOAT(NCOALL)/NDIV
      IF(RNOW.LT.RBEST)THEN
        IAXOPT=IAX
        RBEST=RNOW
        NDIVB=NDIV
      ENDIF
 
* end of loop over IAX
 
1     CONTINUE
 
 
* now the best axis is selected - compare with axis requested by CALL
* to GSORD (if any)
 
      IF(IAXNOW.GT.0)THEN
 
*        WRITE (CHMAIL,1002) NAME,NIN,IAXOPT,NDIVB,RBEST,IAXNOW
*        CALL  GMAIL (0, 0)
 1002   FORMAT(' GGORDQ : Volume ',A4,2X,'NIN=',I4,' IAX=',I2,2X,
     +    'NDIV=',I3,2X,'NVOL/DIV=',F5.1,2X,'IAX wanted by user:',I2)
 
      ELSE
 
*        WRITE (CHMAIL,1003) NAME,NIN,IAXOPT,NDIVB,RBEST
*        CALL  GMAIL (0, 0)
 1003   FORMAT(' GGORDQ : Volume ',A4,2X,'NIN=',I4,' IAX=',I2,2X,
     +    'NDIV=',I3,2X,'NVOL/DIV=',F5.1)
 
      ENDIF
 
* overwrite old axis and store sorting information for new axis
 
      Q(JVO+1)=-IAXOPT
      CALL GGORD(IVO)
 
      END
+DECK,GSCHIT
*CMZ :  1.30/00 02/06/96  16.40.08  by  Pavel Nevski
*CMZ :  1.00/00 16/08/95  01.09.49  by  Pavel Nevski
*-- Author :
      SUBROUTINE GSCHIT(ISET,IDET,ITRA,NUMBV,HITS,NHSUM,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store HITS values into detector IUDET of set IUSET       *
C.    *                                                                *
C.    *       NUMBV  volume numbers                                    *
C.    *       HITS  array of values for the elements of current hit    *
C.    *       ITRA  track number associated to this hit                *
C.    *       IHIT  output parameter containing the hit number         *
C.    *             If IHIT=0  hit has not been stored                 *
C.    *                                                                *
C.    *       Same action as GSAHIT but in case the physical volume    *
C.    *       specified by NUMBV contains already some hit for the     *
C.    *       same track, then the routine will sum up the last NHSUM  *
C.    *       elements of the hit.                                     *
C.    *        In order to use that routine , no packing must be       *
C.    *        specified for these NHSUM last hits.                    *
C.    *        If NHSUM.LE.0 then GSCHIT is the same as GSAHIT.        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+seq,GCVOLU
+SEQ,GCUNIT
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(*),HITS(*)
      PARAMETER (MAXINT=2147483647)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      CALL GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
      IF (IHIT.LE.1)  GO TO 999
      IF (NHSUM.LE.0) GO TO 999
C
      NV=IQ(JD+1)
      NH=IQ(JD+3)
      NW=NV+NH+1
      JNEWH = JHD+(IHIT-1)*NW
      JCURR = JNEWH
C
      DO 30 I=1,IHIT-1
         JCURR = JCURR-NW
C
C             Check if track number is ITRA
C
         IF (ITRA.NE.IQ(JCURR+1)) GO TO 999
C
C             Check if volume numbers are the same
C
         DO 10 J=2,NV+1
            IF (IQ(JCURR+J).NE.IQ(JNEWH+J)) GO TO 30
   10    CONTINUE
C
C             Volumes are the same. Now sum the last NHSUM hits
C
         DO 20 K=NW,NW-NHSUM+1,-1
            IF (IQ(JCURR+K).GT.MAXINT-IQ(JNEWH+K)) THEN
               NMESS=NMESS+1
               IF (NMESS.LT.3) THEN
                  WRITE (CHMAIL,10000) IQ(JSET+ISET),IQ(JS+IDET)
10000             FORMAT(' ***** GSCHIT OVERFLOW WARNING FOR SET= ',
     +                                               A4,' DET= ',A4)
                  CALL GMAIL(0,0)
               ENDIF
               GO TO 999
            ELSE
               IQ(JCURR+K)=IQ(JCURR+K)+IQ(JNEWH+K)
            ENDIF
   20    CONTINUE
C
C             Remove temporarily stored hit
C
*****    IHIT=IHIT-1
         IHIT=IHIT-I
         IQ(JH+IDET)=IQ(JH+IDET)-NW
         GO TO 999
   30 CONTINUE
C
  999 CONTINUE
      END
 
 
 
 
+DECK,GUSCNTR.
*CMZ :  1.30/00 12/05/97  15.31.50  by  Pavel Nevski
*CMZU:  1.00/00 17/03/94  10.22.21  by  Andrea DellAcqua
*-- Author :    *MRT : by Pavel Nevski
*----------------------------------------------------------------------*
      SUBROUTINE GUSCNTR(PRECOR)
*                                                                      *
* Description :  routine to control a looping near a boundary          *
* Arguments   :  PRECOR  (modified) GEANT tracking precision           *
*                                                                      *
* Author      :  Pavel Nevski                       Date : 25/05/93    *
* Modification:  Never done                                            *
*----------------------------------------------------------------------*
+CDE,TYPING.
+CDE,GCTMED.  - GEANT common GCTMED (version 3.15)
+CDE,GCTRAK.  - GEANT common GCTRACK (version 3.15)
+CDE,GCVOLU.  - Multi-level current volume description
+CDE,GCUNIT.  - Geant logical units
*
      INTEGER ICNT,IPRI,MSTEP,LU
      REAL SAFEOLD,ONLY,PRECOR
      DATA ICNT,MSTEP /0,0/
      IPRI=0
      SAFEOLD = SAFETY+STEP
      ONLY=GONLY(NLEVEL)
C   Check IGNEXT==1 & SAFETY<0 & STEP<10*PREC & ONLY>0
      IF (IGNEXT.EQ.1 .AND. SAFETY.LT.0 .AND. STEP.LT.10*PREC
     *    .AND.  ONLY.GT.0 .AND. INWVOL.EQ.0) THEN
         ICNT=ICNT+1
      ELSE
         ICNT=0
      END IF
C   Check ICNT==10
      IF (ICNT.EQ.10) THEN
         IFIELD =0
      END IF
C   Check 11<=ICNT<=18
      IF (11.LE.ICNT.AND.ICNT.LE.18) THEN
         PRECOR=PRECOR*2
      END IF
C   Check 20<=ICNT<=20
      IF (20.LE.ICNT.AND.ICNT.LE.20) THEN
         IPRI =1
      END IF
C   Check NSTEP>=MSTEP+1000
      IF (NSTEP.GE.MSTEP+1000) THEN
         MSTEP = NSTEP
         IPRI=0
      END IF
C   Check NSTEP==MAXNST
      IF (NSTEP.EQ.MAXNST) THEN
         IPRI=3
      END IF
C   If Amax1(Abs(Vect(1)),Abs(Vect(2)))>Rmx \ Abs(Vect(3))>Zmx [Istop=1;]
C   Check IPRI>0
      IF (IPRI.LE.0)GO TO 1
      CALL GPCXYZ
      LU=LOUT
      WRITE(LU,10) NSTEP,ICNT,IGNEXT,PREC,SAFETY,SNEXT,PRECOR
10    FORMAT(5x,'Nstep,icnt,IGnext,Prec,Safety,Snext,Precor=',
     >       2I5,I3,4F10.4)
1     CONTINUE
      END         ! GUSCNTR
+DECK,Gtrack.
*CMZ :          27/03/98  16.51.21  by  Pavel Nevski
*CMZ :  1.30/00 17/04/97  14.00.58  by  Pavel Nevski
*CMZU:  1.00/00 11/07/94  15.46.40  by  Pavel Nevski
*-- Author :
      SUBROUTINE GTRACK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Controls tracking of current particle,                   *
C.    *        up to end of track for sequential tracking mode, or     *
C.    *        through current volume for parallel tracking mode.      *
C.    *                                                                *
C.    *    ==>Called by : GUTRAK                                       *
C.    *       Authors   : R.Brun, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCPHYS.
+CDE, GCPARM.
+CDE, GCSETS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCNUM.
+SEQ,GCJUMP, IF=USRJMP
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      DIMENSION CUTS(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      SAVE PRECOR
+SELF,IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF,IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
C.
C.    ------------------------------------------------------------------
      ISTOP = 0
      EPSCUR = EPSMAC
      NSTOUT = 0
      INWOLD = 0
      LSAMVL = .FALSE.
*
* *** Check validity of tracking medium and material parameters
*
   10 IF (NUMED.NE.NUMOLD) THEN
         NUMOLD = NUMED
         IUPD   = 0
         JTM    = LQ(JTMED- NUMED)
         DO 20 I = 1,5
            NATMED(I) = IQ(JTM+I)
   20    CONTINUE
         NMAT     = Q(JTM + 6)
         ISVOL    = Q(JTM + 7)
         IFIELD   = Q(JTM + 8)
         FIELDM   = Q(JTM + 9)
         TMAXFD   = Q(JTM + 10)
         STEMAX   = Q(JTM + 11)
         DEEMAX   = Q(JTM + 12)
         EPSIL    = Q(JTM + 13)
         STMIN    = Q(JTM + 14)
         PRECOR   = MIN(0.1*EPSIL, 0.0010)
         IF (LQ(JTM).EQ.0) THEN
            IF (ISTPAR.NE.0) THEN
               DO 30 I = 1,10
                  CUTS(I) = Q(JTMED+I)
   30          CONTINUE
               DO 40 I = 1,13
                  MECA(1,I) = Q(JTMED+10+I)
   40          CONTINUE
               ILABS = Q(JTMED+10+21)
               ISYNC = Q(JTMED+10+22)
               ISTRA = Q(JTMED+10+23)
               ISTPAR = 0
            ENDIF
         ELSE
            JTMN = LQ(JTM)
            DO 50 I = 1,10
               CUTS(I) = Q(JTMN+I)
   50       CONTINUE
            DO 60 I = 1,13
               MECA(1,I) = Q(JTMN+10+I)
   60       CONTINUE
            ILABS = Q(JTMN+10+21)
            ISYNC = Q(JTMN+10+22)
            ISTRA = Q(JTMN+10+23)
            ISTPAR = 1
         ENDIF
*
         JMA   = LQ(JMATE-NMAT)
         JPROB = LQ(JMA-4)
         JMIXT = LQ(JMA-5)
         DO 70 I = 1,5
            NAMATE(I) = IQ(JMA+I)
   70    CONTINUE
         A    = Q(JMA +6)
         Z    = Q(JMA +7)
         DENS = Q(JMA +8)
         RADL = Q(JMA +9)
         ABSL = Q(JMA +10)
         IF(IQ(JTM-2).GE.3.AND.LQ(JTM-3).NE.0.AND.ITCKOV.NE.0.AND.
     +      LQ(LQ(JTM-3)-3).NE.0.AND.Z.GE.1.) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag.
*
            IMCKOV = 1
         ELSE
            IMCKOV = 0
         ENDIF
*
*
*  **   Update precomputed quantities
*
         IMULL = IMULS
         IF (ILOSS.LE.0) THEN
            DEEMAX = 0.
            ILOSL = 0
         ELSEIF (DEEMAX.GT.0.) THEN
            ILOSL = ILOSS
         ELSE
            ILOSL = 0
         ENDIF
      ENDIF
*
      IF(LSAMVL) THEN
*
*       If now the particle is entering in the same volume where
*       it was exiting from last step, and if it has done this for
*       more than 5 times, we decrease the precision of tracking
         NSTOUT=NSTOUT+1
         IF(MOD(NSTOUT,5).EQ.0) THEN
            EPSCUR=NSTOUT*EPSMAC
*            WRITE(CHMAIL,10000)ITRA,ISTAK,NTMULT,NAPART
*10000          FORMAT(' *** GTRAcCK *** Boundary loop: track ',
*     +         I6,' stack ',I6,' NTMULT ',I8,1X,5A4)
*            CALL GMAIL(1,0)
*            WRITE (CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
*            CALL GMAIL(0,0)
*            WRITE(CHMAIL,10100) EPSCUR
*10100          FORMAT('                Precision now set to ',G10.3)
*            CALL GMAIL(0,1)
         ENDIF
      ELSE
         NSTOUT = 0
         EPSCUR = EPSMAC
      ENDIF
*
      INWVOL = 1
*
* *** Compute SET and DET number if volume is sensitive
*
*      IF (JSET.GT.0) THEN
*         IF(ISVOL.GT.0) THEN
*            CALL GFINDS
*         ELSE
*            IHSET = 0
*            IHDET = 0
*            ISET = 0
*            IDET = 0
*            IDTYPE = 0
*            NVNAME = 0
*         ENDIF
*      ENDIF
*
*    Clear step dependent variables
*
   80 NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NGPHOT = 0.
      IGNEXT = 0
      INWOLD = INWVOL
      PREC   = MAX(PRECOR,MAX(ABS(VECT(1)),ABS(VECT(2)),
     +                        ABS(VECT(3)),SLENG)*EPSCUR)
*
*     Give control to user at entrance of volume (INWVOL=1)
*
      IF (INWVOL.EQ.1) THEN
+SELF, IF=-USRJMP
         CALL GUSTEP
+SELF, IF=USRJMP
         CALL JUMPT0(JUSTEP)
+SELF
         IF (ISTOP.NE.0) GO TO 999
         INWVOL = 0
      ENDIF
*
* *** Propagate particle up to next volume boundary or end of track
*
      INGOTO = 0
      NLEVIN = NLEVEL
      IF (IPARAM.NE.0) THEN
         IF (GEKIN.LE.PACUTS(ITRTYP)) THEN
            NMEC = NMEC+1
            LMEC(NMEC) = 26
            ISTOP = 2
+SELF, IF=-USRJMP
            CALL GUPARA
+SELF, IF=USRJMP
            CALL JUMPT0(JUPARA)
+SELF
            GO TO 90
         ENDIF
      ENDIF
      IF      (ITRTYP.EQ.1) THEN
         CALL GTGAMA
      ELSE IF (ITRTYP.EQ.2) THEN
         CALL GTELEC
      ELSE IF (ITRTYP.EQ.3) THEN
         CALL GTNEUT
      ELSE IF (ITRTYP.EQ.4) THEN
         CALL GTHADR
      ELSE IF (ITRTYP.EQ.5) THEN
         CALL GTMUON
      ELSE IF (ITRTYP.EQ.6) THEN
         CALL GTNINO
      ELSE IF (ITRTYP.EQ.7) THEN
         CALL GTCKOV
      ELSE IF (ITRTYP.EQ.8) THEN
         CALL GTHION
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(10+ITRTYP)
      STLOSS=STEP
*
*     Check for possible endless loop
*
   90 NSTEP = NSTEP +1
      IF (NSTEP.GT.MAXNST) THEN
         IF (ISTOP.EQ.0) THEN
            ISTOP = 99
            IF (IDEBUG.GT.0) THEN
            NMEC  = NMEC +1
            LMEC(NMEC) = 30
            WRITE(CHMAIL,10200) MAXNST
            CALL GMAIL(1,0)
            WRITE(CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10300)ITRA,ISTAK,NTMULT,(NAPART(I),I=1,5),
     +      TOFG*1.E9
            CALL GMAIL(0,1)
10200       FORMAT(' *** GTRACK *** More than ',I6,
     +             ' steps, tracking abandoned!')
10250       FORMAT('                IEVENT=',I7,' IDEVT=',I7,
     +             ' Random Seeds = ',I10,2X,I10)
10300       FORMAT('                Track',I6,' stack',I6,' NTMULT',
     +             I8,1X,5A4,'Time of flight ',F10.3,' ns')
            ENDIF
         ENDIF
      ENDIF
*
* *** Give control to user at end of each tracking step
*
      SAFETY = SAFETY -STEP
+SELF, IF=-USRJMP
      CALL GUSTEP
+SELF, IF=USRJMP
      CALL JUMPT0(JUSTEP)
+SELF
C - pln - 11/7/94  - add user control over loopers
      CALL GUSCNTR(PRECOR)
*
      IF (ISTOP.NE.0) GO TO 999
*
*      Renormalize direction cosines
*
      PMOM = SQRT(VECT(4)**2+VECT(5)**2+VECT(6)**2)
      IF(PMOM.GT.0.) THEN
         CMOD = 1./PMOM
         VECT(4) = VECT(4)*CMOD
         VECT(5) = VECT(5)*CMOD
         VECT(6) = VECT(6)*CMOD
      ENDIF
*
      IF (INWVOL.EQ.0) then
         if   (GONLY(NLEVEL).gt.0
     +    .or. Safety.gt.0
     +    .or. Iswit(10).lt.0) then
                                     GO TO 80
         else
            CALL GTMEDI(VECT,NUMED)
            if (NUMED.EQ.NUMOLD)     GO TO 80
         endif
         WRITE(CHMAIL,10003) NAMES(NLEVEL)
10003    FORMAT(' *** GTRACK *** Logic problem in ',A4)
         if (IDEBUG.GT.0) CALL GMAIL(1,0)
      endif
*
      IF (NJTMAX.GT.0) THEN
         CALL GSTRAC
         IF (NLEVIN.EQ.0) GO TO 100
         GO TO 999
      ELSE
         IF (NLEVIN.GE.NLEVEL) THEN
            INFROM = 0
         ELSE
            IF (NLEVIN.EQ.0) GO TO 100
            INFROM = LINDEX(NLEVIN+1)
         ENDIF
         IF (NLEVIN.NE.NLEVEL) INGOTO = 0
         NLEVEL = NLEVIN
*
         CALL GTMEDI (VECT, NUMED)
         IF (NUMED.NE.0) THEN
            SAFETY = 0.
            GO TO 10
         ENDIF
      ENDIF
*
*     Track outside setup, give control to user (INWVOL=3)
*
  100 INWVOL = 3
      ISTOP  = 1
      ISET   = 0
      IDET   = 0
      NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NLCUR  = NLEVEL
      NLEVEL = 1
+SELF, IF=-USRJMP
      CALL GUSTEP
+SELF, IF=USRJMP
      CALL JUMPT0(JUSTEP)
+SELF
      NLEVEL = NLCUR
*                                                             END GTRACK
  999 END
+DECK,GXDZ.
*CMZ :  1.30/00 25/05/96  05.56.55  by  Pavel Nevski
*CMZ :  1.00/00 20/11/95  03.51.01  by  Pavel Nevski
*-- Author :
      SUBROUTINE GXDZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      DZEBRA control commands                                   *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                                                                *
C.    * Modifications:                                                 *
C.    *  PN, 20.11.95: change unit 10 to 61 due to SGI problems        *
C.    *  PN, 25.05.96: reaccess link in DISP command after RZ access   *
C.    *  PN, 25.05.96: default documentation file detm.rz introduced   *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCXLUN
      COMMON/GCLTMP/LTEMPA(3)
      COMMON/QUEST/IQUEST(100)
      CHARACTER*20  CHOPT
      CHARACTER*4   BNAME
      CHARACTER*32  CHPATL
      CHARACTER*255 DOCFIL
      CHARACTER*10  CHTOP
      CHARACTER*12  CHTDIR
      CHARACTER*12  CDEF/'detm.rz'/
      LOGICAL       EXST
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
      INQUIRE  (FILE='detm.rz',EXIST=EXST)
*
      IF(CHPATL.EQ.'SHOW')THEN
         CALL KUGETC(BNAME,NCH)
         CALL KUGETI(NUMBER)
         CALL KUGETC(CHOPT,NCH)
         LOC=LZLOC(IXSTOR,BNAME,NUMBER)
         IF(LOC.NE.0)THEN
            CALL DZSHOW('DZSHOW',IXSTOR,LOC,CHOPT,0,0,0,0)
         ENDIF
*
      ELSEIF(CHPATL.EQ.'SURV')THEN
         CALL KUGETC(BNAME,NCH)
         CALL KUGETI(NUMBER)
         LOC=LZLOC(IXSTOR,BNAME,NUMBER)
         IF(LOC.NE.0)THEN
            CALL DZSURV('DZSURV',IXSTOR,LOC)
         ENDIF
*
      ELSEIF(CHPATL.EQ.'SNAP')THEN
         CALL KUGETI(IDIV)
         CALL KUGETC(CHOPT,NCH)
         CALL DZSNAP('DZSNAP',IDIV,CHOPT)
*
      ELSEIF(CHPATL.EQ.'VERIFY')THEN
         CALL KUGETI(IDIV)
         CALL KUGETC(CHOPT,NCH)
         CALL DZVERI('DZVERI',IDIV,CHOPT)
*
      ELSEIF(CHPATL.EQ.'STORE')THEN
         CALL KUGETI(IXSTOR)
         CALL DZSTOR('DZSTOR',IXSTOR)
*
      ELSEIF (CHPATL.EQ.'DDIV') THEN
+SELF, IF=DZDOC
         CALL KUGETI(IDIV)
         DOCFIL=' '
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC
         If (NCH.le.1 .and. EXST) Then
            DOCFIL=CDEF
            NCH=LENOCC(CDEF)
         EndIf
         CHOPT='IN'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         CHTOP =' '
         CHTDIR=' '
         IF(DOCFIL.NE.' ') THEN
            CALL GXLUNF(61, 3, IFREE)
            IF(IFREE.NE.0) THEN
               LRECL = 256
               CALL RZOPEN(IFREE,CHTOP,DOCFIL(1:NCH),'W',LRECL,ISTAT)
               IF(ISTAT.NE.0) GOTO 999
               CALL RZFILE(IFREE,CHTOP,' ')
               LUNIT(IFREE) = 3
               CHTDIR='//'//CHTOP
            ENDIF
         ENDIF
*
*        Workstation ID is 1 for GEANT
*
         IWTYPE=IGIWTY(1)
         CALL DZDDIV(IDIV,LMAIN,CHTDIR,CHOPT,IWDISP,
     +               IWMETA,ILOCNR,IWTYPE)
         IF(DOCFIL.NE.' ') THEN
            CALL RZEND(CHTOP)
            CLOSE(IFREE)
            LUNIT(IFREE)=0
         ENDIF
+SELF, IF=-DZDOC
*
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
10000    FORMAT(' *** GXDZ *** : Sorry, command not available',
     +          ' in this implementation')
+SELF
      ELSEIF (CHPATL.EQ.'DISP') THEN
+SELF, IF=DZDOC
         CALL KUGETC(BNAME,NCH)
         DOCFIL=' '
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC
         If (NCH.le.1 .and. EXST) Then
            DOCFIL=CDEF
            NCH=LENOCC(CDEF)
         EndIf
         CALL KUGETI(NUMBER)
         CHOPT='N'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         CHTOP =' '
         CHTDIR=' '
         IF (LZLOC(IXSTOR,BNAME,NUMBER).GT.0) THEN
            IF(DOCFIL.NE.' ') THEN
               CALL GXLUNF(61, 3, IFREE)
               IF(IFREE.NE.0) THEN
                  LRECL = 256
                  CALL RZOPEN(IFREE,CHTOP,DOCFIL(1:NCH),
     +                        'W',LRECL,ISTAT)
                  IF(ISTAT.NE.0) GOTO 999
                  CALL RZFILE(IFREE,CHTOP,' ')
                  LUNIT(IFREE) = 3
                  CHTDIR='//'//CHTOP
               ENDIF
            ENDIF
*
*        Workstation ID is 1 for GEANT
*
            IWTYPE=IGIWTY(1)
            LOC=LZLOC(IXSTOR,BNAME,NUMBER)
            CALL DZDISP(IXSTOR,LOC,CHTDIR,CHOPT,IWDISP,
     +                  IWMETA,ILOCNR,IWTYPE)
            IF(DOCFIL.NE.' ') THEN
               CALL RZEND(CHTOP)
               CLOSE(IFREE)
               LUNIT(IFREE)=0
            ENDIF
         ENDIF
+SELF, IF=-DZDOC
*
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
+SELF
      ELSEIF (CHPATL.EQ.'DIRZ') THEN
+SELF, IF=DZDOC
         DOCFIL=CDEF
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC
         If (NCH.le.1 .and. EXST) Then
            DOCFIL=CDEF
            NCH=LENOCC(CDEF)
         EndIf
         CHOPT='N'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         IDZSTR=0
         CALL MZLINT(IDZSTR,'/GCLTMP/',LTEMPA,LTEMPA(3),LTEMPA)
         CALL DZDIRZ(IDZSTR,LTEMPA(3),1,DOCFIL(1:NCH),CHOPT,
     +               IWDISP,IWMETA,ILOCNR)
         LTEMPA(1)=0
+SELF, IF=-DZDOC
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
+SELF
      ENDIF
*
  999 END
+DECK,GXDRAW,If=test.
*CMZ :  1.30/00 17/04/97  17.46.54  by  Pavel Nevski
*CMZ :  3.21/02 28/03/94  01.30.59  by  S.Giani
*-- Author :
      SUBROUTINE GXDRAW
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Drawing commands                                          *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                  S.Giani     **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,PAWC
+SEQ,GCUNIT
+SEQ,GCDRAW
+SEQ,GCGOBJ.
+SEQ,GCMUTR
+SEQ,GCSPEE
+SEQ,GCCURS
+SEQ,GCHIL2.
+SEQ,GCURSB.
+SEQ,GCJUMP, IF=USRJMP
+SEQ,GCVDMA.
+SEQ,GCFDIM.
*
      COMMON/QUEST/IQUEST(100)
*
      DIMENSION NNAME(15),NNUMB(15),RVAL(2)
*SG
      DIMENSION VX(4),VXX(4),VVX(4),XV(4),BX(4)
      DIMENSION VY(4),VYY(4),VVY(4),YV(4),BY(4)
      CHARACTER*4 NAME,CHNUMB,IDS,IVS,ICS,NNVV,NVNV,MOTH
      CHARACTER*4 CHNRS,CHAX,YESNO,CENT
      CHARACTER*4 NOPT,SAMP,KSAM,KLSA
      CHARACTER*6 MODE
 
*SG
      CHARACTER*80 CHTEXT
      CHARACTER*32 CHPATL,VNAME
      CHARACTER*64 NAMNUM
*
      CALL AGCHECK
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'BOX ') THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
10000      FORMAT(' *** GXDRAW ***:',
     +            ' No more space to store MCVOL information.')
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
10100      FORMAT(' *** GXDRAW ***: Please reset MCVOL')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(XMIN)
         CALL KUGETR(XMAX)
         CALL KUGETR(YMIN)
         CALL KUGETR(YMAX)
         CALL KUGETR(ZMIN)
         CALL KUGETR(ZMAX)
         IF(XMIN.GE.XMAX.OR.YMIN.GE.YMAX.OR.ZMIN.GE.ZMAX)THEN
            WRITE(CHMAIL,10200)
10200       FORMAT(' Wrong Box limits. Check values ')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='BOX'
         GXMIN(NCVOLS)=XMIN
         GXMAX(NCVOLS)=XMAX
         GYMIN(NCVOLS)=YMIN
         GYMAX(NCVOLS)=YMAX
         GZMIN(NCVOLS)=ZMIN
         GZMAX(NCVOLS)=ZMAX
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
* Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 10 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=-100000
               GXMAX(JJ)=-99999
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-99999
               GZMIN(JJ)=-100000
               GZMAX(JJ)=-99999
   10       CONTINUE
            NCVOLS=0
         ENDIF
      ELSEIF (CHPATL.EQ.'TUBE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX)
         CALL KUGETR(ZDEM)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='TUBE'
         GXMIN(NCVOLS)=RMAX
         GXMAX(NCVOLS)=ZDEM
         GYMIN(NCVOLS)=XMED
         GYMAX(NCVOLS)=YMED
         GZMIN(NCVOLS)=ZMED
         GZMAX(NCVOLS)=0.
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 20 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=0.1
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-100000
               GZMIN(JJ)=-100000
               GZMAX(JJ)=0.
   20       CONTINUE
            NCVOLS=0
         ENDIF
 
      ELSEIF (CHPATL.EQ.'CONE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX1)
         CALL KUGETR(RMAX2)
         CALL KUGETR(ZDEM)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='CONE'
         GXMIN(NCVOLS)=RMAX1
         GXMAX(NCVOLS)=RMAX2
         GYMIN(NCVOLS)=ZDEM
         GYMAX(NCVOLS)=XMED
         GZMIN(NCVOLS)=YMED
         GZMAX(NCVOLS)=ZMED
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 30 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=0.1
               GYMIN(JJ)=0.1
               GYMAX(JJ)=-100000
               GZMIN(JJ)=-100000
               GZMAX(JJ)=-100000
   30       CONTINUE
            NCVOLS=0
         ENDIF
 
      ELSEIF (CHPATL.EQ.'SPHE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='SPHE'
         GXMIN(NCVOLS)=RMAX
         GXMAX(NCVOLS)=XMED
         GYMIN(NCVOLS)=YMED
         GYMAX(NCVOLS)=ZMED
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 40 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=-100000
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-100000
   40       CONTINUE
            NCVOLS=0
         ENDIF
*
      ELSEIF (CHPATL.EQ.'VALCUT') THEN
         CALL KUGETR(XCUT)
         CALL KUGETR(YCUT)
         CALL KUGETR(ZCUT)
*
      ELSEIF (CHPATL.EQ.'SPOT') THEN
         CALL KUGETR(XLPOS)
         CALL KUGETR(YLPOS)
         CALL KUGETR(ZLPOS)
         CALL KUGETI(INTEN)
         CALL GLIGHT(XLPOS,YLPOS,ZLPOS,INTEN)
*
      ELSEIF (CHPATL.EQ.'VAR5D') THEN
         CALL KUGETR(TSEQTO)
         CALL KUGETI(NPROC)
         CALL KUGETI(NMPTOT)
         CALL KUGETR(TOTMBY)
         CALL KUGETR(TSEQ)
         CALL KUGETR(TLAT)
         CALL KUGETR(TNET)
*
      ELSEIF (CHPATL.EQ.'RANG5D') THEN
         CALL KUGETR(X1MIN)
         CALL KUGETR(X1MAX)
         CALL KUGETR(Y1MIN)
         CALL KUGETR(Y1MAX)
         CALL KUGETR(Z1MIN)
         CALL KUGETR(Z1MAX)
*
      ELSEIF (CHPATL.EQ.'DRAW') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         GTHETL=GTHETA
         GPHIL=GPHI
         GPSIL=GPSI
         GU0L=GU0
         GV0L=GV0
         GSCUL=GSCU
         GSCVL=GSCV
         IF(RAYTRA.EQ.1.)THEN
           CALL GDRAYT(NAME,GTHETL,GPHIL,GPSIL,GU0L,GV0L,GSCUL,GSCVL)
         ELSE
           CALL GDRAW(NAME,GTHETL,GPHIL,GPSIL,GU0L,GV0L,GSCUL,GSCVL)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'DVOLUME') THEN
         CALL KUGETI(N)
         IF (N.EQ.0) GO TO 60
         IF (N.LT.0.OR.N.GT.15) GO TO 999
*
         CALL KUGETC(CHTEXT,NCH)
         DO 50 I=1,N
            CALL KUGETL(NAMNUM,NCH)
            CALL UCTOH(NAMNUM,NNAME(I),4,4)
            CALL KUGETL(CHNUMB,NCH)
            CALL KICTON(CHNUMB,NNUMB(I),RVAL)
            IF (IQUEST(1).NE.0) GO TO 999
   50    CONTINUE
*
         CALL KUGETC(CHNRS,NCH)
         NRS=0
         IF (CHNRS.EQ.'DRS') NRS=1
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
   60    CALL GDRVOL(N,NNAME,NNUMB,NRS,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,
     +   GSCV)
*
      ELSEIF (CHPATL.EQ.'DCUT') THEN
         IHOLE=0
         CALL KUGETC(NAME,NCH)
         CALL KUGETC(CHAX,NCH)
         IF (CHAX.EQ.'X'.OR.CHAX.EQ.'1') THEN
            IAX=1
         ELSEIF (CHAX.EQ.'Y'.OR.CHAX.EQ.'2')THEN
            IAX=2
         ELSEIF (CHAX.EQ.'Z'.OR.CHAX.EQ.'3')THEN
            IAX=3
         ENDIF
         CALL KUGETR(CCUT)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL GDRAWC(NAME,IAX,CCUT,GU0,GV0,GSCU,GSCV)
*
      ELSEIF (CHPATL.EQ.'DXCUT') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(CUTTHE)
         CALL KUGETR(CUTPHI)
         CALL KUGETR(CCUT)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL GDRAWX(NAME,CUTTHE,CUTPHI,CCUT,GTHETA,GPHI,GU0,GV0,GSCU,
     +   GSCV)
*
***SG
*
*
*   It's now possible to shift each volume into a more visible place !
*
      ELSEIF(CHPATL.EQ.'SHIFT') THEN
         IF(NSHIFT.EQ.0)KSHIFT=1
         NSHIFT=NSHIFT+1
         IF(NSHIFT.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10300)
10300      FORMAT(' *** GXDRAW ***:',
     +            ' No more space to store SHIFT information.')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NVNV,NCH)
         CALL KUGETR(XXXX)
         CALL KUGETR(YYYY)
         CALL KUGETR(ZZZZ)
         GNVNV(NSHIFT)=NVNV
         GXXXX(NSHIFT)=XXXX
         GYYYY(NSHIFT)=YYYY
         GZZZZ(NSHIFT)=ZZZZ
*   Resetting Shift mode
         IF(GNVNV(NSHIFT).EQ.'.')THEN
            KSHIFT=0
            DO 70 KK=1,NSHIFT
               GNVNV(KK)=' '
               GXXXX(KK)=0
               GYYYY(KK)=0
               GZZZZ(KK)=0
   70       CONTINUE
            NSHIFT=0
         ENDIF
*
*  To make the detector 'explode'
*
      ELSEIF(CHPATL.EQ.'BOMB')THEN
         CALL KUGETR(BOOM)
         GBOOM=BOOM
*
***SG
*
      ELSEIF (CHPATL.EQ.'DTREE') THEN
*         JSIM=0
         KXXX=0
         NNPAR=NPAR
         CALL KUGETC(NAME,NCH)
         CALL UHTOC(IQ(JVOLUM+1),4,MOMO,4)
         CALL KUGETI(LEVMAX)
         IF(NNPAR.EQ.3)THEN
            CALL KUGETI(ISELT)
            IISELT=ISELT
         ELSE
            ISELT=111
         ENDIF
         IWTY=IGIWTY(1)
         JVSIM=2
         IF(IWTY.GT.10.OR.IWTY.LT.1)JVSIM=1
         IF (NAME.EQ.'    ')NAME=MOMO
         IF (NAME.NE.MOMO) THEN
            INTFLA=10
            CALL GDTREE(MOMO,0,110)
            DO 80 J=1,NUMND2
               IQ(JFINAM+J)=IQ(JNAM1+J)
               IQ(JFISCA+J)=IQ(JSCA1+J)
               IQ(JFIMOT+J)=IQ(JMOT1+J)
   80       CONTINUE
            KXXX=1
            IF(LEVMAX.LT.0)THEN
               LEVMAX=-LEVMAX
               DO 90  II=1,LEVMAX
                  CALL GDTR8(NAME,MOTH,IONL)
                  NAME=MOTH
   90          CONTINUE
               LEVMAX=3
            ENDIF
         ELSE
            INTFLA=10
            CALL GDTREE(NAME,0,110)
            DO 100 J=1,NUMND2
               IQ(JFINAM+J)=IQ(JNAM1+J)
               IQ(JFISCA+J)=IQ(JSCA1+J)
               IQ(JFIMOT+J)=IQ(JMOT1+J)
  100       CONTINUE
            INTFLA=-1
            CALL GDTREE(NAME,LEVMAX,ISELT)
         ENDIF
*
         CALL GDPLST(JVSIM,NAME,LEVMAX,KXXX)
*
      ELSEIF (CHPATL.EQ.'DSPEC') THEN
         CALL KUGETC(NAME,NCH)
         CALL GDSPEC(NAME)
*
      ELSEIF (CHPATL.EQ.'D3DSPEC') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(TETA3)
         CALL KUGETR(PHI3)
         CALL KUGETR(PSI3)
         CALL KUGETR(U03)
         CALL KUGETR(V03)
         CALL KUGETR(ZM3)
         CALL GSPE3D(NAME,TETA3,PHI3,PSI3,U03,V03,ZM3)
*
      ELSEIF (CHPATL.EQ.'DFSPC') THEN
         CALL KUGETC(NAME,NCH)
         ISORT=0
         CALL KUGETC(YESNO,NCH)
         IF (YESNO.EQ.'Y') ISORT=1
         INTER=1
         CALL KUGETC(MODE,NCH)
         IF (MODE.EQ.'B') INTER=0
         CALL GDFSPC(NAME,ISORT,INTER)
*
      ELSEIF (CHPATL.EQ.'DTEXT') THEN
         CALL KUGETR(X0)
         CALL KUGETR(Y0)
         CALL KUGETS(CHTEXT,NCH)
         CALL KUGETR(SIZE)
         CALL KUGETR(ANGLE)
         CALL KUGETI(LWID)
         CALL KUGETC(CENT,NCH)
         IF (CENT.EQ.'LEFT'.OR.CENT.EQ.'-1') THEN
            IOPT=-1
         ELSEIF (CENT.EQ.'RIGHT'.OR.CENT.EQ.'1') THEN
            IOPT=1
         ELSE
            IOPT=0
         ENDIF
         CALL IGSET('TXFP',-60.)
         IWTY=IGIWTY(1)
         IF(IWTY.GT.10.OR.IWTY.LT.1)CALL IGSET('TXFP',-61.)
         CALL GDRAWT(X0,Y0,CHTEXT,SIZE,ANGLE,LWID,IOPT)
         CALL IGSET('TXFP',2.)
*
      ELSEIF (CHPATL.EQ.'DVECTOR') THEN
         CALL KUGETV(VNAME,LPARX,LLL)
         CALL KUGETV(VNAME,LPARY,LLL)
         CALL KUGETI(NP)
         CALL GDRAWV(QQ(LPARX),QQ(LPARY),NP)
*
      ELSEIF (CHPATL.EQ.'DSCALE') THEN
         CALL KUGETR(X0)
         CALL KUGETR(Y0)
         CALL GDSCAL(X0,Y0)
*
      ELSEIF (CHPATL.EQ.'DAXIS') THEN
         CALL KUGETR(XX0)
         CALL KUGETR(YY0)
         CALL KUGETR(ZZ0)
         CALL KUGETR(DDX)
         CALL GDAXIS(XX0,YY0,ZZ0,DDX)
*
      ELSEIF (CHPATL.EQ.'DMAN') THEN
         CALL KUGETR(U0)
         CALL KUGETR(V0)
         CALL KUGETC(MODE,NCH)
         IF (MODE.EQ.'WM1') THEN
            CALL GDWMN1(U0,V0)
         ELSE IF (MODE.EQ.'WM3') THEN
            CALL GDWMN3(U0,V0)
         ELSE IF (MODE.EQ.'WM2') THEN
            CALL GDWMN2(U0,V0)
         ELSE IF (MODE.EQ.'MAN') THEN
            CALL GDMAN(U0,V0)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'DHEAD') THEN
         ISELH=111110
         CALL KUGETI(ISELH)
         CHRSIZ=0.6
         CALL KUGETS(CHTEXT,NCH)
         CALL KUGETR(CHRSIZ)
         CALL GDHEAD(ISELH,CHTEXT,CHRSIZ)
*
      ELSEIF (CHPATL.EQ.'MEASURE') THEN
         CALL IGLOC2(1,NT,U0,V0,U1,V1,ISTAT,'L')
         IF (ISTAT.EQ.0) GO TO 999
         UDIST=(U1-U0)/(GSCU*GZUA)
         VDIST=(V1-V0)/(GSCV*GZVA)
         DIST=SQRT(UDIST*UDIST+VDIST*VDIST)
         WRITE (CHMAIL,'('' MEASURE : '',F9.4,'' CM'')') DIST
         CALL GMAIL(0,0)
*
      ELSEIF (CHPATL.EQ.'MOVE')  THEN
         IWTY=IGIWTY(1)
         IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
            ISTAT=0
            LEP=-ABS(LEP)
            CALL KUGETC(NAME,NCH)
            CALL KUGETC(NOPT,NCH)
            VX(1)=0.
            VX(2)=4.
            VX(3)=4.
            VX(4)=0.
            VY(1)=0.
            VY(2)=0.
            VY(3)=1.
            VY(4)=1.
            VXX(1)=4.
            VXX(2)=8.
            VXX(3)=8.
            VXX(4)=4.
            VYY(1)=0.
            VYY(2)=0.
            VYY(3)=1.
            VYY(4)=1.
            VVX(1)=8.
            VVX(2)=12.
            VVX(3)=12.
            VVX(4)=8.
            VVY(1)=0.
            VVY(2)=0.
            VVY(3)=1.
            VVY(4)=1.
            XV(1)=12.
            XV(2)=16.
            XV(3)=16.
            XV(4)=12.
            YV(1)=0.
            YV(2)=0.
            YV(3)=1.
            YV(4)=1.
            BX(1)=16.
            BX(2)=20.
            BX(3)=20.
            BX(4)=16.
            BY(1)=0.
            BY(2)=0.
            BY(3)=1.
            BY(4)=1.
*****           CALL IGSET('DRMD',2.)
            CALL ISFAIS(1)
            CALL GDCOL1(2)
            CALL IFA(4,VX,VY)
            CALL GDCOL1(3)
            CALL IFA(4,VXX,VYY)
            CALL GDCOL1(4)
            CALL IFA(4,VVX,VVY)
            CALL GDCOL1(6)
            CALL IFA(4,XV,YV)
            CALL GDCOL1(7)
            CALL IFA(4,BX,BY)
            AITXCO=5.
            CALL IGSET('TXCI',AITXCO)
            CALL IGSET('TXFP',-60.)
            CALL GDRAWT(2.,.2,'THETA',.7,0.,4,0)
            CALL GDRAWT(6.,.2,'PHI',.7,0.,4,0)
            CALL GDRAWT(10.,.2,'TRASL',.7,0.,4,0)
            CALL GDRAWT(14.,.2,'ZOOM',.7,0.,4,0)
            CALL GDRAWT(18.,.2,'OFF',.7,0.,4,0)
            CALL IGSET('TXFP',2.)
            LLEP=ABS(LEP)
            IF(LLEP.GT.1)THEN
               LCLC=1
            ELSE
               LCLC=0
            ENDIF
            CALL ISFACI(LCLC)
            CALL IGBOX(0.,20.,20.,1.)
            CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
            IOPTS = INDEX(NOPT,'S')+INDEX(NOPT,'s')
            IOPTT = INDEX(NOPT,'T')+INDEX(NOPT,'t')
            IOPTH = INDEX(NOPT,'H')+INDEX(NOPT,'h')
            IF(IOPTT.NE.0) CALL GDXYZ(0)
            IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
            MO=2
*           OOY2=10.
*           OOX2=10.
            OGSCU=GSCU
            OGSCV=GSCV
*         ipx=1
            CALL IGQWK(1,'MXDS',RVAL)
            IXXX=RVAL(1)
            IYYY=RVAL(2)
            IYYY1=(IYYY*19.)/20.
            DO 110 J=1,1000000
               IF(ISTAT.EQ.2.AND.IOPTT.NE.0) CALL GKXYZ(-.25)
               IF(ISTAT.EQ.2.AND.IOPTH.NE.0) CALL GKHITS('*','*',-.1)
               CALL IRQLC(1,MO,ISTAT,NT,X2,Y2)
*           CALL ISFAIS(1)
*****           CALL IGSET('DRMD',2.)
               IF(MO.NE.-2)THEN
                  IF(X2.GT.0..AND.X2.LT.4..AND.Y2.LT.1.)NBAR=1
                  IF(X2.GT.4..AND.X2.LT.8..AND.Y2.LT.1.)NBAR=2
                  IF(X2.GT.8..AND.X2.LT.12..AND.Y2.LT.1.)NBAR=3
                  IF(X2.GT.12..AND.X2.LT.16..AND.Y2.LT.1.)NBAR=4
                  IF(X2.GT.16..AND.X2.LT.20..AND.Y2.LT.1.)THEN
                     CALL IGSET('DRMD',1.)
                     LEP=-LEP
                     GO TO 999
                  ENDIF
               ENDIF
*           YY22=ABS(Y2-OOY2)
               IF(NBAR.EQ.1) THEN
                  GTHETA=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ELSEIF(NBAR.EQ.2) THEN
*             GBOOM=Y2/10.
                  GPHI=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ELSEIF(NBAR.EQ.3) THEN
*             XX22=ABS(X2-OOY2)
                  GU0=X2
                  GV0=Y2
***             GTHETA=18.*Y2
***             GPHI=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2.AND.XX22.LT..2)GOTO 177
*             OOY2=Y2
*             OOX2=X2
               ELSEIF(NBAR.EQ.4) THEN
                  GSCU=OGSCU*Y2*.25
                  GSCV=OGSCV*Y2*.25
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ENDIF
*****           CALL IGSET('DRMD',1.)
               CALL IGPXMP(IPX,IXXX,IYYY1,'O')
               CALL ISFACI(LCLC)
               IF(LCLC.NE.0)CALL IGBOX(0.,20.,20.,1.)
               CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
               IF(IOPTT.NE.0) CALL GDXYZ(0)
               IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
               CALL IGPXMP(IPX,0,0,'CDR')
**       CALL GDRAW(NAME,SGT1,SGT2,SGT3,SGT4,SGT5,SGT6,SGT7)
*       CALL GDXYZ(0)
*       CALL GDHITS('*','*',0,-1,.4)
  110       CONTINUE
         ENDIF
*
      ELSEIF (CHPATL.EQ.'MOVE3D')  THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL KUGETR(GSCZ)
         CALL KUGETC(NOPT,NCH)
         GSCU=GSCU*GSCZ
         GSCV=GSCV*GSCZ
         CALL HPLI
         CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
         IOPTT = INDEX(NOPT,'T')+INDEX(NOPT,'t')
         IOPTH = INDEX(NOPT,'H')+INDEX(NOPT,'h')
         IF(IOPTT.NE.0) CALL GDXYZ(0)
         IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
*
      ELSEIF (CHPATL.EQ.'PERSP') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(DISTT)
         CALL KUGETC(SAMP,NCH)
         IF(DISTT.LT.100.)DISTT=100.
         DPERS=DISTT
         IF(SAMP(1:2).EQ.'ON')THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               LEP=-ABS(LEP)
               CALL IGQWK(1,'MXDS',RVAL)
               IXXX=RVAL(1)
               IYYY=RVAL(2)
               DO 120 II=1,1000000
                  CALL IRQLC(1,2,ISTAT,NT,X2,Y2)
                  IF(ISTAT.EQ.0)GOTO 130
                  DPERS=Y2*100.+100.
                  GTHETA=X2*4.5
                  GPHI=90.-GTHETA
                  CALL IGPXMP(IPX,IXXX,IYYY,'O')
                  CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
                  CALL IGPXMP(IPX,0,0,'CDR')
  120          CONTINUE
  130          CONTINUE
            ENDIF
         ENDIF
 
      ELSEIF (CHPATL.EQ.'LENS') THEN
         ZZFV=0.
         IWTY=IGIWTY(1)
         IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
            CALL KUGETI(KNUM)
            IF(KNUM.EQ.1000)KNUM=MYISEL
            CALL KUGETC(KSAM,NCH)
            KLLM=KNUM
            KLSA=KSAM
            CALL GDLENS(KLLM,KLSA)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'ZOOM') THEN
         CONTINUE
         ZZFV=0.
         ZFU=2.
         CALL KUGETR(ZFU)
         ZFV=ZFU
         CALL KUGETR(ZFV)
         ZZFU=ZFU
         ZZFV=ZFV
         IF(ZZFU.EQ.0.)ZZFV=0.
         IF(ZFU.EQ.0.OR.ZFV.EQ.0)GO TO 140
         IMODE=1
         CALL KUGETI(IMODE)
         UZ0=PLTRNX*.5
         CALL KUGETR(UZ0)
         VZ0=PLTRNY*.5
         CALL KUGETR(VZ0)
         U0 =UZ0
         CALL KUGETR(U0)
         V0 =U0
         CALL KUGETR(V0)
*
         IF(IMODE.GT.1000)THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               ISEL1=IMODE-1000
               CALL GDXZOO(ISEL1,ZFU,ZFV,UZ0,VZ0,U0,V0)
               RETURN
            ENDIF
         ELSEIF(IMODE.EQ.1000)THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               ISEL1=MYISEL
               CALL GDXZOO(ISEL1,ZFU,ZFV,UZ0,VZ0,U0,V0)
               RETURN
            ENDIF
         ENDIF
*
         IF(IMODE.EQ.0)THEN
*
            CALL GDCURS(UZ0,VZ0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
*
         ELSE IF(IMODE.EQ.1)THEN
*
            CALL IGLOC2(1,NT,UZ1,VZ1,UZ2,VZ2,ISTAT,'R')
            IF (ISTAT.EQ.0) GO TO 999
            IF (UZ2-UZ1.EQ.0.) UZ2=UZ1+PLTRNX/200.
            IF (VZ2-VZ1.EQ.0.) VZ2=VZ1+PLTRNY/200.
            ZFU=PLTRNX/ABS(UZ2-UZ1)
            ZFV=PLTRNY/ABS(VZ2-VZ1)
            UZ0=(UZ1+UZ2)/2.
            VZ0=(VZ1+VZ2)/2.
*
         ELSE IF(IMODE.EQ.2)THEN
*
            CALL GDCURS(UZ0,VZ0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
            CALL GDCURS(U0,V0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
*
         ENDIF
*
  140    CALL GDZOOM(ZFU,ZFV,UZ0,VZ0,U0,V0)
*
*
      ELSEIF (CHPATL.EQ.'DXYZ') THEN
         CALL KUGETI(IT)
         CALL GDXYZ(IT)
*
      ELSEIF (CHPATL.EQ.'KXYZ') THEN
         CALL KUGETR(EPSXYZ)
         CALL GKXYZ(EPSXYZ)
*
      ELSEIF (CHPATL.EQ.'DPART') THEN
         CALL KUGETI(IT)
         ISELP = 11
         CALL KUGETI(ISELP)
         CALL KUGETR(SIZE)
         CALL GDPART(IT,ISELP,SIZE)
*
      ELSEIF (CHPATL.EQ.'DHITS') THEN
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IUTR)
         ISYMB=0
         CALL KUGETI(ISYMB)
         CALL KUGETR(SSYMB)
         CALL GDHITS(IVS,ICS,IUTR,ISYMB,SSYMB)
*
      ELSEIF (CHPATL.EQ.'KHITS') THEN
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETR(EPSHIT)
         CALL GKHITS (IVS,ICS,EPSHIT)
*
      ELSEIF (CHPATL.EQ.'DCHIT') THEN
         IUTR =0
         ISYMB=0
         SIZMAX=1.
         KDHIT =4
         HITMIN=0.
         HITMAX=0.
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IUTR)
         CALL KUGETI(ISYMB)
         CALL KUGETR(SIZMAX)
         CALL KUGETI(KDHIT)
         CALL KUGETR(HITMIN)
         CALL KUGETR(HITMAX)
         CALL GDCHIT(IVS,ICS,IUTR,ISYMB,SIZMAX,KDHIT, HITMIN,HITMAX)
*
      ELSEIF (CHPATL.EQ.'DUVIEW') THEN
         CALL KUGETC(IDS,NCH)
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IVIEW)
+SELF, IF=-USRJMP
         CALL GUVIEW(IDS,IVS,ICS,IVIEW)
+SELF, IF=USRJMP
         CALL JUMPT4(JUVIEW,IDS,IVS,ICS,IVIEW)
+SELF
      ENDIF
*
  999 END
+DECK,GMEDIA,IF=-OLD.
*CMZ :          13/02/98  18.13.57  by  Pavel Nevski
*CMZ :  1.30/00 30/04/97  22.41.05  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.24.17  by  S.Giani
*-- Author :
      SUBROUTINE GMEDIA (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Called by :  GTREVE, GLTRAC, 'User'                          *
C.    *   Authors   : R.Brun, F.Bruyant, A.McPherson                   *
C.    *               S.Giani.                                         *
C.    *                                                                *
C.    *   Modified by S.Giani (1993) to perform the search according   *
C.    *    to the new 'virtual divisions' algorithm and to build the   *
C.    *    stack of the 'possible overlapping volumes' in the case of  *
C.    *    MANY volumes. Any kind of boolean operation is now possible.*
C.    *    Divisions along arbitrary axis are now possible.            *
C.    *   PN: in MANY volums the search should start from top          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCFLAG.
+SEQ, GCKINE.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCVDMA.
+SEQ, GCHVIR.
C.
      DIMENSION  X(*)
      REAL       XC(6)
      LOGICAL    BTEST
      CHARACTER  NAME*4
C.
C.    ------------------------------------------------------------------
*
      nvmany=0
      nfmany=0
      new2fl=0
*
      IF (NLEVEL.EQ.0) CALL GMEDIN
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
*            The information contained in INFROM has to be invalidated
*            because it has no meaning for the subsequent tracking. INFR
*            is a local variable used to optimise the search in the
*            geometry tree.
*
      INFROM = 0
*
* *** Check if point is in current volume
*
      INFR   = 0
      JVIN   = 0
C
C        PN: in MANY volums the search should start from top
  100 If (NLEVEL.GT.1) then
         If (GONLY(NLEVEL).EQ.0) then
            NLEVEL=NLEVEL-1
            GOTO 100
         endif
      endif
C
C*****  Code Expanded From Routine:  GTRNSF
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*GRMAT(3
     +      ,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*GRMAT(6
     +      ,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*GRMAT(9
     +      ,NLEVEL)
 
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
*
*       Do not set INFR whne going up the tree. GMEDIA can be called
*       by the user and it  should not assume  that the previous
*       position has something to do with the current search. INFR
*       is otherwise useful when searching in a 'MANY' volume
*       configuration. This statement is commented for the above reason.
*
*              INFR  =LINDEX(NLEVEL+1)
            ELSE
               INFR  =0
            ENDIF
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ENDIF
*
*  **   Point is in current volume
*
      IF(INFR  .GT.0) THEN
         JIN=LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
      NLMIN = NLEVEL
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            INFR   = 0
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT  = LQ(JVO-NIN-1)+1
         NCONT  = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  new2fl=0
                  IF (GONLY(NLEVEL).NE.0.) THEN
                    NLMANY = 0
                    nvmany = 0
                    nfmany = 0
                  ENDIF
                  INFR   = 0
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR  .GT.0) THEN
            JIN = LQ(JVO-INFR  )
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
            nfmany=nvmany+1
         ENDIF
         if(new2fl.eq.0)then
            nvmany=nvmany+1
            manyle(nvmany)=nlevel
            do 401 i = 1,nlevel
              manyna(nvmany,i)=names(i)
              manynu(nvmany,i)=number(i)
 401        continue
         endif
*
*   *   Go up the tree up to a volume with positioned contents
*
         new2fl=-1
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      if(nlmany.eq.0)then
        nvmany=0
        nfmany=0
      endif
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GMEDIA
  999 IF(JGSTAT.NE.0) CALL GFSTAT(2)
      END
+DECK,GSDETV
*CMZ :  1.30/00 24/05/96  21.28.46  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDETV (IUSET, IUDET, IDTYPE, NWHI, NWDI, ISET, IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines detector IUDET as a member of set IUSET          *
C.    *     and prepares the DETector structure                        *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for primary allocation of HITS banks *
C.    * NWDI      number of words for primary allocation of DIGI banks *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The path through the volume tree will be automatically set   *
C.    *   in GGDETV,called by GGCLOS, after all volumes have been      *
C.    *   positionned.                                                 *
C.    * - The detector type  IDTYPE is not used  internally by GEANT   *
C.    *   and  can be  defined by  the user  to distinguish  quickly   *
C.    *   between various kinds of detectors,  in the routine GUSTEP   *
C.    *   for example.                                                 *
C.    *                                                                *
C.    *       IQ(JSET+ISET) = IUSET                                    *
C.    *       JS = LQ(JSET-ISET) = pointer to set IUSET                *
C.    *       IQ(JS+IDET)=IUDET                                        *
C.    *       JD= LQ(JS-1)  = pointer to detector IUDET                *
C.    *       IQ(JD+1)=Number of words to store packed volume numbers  *
C.    *       IQ(JD+2)=Number of volume descriptors                    *
C.    *       IQ(JD+3)=Number of words per hit                         *
C.    *       IQ(JD+4)=Number of elements per hit                      *
C.    *       IQ(JD+5)=Number of words per digitisation                *
C.    *       IQ(JD+6)=Number of elements per digitisation             *
C.    *       IQ(JD+7)=NWHI, primary size of hit bank                  *
C.    *       IQ(JD+8)=NWDI, primary size of digitisation bank         *
C.    *       IQ(JD+9)=Number of paths through the JVOLUM tree         *
C.    *       IQ(JD+10)=For aliases only, IDET of mother detector      *
C.    *       IQ(JD+11)=Name of first volume descriptor                *
C.    *       IQ(JD+12)=Number of bits for packing its number          *
C.    *       ...                                                      *
C.    *       IQ(JD+9+2*NV)=Name of last volume descriptor             *
C.    *       IQ(JD+10+2*NV)=Number of bits for packing its number     *
C.    *       then for each possible path                              *
C.    *       list of names and numbers for all levels                 *
C.    *       (The number of levels is entered as number attached to   *
C.    *       the first name which is the top of the JVOLUM tree)      *
C.    *                                                                *
C.    *            The Detector Set data structure JSET                *
C.    *            ------------------------------------                *
C.    *                                                                *
C.    *                                        | JSET                  *
C.    *    NSET            ISET                v         NSET          *
C.    *     ................................................           *
C.    *     |              | |               |  | Set names|           *
C.    *     ................................................           *
C.    *                     | JS                                       *
C.    *                     |                                          *
C.    *    NDET       IDET  v                    NDET                  *
C.    *     ........................................                   *
C.    *     |        |  |  | | Detector names      |                   *
C.    *     ........................................                   *
C.    *                  | JD                                          *
C.    *       -3  -2  -1 v                                             *
C.    *     ................................................           *
C.    *     |   |   |   |  | Volume parameters, in GGDETV  |           *
C.    *     ................................................           *
C.    *              JDH                                               *
C.    *          JDD                                                   *
C.    *      JDU                                                       *
C.    *                                                                *
C.    * The JSET structure is filled by GSDETV + GGDETV, and by        *
C.    *      GSDETH, GSDETD and GSDETU, eventually by GSDETA.          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors   R.Brun, F.Bruyant    **********                *
C.    *                                                                *
C.    * Modifications:                                                 *
C.    *  PN, 20.04.96:  warning on non-sensetive volume in DEBUG only  *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCMZFO.
+CDE,GCFLAG.
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      ISET = 0
      IDET = 0
C
C     Check if volume IUDET has been defined
C
      IF (JVOLUM.LE.0) GO TO 920
      NVOLUM = IQ(JVOLUM-1)
      CALL GLOOK (IUDET, IQ(JVOLUM+1), NVOLUM, IVOL)
      IF (IVOL.EQ.0) GO TO 920
C
C     Check that volume IVOL is a sensitive medium
C
      JVO = LQ(JVOLUM-IVOL)
      ITM = Q(JVO+4)
      JTM = LQ(JTMED-ITM)
      IF (Q(JTM+7).EQ.0. .AND. IDEBUG.GT.0) THEN
         WRITE (CHMAIL,1000) IUDET
         CALL GMAIL(0,0)
      ENDIF
C
      IF (JSET.EQ.0)THEN
C
C     Create mother JSET bank
C
         CALL MZBOOK (IXCONS, JSET, JSET, 1, 'SETS', 0,0,0, 5, 0)
         IQ(JSET-5)=0
         NSET = 0
      ELSE
C
         NSET = IQ(JSET-1)
         CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
         IF (ISET.NE.0) GO TO 30
      ENDIF
C
C     Create JSET bank
C
      CALL MZPUSH (IXCONS, JSET, 1, 1, 'I')
      NSET = NSET +1
C
      ISET = NSET
      CALL UCTOH (IUSET, IQ(JSET+ISET), 4, 4)
      CALL MZBOOK (IXCONS, JS, JSET, -ISET, 'SETS', 0,0,0, 5, 0)
      IQ(JS-5) = ISET
C
C     Check if detector has already been defined
C
  30  JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.NE.0)THEN
         CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
         IF (IDET.NE.0) GO TO 930
      ENDIF
C
C     If not, create detector bank
C
      CALL MZPUSH (IXCONS, JS, 1, 1, 'I')
      NDET = NDET +1
      IDET = NDET
      CALL UCTOH (IUDET, IQ(JS+IDET), 4, 4)
      CALL MZBOOK (IXCONS, JD, JS, -IDET, 'SEJD', 4,4,100, IOSEJD, 0)
      IQ(JD-5) = IDET
C
      IQ(JD+7) = NWHI
      IQ(JD+8) = NWDI
      IQ(JD+9) = -1
C
C     Now enter Set/Det into JVOLUM data structure
C
      CALL GSATT (IUDET, 'SET ', ISET)
      CALL GSATT (IUDET, 'DET ', IDET)
      CALL GSATT (IUDET, 'DTYP', IDTYPE)
      GO TO 999
C
C     Errors
C
  920 WRITE (CHMAIL,2000) IUDET
      CALL GMAIL(0,0)
      GO TO 999
C
  930 WRITE (CHMAIL,3000)  IUSET, IUDET
      CALL GMAIL(0,0)
C
 1000 FORMAT (' ***** GSDETV - ISVOL=0 FOR DETECTOR ',A4,' - WARNING!')
 2000 FORMAT (' ***** GSDETV ERROR, VOLUME ',A4,' NOT DEFINED')
 3000 FORMAT (' ***** GSDETV ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' ALREADY DEFINED')
C
  999 RETURN
      END
+DECK,GXPICK
*CMZ :  1.30/00 31/05/96  19.39.03  by  Unknown
*CMZ :  3.21/02 29/03/94  15.41.33  by  S.Giani
*-- Author :
      SUBROUTINE GXPICK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Geometry commands                                         *
C.    *                                                                *
C.    * Point to volume just drawn to pick up medium name, volume name *
C.    * etc. The first point points to the volume, the second point    *
C.    * gives the position of the character string which contains this *
C.    * information.                                                   *
C.    *                                                                *
C.    *       Authors:   S.Egli      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCVOLU
+SEQ,GCDRAW
+SEQ,GCBANK
+SEQ,GCSETS
+SEQ,GCTMED
+SEQ,GCMATE
+SEQ,GCUNIT
*
* this COMMON filled in routine GDRAW !
*
      COMMON/GCVHLP/NVLAST
*
      DIMENSION XC(3),XYZ(3),XINVMA(3,3),VL(3),VM(3),VN(3)
      DIMENSION XX(10),YY(10),RHELP(3)
*
      CHARACTER*4 NAMV,CHIDTY
      CHARACTER*20 NAMM
      LOGICAL BTEST
*
* determine inverse matrix xinvma for current view parameters
*
      PH = ABS(MOD(GPHI,360.))
      THET = ABS(MOD(GTHETA,360.))
      IF(THET.LE.180.)GO TO 10
      PH = PH + 180.
      THET = 360. - THET
*
   10 ST = SIN(THET * DEGRAD)
      CT = COS(THET * DEGRAD)
      SP = SIN(PH * DEGRAD)
      CP = COS(PH * DEGRAD)
*
*             VN is new nu axis
*
      VN(1) = ST * CP
      VN(2) = ST * SP
      VN(3) = CT
*
      IF(ABS(VN(2)).GT.0.99999) THEN
*
*             Special case when observer line of sight is along mu:
*             in this case one chooses arbitrarily the vertical axis of
*             plane of projection as the lambda axis and the horizontal
*             as the nu axis
*
         VL(1) = 0.
         VL(2) = 0.
         VL(3) = 1.
         VM(1) = 1.
         VM(2) = 0.
         VM(3) = 0.
      ELSE
*
         VM(1) = 0.
         VM(2) = 1.
         VM(3) = 0.
*
*             Define new lambda axis
*
         CALL CROSS(VM,VN,VL)
         CALL VUNIT(VL,VL,3)
*
*             Define new mu axis
*
         CALL CROSS(VN,VL,VM)
      ENDIF
*
*   now invert matrix defined by VL,VM,VN -> XINVMA
*
      DO 20 I=1,3
         XINVMA(1,I)=VL(I)
         XINVMA(2,I)=VM(I)
         XINVMA(3,I)=VN(I)
   20 CONTINUE
*
      CALL RINV(3,XINVMA,3,RHELP,IFAIL)
      IF(IFAIL.NE.0)THEN
         WRITE(CHMAIL,10100) IFAIL
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
*   perspective projection ?
*
      CALL UCTOH('PERS',IPERS,4,4)
      IF(IPRJ.EQ.IPERS)THEN
         WRITE(CHMAIL,10200)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
* pick up two points in user coordinates:
*
   30 CALL IRQLC(1,1,ISTAT,NT,U0,V0)
      IF(ISTAT.EQ.0)GOTO 999
      CALL IRQLC(1,1,ISTAT,NT,U1,V1)
      IF(ISTAT.EQ.0)GOTO 999
*
* transform (u0,v0) to coordinates in MARS system:
*  (inverse operation of what is done in routine GDFR3D)
*
*   take zoom parameters into account:
*
      U01=(U0-GZUB-GZUC)/GZUA
      V01=(V0-GZVB-GZVC)/GZVA
*
*   rotate and shift back
*
      UU=+COSPSI*(U01-GU0)+SINPSI*(V01-GV0)
      VV=-SINPSI*(U01-GU0)+COSPSI*(V01-GV0)
      XYZ(1)=UU/GSCU
      XYZ(2)=VV/GSCV
      XYZ(3)=DCUT
*
*   apply xinvma
*
      XC(1)=XINVMA(1,1)*XYZ(1)+XINVMA(1,2)*XYZ(2)+XINVMA(1,3)*XYZ(3)
      XC(2)=XINVMA(2,1)*XYZ(1)+XINVMA(2,2)*XYZ(2)+XINVMA(2,3)*XYZ(3)
      XC(3)=XINVMA(3,1)*XYZ(1)+XINVMA(3,2)*XYZ(2)+XINVMA(3,3)*XYZ(3)
*
*   build up GCVOLU structure with last drawn volume as
*   top of tree
*
      NLEV=1
      LNUM=0
      CALL GLVOLU(NLEV,NVLAST,LNUM,IER)
*
*  determine medium
*
      NUMED=0
      CALL GMEDIA(XC,NUMED)
*
      IF(NUMED.EQ.0)THEN
         WRITE(CHMAIL,10300)
         CALL GMAIL(0,0)
         GOTO 30
      ENDIF
      JTM = LQ(JTMED- NUMED)
      DO 40 I=1,5
   40 NATMED(I)=IQ(JTM+I)
      NMAT   = Q(JTM + 6)
      ISVOL  = Q(JTM + 7)
      IFIELD = Q(JTM + 8)
      FIELDM = Q(JTM + 9)
      TMAXFD = Q(JTM + 10)
      STEMAX = Q(JTM + 11)
      DEEMAX = Q(JTM + 12)
      EPSIL  = Q(JTM + 13)
      STMIN  = Q(JTM + 14)
      CALL UHTOC(NAMES(NLEVEL),4,NAMV,4)
      CALL UHTOC(NATMED,4,NAMM,20)
      DO 50 I=1,20
         IF(NAMM(I:I).EQ.'$')NAMM(I:I)=' '
   50 CONTINUE
      DO 60 I=20,1,-1
         IF(NAMM(I:I).NE.' ')GOTO 70
   60 CONTINUE
   70 NJLAST=I
*
*  determine detector idtype
*
      IF(JSET.GT.0)CALL GFINDS
*
* draw pointer and write volume name,medium
*
      XX(1)=U0
      YY(1)=V0
      XX(2)=U1
      YY(2)=V1
      CALL IPL(2,XX,YY)
*
*  determine text alignment
*
*     protect against double click:
      If (abs(V1-V0)+abs(U1-U0).GT.0) PHI=ATAN2(V1-V0,U1-U0)*RADDEG
      IF(ABS(PHI).LT.90.)THEN
         IHOR=1
      ELSE
         IHOR=3
      ENDIF
      IF(PHI.GT.0.)THEN
         IVER=5
      ELSE
         IVER=1
      ENDIF
      CALL ISTXAL(IHOR,IVER)
*
      IF(.NOT.BTEST(IQ(LQ(JVOLUM-LVOLUM(1))),4))THEN
         CALL ITX(U1,V1,NAMV//'"j# '//NAMM(1:NJLAST))
      ELSE
         WRITE(CHIDTY,10000)IDTYPE
         CALL ITX(U1,V1,NAMV//'"j# '//NAMM(1:NJLAST)//','//CHIDTY)
      ENDIF
      GOTO 30
10000 FORMAT(I4)
10100 FORMAT(' GXPICK: Matrix inversion failed with ',I3,
     +       '; abandoning')
10200 FORMAT(' GXPICK: perspective projection can not be handled')
10300 FORMAT(' GXPICK: point is outside volume')
  999 END
 
+DECK,GXCONT.
*CMZ :  1.30/00 16/04/97  20.12.19  by  Pavel Nevski
*CMZ :  3.21/02 07/07/94  19.47.38  by  S.Giani
*-- Author :
      SUBROUTINE GXCONT
**
**    ******************************************************************
**    *                                                                *
**    *      General control commands                                  *
**    *                                                                *
**    *       Authors:   R.Brun      **********                        *
**    *                  P.Zanarini  **********                        *
**    *                  S.Giani     **********                        *
**    *                                                                *
**    * Modifications:                                 PN, 06 July 96  *
**    *  - strong typing introduced to find undefined variables        *
**    *  - GCTIME common was missing                                   *
**    *  - SPART command corrected ( a la NA49 and Star): Ubuf,        *
**    *    branching ratios and decay modes are KUIP vectors!          *
**    *  - RNDM command with single parameter ISEQ (1-215) recals      *
**    *    standard precomputed sequences.                             *
**    *    If ISEQ=0, sequence is elected according to IGTIME.         *
**    *  - Time control introduced - upon the limit IQUEST(1) is set   *
**    ******************************************************************
**
+CDE,QUEST,PAWC,SCLINK,ZSTATE.
+CDE,GCBANK,GCTMED,GCUNIT,GCFLAG,GCKINE,GCPHYS.
+CDE,GCMULO,GCLIST,GCSTAK,GCDRAW,GCTIME.
*
      Integer      IGIWTY,IwkSty,i,N,Npar,Npk,Nch,Level,Numb,Imat,
     +             NumHit,Llow,Lhigh,Llo1,Lhig1,Llo2,Lhig2,NW,
     +             Idm,Nlmat,Nmec,Kmec,ItMed,Is1,Is2
      Real         A,Z,Dens,RadL,AbsL,ParVal,T
      CHARACTER*20 CHNAME
      CHARACTER*4  CHMECA,CHDEB,CHSET,CHDET,CHMECS(20)
      CHARACTER*32 CHPATL,CHPAR,Cmate,Cpart,Cvec
      External     IGIWTY
* the following is a part of the GCDRAW keeps, forgotten in the official code
      Integer      MyISel
      real         zzfu,zzfv
      Logical      First_QNEXT/.true./
**
**    ------------------------------------------------------------------
**
      IWKSTY = IGIWTY(1)
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'KINE') THEN
         CALL KUGETI(IKINE)
         NPK=NPAR-1
         DO 10 I=1,NPK
            CALL KUGETR(PKINE(I))
   10    CONTINUE
*
      ELSEIF (CHPATL.EQ.'SORD') THEN
         CALL KUGETI(ISTORD)
*
*     ELSEIF (CHPATL.EQ.'PATR') THEN
*        CALL KUGETI(NJTMAX)
*        CALL KUGETI(NJTMIN)
*        WRITE(CHMAIL,'('' *** GXCONT: Parallel tracking disabled, '',
*    +                  ''see documentation'')')
*        CALL GMAIL(1,1)
*
      ELSEIF (CHPATL.EQ.'RUNG') THEN
         CALL KUGETI(IDRUN)
         CALL KUGETI(IDEVT)
*
      ELSEIF (CHPATL.EQ.'GTIME') THEN
         CALL KUGETR(T)
         CALL KUGETR(TIMEND)
         CALL KUGETI(ITIME)
*
      ELSEIF (CHPATL.EQ.'TRACK') THEN
         IF(JXYZ.NE.0)CALL MZDROP(IXDIV,JXYZ,' ')
         IF(JHITS.NE.0)CALL MZDROP(IXDIV,JHITS,' ')
         CALL MZGARB(IXDIV,0)
         CALL GTREVE
*
      ELSEIF (CHPATL.EQ.'TRIGGER') THEN
         CALL KUGETI(N)
         NEVENT=IEVENT+N
         If (First_QNEXT) then
             First_QNEXT=.false.
             CALL QNEXTE
         else
             CALL QNEXT
         endif
*
      ELSEIF (CHPATL.EQ.'SWITCH') THEN
         CALL KUGETI(I)
         IF(I.GE.1.AND.I.LE.10) THEN
            IF(NPAR.LT.2)THEN
               WRITE(CHMAIL,'('' ISWIT('',I2,'')= '',I3)')I,ISWIT(I)
               CALL GMAIL(0,0)
            ENDIF
            CALL KUGETI(ISWIT(I))
         ENDIF
*
      ELSEIF (CHPATL.EQ.'PRINT') THEN
         CALL KUGETC(CHNAME,NCH)
         N=0
         CALL KUGETI(N)
         CALL GPRINT(CHNAME,N)
*
      ELSEIF (CHPATL.EQ.'DEBUG') THEN
         CALL KUGETC(CHDEB,NCH)
         IF(CHDEB.EQ.'ON')THEN
            IDEBUG=max(IDEBUG,1)
            IDEMIN=1
            IDEMAX=1000000
            ITEST =1
            ITIME =1
         ELSE
            IDEBUG=0
            IDEMIN=0
            IDEMAX=0
         ENDIF
*
      ELSEIF (CHPATL.EQ.'OUTPUT_LP') THEN
         CALL KUGETI(LOUT)
*
      ELSEIF (CHPATL.EQ.'PHITS') THEN
         CALL KUGETC(CHSET,NCH)
         CALL KUGETC(CHDET,NCH)
         CALL KUGETI(NUMHIT)
         IPKHIT=NUMHIT
         CALL GPHITS(CHSET,CHDET)
         IPKHIT=0
*
      ELSEIF (CHPATL.EQ.'PDIGI') THEN
         CALL KUGETC(CHSET,NCH)
         CALL KUGETC(CHDET,NCH)
         CALL GPDIGI(CHSET,CHDET)
*
      ELSEIF (CHPATL.EQ.'MZLOGL') THEN
         IXSTOR=0
         LEVEL=0
         CALL KUGETI(LEVEL)
         CALL MZLOGL(IXSTOR,LEVEL)
*
      ELSEIF (CHPATL.EQ.'PMATE') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPMATX(NUMB)
         ELSE
            CALL GPMATE(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'SMATE') THEN
         CALL KUGETI(IMAT)
         CALL KUGETC(Cmate,NCH)
         CALL KUGETR(A)
         CALL KUGETR(Z)
         CALL KUGETR(DENS)
         CALL KUGETR(RADL)
         CALL KUGETR(ABSL)
         CALL KUGETV(Cvec,LLOW,LHIGH)
         CALL KUGETI(NW)
         CALL GSMATE(IMAT,Cmate,A,Z,DENS,RADL,ABSL,QQ(LLOW),NW)
*
      ELSEIF (CHPATL.EQ.'SMIXT') THEN
         CALL KUGETI(IMAT)
         CALL KUGETC(Cmate,NCH)
         CALL KUGETV(Cvec,LLOW,LHIGH)
         CALL KUGETV(Cvec,LLO1,LHIG1)
         CALL KUGETR(DENS)
         CALL KUGETI(NLMAT)
         CALL KUGETV(Cvec,LLO2,LHIG2)
         CALL GSMIXT(IMAT,Cmate,QQ(LLOW),QQ(LLO1),DENS,NLMAT,QQ(LLO2))
*
      ELSEIF (CHPATL.EQ.'PRMAT') THEN
         CALL KUGETI(Imat)
         CALL KUGETI(IPART)
         CALL KUGETC(CHMECA,NCH)
         CALL GPRMAT(Imat,IPART,CHMECA,NEKBIN,ELOW)
*
      ELSEIF (CHPATL.EQ.'DRMAT') THEN
         CALL KUGETI(Imat)
         CALL KUGETI(IPART)
         IF(NPAR.GT.2) THEN
            NMEC = NPAR-2
            DO 11 KMEC=1,NMEC
               CALL KUGETC(CHMECS(KMEC),NCH)
  11        CONTINUE
         ELSE
            NMEC = 1
            CHMECS(1)='ALL'
         ENDIF
         CALL GDRMAT(Imat,IPART,CHMECS,NMEC)
*
      ELSEIF (CHPATL.EQ.'PLMAT') THEN
         CALL KUGETI(Imat)
         CALL KUGETI(IPART)
         CALL KUGETC(CHMECA,NCH)
         IDM=0
         CALL KUGETI(IDM)
         CALL GPLMAT(Imat,IPART,CHMECA,NEKBIN,ELOW,IDM)
*
      ELSEIF (CHPATL.EQ.'SPART') THEN
         CALL KUGETI(IPART)
         CALL KUGETC(Cpart,NCH)
         CALL KUGETI(ITRTYP)
         CALL KUGETR(AMASS)
         CALL KUGETR(CHARGE)
         CALL KUGETR(TLIFE)
         CALL KUGETV(Cvec,LLOW,LHIGH)
         CALL KUGETI(NW)
         CALL GSPART(IPART,Cpart,ITRTYP,AMASS,CHARGE,TLIFE,QQ(LLOW),NW)
         CALL KUGETV(CVEC,LLO1,LHIG1)
         CALL KUGETV(CVEC,LLO2,LHIG2)
         CALL GSDK  (IPART,QQ(LLO1),IQQ(LLO2))
*
      ELSEIF (CHPATL.EQ.'PPART') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPPARX(NUMB)
         ELSE
            CALL GPPART(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'PRKINE') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPKINX(NUMB)
         ELSE
            CALL GPKINE(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'STPAR') THEN
         CALL KUGETI(ITMED)
         CALL KUGETC(CHPAR,NCH)
         CALL KUGETR(PARVAL)
         CALL GSTPAR(ITMED,CHPAR,PARVAL)
*
      ELSEIF (CHPATL.EQ.'RNDM') THEN
         IF (NPAR.EQ.0) THEN
            CALL GRNDMQ(IS1,IS2,0,'G')
            WRITE(CHMAIL, 10000) IS1, IS2
10000       FORMAT('  RANDOM NUMBER = ',2I12)
            CALL GMAIL(0,0)
         ELSEIF (NPAR.EQ.1) THEN
            CALL KUGETI(IS1)
            If (IS1.LE.0) IS1=IGTIME
            IS2 = mod(IS1, 215 ) + 1
            CALL GRNDMQ(0, 0, IS2, ' ')
         ELSEIF (NPAR.EQ.2) THEN
            CALL KUGETI(NRNDM(1))
            CALL KUGETI(NRNDM(2))
            If (NRNDM(2).GT.0) THEN
               CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'S')
            else
               IS1 = mod (NRNDM(1),215) + 1
               CALL GRNDMQ( 0, 0, IS1, ' ')
            endif
         ELSE
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
10100       FORMAT(' Please give up to 2 seeds to initialize',
     +             ' the random number generator')
         ENDIF
         CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'G')
      ENDIF
*
   30 END
 
+DECK,GXPHYS.
*CMZ :  1.30/00 06/07/96  18.25.27  by  Pavel Nevski
*CMZ :  3.21/04 09/11/94  15.31.28  by  S.Ravndal
*-- Author :    R.Brun
      SUBROUTINE GXPHYS
**
**    ******************************************************************
**    *                                                                *
**    *      Physics parameters control commands                       *
**    *                                                                *
**    *       Author:    R.Brun      **********                        *
**    *                                                                *
**    * Modifications:                                PN 06 July 96    *
**    * - strong typing introduced to find undefined variables         *
**    * - GCTRAK.IGAUTO was missing                                    *
**    * - ICKOV was never used. GTMED.ITCKOV is read instead           *
**    * - ITCKOV and ILABS correlated as in GFFGO                      *
**    ******************************************************************
**
+CDE,TYPING,GCBANK,GCPHYS,GCCUTS,GCONSt,GCUNIT,GCMULO,GCTMED,GCTRAK.
*
      Integer       Npar,i,j,Ipart,Imate,Npoint,JTM,JTMi,JM,JMA
      Real          Stepa
      Real          UCUTS(10),ULCUTS(10)
      EQUIVALENCE  (UCUTS(1),CUTGAM)
      Integer       MECA(5,13)
      EQUIVALENCE  (MECA(1,1),IPAIR)
      CHARACTER*6   CUTNAM(10)
      CHARACTER*4   CEN(10)
      CHARACTER*32  CHPATL
      CHARACTER*10  CHNUMB
      PARAMETER    (CHNUMB='1234567890')
      DATA  CUTNAM/'CUTGAM','CUTELE','CUTNEU','CUTHAD','CUTMUO',
     +             'BCUTE' ,'BCUTM' ,'DCUTE' ,'DCUTM' ,'PPCUTM'/
**
**    ------------------------------------------------------------------
**
      CALL KUPATL(CHPATL,NPAR)
*
      IF(CHPATL.EQ.'ANNI')THEN
         CALL KUGETI(IANNI)
*
      ELSEIF(CHPATL.EQ.'AUTO')THEN
         CALL KUGETI(IGAUTO)
*
      ELSEIF(CHPATL.EQ.'BREM')THEN
         CALL KUGETI(IBREM)
*
      ELSEIF(CHPATL.EQ.'CKOV')THEN
         CALL KUGETI(ITCKOV)
*
      ELSEIF(CHPATL.EQ.'COMP')THEN
         CALL KUGETI(ICOMP)
*
      ELSEIF(CHPATL.EQ.'DCAY')THEN
         CALL KUGETI(IDCAY)
*
      ELSEIF(CHPATL.EQ.'DRAY')THEN
         CALL KUGETI(IDRAY)
*
      ELSEIF(CHPATL.EQ.'ERAN')THEN
         CALL KUGETR(EKMIN)
         CALL KUGETR(EKMAX)
         CALL KUGETI(NEKBIN)
         NEKBIN=MIN(NEKBIN,199)
*
      ELSEIF(CHPATL.EQ.'HADR')THEN
         CALL KUGETI(IHADR)
*
      ELSEIF(CHPATL.EQ.'LABS')THEN
         CALL KUGETI(ILABS)
*
      ELSEIF(CHPATL.EQ.'LOSS')THEN
         CALL KUGETI(ILOSS)
         IF(ILOSS.EQ.2)THEN
            IDRAY=0
         ELSE
            IDRAY=1
         ENDIF
*
      ELSEIF(CHPATL.EQ.'MULS')THEN
         CALL KUGETI(IMULS)
*
      ELSEIF(CHPATL.EQ.'MUNU')THEN
         CALL KUGETI(IMUNU)
*
      ELSEIF(CHPATL.EQ.'PAIR')THEN
         CALL KUGETI(IPAIR)
*
      ELSEIF(CHPATL.EQ.'PFIS')THEN
         CALL KUGETI(IPFIS)
*
      ELSEIF(CHPATL.EQ.'PHOT')THEN
         CALL KUGETI(IPHOT)
*
      ELSEIF(CHPATL.EQ.'RAYL')THEN
         CALL KUGETI(IRAYL)
*
      ELSEIF(CHPATL.EQ.'STRA')THEN
         CALL KUGETI(ISTRA)
*
      ELSEIF(CHPATL.EQ.'SYNC')THEN
         CALL KUGETI(ISYNC)
*
      ELSEIF(CHPATL.EQ.'CUTS')THEN
         IF(NPAR.LE.0)THEN
            WRITE(LOUT,10000)
10000       FORMAT(/,' Current PHYSICS parameters:',/)
            DO 10 I=1,10
               CALL GEVKEV(UCUTS(I),ULCUTS(I),CEN(I))
               WRITE(LOUT,10100)CUTNAM(I),ULCUTS(I),CEN(I)
10100          FORMAT(5X,A,' = ',F7.2,1X,A)
   10       CONTINUE
            GO TO 999
         ENDIF
         CALL KUGETR(CUTGAM)
         CALL KUGETR(CUTELE)
         CALL KUGETR(CUTHAD)
         CALL KUGETR(CUTNEU)
         CALL KUGETR(CUTMUO)
         CALL KUGETR(BCUTE)
         CALL KUGETR(BCUTM)
         CALL KUGETR(DCUTE)
         CALL KUGETR(DCUTM)
         CALL KUGETR(PPCUTM)
         CALL KUGETR(TOFMAX)
         CALL KUGETR(GCUTS(1))
         IF(BCUTE.LE.0.)BCUTE=CUTGAM
         IF(BCUTM.LE.0.)BCUTM=CUTGAM
         IF(DCUTE.LE.0.)DCUTE=CUTELE
         IF(DCUTM.LE.0.)DCUTM=CUTELE
         IF(PPCUTM.LT.4.*EMASS)PPCUTM=4.*EMASS
*
      ELSEIF(CHPATL.EQ.'DRPRT')THEN
         CALL KUGETI(IPART)
         CALL KUGETI(IMATE)
         CALL KUGETR(STEPA)
         CALL KUGETI(NPOINT)
         CALL GDRPRT(IPART,IMATE,STEPA,NPOINT)
*
      ELSEIF(CHPATL.EQ.'PHYSI')THEN
         IF(JTMED.GT.0)THEN
            DO 30 I=1,IQ(JTMED-2)
               JTM=LQ(JTMED-I)
               IF(JTM.LE.0)GO TO 30
               IF(IQ(JTM-2).EQ.0)THEN
                  CALL MZPUSH(IXCONS,JTM,10,0,'I')
                  GO TO 30
               ENDIF
               DO 20 J=1,10
                  JTMI=LQ(JTM-J)
                  IF(JTMI.GT.0)THEN
                     CALL MZDROP(IXCONS,JTMI,' ')
                  ENDIF
   20          CONTINUE
   30       CONTINUE
            CALL UCOPY(CUTGAM,Q(JTMED+1),10)
            DO 40 I=1,13
               Q(JTMED+10+I)=MECA(1,I)
   40       CONTINUE
         ENDIF
         IF(JMATE.LE.0)GO TO 999
         DO 60 I=1,IQ(JMATE-2)
            JMA=LQ(JMATE-I)
            IF(JMA.LE.0)GO TO 60
            DO 50 J=1,IQ(JMA-2)
               IF(J.EQ.4.OR.J.EQ.5)GO TO 60
               JM=LQ(JMA-J)
               IF(JM.LE.0)GO TO 50
               CALL MZDROP(IXCONS,JM,'L')
   50       CONTINUE
   60    CONTINUE
         CALL MZGARB (IXCONS, 0)
         CALL GPHYSI
      ENDIF
*
      IF(ILABS.NE.0 .and. ITCKOV.NE.0) ILABS=1
*
  999 END
+DECK,GBRSGE.
*CMZ :  1.30/00 30/10/96  18.46.07  by  Pavel Nevski
*-- Author :    L.Urban
      FUNCTION GBRSGE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) electron BREMSSTRAHLUNG.                   *
C.    *         (SIG in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRSGA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    *  correction for T> 100 GeV !  (by L.Urban on 23/09/96)         *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCMATE
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      SAVE C
+SELF,IF=-BETHE.
      PARAMETER (AKSI=1.80,ALFA=0.98,VS=0.0001)
      DATA C1/ 0.430748E-02, 0.576058E-02,-0.122564E-02, 0.114843E-03
     +      ,-0.489452E-05, 0.795991E-07, 0.326746E-02,-0.132872E-02
     +      , 0.217197E-03,-0.179769E-04, 0.766114E-06,-0.125603E-07
     +      , 0.326452E-02,-0.175331E-02, 0.415488E-03,-0.507652E-04
     +      , 0.297569E-05,-0.651741E-07, 0.847189E-03,-0.433923E-03
     +      , 0.116672E-03,-0.166799E-04, 0.110237E-05,-0.263383E-07
     +      , 0.846052E-04,-0.415764E-04, 0.129610E-04,-0.212844E-05
     +      , 0.152871E-06,-0.384393E-08, 0.300838E-05,-0.136833E-05
     +      , 0.507296E-06,-0.943623E-07, 0.720305E-08,-0.187210E-09
     +      , 0.448230E-01,-0.210048E-01, 0.379434E-02,-0.328431E-03
     +      , 0.136710E-04,-0.220593E-06,-0.539248E-02, 0.330244E-02
     +      ,-0.733726E-03, 0.732312E-04,-0.336810E-05, 0.583913E-07
     +      ,-0.106983E-02, 0.378021E-03,-0.384854E-04, 0.978156E-06
     +      , 0.410622E-07,-0.174250E-08,-0.117501E-04,-0.983887E-05
     +      , 0.239644E-05,-0.190104E-06, 0.619226E-08,-0.680932E-10/
      DATA C2/ 0.168074E-03,-0.934609E-04, 0.141293E-04,-0.854216E-06
     +      , 0.183287E-07, 0.932144E-04,-0.234926E-04, 0.136656E-05
     +      , 0.351109E-07,-0.330189E-08, 0.174523E-04, 0.253854E-05
     +      ,-0.171643E-05, 0.183074E-06,-0.566331E-08, 0.111970E-05
     +      , 0.112776E-05,-0.386924E-06, 0.367597E-07,-0.108504E-08
     +      , 0.171604E-07, 0.738801E-07,-0.218761E-07, 0.199032E-08
     +      ,-0.576173E-10,-0.105531E-03, 0.362995E-04,-0.433334E-05
     +      , 0.207664E-06,-0.330250E-08,-0.168293E-05,-0.773204E-06
     +      , 0.227974E-06,-0.159385E-07, 0.321958E-09, 0.167046E-05
     +      ,-0.440761E-06, 0.396377E-07,-0.151053E-08, 0.215624E-10/
+SELF,IF=BETHE.
      PARAMETER (AKSI=1.80,ALFA=1.00,VS=0.0001)
      DATA C1/ 0.111394E-01, 0.138592E-02,-0.274910E-03, 0.198389E-04
     +      ,-0.472291E-06,-0.668760E-09, 0.839876E-02,-0.449619E-02
     +      , 0.917722E-03,-0.874992E-04, 0.390015E-05,-0.653499E-07
     +      , 0.464718E-02,-0.260321E-02, 0.582582E-03,-0.631769E-04
     +      , 0.325801E-05,-0.638109E-07, 0.101243E-02,-0.532089E-03
     +      , 0.129100E-03,-0.161260E-04, 0.958116E-06,-0.212606E-07
     +      , 0.926006E-04,-0.455288E-04, 0.124755E-04,-0.182510E-05
     +      , 0.122078E-06,-0.294182E-08, 0.308111E-05,-0.134712E-05
     +      , 0.436230E-06,-0.751770E-07, 0.552327E-08,-0.140541E-09
     +      , 0.292552E-02,-0.830719E-03, 0.210705E-04, 0.103750E-04
     +      ,-0.953318E-06, 0.236453E-07, 0.110907E-02,-0.219463E-03
     +      , 0.128517E-04,-0.554575E-06, 0.507378E-07,-0.182214E-08
     +      ,-0.639866E-03, 0.209918E-03,-0.250183E-04, 0.138030E-05
     +      ,-0.358845E-07, 0.366305E-09, 0.300095E-04,-0.133668E-04
     +      , 0.198606E-05,-0.133100E-06, 0.414062E-08,-0.485929E-10/
      DATA C2/ 0.938677E-04,-0.613470E-04, 0.981984E-05,-0.646289E-06
     +      , 0.150731E-07, 0.331764E-04, 0.447248E-05,-0.313021E-05
     +      , 0.329777E-06,-0.997210E-08, 0.876484E-08, 0.110042E-04
     +      ,-0.313406E-05, 0.280040E-06,-0.794116E-08,-0.103097E-05
     +      , 0.220550E-05,-0.569158E-06, 0.491359E-07,-0.136987E-08
     +      ,-0.781963E-07, 0.123162E-06,-0.302825E-07, 0.255485E-08
     +      ,-0.702300E-10,-0.193213E-03, 0.640349E-04,-0.720586E-05
     +      , 0.329673E-06,-0.514682E-08, 0.362138E-04,-0.142783E-04
     +      , 0.184063E-05,-0.967983E-07, 0.179386E-08, 0.496130E-06
     +      , 0.210105E-06,-0.538512E-07, 0.372388E-08,-0.812734E-10/
+SELF.
C.
      DATA THIGH,CHIGH/100.,50./
C.    ------------------------------------------------------------------
C.
      GBRSGE=0.
*
      IF(BCUT.LE.0.) GOTO 99
      IF(BCUT.GE.T) GOTO 99
*
      IF(T.GT.THIGH) THEN
          TT=THIGH
        IF(BCUT.GE.THIGH) THEN
            EC=CHIGH
        ELSE
            EC=BCUT
        ENDIF
      ELSE
          TT=T
          EC=BCUT
      ENDIF
*
      E=TT+EMASS
*
C
      X=LOG(E/EMASS)
      Y=LOG(E*VS/EC)
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=ZZ*(ZZ+AKSI)*E*E*(LOG(TT/EC))**ALFA/(TT*(E+EMASS))
      IF(FAC.LE.0.) GOTO 99
C
      GBRSGE=FAC*S
*
      IF(T.GT.THIGH) THEN
 
       IF(BCUT.LT.THIGH) THEN
        RAT=BCUT/T
        S=(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
        RAT=BCUT/TT
        S=S/(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
       ELSE
        RAT=BCUT/T
        S=(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
        RAT=EC/TT
        S=S/(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
       ENDIF
 
        GBRSGE=GBRSGE*S
      ENDIF
*
99    RETURN
*
      END
+DECK,GBRELE.
*CMZ :  1.30/00 30/10/96  18.44.39  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :      L.Urban
      FUNCTION GBRELE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates energy loss by soft Bremsstrahlung                 *
C.    *         (in GeV barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRELA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *  corrected by L.Urban on 23/09/96                              *
C.    *    ( correction for T>100. GeV)                                *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCMATE
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
+SELF,IF=-BETHE.
      DATA C1/-0.960613E-01, 0.631029E-01,-0.142819E-01, 0.150437E-02
     +      ,-0.733286E-04, 0.131404E-05, 0.859343E-01,-0.529023E-01
     +      , 0.131899E-01,-0.159201E-02, 0.926958E-04,-0.208439E-05
     +      ,-0.684096E+01, 0.370364E+01,-0.786752E+00, 0.822670E-01
     +      ,-0.424710E-02, 0.867980E-04,-0.200856E+01, 0.129573E+01
     +      ,-0.306533E+00, 0.343682E-01,-0.185931E-02, 0.392432E-04
     +      , 0.127538E+01,-0.515705E+00, 0.820644E-01,-0.641997E-02
     +      , 0.245913E-03,-0.365789E-05, 0.115792E+00,-0.463143E-01
     +      , 0.725442E-02,-0.556266E-03, 0.208049E-04,-0.300895E-06
     +      ,-0.271082E-01, 0.173949E-01,-0.452531E-02, 0.569405E-03
     +      ,-0.344856E-04, 0.803964E-06, 0.419855E-02,-0.277188E-02
     +      , 0.737658E-03,-0.939463E-04, 0.569748E-05,-0.131737E-06
     +      ,-0.318752E-03, 0.215144E-03,-0.579787E-04, 0.737972E-05
     +      ,-0.441485E-06, 0.994726E-08, 0.938233E-05,-0.651642E-05
     +      , 0.177303E-05,-0.224680E-06, 0.132080E-07,-0.288593E-09/
      DATA C2/-0.245667E-03, 0.833406E-04,-0.129217E-04, 0.915099E-06
     +      ,-0.247179E-07, 0.147696E-03,-0.498793E-04, 0.402375E-05
     +      , 0.989281E-07,-0.133378E-07,-0.737702E-02, 0.333057E-02
     +      ,-0.553141E-03, 0.402464E-04,-0.107977E-05,-0.641533E-02
     +      , 0.290113E-02,-0.477641E-03, 0.342008E-04,-0.900582E-06
     +      , 0.574303E-05, 0.908521E-04,-0.256900E-04, 0.239921E-05
     +      ,-0.741271E-07,-0.341260E-04, 0.971711E-05,-0.172031E-06
     +      ,-0.119455E-06, 0.704166E-08, 0.341740E-05,-0.775867E-06
     +      ,-0.653231E-07, 0.225605E-07,-0.114860E-08,-0.119391E-06
     +      , 0.194885E-07, 0.588959E-08,-0.127589E-08, 0.608247E-10/
      DATA AKSI,BETA,VE/2.51,0.99,0.00004/
+SELF,IF=BETHE.
      DATA C1/ 0.834459E-02, 0.443979E-02,-0.101420E-02, 0.963240E-04
     +      ,-0.409769E-05, 0.642589E-07, 0.464473E-02,-0.290378E-02
     +      , 0.547457E-03,-0.426949E-04, 0.137760E-05,-0.131050E-07
     +      ,-0.547866E-02, 0.156218E-02,-0.167352E-03, 0.101026E-04
     +      ,-0.427518E-06, 0.949555E-08,-0.406862E-02, 0.208317E-02
     +      ,-0.374766E-03, 0.317610E-04,-0.130533E-05, 0.211051E-07
     +      , 0.158941E-02,-0.385362E-03, 0.315564E-04,-0.734968E-06
     +      ,-0.230387E-07, 0.971174E-09, 0.467219E-03,-0.154047E-03
     +      , 0.202400E-04,-0.132438E-05, 0.431474E-07,-0.559750E-09
     +      ,-0.220958E-02, 0.100698E-02,-0.596464E-04,-0.124653E-04
     +      , 0.142999E-05,-0.394378E-07, 0.477447E-03,-0.184952E-03
     +      ,-0.152614E-04, 0.848418E-05,-0.736136E-06, 0.190192E-07
     +      ,-0.552930E-04, 0.209858E-04, 0.290001E-05,-0.133254E-05
     +      , 0.116971E-06,-0.309716E-08, 0.212117E-05,-0.103884E-05
     +      ,-0.110912E-06, 0.655143E-07,-0.613013E-08, 0.169207E-09/
      DATA C2/ 0.301125E-04,-0.461920E-04, 0.871485E-05,-0.622331E-06
     +      , 0.151800E-07,-0.478023E-04, 0.247530E-04,-0.381763E-05
     +      , 0.232819E-06,-0.494487E-08,-0.336230E-04, 0.223822E-04
     +      ,-0.384583E-05, 0.252867E-06,-0.572599E-08, 0.105335E-04
     +      ,-0.567074E-06,-0.216564E-06, 0.237268E-07,-0.658131E-09
     +      , 0.282025E-05,-0.671965E-06, 0.565858E-07,-0.193843E-08
     +      , 0.211839E-10, 0.157544E-04,-0.304104E-05,-0.624410E-06
     +      , 0.120124E-06,-0.457445E-08,-0.188222E-05,-0.407118E-06
     +      , 0.375106E-06,-0.466881E-07, 0.158312E-08, 0.945037E-07
     +      , 0.564718E-07,-0.319231E-07, 0.371926E-08,-0.123111E-09/
      DATA AKSI,BETA,VE/2.10,1.00,0.001/
+SELF.
      DATA CORFAC/0.805485E-10/
C.
      DATA THIGH,CHIGH/100.,50./
C.    ------------------------------------------------------------------
C.
      GBRELE=0.
 
      IF(BCUT.LE.0.) GOTO 99
************************************
      CUTSAV=BCUT
      IF(BCUT.GT.T) BCUT=T
*************************************
      IF(T.GT.THIGH) THEN
          TT=THIGH
        IF(BCUT.GE.THIGH) THEN
            EC=CHIGH
        ELSE
            EC=BCUT
        ENDIF
      ELSE
          TT=T
          EC=BCUT
      ENDIF
 
      E=TT+EMASS
      IF(BCUT.GT.TT) EC=TT
C
      X=LOG(TT/EMASS)
      Y=LOG(EC/(E*VE))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
             ENDIF
             XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
+SELF,IF=-BETHE.
      CORR=1./(1.+CORFAC*DENS*Z*E*E/(A*EC*EC))
+SELF,IF=BETHE.
      CORR=1.
+SELF.
      FAC=ZZ*(ZZ+AKSI)*E*E*(EC*CORR/TT)**BETA/(E+EMASS)
      IF(FAC.LE.0.) GOTO 99
C
      GBRELE=FAC*S
 
      IF(T.GT.THIGH) THEN
 
       IF(BCUT.LT.THIGH) THEN
        RAT=BCUT/T
        S=(1.-0.5*RAT+2.*RAT*RAT/9.)
        RAT=BCUT/TT
        S=S/(1.-0.5*RAT+2.*RAT*RAT/9.)
       ELSE
        RAT=BCUT/T
        S=BCUT*(1.-0.5*RAT+2.*RAT*RAT/9.)
        RAT=EC/TT
        S=S/(EC*(1.-0.5*RAT+2.*RAT*RAT/9.))
       ENDIF
 
        GBRELE=GBRELE*S
      ENDIF
******************************************
      BCUT=CUTSAV
******************************************
C
  99  RETURN
      END
 
 
+DECK,GPAIRG.
*CMZ :  1.30/00 19/09/96  18.01.50  by  Pavel Nevski
*CMZ :  3.21/04 21/02/95  11.53.59  by  S.Giani
*-- Author :
      SUBROUTINE GPAIRG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates e+e- pair production by photons.                    *
C.    *                                                                *
C.    *  The secondary electron energies are sampled using the         *
C.    *  Coulomb corrected BETHE-HEITLER cross-sections.For this the   *
C.    *   modified version of the random number techniques of          *
C.    *   BUTCHER and MESSEL (NUCL.PHYS,20(1960),15) are employed.     *
C.    *                                                                *
C.    *  NOTE :                                                        *
C.    *  (1) Effects due to the breakdown of the BORN approximation at *
C.    *      low energies are ignored.                                 *
C.    *  (2) The differential cross-section implicitly takes account   *
C.    *      of pair production in both nuclear and atomic electron    *
C.    *      fields. However, triplet production is not generated.     *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    *  Correction: S.Randval:  PEL1 = SQRT((EEL1+EMASS)*TEL1)        *
C.    ******************************************************************
C.
+CDE,GCBANK
+CDE,GCJLOC
+CDE,GCONSP
+CDE,GCTRAK
+CDE,GCKING
+CDE,GCPHYS
+CDE,GCCUTS
      DIMENSION NTYPEL(2)
      DIMENSION RNDM(2)
      LOGICAL ROTATE
      PARAMETER (ONE=1,ONETHR=ONE/3,EMAS2=2*EMASS)
C.
C.    ------------------------------------------------------------------
C.
C             If not enough energy : no pair production
C
      EGAM   = VECT(7)
      IF (EGAM.LT.EMAS2) GO TO 999
C
      KCASE  = NAMEC(6)
      IF(IPAIR.NE.1) THEN
         ISTOP  = 2
         NGKINE = 0
         DESTEP = DESTEP + EGAM
         VECT(7)= 0.
         GEKIN  = 0.
         GETOT  = 0.
         GO TO 999
      ENDIF
C
C             For low energy photons approximate the electron energy by
C             sampling from a uniform distribution in the interval
C             EMASS -> EGAM/2.
C
      IF (EGAM.LE.2.1E - 03)THEN
         CALL GRNDM(RNDM,1)
         EEL1   = EMASS + (RNDM(1)*(0.5*EGAM - EMASS))
         X=EEL1/EGAM
         GO TO 20
      ENDIF
C
      Z3=Q(JPROB+2)
      F=8.*Q(JPROB+3)
      IF(EGAM.GT.0.05) F=F+8.*Q(JPROB+4)
      X0=EMASS/EGAM
      DX=0.5-X0
      DMIN=544.*X0/Z3
      DMIN2=DMIN*DMIN
      IF(DMIN.LE.1.)THEN
         F10=42.392-7.796*DMIN+1.961*DMIN2-F
         F20=41.405-5.828*DMIN+0.8945*DMIN2-F
      ELSE
         F10=42.24-8.368*LOG(DMIN+0.952)-F
         F20=F10
      ENDIF
C
C             Calculate limit for screening variable,DELTA, to ensure
C             that screening rejection functions always remain
C             positive.
C
      DMAX=EXP((42.24-F)/8.368)-0.952
C
C             Differential cross-section factors which form
C             the coefficients of the screening functions.
C
      DSIG1=DX*DX*F10/3.
      DSIG2=0.5*F20
      BPAR   = DSIG1 / (DSIG1 + DSIG2)
C
C             Decide which screening rejection function to use and
C             sample the electron/photon fractional energy BR.
C
   10 CALL GRNDM(RNDM,2)
      IF(RNDM(1).LT.BPAR)THEN
         X=0.5-DX*RNDM(2)**ONETHR
         IREJ=1
      ELSE
         X=X0+DX*RNDM(2)
         IREJ   = 2
      ENDIF
C
C             Calculate DELTA ensuring positivity.
C
      D=0.25*DMIN/(X*(1.-X))
      IF(D.GE.DMAX) GOTO 10
      D2=D*D
C
C             Calculate F1 and F2 functions using approximations.
C             F10 and F20 are the F1 and F2 functions calculated for the
C             DELTA=DELTA minimum.
C
      IF(D.LE.1.)THEN
         F1=42.392-7.796*D+1.961*D2-F
         F2=41.405-5.828*D+0.8945*D2-F
      ELSE
         F1=42.24-8.368*LOG(D+0.952)-F
         F2=F1
      ENDIF
      IF(IREJ.NE.2)THEN
         SCREJ=F1/F10
      ELSE
         SCREJ=F2/F20
      ENDIF
C
C             Accept or reject on basis of random variate.
C
      CALL GRNDM(RNDM,1)
      IF(RNDM(1).GT.SCREJ) GOTO 10
      EEL1=X*EGAM
C
C             Successful sampling of first electron energy.
C
C             Select charges randomly.
C
   20 NTYPEL(1) = 2
      CALL GRNDM(RNDM,2)
      IF (RNDM(1).GT.0.5) NTYPEL(1) = 3
      NTYPEL(2) = 5 - NTYPEL(1)
C
C             Generate electron decay angles with respect to a Z-axis
C             defined along the parent photon.
C             PHI is generated isotropically and THETA is assigned
C             a universal angular distribution
C
      EMASS1 = EMASS
      THETA  = GBTETH(EEL1, EMASS1, X)*EMASS/EEL1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      PHI    = TWOPI*RNDM(2)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Rotate tracks into GEANT system
C
      CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
      NGKINE = 0
      TEL1 = EEL1 - EMASS
      PEL1 = SQRT((EEL1+EMASS)*TEL1)
      IF(TEL1.GT.CUTELE) THEN
         PEL1 = SQRT((EEL1+EMASS)*TEL1)
         NGKINE = NGKINE + 1
         GKIN(1,NGKINE) = PEL1 * SINTH * COSPHI
         GKIN(2,NGKINE) = PEL1 * SINTH * SINPHI
         GKIN(3,NGKINE) = PEL1 * COSTH
         GKIN(4,NGKINE) = EEL1
         GKIN(5,NGKINE) = NTYPEL(1)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL1
         IF(NTYPEL(1).EQ.2) CALL GANNI2
      ENDIF
C
C             Momentum vector of second electron. Recoil momentum of
C             target nucleus/electron ignored.
C
      EEL2=EGAM-EEL1
      TEL2=EEL2-EMASS
      IF(TEL2.GT.CUTELE) THEN
         PEL2 = SQRT((EEL2+EMASS)*TEL2)
         NGKINE = NGKINE + 1
         SINTH=SINTH*PEL1/PEL2
         COSTH=SQRT(MAX(0.,1.-SINTH**2))
         GKIN(1,NGKINE)=-PEL2*SINTH*COSPHI
         GKIN(2,NGKINE)=-PEL2*SINTH*SINPHI
         GKIN(3,NGKINE)=PEL2*COSTH
         GKIN(4,NGKINE)=EEL2
         GKIN(5,NGKINE) = NTYPEL(2)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL2
         IF(NTYPEL(2).EQ.2) CALL GANNI2
      ENDIF
      ISTOP = 1
      IF(NGKINE.EQ.0) ISTOP = 2
 999  END
 
 
+DECK,gtnex1.
*CMZ :  1.30/00 09/09/96  22.04.42  by  Pavel Nevski
*CMZ :  3.21/04 21/03/95  16.13.08  by  S.Giani
*-- Author :
      SUBROUTINE GTNEX1
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *                                                                *
C.    *   Author   : S.Giani (1993)                                    *
C.    *                                                                *
C.    *   This routine is now based on the new 'virtual divisions'     *
C.    *    algorithm to speed up the tracking.                         *
C.    *   The tracking for MANY volumes is not anymore based on a step *
C.    *    search: it is now based on a search through the list of     *
C.    *    'possible overlapping volumes' built by GTMEDI.             *
C.    *    Boolean operations and divisions along arbitrary axis are   *
C.    *     now supported.                                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+SEQ, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SEQ,GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
+SEQ, GCVDMA.
      DIMENSION NUMTMP(15),NAMTMP(15)
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      CHARACTER*4 NAME
      dimension iarrin(500),cxm(3),xxm(6)
      REAL      X0(6), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      mycoun=0
      myinfr=0
      newfl=0
      manyfl=0
      tsafet=big
      tsnext=big
401   IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      sneold=SNEXT
      nnn=0
      nflag=0
      mmm=0
      snxtot=0.
 111  if(nin.gt.1)then
        if(nnn.gt.0)goto 112
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.eq.4)then
         do 1 i=1,6
          xxm(i)=xc(i)
 1       continue
        endif
        divthi=(chmoth-clmoth)/ndivto
        if(iaxis.le.3)then
          cx=xc(iaxis)
          if(xc(iaxis+3).ge.0.)then
            inc=1
          else
            inc=-1
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.4)then
            dr= xc(1)*xc(4)+xc(2)*xc(5)
*            if(dr.eq.0.)print *,'dr.eq.0.'
            if(dr.ge.0.)then
              inc=1
            else
              inc=-1
            endif
          elseif(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
            dfi=xc(1)*xc(5)-xc(2)*xc(4)
            if(dfi.ge.0)then
              inc=1
            else
              inc=-1
            endif
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
 112    iofset=iq(jvdiv+ivdiv)
        jcont2=jvdiv+iofset+1
        ncont=iq(jcont2)
        if(ncont.eq.0)then
          idmi=iq(jcont2+1)
          idma=iq(jcont2+2)
          llflag=0
        elseif(ncont.eq.1)then
          idmi=iq(jcont2+2)
          idma=iq(jcont2+3)
          in=iq(jcont2+1)
        else
          idmi=iq(jcont2+ncont+1)
          idma=iq(jcont2+ncont+2)
          iii=1
          in=iq(jcont2+iii)
        endif
        if(nnn.eq.0)then
         cxold=cx
         if(inc.gt.0)then
          cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
          if(iaxis.ne.6)then
           safety=min(safety,(cxold-cmin))
          else
           safefi=min(90.,(cxold-cmin))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         else
          cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
          if(iaxis.ne.6)then
           safety=min(safety,(cmax-cxold))
          else
           safefi=min(90.,(cmax-cxold))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         endif
        endif
        if(ncont.eq.0)goto 181
      elseif(nin.eq.1)then
        in=1
      endif
*
  150 if(nin.gt.1.and.ncont.gt.1)then
        in=iq(jcont2+iii)
      endif
      if(nin.gt.0)then
*        if(infrom.gt.0.and.myinfr.eq.0.and.newfl.eq.0)then
*          if(in.eq.infrom)goto 171
*        endif
        jin=lq(jvo-in)
        if(.NOT.BTEST(iq(jin),4))then
        else
          goto 171
        endif
      endif
      if(nin.gt.1)then
        llflag=0
        if(mmm.le.500)then
         do 151 ll=1,mmm
          if(iarrin(ll).eq.in)then
            llflag=1
            goto 171
          endif
 151     continue
        endif
        if(llflag.eq.0)then
          mmm=mmm+1
          if(mmm.le.500)then
            iarrin(mmm)=in
          endif
        endif
      endif
      IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 179
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
 179  if((nin.eq.1).or.(nin.gt.1.and.llflag.eq.0))then
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
      ENDIF
      endif
 171  if(nin.eq.1)then
        goto 300
      elseif(nin.ge.1.and.ncont.gt.1)then
           iii=iii+1
           if(iii.le.ncont)goto 150
      endif
*
*   *         Compute distance to boundary of current volume
*
 181  if(nnn.eq.0)then
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               safe=max(safe,0.)
               if(snxt.le.-prec)snxt=big1
               snxt=max(snxt,0.)
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
      endif
      if(iaxis.eq.4)then
       if(idma.eq.ndivto.and.inc.gt.0)goto 400
        cxm(1)=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
        if(idmi.eq.idma)then
          cxm(2)=cxm(1)+divthi
        else
          cxm(2)=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
        endif
        cxm(3)=20000.
        call gntube(xxm,cxm,3,1,SNEXT,snxnew,safe)
        if(snxnew.lt.0.)snxnew=big1
        snxnew=snxnew+.004
        snxtot=snxtot+snxnew
        if(snxtot.lt.SNEXT)then
          xxm(1)=xxm(1)+snxnew*xxm(4)
          xxm(2)=xxm(2)+snxnew*xxm(5)
          xxm(3)=xxm(3)+snxnew*xxm(6)
          call gfcoor(xxm,iaxis,cxnew)
          xevdiv=((cxnew-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xevdiv
          dr= xxm(1)*xxm(4)+xxm(2)*xxm(5)
*          if(dr.eq.0.)print *,'dr.eq.0.'
          if(dr.ge.0.)then
              inc=1
          else
              inc=-1
          endif
          if((xevdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
              ivdiv=1
          elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
          endif
          nnn=nnn+1
          goto 111
        else
          if(inc.gt.0)then
           cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
           safety=min(safety,(cmax-cxold))
          else
           cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
           safety=min(safety,(cxold-cmin))
          endif
          goto 400
        endif
      endif
          if(nnn.ne.0.and.SNEXT.eq.sneold)goto 199
               x0(1) = xc(1) + SNEXT*xc(4)
               x0(2) = xc(2) + SNEXT*xc(5)
               x0(3) = xc(3) + SNEXT*xc(6)
               x0(4) = xc(4)
               x0(5) = xc(5)
               x0(6) = xc(6)
          if(iaxis.le.3)then
            cx=x0(iaxis)
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          else
            call gfcoor(x0,iaxis,cx)
            if(iaxis.eq.6)then
             if((cx-clmoth).lt.-1.)then
              cx=cx+360.
             elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
             endif
             if(cx.gt.chmoth)then
              cx=chmoth
             elseif(cx.lt.clmoth)then
              cx=clmoth
             endif
            endif
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          endif
 199      if(ievdiv.ge.idmi.and.ievdiv.le.idma)then
            if(inc.gt.0)then
             cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
             if(iaxis.ne.6)then
              safety=min(safety,(cmax-cxold))
             else
              safefi=min(90.,(cmax-cxold))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            else
             cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
             if(iaxis.ne.6)then
              safety=min(safety,(cxold-cmin))
             else
              safefi=min(90.,(cxold-cmin))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            endif
            goto 400
          endif
          if(iaxis.eq.6.or.iaxis.le.3)then
           if(ievdiv.lt.idmi.and.inc.gt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idmi=',idmi,' inc.gt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safety=min(safety,abs(cmax-cxold))
             elseif(iaxis.eq.6)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safefi=min(90.,(cmax-cxold))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           elseif(ievdiv.gt.idma.and.inc.lt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idma=',idma,' inc.lt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safety=min(safety,abs(cxold-cmin))
             elseif(iaxis.eq.6)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safefi=min(90.,(cxold-cmin))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           endif
          endif
          nnn=nnn+1
          sneold=SNEXT
          if(inc.gt.0)then
            if(iaxis.eq.6)then
             if(idma.eq.ndivto.and.(chmoth-clmoth).eq.360.)then
               ivdiv=1
             else
               ivdiv=idma+1
             endif
            else
             ivdiv=idma+1
            endif
          else
            if(iaxis.eq.6)then
             if(idmi.eq.1.and.(chmoth-clmoth).eq.360.)then
               ivdiv=ndivto
             else
               ivdiv=idmi-1
             endif
            else
             ivdiv=idmi-1
            endif
          endif
          goto 111
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         if(raytra.eq.1.)ingoto=-1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      if(nin.eq.1.and.ignext.ne.0)then
        if(q(jin+8).eq.0.)iact=1
      endif
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
 400  if(iswit(9).eq.123456789.and.Q(JVO+3).gt.1.)then
        print *,'n. of checked objects = ',mmm
      endif
      if(myinfr.gt.0)then
        jin=lq(jvo-myinfr)
        iq(jin)=ibclr(iq(jin),4)
        myinfr=0
      endif
      if(gonly(nlevel).eq.0..or.nvmany.ne.0) THEN
         if(safety.lt.tsafet)tsafet=safety
         if(snext.lt.tsnext)then
          mycoun=mycoun+1
          tsnext=snext
          tignex=ignext
          tingot=ingoto
          call gscvol
          if(ingoto.gt.0)then
            iq(jgpar2+nlevel+1)=iq(jgpar+nlevel+1)
            lq(jgpar2-nlevel-1)=lq(jgpar-nlevel-1)
          endif
         endif
         if(gonly(nlevel).eq.0.)then
 404       continue
           if(gonly(nlevel-1).eq.0..or.newfl.eq.0)then
             if(gonly(nlevel-1).ne.0.)newfl=1
             nlevel=nlevel-1
             jvo=lq(jvolum-lvolum(nlevel))
             nin=q(jvo+3)
             if(nin.lt.0)goto 404
             myinfr=lindex(nlevel+1)
             jin=lq(jvo-myinfr)
             iq(jin)=ibset(iq(jin),4)
             ignext=0
             goto 401
           endif
         endif
 403   continue
       if(manyfl.lt.nvmany)then
         manyfl=manyfl+1
         if(manyfl.eq.nfmany)goto 403
         levtmp=manyle(manyfl)
         do 402 i=1,levtmp
          namtmp(i)=manyna(manyfl,i)
          numtmp(i)=manynu(manyfl,i)
 402     continue
         call glvolu(levtmp,namtmp,numtmp,ier)
         if(ier.ne.0)print *,'Fatal error in GLVOLU'
         ignext=0
         goto 401
       endif
       if(tsafet.le.safety)safety=tsafet
       if(tsnext.le.snext)then
         snext=tsnext
         ignext=tignex
         ingoto=tingot
         call gfcvol
         nlevin=nlevel
         if(ingoto.gt.0)then
          iq(jgpar+nlevel+1)=iq(jgpar2+nlevel+1)
          lq(jgpar-nlevel-1)=lq(jgpar2-nlevel-1)
         endif
       endif
      endif
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNXT.EQ.BIG1) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
 
+DECK,GTNEX2.
*CMZ :  1.30/00 18/09/96  20.43.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTNEX2
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+SEQ, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SEQ,GCJUMP, IF=USRJMP
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      REAL      X0(3), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      ISEARC = Q(JVO+1)
      IF (ISEARC.GE.-1) GO TO 120
*
*  ** Contents are ordered by (dynamic) GSORD, select neighbours
*
      JSB = LQ(LQ(JVO-NIN-1))
      IAX = Q(JSB+1)
      NSB = Q(JSB+2)
      IF (IAX.LE.3) THEN
         CX  = XC(IAX)
         INC = SIGN(1., XC(IAX+3))
      ELSE
         CALL GFCOOR (XC, IAX, CX)
         IF (IAX.LE.5) THEN
            DR = XC(1)*XC(4) +XC(2)*XC(5)
            IF (IAX.EQ.5) DR = DR +XC(3)*XC(6)
            INC = SIGN(1., DR)
         ELSE IF (IAX.EQ.6) THEN
            INC = SIGN(1., XC(1)*XC(5)-XC(2)*XC(4))
         ELSE
            INC = SIGN(1., XC(3)*(XC(1)*XC(4)+XC(2)*XC(5))
     +                    -XC(6)*(XC(1)*XC(1)+XC(2)*XC(2)))
         ENDIF
      ENDIF
      IDIV = LOCATF (Q(JSB+3), NSB, CX)
      IF (IDIV.LT.0) IDIV = -IDIV
      IF (IAX.NE.6) THEN
         IF (IDIV.EQ.0) THEN
            IF (INC.LT.0.AND.IAX.LE.3) THEN
               SAFETY = Q(JSB+3) -CX
               GO TO 300
            ENDIF
            IDIV = 1
         ELSE IF (IDIV.EQ.NSB) THEN
            IF (INC.GT.0.AND.IAX.NE.7) THEN
               SAFETY = CX -Q(JSB+2+NSB)
               GO TO 300
            ENDIF
            IDIV = NSB -1
         ELSE
            IF (IAX.NE.7) THEN
               IF (INC.GT.0) THEN
                  SAFETY = CX -Q(JSB+2+IDIV)
               ELSE
                  SAFETY = Q(JSB+3+IDIV) -CX
               ENDIF
            ELSE
               SAFETY = 0.
            ENDIF
         ENDIF
      ELSE IF (IAX.EQ.6) THEN
         IF (IDIV.EQ.0) IDIV = NSB
         SAFETY = 0.
      ENDIF
*
      IDIVL = 0
      IDIVB = 0
      JSC0  = LQ(JVO-NIN-2)
  110 NCONT = IQ(JSC0+IDIV)
*
*  ** Loop over (selected) contents
*
      IF (NCONT.EQ.0) THEN
         IF (IDIV.EQ.IDIVL) GO TO 400
         IDIV = IDIV +INC
         IF (IAX.NE.6) GOTO 110
*      (following statement for IAX=6, when division NSB is empty)
         IF (IDIV.GT.NSB) IDIV = 1
         IF (IDIV.EQ.0) IDIV = NSB
         GO TO 110
      ELSE
         ICONT = 1
         JSCV = LQ(JSC0-IDIV)
         GO TO 140
      ENDIF
*
  120 JNEAR = LQ(JVO-NIN-1)
      IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
         CALL GUNEAR (ISEARC, 2, XC, JNEAR)
+SELF, IF=USRJMP
         CALL JUMPT4(JUNEAR, ISEARC, 2, XC, JNEAR)
+SELF
         IF (IQ(JNEAR+1).EQ.0) GO TO 300
      ELSE
         IF (INFROM.GT.0) THEN
            JIN = LQ(JVO-INFROM)
            IF (LQ(JIN-1).NE.0) THEN
               JNE = LQ(JIN-1)
               IF (IQ(JNE+1).GT.1.OR.IQ(JNE+2).NE.0) JNEAR = JNE
            ENDIF
         ENDIF
      ENDIF
      JNEAR = JNEAR +1
      NNEAR = IQ(JNEAR)
      IF (IQ(JNEAR+1).NE.0) THEN
         INEAR = 1
      ELSE
         INEAR = 2
      ENDIF
*
  130 IN = IQ(JNEAR+INEAR)
      GO TO 150
*
  140 IN = IQ(JSCV+ICONT)
*
  150 IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 180
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
         IF (ISEARC.EQ.-2) THEN
            IF (MOD(IQ(JSC0),2).NE.0) THEN
               IDIVB = IDIV
            ELSE
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVB = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVB = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVB.LT.0) IDIVB = -IDIVB
               IF (IDIVB.EQ.0) THEN
                  IF (IAX.EQ.6) THEN
                     IDIVB = NSB
                  ELSE
                     IDIVB = 1
                  ENDIF
               ELSE IF (IDIVB.EQ.NSB) THEN
                  IF (IAX.NE.6) IDIVB = NSB - 1
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (ISEARC.EQ.-2) THEN
         IF (ICONT.EQ.NCONT) THEN
            IF (IDIVL.EQ.0) THEN
               IF (IDIVB.NE.0) THEN
                  IF (IDIV.EQ.IDIVB) GO TO 300
                  IF (.NOT.BTEST(IQ(JVO),2)) THEN
                     IDIVL = IDIVB
                     GO TO 193
                  ENDIF
               ENDIF
*
*   *         Compute distance to boundary of current volume
*
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
*
*   *         Check wether other pseudo-divisions have to be scanned
*
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVL = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVL = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVL.LT.0) IDIVL = -IDIVL
               IF (IDIVL.EQ.0) THEN
                  IF(IAX.EQ.6)THEN
                     IDIVL=NSB
                  ELSE
                     IDIVL=1
                  ENDIF
               ELSEIF (IDIVL.EQ.NSB)THEN
                  IF(IAX.NE.6)IDIVL=NSB-1
               ENDIF
            ELSE
               IF (IDIV.EQ.IDIVB)   GO TO 400
            ENDIF
  193       IF ((IDIV-IDIVL)*INC.GE.0) GO TO 400
            IDIV = IDIV +INC
            GO TO 110
         ELSE
            ICONT = ICONT +1
            GO TO 140
         ENDIF
      ELSE
         IF (INEAR.EQ.NNEAR) GO TO 300
         INEAR = INEAR +1
         GO TO 130
      ENDIF
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
  400 IF (GONLY(NLEVEL).EQ.0.) THEN
*
* ***   Case of a 'NOT ONLY' volume -> step search
*
         SAFETY = 0.
         EPSI2  = 0.5*EPSIL
         ST     = SNEXT -EPSI2
         IF (ST.LE.0) GO TO 900
         EPSI3  = 10.*EPSIL
         IF (ST.LE.EPSI3) THEN
            NN = 1
         ELSE
            NN = ST/EPSI3 +1
            ST = ST/NN
         ENDIF
*
         NBIN = 0
         SN   = 0.
  420    SN   = SN +ST
         XT(1) = VECT(1) + SN*VECT(4)
         XT(2) = VECT(2) + SN*VECT(5)
         XT(3) = VECT(3) + SN*VECT(6)
*
         INGOTO = 0
         CALL GINVO2 (XT, ISAME)
         IF (ISAME.EQ.0) THEN
            IF (ST.LE.EPSI2) GO TO 490
            SN   = SN -ST
            ST   = 0.5*ST
            NBIN = 1
            GO TO 420
         ENDIF
*
         IF (NBIN.NE.0) THEN
            IF (ST.LT.EPSI2) THEN
               ST = EPSI2
            ELSE
               ST = 0.5*ST
            ENDIF
            GO TO 420
         ENDIF
         NN = NN -1
         IF (NN.GT.0) GO TO 420
         GO TO 495
*
  490    IF (SN.LT.SNEXT) THEN
            INGOTO = -1
            SNEXT  = SN
            IGNEXT = 1
            GO TO 900
         ENDIF
*
  495    NLEVIN = NLEVEL
      ENDIF
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNEXT.LT.0.) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
+DECK,GINVO1.
*CMZ :  1.30/00 18/09/96  19.58.23  by  Pavel Nevski
*CMZ :  3.21/02 03/07/94  17.14.15  by  S.Giani
*-- Author :
      SUBROUTINE GINVO1 (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
C.
      DIMENSION  X(*)
      REAL       XC(6), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
         ingt=0
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480
 
  450 ISAME = 0
 
  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+DECK,GINVO2.
*CMZ :  1.30/00 18/09/96  19.59.25  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GINVO2 (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
C.
      DIMENSION  X(*)
      REAL       XC(3), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               IDIV = LOCATF (Q(JSB+3), NSB, XC(IAX))
            ELSE
               CALL GFCOOR (XC, IAX, CX)
               IDIV = LOCATF (Q(JSB+3), NSB, CX)
            ENDIF
            IF (IDIV.LT.0) IDIV = -IDIV
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=USRJMP
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF
            ELSEIF (INFR.GT.0) THEN
               JNUP = LQ(LQ(JVO-INFR)-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480
 
  450 ISAME = 0
 
  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+DECK,GSSTAK.
*CMZ :          25/03/98  00.20.33  by  Pavel Nevski
*CMZ :  1.30/00 04/05/97  23.58.54  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSSTAK (IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GSSTAK (IFLAG)                                        *
C.    *                                                                *
C.    *   Stores in auxiliary stack JSTAK the particle currently       *
C.    *    described in common /GCKINE/.                               *
C.    *                                                                *
C.    *   On request, creates also an entry in structure JKINE :       *
C.    *    IFLAG =                                                     *
C.    *     0 : No entry in JKINE structure required (user)            *
C.    *     1 : New entry in JVERTX / JKINE structures required (user) *
C.    *    <0 : New entry in JKINE structure at vertex -IFLAG (user)   *
C.    *     2 : Entry in JKINE structure exists already (from GTREVE)  *
C.    *                                                                *
C.    *   Called by : GSKING, GTREVE                                   *
C.    *   Author    : S.Banerjee, F.Bruyant                            *
C.    *   Modifications: PN - put protection against lack of memory.   *
C.    *   - reject Cerenkov photons if mechanism is not activated.     *
C.    *   - save interaction description (MECAT) in stack and NTTARG   *
C.    *   - accept all unknown IPART as geantino                       *
C.    ******************************************************************
C.
+CDE, TYPING, GCBANK, GCTRAK, GCKINE, GCKING, GCFLAG.
+CDE, GCJLOC, GCMZFO, GCNUM,  GCSTAK, GCVOLU, GCTMED.
+CDE, GCJUMP, IF=USRJMP
*
      INTEGER         NVTX,ITR
      COMMON /VTXKIN/ NVTX,ITR
      REAL    UBUF(1)
      DATA    UBUF/0./
      INTEGER         IFLAG,IER,ISKIP,LP,ITRT,JST,I,MECAT
C.
C.    ------------------------------------------------------------------
*
      IF (IEOTRI.NE.0) RETURN
*
*     IF (IPART.LE.0.OR.IPART.GT.NPART) ...
      IF (IPART.LE.0)  THEN
         PRINT *, ' GSSTAK - Unknown particle code, skip track ', IPART
         GO TO 999
      ENDIF
*
* ***                          protect against lack of memory faults
      IF (IFLAG.NE.0) THEN
         CALL AGNEED(IER)
         IF (IER.NE.0) RETURN
      ENDIF
*
* ***                   create target description for GEANT produced vertices
      Mecat = 0
      If (NGKINE.GT.0 .and. NMEC.GT.0) then
          Mecat = min(LMEC(NMEC),49) + LVOLUM(NLEVEL)*100
          If (ISTOP.EQ.0) Mecat = Mecat+50 ! flag non-stopped particles
          If (ISTAK.GT.0) Mecat = -Mecat   ! flag disconnected vertex
      ENDIF
*
* ***                          Give control to user for track selection
+SELF,IF=-USRJMP.
      CALL GUSKIP(ISKIP)
+SELF,IF= USRJMP.
      CALL JUMPT1(JUSKIP,ISKIP)
+SELF.
      IF (ISKIP.NE.0) GO TO 999
*
* *** Check if an entry in JKINE structure is required
*
      IF (IFLAG.EQ.1) THEN
         CALL GSVERT (VERT,  ITRA, 0, UBUF, 0, NVTX)
         If (NVTX.LE.0) THEN
            Print *,' GSSTAK cannot set Vertex for ',ITRA,Mecat
            Print *,' ****** event simulation abandoned ******'
            IEOTRI=1
            RETURN
         ENDIF
         Q(6+LQ(JVERTX-NVTX))=MECAT
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE IF (IFLAG.LT.0) THEN
         NVTX = -IFLAG
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE
         IF (IFLAG.EQ.0) THEN
*          Store -ITRA in stack for a track without entry in JKINE
            ITR = -ITRA
         ELSE
            ITR = ITRA
         ENDIF
      ENDIF
*
* *** Store information in stack
*
      IF (JSTAK.EQ.0) THEN
         NDBOOK = NTSTKP*NWSTAK +3
         NDPUSH = NTSTKS*NWSTAK
         CALL MZBOOK (IXCONS,JSTAK,JSTAK,1,'STAK', 0,0,NDBOOK, IOSTAK,3)
         IQ(JSTAK+2) = NTSTKP
      ELSE IF (IQ(JSTAK+1).EQ.IQ(JSTAK+2)) THEN
         CALL AGNEED (IER)
         IF (IER.NE.0) RETURN
         CALL MZPUSH (IXCONS, JSTAK, 0, NDPUSH, 'I')
         IQ(JSTAK+2) = IQ(JSTAK+2) +NTSTKS
      ENDIF
*
      LP   = 0
      IF (IPART.LE.IQ(JPART-2)) LP = LQ(JPART-Ipart)
      IF (LP.LE.0)              LP = LQ(JPART-48)
 
*PN:  do not save Cerenkov photons if the mechanism is not activated
      ITRT =  Q(6+LP)
      IF (ITRT.EQ.7 .and. ITCKOV.EQ.0) GO TO 999
*
      JST = JSTAK +IQ(JSTAK+1)*NWSTAK +3
      IQ(JSTAK+1) = IQ(JSTAK+1) +1
      IF (IQ(JSTAK+3).EQ.0)  IQ(JSTAK+3) = IQ(JSTAK+1)
      IF (IQ(JSTAK+1).GT.NSTMAX)  NSTMAX = IQ(JSTAK+1)
*
      IQ(JST+1)   = ITR       ! track number(or parent), STACK_ONLY flag
      IQ(JST+2)   = IPART     ! particle type
      IQ(JST+3)   = Mecat     ! its production history
      DO 90 I = 1,3
         Q(JST+3+I) = VERT(I)
         Q(JST+6+I) = PVERT(I)
   90 CONTINUE
      Q(JST+10) = TOFG
      Q(JST+11) = SAFETY
      Q(JST+12) = UPWGHT
*
      NALIVE = NALIVE +1
*                                                             END GSSTAK
  999 END
+DECK,GSVERT
*CMZ :  1.30/00 03/05/97  16.32.36  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GSVERT(V,NTBEAM,NTTARG,UBUF,NWBUF,NVTX)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Creates a new vertex bank                                *
C     *       Vertex is generated from tracks NTBEAM NTTARG            *
C     *       NVTX is the new vertex number                            *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    * Modifications:                                                 *
C.    * PN, 07/Feb/97: allow negative NTbeam and NTtarg                *
C.    ******************************************************************
C.
+CDE,TYPING.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCFLAG
+SEQ,GCPUSH
+SEQ,GCTRAK
+SEQ,GCKINE
+SEQ,GCUNIT
+SEQ,QUEST
      REAL     V(3),UBUF(1)
      INTEGER  LGKINE,NTBEAM,NTTARG,NWBUF,NVTX,NT(2),IER,
     >         JV,JUV,I,J,JK,NVG,NFREE
C.
C.    ------------------------------------------------------------------
C.
      CALL AGNEED (IER)
      IF (IER.NE.0) GO TO 90
 
      NVTX   = NVERTX + 1
      IF (JVERTX.EQ.0)THEN
C        simulated vertex list
         CALL MZBOOK(IXDIV,JVERTX,JVERTX,1,'VERT',NCVERT,NCVERT,2,2,0)
         IQ(JVERTX-5)=0
      ENDIF
      IF (NVTX.GT.IQ(JVERTX-2)) CALL MZPUSH(IXDIV,JVERTX,NPVERT,0,'I')
      IF (NVTX.GT.IQ(JVERTX-2)) THEN
         PRINT *,' GSVERT ERROR: WRONG NVertex ',NVTX
         GOTO 90
      ENDIF
C     one vertex parameters
      CALL MZBOOK(IXDIV,JV,JVERTX,-NVTX,'VERT',1,1,9,3,0)
C     and users buffer
      IF (NWBUF.GT.0) THEN
         CALL MZBOOK(IXDIV,JUV,JV,-1,'VERU',0,0,NWBUF,2,0)
         IQ(JUV-5)=NVTX
         DO 3 I=1,NWBUF
   3     Q(JUV+I)=UBUF(I)
      ENDIF
      DO 4 I=1,3
   4  Q(JV + I) = V(I)
      Q(JV + 4) = TOFG
      Q(JV + 5) = NTBEAM
      Q(JV + 6) = NTTARG
C
      NT(1) = NTBEAM
      NT(2) = NTTARG
      Do i=1,2
         IF (NT(i).GT.0) THEN
            JK   = LGKINE(J,NT(i))
            IF(JK.LE.0) GO TO 90
            NVG  = Q(JK + 7)
            NFREE=IQ(JK-1)-7-NVG
            IF(NFREE.LE.0) CALL MZPUSH(IXDIV,JK,0,max(2,NVG/5),'I')
            Q(JK + NVG + 8) = NVTX
            Q(JK + 7) = NVG + 1
         ENDIF
      EndDO
C
      NVERTX      = NVTX
      IQ(JVERTX+1)= NVERTX
      RETURN
C
C             Error
C
  90  NVTX   = 0
      END
 
+DECK,GSAHIT
*CMZ :          19/07/97  13.08.07  by  Pavel Nevski
*CMZ :  1.30/00 18/04/97  18.05.51  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routines to Communicate with the JHITS data structure       *
C.    *   ---------------------------------------------------------    *
C.    *                                                                *
C.    *   Stores  element  values  for current  hit  into  the  data   *
C.    * structure JHITS.                                               *
C.    * ISET      set number  (can be obtained from  /GCSETS/ filled   *
C.    *           by GFINDS)                                           *
C.    * IDET      detector    number   "           "               "   *
C.    *           "                                                    *
C.    * ITRA      track number producing this hit                      *
C.    * NUMBV     array  of  volume numbers  corresponding  to  list   *
C.    *           NAMESV of GSDET                                      *
C.    * HITS      array of values for current hit elements             *
C.    * IHIT      on return, current hit number.  If =0, hit has not   *
C.    *           been stored.                                         *
C.    *                                                                *
C.    *       JH=LQ(JHITS-ISET)                                        *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)= pointer to LAST USED word in JHD            *
C.    *         Each hit is packed into JHD in the following format    *
C.    *        --Track number ITRA not packed                          *
C.    *        --Volume numbers packed                                 *
C.    *        --Hits transformed and packed                           *
C.    *                                                                *
C.    *                The Hit data structure JHITS                    *
C.    *                ----------------------------                    *
C.    *                                                                *
C.    *                                            | JHITS             *
C.    *    NSET                  ISET              v                   *
C.    *     ..........................................                 *
C.    *     |                   |  |              |  |                 *
C.    *     ..........................................                 *
C.    *                           |                                    *
C.    *                           | JH                                 *
C.    *      NDET    IDET         v               NDET                 *
C.    *        .....................................                   *
C.    *        |      |  |      |  |               |                   *
C.    *        .....................................                   *
C.    *                |                                               *
C.    *                | JHD                                           *
C.    *                v                                               *
C.    *               .........................................        *
C.    *               |  | 1st hit        | 2nd hit, etc.     |        *
C.    *               .........................................        *
C.    *                         Bank layout                            *
C.    * JH            =  LQ(JHITS-ISET,)  pointer  to  hits for  set   *
C.    *           number ISET                                          *
C.    * JHD           = LQ(JH-IDET),   pointer to  hits of  detector   *
C.    *           IDET                                                 *
C.    *                  of set ISET                                   *
C.    * IQ(JH+IDET)    number of words  used so far for  storing the   *
C.    *           hits                                                 *
C.    *                  of detector IDET                              *
C.    * IQ(JHD+1)       1st word of 1st hit                            *
C.    * IQ(JHD+NWH+1)  1st word of 2nd hit                             *
C.    *                      JS=LQ(JSET-ISET)                          *
C.    *                      JD=LQ(JS-IDET)                            *
C.    *                      NWH=IQ(JD+3)                              *
C.    *   The JHITS structure is filled with the routines GSAHIT and   *
C.    * GSCHIT.   The routine GFHITS can be used to get the hits for   *
C.    * a detector IDET and set ISET.                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,GCBANK
+CDE,GCUNIT
+CDE,GCFLAG
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(1),HITS(1)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      IHIT=0
      IF(JSET.LE.0)GO TO 99
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 99
      IF(ISET.LE.0)GO TO 99
      IF(ISET.GT.NSET)GO TO 99
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 99
      IF(IDET.LE.0)GO TO 99
      IF(IDET.GT.NDET)GO TO 99
      JD=LQ(JS-IDET)
      JDH=LQ(JD-1)
      IF(JDH.LE.0)GO TO 99
      NW=IQ(JD+1)+IQ(JD+3)+1
      NH=IQ(JD+4)
      NV=IQ(JD+2)
C
C              Create HITS master bank
C
      IF(JHITS.EQ.0)THEN
         CALL MZBOOK(IXDIV,JHITS,JHITS,1,'HITS',NSET,NSET,0,2,0)
         IQ(JHITS-5)=0
      ENDIF
      JH=LQ(JHITS-ISET)
      IF(JH.EQ.0)THEN
         CALL MZBOOK(IXDIV,JH,JHITS,-ISET,'HITS',NDET,NDET,NDET,2,0)
      ENDIF
C
      JHD=LQ(JH-IDET)
      IF(JHD.EQ.0)THEN
C
C            Create Hits bank
C
         NWHI=IQ(JD+7)
         CALL MZBOOK(IXDIV,JHD,JH,-IDET,'SJHD',0,0,NWHI,1,0)
         IQ(JHD-5)=1000*ISET+IDET
         ILAST=0
      ELSE
C
C           Check if enough space. If not increase bank size
C
         NHD=IQ(JHD-1)
         ILAST=IQ(JH+IDET)
         NFREE=NHD-ILAST
         IF(NFREE.LE.NW)THEN
            NWHI2=MAX(100,NW,IQ(JD+7)/2)
*           CALL MZPUSH(IXDIV,JHD,0,NWHI2,'I')
            CALL AgPUSH(Idebug,JHD,0,NHD+NWHI2,Ier)
            IF (Ier.ne.0) Return
            JS  = LQ(JSET-ISET)
            JD  = LQ(JS-IDET)
            JDH = LQ(JD-1)
            JH  = LQ(JHITS-ISET)
         ENDIF
      ENDIF
C
      IQ(JH+IDET)=ILAST+NW
      IHIT=IQ(JH+IDET)/NW
C
C ========>    Store track number,volumes numbers and hits
C
      IQ(JHD+ILAST+1)=ITRA
C
C
C           Store packed volume numbers
C
      NK=ILAST+2
      IF(NV.GT.0)THEN
         K=1
C
         DO 50 I=1,NV
            NB=IQ(JD+2*I+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=NUMBV(I)
               K=1
               IF(I.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(NUMBV(I),0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  50     CONTINUE
         NK=NK+1
      ENDIF
C
C          Store packed hits
C          Before packing, hits are changed to integers
C          Origin is shifted to have only positive integers
C          Result is multiplied by a constant to get resolution
C
      IF(NH.GT.0)THEN
         K=1
         DO 90 I=1,NH
            NB=IQ(JDH+4*I-2)
            XHIT=(HITS(I)+Q(JDH+4*I-1))*Q(JDH+4*I)
            IF(NB.EQ.0)THEN
               VALMX=2.147483E+9
            ELSE
               VALMX=2.**NB-1.
            ENDIF
            IFLAG=0
            IF(XHIT.LT.0.)THEN
               XHIT=0.
               IFLAG=1
            ELSE IF(XHIT.GT.VALMX)THEN
               XHIT=VALMX
               IFLAG=1
            ENDIF
            IF(IFLAG.NE.0)THEN
               NMESS=NMESS+1
               IF(NMESS.LT.10)THEN
                  WRITE(CHMAIL,1000)IQ(JSET+ISET),IQ(JS+IDET),I,HITS(I)
     +             ,Q(JDH+4*I-1),Q(JDH+4*I)
                  CALL GMAIL(0,0)
               ENDIF
            ENDIF
C
            KHIT=XHIT+0.5
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=KHIT
               NK=NK+1
               K=1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(KHIT,0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
 1000 FORMAT(' ***** GSAHIT OVERFLOW WHEN IUSET= ',A4,' IUDET= ',
     +A4,' HITS(',I2,')=',E14.7,' ORIG= ',E14.7,' FACT= ',E14.7)
  99  RETURN
      END
+DECK,GSKINE
*CMZ :          25/03/98  00.14.32  by  Pavel Nevski
*CMZ :  1.30/00 23/03/97  22.06.36  by  Pavel Nevski
*CMZ :  3.21/02 28/03/94  01.30.59  by  S.Giani
*-- Author :
      SUBROUTINE GSKINE(PLAB,IPART,NV,BUF,NWBUF,NT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Store kinematics of track NT into data structure         *
C     *       Track is coming from vertex NV                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    *    Modifications:                                              *
C.    *    PN: put all unknown particles as Geantino                   *
C.    ******************************************************************
C.
+CDE,TYPING.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCFLAG
+SEQ,GCPUSH
+SEQ,GCUNIT
+SEQ,QUEST
 
      REAL      PLAB(3),BUF(1),P2,AMASS,E
      INTEGER   LGKINE,IPART,NV,NWBUF,NT,NTI,IER,JV,JPA,JK,JUK,NTG,
     >          I,J,NFREE,JKIN
C.
C.    ------------------------------------------------------------------
C.
      CALL AGNEED (IER)
      IF (IER.NE.0)     GO TO 90
 
      IF (NV.LE.0)      GO TO 10
      IF (JVERTX.LE.0)  GO TO 90
      IF (NV.GT.NVERTX) GO TO 90
      JV = LQ(JVERTX- NV)
      IF (JV.LE.0)      GO TO 90
C
   10 NT     = NTRACK + 1
      IF (JKINE.EQ.0) THEN
         CALL MZBOOK(IXDIV,JKINE,JKINE,1,'KINE',NCKINE,NCKINE,2,2,0)
         IQ(JKINE-5)=0
      ENDIF
      J = LgKINE(JKIN,NT)
      NTI=NT-IQ(JKIN+2)
      IF(NTI.GT.IQ(JKIN-2)) CALL MZPUSH(IXDIV,JKIN,NPKINE,0,'I')
      IF(NTI.GT.IQ(JKIN-2)) THEN
         PRINT *,' GSKINE ERROR: WRONG NTRACK ',NTRACK
         GOTO 90
      ENDIF
C
      IF (JPART.LE.0) GO TO 90
      JPA = 0
      IF (IPART.LE.IQ(JPART-2)) JPA = LQ(JPART- IPART)
      IF (JPA.LE.0)             JPA = LQ(JPART- 48)
 
      P2     = PLAB(1)**2 + PLAB(2)**2 + PLAB(3)**2
      AMASS  = Q(JPA + 7)
      E      = SQRT(P2 + AMASS*AMASS)
C
C            Store kinematics in JKINE
C
      NTRACK = NT
      IQ(JKIN+1)=NTRACK
      CALL MZBOOK(IXDIV,JK,JKIN,-NTI,'KINE',1,1,8,3,0)
      Q(JK + 1) = PLAB(1)
      Q(JK + 2) = PLAB(2)
      Q(JK + 3) = PLAB(3)
      Q(JK + 4) = E
      Q(JK + 5) = IPART
      Q(JK + 6) = NV
C
C            Copy user words
C
      IF(NWBUF.GT.0)THEN
         CALL MZBOOK(IXDIV,JUK,JK,-1,'KINU',0,0,NWBUF,3,0)
         IQ(JUK-5)=NT
C
         DO 15 I=1,NWBUF
            Q(JUK+I)=BUF(I)
   15    CONTINUE
      ENDIF
C
C
C            Connect track NT to vertex NV
C
      IF(NV.GT.0)THEN
         JV = LQ(JVERTX- NV)
         NTG = Q(JV + 7)
         NFREE=IQ(JV-1)-7-NTG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JV,0,max(2,NTG/5),'I')
         Q(JV + NTG + 8) = NT
         Q(JV + 7) = NTG + 1
      ENDIF
C
      GO TO 99
C
C            Error
C
  90  NT = 0
  99  RETURN
      END
 
 
+DECK,GLTRAC.
*CMZ :          25/03/98  00.13.37  by  Pavel Nevski
*CMZ :  1.30/00 03/05/97  16.07.14  by  Pavel Nevski
*CMZ :  3.21/04 13/12/94  15.36.22  by  S.Giani
*-- Author :
      SUBROUTINE GLTRAC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GLTRAC                                                *
C.    *                                                                *
C.    *   Extracts next track from stack JSTAK and prepares commons    *
C.    *    /GCTRAK/, /GCKINE/ and /GCVOLU/                             *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *   Modifications:                                               *
C.    *   1. extend KINE bank with LgKINE                              *
C.    *   2. all unknown particle are treated as geantino              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
      DIMENSION RNDM(5)
+SELF,IF=-SINGLE.
      DOUBLE PRECISION P2,GETOTD,GEKIND
      DOUBLE PRECISION PXD,PYD,PZD,ONE,HNORM,DAMASS,PP
+SELF.
      PARAMETER (ONE=1)
      COMMON /GCKINE_CONT/ ITRO,TOFO,MECATO
C.
C.    ------------------------------------------------------------------
*
* *** Extract next track from stack JSTAK
*
      IF(ISTORD.EQ.1) THEN
*
* *** User ordering of tracks if requested
         CALL GSTORD
      ENDIF
      ISTAK = IQ(JSTAK+1)
      IQ(JSTAK+1) = ISTAK -1
      JST = JSTAK +NWSTAK*IQ(JSTAK+1) +3
      ITRA   = IQ(JST+1)
      IF (ITRA.LT.0) THEN
         ITRA = -ITRA
      ELSE
*
*        This is a new track. We set to zero the stack number and
*        update the vertex number
         ISTAK = 0
*<       JK=LQ(JKINE-ITRA)
         IVERT=Q(LgKINE(JK,ITRA)+6)
      ENDIF
*PN: extract and save ALL from stack, it may be overwritten by interactions
      ITRO   = IQ(JST+1)
      IPART  = IQ(JST+2)
      MECATO = IQ(JST+3)
      DO 60 I = 1,3
         VERT(I) = Q(JST+3+I)
        PVERT(I) = Q(JST+6+I)
   60 CONTINUE
      TOFO   = Q(JST+10)
      TOFG   = Q(JST+10)
      SAFETY = Q(JST+11)
      UPWGHT = Q(JST+12)
*
* *** Prepare tracking parameters
*
      VECT(1) = VERT(1)
      VECT(2) = VERT(2)
      VECT(3) = VERT(3)
      PXD = PVERT(1)
      PYD = PVERT(2)
      PZD = PVERT(3)
      P2 = PXD**2+PYD**2+PZD**2
      IF(P2.GT.0.) THEN
         PP    = SQRT(P2)
         HNORM = ONE/PP
         VECT(4) = PVERT(1)*HNORM
         VECT(5) = PVERT(2)*HNORM
         VECT(6) = PVERT(3)*HNORM
         VECT(7) = PP
      ELSE
         VECT(4) = 0.
         VECT(5) = 0.
         VECT(6) = 1.
         VECT(7) = 0.
      ENDIF
*
*  ** Reload Particle characteristics, if needed
*
      IF (IPART.NE.IPAOLD) THEN
         JPA = 0
         IF (IPART.LE.IQ(JPART-2)) JPA = LQ(JPART-IPART)
         IF (JPA .EQ. 0)           JPA = LQ(JPART-48)
 
         DO 90 I = 1,5
            NAPART(I) = IQ(JPA+I)
   90    CONTINUE
         ITRTYP = Q(JPA+6)
         AMASS  = Q(JPA+7)
         CHARGE = Q(JPA+8)
         TLIFE  = Q(JPA+9)
         IUPD   = 0
         IPAOLD = IPART
      ENDIF
*
      DAMASS = AMASS
      GETOTD = SQRT(P2+DAMASS**2)
      GEKIND = GETOTD - DAMASS
      GETOT  = GETOTD
      GEKIN  = GEKIND
*
      IF (ITRTYP.EQ.7) THEN
*
* *** Cerenkov photon. Retrieve polarisation
         JPO = LQ(JSTAK-1)+(ISTAK-1)*3
         POLAR(1) = Q(JPO+1)
         POLAR(2) = Q(JPO+2)
         POLAR(3) = Q(JPO+3)
      ELSE
         CALL GEKBIN
      ENDIF
*
      SLENG  = 0.
      NSTEP  = 0
      NTMSTO = NTMSTO +1
      NTMULT = NTMSTO
      ISTORY = 0
*
*  ** Initialize interaction probabilities
*
      IF (ITRTYP.EQ.1) THEN
*      Gammas
         CALL GRNDM(RNDM,5)
         ZINTPA = -LOG(RNDM(1))
         ZINTCO = -LOG(RNDM(2))
         ZINTPH = -LOG(RNDM(3))
         ZINTPF = -LOG(RNDM(4))
         ZINTRA = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.2) THEN
*       Electrons
         CALL GRNDM(RNDM,3)
         ZINTBR = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
         ZINTAN = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.3) THEN
*       Neutral hadrons
         CALL GRNDM(RNDM,2)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
      ELSE IF (ITRTYP.EQ.4) THEN
*       Charged hadrons
         CALL GRNDM(RNDM,3)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
         ZINTDR = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.5) THEN
*       Muons
         CALL GRNDM(RNDM,5)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTBR = -LOG(RNDM(2))
         ZINTPA = -LOG(RNDM(3))
         ZINTDR = -LOG(RNDM(4))
         ZINTMU = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.7) THEN
*       Cerenkov photons
         CALL GRNDM(RNDM,1)
         ZINTLA = -LOG(RNDM(1))
      ELSE IF (ITRTYP.EQ.8) THEN
*       Ions
         CALL GRNDM(RNDM,2)
         ZINTHA = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
      ENDIF
*
*   * Prepare common /GCVOLU/ and structure JGPAR, if needed
*
      IF (NJTMAX.LE.0) THEN
        IF (GONLY(NLEVEL).EQ.0.) NLEVEL=0
        CALL GMEDIA (VECT, NUMED)
      ENDIF
      INFROM = 0
*                                                             END GLTRAC
      END
 
 
+DECK,gpdcay.
*CMZ :  1.30/00 19/04/97  17.50.02  by  Pavel Nevski
*-- Author :    Pavel Nevski
*
      SUBROUTINE GPDCAY  (IPART)
*-
*-    ******************************************************************
*-    *                                                                *
*-    *  Print branching ratios and decay modes for GEANT particles.   *
*-    *                                                                *
*-    *    ==>Called by : <USER>                                       *
*-    *       Author    P.Nevski                                       *
*-    *                                                                *
*-    ******************************************************************
*-
+CDE,TYPING,GCBANK,GCNUM,GCUNIT.
      REAL      BRATIO
      INTEGER   LENOCC,IPART,IP1,IP2,IP,JPA,
     >          MODE,JDK1,JDK2,L1,L,LL,I,JP,M1
      CHARACTER CNAME*20,CMODE*200
*-
*-    ------------------------------------------------------------------
*-
      IF (IPART.EQ.0) THEN
         IP1=1
         IP2=NPART
      ELSE
         IP1=IPART
         IP2=IPART
      ENDIF
*
      DO IP=IP1,IP2
         IF (IP.LE.0)      GOTO 90
         IF (IP.GT.NPART)  GOTO 90
         JPA = LQ(JPART-IP)
         IF (JPA.LE.0)     GOTO 90
         JDK1=LQ(JPA-1) !  PABR bank
         IF (JDK1.LE.0)    GOTO 90
         JDK2=LQ(JPA-2) !  PAMO bank
         IF (JDK2.LE.0)    GOTO 90
*
         CALL UHTOC(IQ(JPA+1),4,CMODE,20)
         L1=LENOCC(CMODE(1:20))
         WRITE(LOUT,1000) IP,CMODE(1:L1)
 1000    FORMAT(I5,1x,A,'  Decay(s):')
*
*    COPY branching ratios & decay modes.
*
         DO I  = 1,6
            CMODE = CMODE(1:L1)//' => '
            LL     = L1+4
            BRATIO = Q(JDK1+I)
            IF (BRATIO.LE.0) GO TO 60
            MODE   = IQ(JDK2+I)
            DO WHILE (MODE.GT.0)
               M1  = MOD(MODE,100)
               IF (M1.LE.0) GOTO 50
               JP  = LQ(JPART-M1)
               IF (JP.LE.0) GO TO 50
               CALL UHTOC(IQ(JP+1),4,CNAME,20)
               L   = LENOCC(CNAME)
               CMODE=CMODE(1:LL)//CNAME(1:L)//' & '
               LL  = LL+L+3
  50           MODE=MODE/100
            ENDDO
            WRITE(LOUT,1001) BRATIO,CMODE(1:LL-3)
 1001       FORMAT(6x,'Branching(%)=',F8.3,' Channel: ',A)
  60     ENDDO
C
  90     CONTINUE
      ENDDO
      END
 
 
 
 
 
 
+DECK,gfdcay.
*CMZ :          01/07/97  10.45.18  by  Pavel Nevski
*CMZ :  1.30/00 19/04/97  17.50.46  by  Pavel Nevski
*CMZ :  3.21/03 02/08/94  18.13.20  by  S.Ravndal
*-- Author :
      SUBROUTINE GFDCAY (IPART,BRATIO,MODE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Return branching ratios and decay modes for GEANT particles.  *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    P.Nevski                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCNUM
+SEQ,GCUNIT
      REAL      BRATIO(6)
      INTEGER   MODE(6)
C.
C.    ------------------------------------------------------------------
C.
      CALL VZERO(BRATIO,6)
      CALL VZERO(MODE,6)
      IF (IPART.LE.0)      RETURN
      IF (IPART.GT.NPART)  RETURN
C
C     Particle pointer.
C
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0)        RETURN
C
C PABR bank
      JDK1=LQ(JPA-1)
      IF (JDK1.LE.0)       RETURN
C PAMO bank
      JDK2=LQ(JPA-2)
      IF (JDK2.LE.0)       RETURN
C
C     COPY branching ratios & decay modes.
C
      DO I=1,6
         BRATIO(I) = Q(JDK1+I)
         MODE(I)   = IQ(JDK2+I)
      ENDDO
C
  99  RETURN
      END
 
+DECK,GFLUCT.
*CMZ :          14/10/97  20.16.21  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFLUCT(DEMEAN,DE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Subroutine to decide which method is used to simulate        *
C.    *   the straggling around the mean energy loss.                  *
C.    *                                                                *
C.    *                                                                *
C.    *   DNMIN:  <---------->1<-------->30<--------->50<--------->    *
C.    *                                                                *
C.    *  STRA=0   :                                                    *
C.    *   LOSS=2  <----------GLANDZ-------------------><--GLANDO-->    *
C.    *   LOSS=1,3<---------------------GLANDZ-------------------->    *
C.    *   LOSS=4              no call to GFLUCT is done                *
C.    *   STRA=1  <-----------PAI---------------------><--GLANDZ-->    *
C.    *   STRA=2  <---PAI----><---ASHO---><----PAI----><--GLANDZ-->    *
C.    *                                                                *
C.    *   DNMIN :  an estimation of the number of collisions           *
C.    *            with energy close to the ionization energy          *
C.    *            (see PHYS333)                                       *
C.    *                                                                *
C.    *   Input  : DEMEAN (mean energy loss)                           *
C.    *   Output : DE   (energy loss in the current step)              *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTMUON,GTHADR                         *
C.    *                                                                *
C.    *   Modifications:                                               *
C.    *PN,27/07/97: For Gamma<1.1 PAI fluctuations are scaled as 1/v**2*
C.    *             Brems losses are added to ionization for all models*
C.    ******************************************************************
C.
+CDE, GCBANK, GCJLOC, GCONST
+CDE, GCMATE, GCCUTS, GCMULO
+CDE, GCPHYS, GCKINE, GCTRAK
*
      PARAMETER (DGEV=0.153536 E-3, DNLIM=50)
      PARAMETER (ASHMIN=1,ASHMAX=30)
**
      DE=DEMEAN
      IF (STEP. LE.0) return
      IF (ILOSS.LE.0) return
 
      POTI  = Q(JPROB+9)
      GAMMA = GETOT/AMASS
      BETA  = VECT(7)/GETOT
      XI    = DGEV*CHARGE**2*STEP*DENS*Z/(A*BETA*BETA)
      DNMIN = MIN(XI,DEMEAN)/POTI
*
*PN,27/06/97:  PAI properly tabulated for GAMMA higher than 1.1
      IF (ILOSS.GT.1 .and. DNMIN.GE.DNLIM) THEN
 
         CALL GLANDO(ILOSS,STEP,Z,A,DENS,VECT(7),GETOT,AMASS,DELAND,I)
         DE = DEMEAN + DELAND
 
      else IF (ISTRA.GT.0 .and. DNMIN.LT.DNLIM) THEN
+SELF,IF=ASHO
*        ISTRA = 2 --> PAI + URBAN + ASHO
         IF (DNMIN.GE.ASHMIN.AND.DNMIN.LT.ASHMAX .AND.ISTRA.EQ.2) THEN
             CALL GASHO(VECT(7),AMASS,STEP,DE)
         ELSE
             DE = GSTREN(GAMMA,DCUTE,STEP)
             If (Gamma.LE.1.1) DE=DE*.173554/(BETA*BETA)
         ENDIF
+SELF,IF=-ASHO
         DE = GSTREN(max(GAMMA,1.1),DCUTE,STEP)
         If (Gamma.LE.1.1) DE=DE*.173554/(BETA*BETA)
+SELF.
      ELSE
 
         DEDX  = DEMEAN/STEP
         CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,Q(JPROB+ 10))
 
      ENDIF
*
*        Add brem losses to ionisation
*        - wrong these are LOSSES, not a measured IONIZATION !!!
*
*      NB = 0
*      IF (ITRTYP.EQ.2) NB=2*NEK1
*      IF (ITRTYP.EQ.5) NB=  NEK1
*      IF (NB.GT.0) THEN
*         JBASE = LQ(JMA-1)+NB+IEKBIN
*         DE = DE +(1.-GEKRAT)*Q(JBASE)+GEKRAT*Q(JBASE+1)
*      ENDIF
*
      END
+DECK,GSMIXT
*CMZ :          02/09/97  18.34.00  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSMIXT(IMAT,NAMATE,A,Z,DENS,NLMAT,WMAT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines mixture OR COMPOUND IMAT as composed by          *
C.    *       THE BASIC NLMAT materials defined by arrays A,Z and WMAT *
C.    *                                                                *
C.    *       If NLMAT.GT.0 then WMAT contains the PROPORTION BY       *
C.    *       WEIGTHS OF EACH BASIC MATERIAL IN THE MIXTURE.           *
C.    *                                                                *
C.    *       If NLMAT.LT.0 then WMAT contains the number of atoms     *
C.    *       of a given kind into the molecule of the COMPOUND        *
C.    *       In this case, WMAT in output is changed to relative      *
C.    *       weigths.                                                 *
C.    *                                                                *
C.    *       nb : the radiation length is computed according          *
C.    *            the EGS manual slac-210 uc-32 June-78               *
C.    *                           formula  2-6-8 (37)                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    *    Modifications:                                              *
C.    *    PN, 2.09.97  - Calculate Abs.Length for protons, not pions  *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCUNIT
+SEQ,GCMZFO
      DIMENSION WMAT(1),A(1),Z(1)
      CHARACTER*(*) NAMATE
      CHARACTER*20 NAME
      DATA ALR2AV , AL183 / 1.39621E-03  ,  5.20948 /
C.
C.    ------------------------------------------------------------------
C.
      IF (IMAT.LE.0)GO TO 99
      IF(JMATE.LE.0)THEN
         CALL MZBOOK(IXCONS,JMATE,JMATE,1,'MATE',NMATE,NMATE,0,3,0)
         IQ(JMATE-5)=0
      ENDIF
      IF(IMAT.GT.NMATE)THEN
         CALL MZPUSH(IXCONS,JMATE,IMAT-NMATE,0,'I')
         NMATE=IMAT
         JMA1=0
      ELSE
         JMA1=LQ(JMATE-IMAT)
         IF(JMA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPMATE(IMAT)
            CALL MZDROP(IXCONS,LQ(JMATE-IMAT),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JMA,JMATE,-IMAT,'MATE',20,20,11,IOMATE,0)
C
      NAME=NAMATE
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JMA+1),4,20)
C
C             Store mixture parameters
C             and parameter for Pair/Brems and
C             Photoelectric routines
C
      NLM    = IABS(NLMAT)
      IF (NLM.LE.0)GO TO 90
      CALL MZBOOK(IXCONS,JMIXT,JMA,-5,'MAMI',2,2,4*NLM,3,0)
      CALL MZBOOK(IXCONS,JMI1,JMIXT,-1,'MAM1',0,0,10,3,0)
      JMA = LQ(JMATE- IMAT)
      IQ(JMIXT-5)=IMAT
      IQ(JMI1-5)=IMAT
C
C             Compute proportion by weigths in the compound
C
      IF(NLMAT.LT.0) THEN
         AMOL   = 0.
         ZMOL   = 0.
         DO 10 I= 1,NLM
         AMOL   = AMOL + WMAT(I)*A(I)
         ZMOL   = ZMOL + WMAT(I)*Z(I)
   10    CONTINUE
         DO 20 I= 1,NLM
         WMAT(I)= WMAT(I)*A(I) / AMOL
   20    CONTINUE
      ENDIF
C
C             Compute effective mixture parameters
C
      AEFF   = 0.
      ZEFF   = 0.
      RADINV = 0.
      DO 40 I = 1,NLM
         AEFF   = AEFF + WMAT(I)*A(I)
         ZEFF   = ZEFF + WMAT(I)*Z(I)
         ZC     = Z(I)
         ALZ    = LOG(ZC)/3.
         XINV   = ZC*(ZC+GXSI(ZC))*(AL183-ALZ-GFCOUL(ZC))/A(I)
         RADINV = RADINV + WMAT(I)*XINV
         Q(JMIXT+3*NLM+I)=XINV
         Q(JMIXT + 2* NLM + I) = WMAT(I)
         Q(JMIXT + NLM + I) = Z(I)
         Q(JMIXT + I) = A(I)
   40 CONTINUE
      RADINV = ALR2AV * DENS * RADINV
      RADEFF = 1. / RADINV
      CALL GHMIX(A,WMAT,NLM,AHEFF)
      ABSEFF=10000.*AHEFF/(6.022*DENS*GHSIGM(5.,14,AHEFF))
C
      Q(JMA + 6) = AEFF
      Q(JMA + 7) = ZEFF
      Q(JMA + 8) = DENS
      Q(JMA + 9) = RADEFF
      Q(JMA + 10) = ABSEFF
      Q(JMA + 11) = NLM
      Q(JMI1 + 1) = AHEFF
      IF(NLMAT.GT.0)THEN
         Q(JMI1 + 2) = AEFF
         Q(JMI1 + 3) = ZEFF
      ELSE
         Q(JMI1 + 2) = AMOL
         Q(JMI1 + 3) = ZMOL
      ENDIF
C
      IF(JMA1.GT.0) THEN
         CALL GPMATE(-IMAT)
      ENDIF
C
      GO TO 99
C
  90  CHMAIL=' ***** GSMIXT ERROR. MIXTURE WITH NO COMPONENTS'
      CALL GMAIL(0,0)
C
  99  RETURN
10000 FORMAT(' *** GSMIXT ***: Warning, material redefinition:')
      END
+deck,trprfn.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 26/08/95  00.36.09  by  Pavel Nevski
*-- Author :
      SUBROUTINE TRPRFN(X1,P1,H1,X2,P2,H2,CH,XL,R,MVAR,IFLAG,ITRAN,IERR)
************************************************************************
*
*
*     SUBR. TRPRFN(X1,P1,H1,X2,P2,H2,CH,XL,*R*,MVAR,IFLAG,ITRAN,IERR*)
*
*     Origin W.Wittek    EMCSW/81/18
*
*     Finite step length case coded by V.Innocente ( Feb. 88 )
*
*     code improved:                   V.Innocente ( April. 90 )
*                   inline code replaces external function
*     code improved:                   V.Innocente ( January 91 )
*                   effect of energy loss added
*
*_______________________________________________________________________
*
* *** ERROR PROPAGATION ALONG A PARTICLE TRAJECTORY IN A MAGNETIC FIELD
*     ROUTINE ASSUMES THAT IN THE INTERVAL (X1,X2) THE QUANTITIES 1/P
*     AND (HX,HY,HZ) ARE CONSTANT.
*
* *** IFLAG  =  -1   INITIALIZATION, TRANSFORMATION OF ERROR MATRIX FROM
*                    EXTERNAL TO SC VARIABLES
*            =   0   ERROR PROPAGATION FROM X1 TO X2
*            =   1   TRANSFORMATION OF ERROR MATRIX FROM SC TO
*                    EXTERNAL VARIABLES
*
*     ITRAN          USED FOR IFLAG = 0 OR 1 ONLY
*            =   0   TRANSFORMATION MATRIX IS UPDATED ,BUT ERROR MATRIX IS NOT
*                    TRANSFORMED
*           =    1   TRANSF. MATRIX IS UPDATED  AND ERROR MATRIX IS TRANSFORMED
*
*     MVAR           SPECIFIES TYPE OF EXTERNAL VARIABLES
*            =   0   ( 1/P,LAMBDA,PHI,YT, ZT ;   SC   )
*            =   1   ( 1/P,  Y',  Z',  Y,  Z ; SPLINE )
*
* *** X1, P1, H1     X,Y,Z COMPONENTS OF POSITION, MOMENTUM AND MAGNETIC   INPUT
*                    FIELD VECTOR/GRADIENT AT STARTING POINT OF INTERVAL
*     X2, P2, H2     ......  AT END POINT OF INTERVAL                      INPUT
*     CH             CHARGE OF PARTICLE                                    INPUT
*     XL             PATHLENGTH FROM X1 TO X2   ( NEGATIVE IF OPPOSITE
*                    TO ACTUAL MOVEMENT OF PARTICLE )                      INPUT
*     R              ERROR MATRIX  (TRIANGLE)                       INPUT/OUTPUT
*     B              5 * 5 TRANSFORMATION MATRIX FOR ERRORS IN
*                    SC VARIABLES                                         OUTPUT
*
* *** IERR   =  1    ILLEGAL VALUE OF MVAR                                OUTPUT
*               2    MOMENTUM IS ZERO
*               3    H*ALFA/P AT X1 AND X2 DIFFER TOO MUCH
*               4    PARTICLE MOVES IN Z - DIRECTION
*
************************************************************************
*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  X1,P1,H1,X2,P2,H2,R,CH,PS,PC,XL,SPX
+CDE,TRCOM3.
+CDE,GCUNIT.
      DIMENSION X1(3),P1(3),H1(9),X2(3),P2(3),H2(9)
      DIMENSION R(15),PS(3),PC(3)
*
      DIMENSION T1(3),T2(3),U1(3),U2(3),V1(3),V2(3),HN(9)
      DIMENSION AN2(3),DX(3)
      DIMENSION HV1(3),HU1(3)
*
      SAVE INIT,DELHP6,CFACT8
*
      DATA INIT/0/
      DATA DELHP6/300.D0/
*
      DATA CFACT8 / 2.997925 D-4 /
*
*____________________________________________________________________
*
      IERR=0
      IF(IFLAG) 10, 20, 80
*
* *** TRANSFORM ERROR MATRIX FROM EXTERNAL TO INTERNAL VARIABLES;
*
   10 NEW=1
      IF(MVAR.NE.1) GO TO 11
      PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      IF(PA1.EQ.0.) GO TO 902
      PS(1)=1./PA1
      IF(P1(1).EQ.0.) GO TO 904
      PS(2)=P1(2)/P1(1)
      PS(3)=P1(3)/P1(1)
      SPX=1.
      IF(P1(1).LT.0.) SPX=-1.
      CALL TRSPSC(PS,R,PC,R,H1,CH,IERR,SPX)
      GO TO 19
*
   11 IF(MVAR.NE.0) GO TO 901
   19 GO TO 900
*
* *** ERROR PROPAGATION ON A HELIX ASSUMING SC VARIABLES
 
*
   20 PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      PA2=SQRT(P2(1)**2+P2(2)**2+P2(3)**2)
      IF(PA1*PA2.EQ.0.) GO TO 902
C      DPA = PA2 - PA1
      PM1=1./PA1
      PM2=1./PA2
      DPM = PM2 - PM1
*
      DO 201 I=1,3
        T1(I) = P1(I)*PM1
        T2(I) = P2(I)*PM2
201   CONTINUE
*
      SINL=T2(3)
      SINL0=T1(3)
*
      COSL=SQRT(ABS(1.-SINL**2))
      IF(COSL.EQ.0.) GO TO 904
      COSL1=1./COSL
      COSL0=SQRT(ABS(1.-SINL0**2))
*
* *** DEFINE TRANSFORMATION MATRIX BETWEEN X1 AND X2 FOR
* *** NEUTRAL PARTICLE OR FIELDFREE REGION
*
      DO 26 I=1,5
         DO 15 K=1,5
            A(I,K)=0.
   15    CONTINUE
         A(I,I)=1.
   26 CONTINUE
      A(4,3)=XL*COSL
      A(5,2)=XL
*
      IF(CH.EQ.0.) GO TO 45
      HA1=SQRT(H1(1)**2+H1(2)**2+H1(3)**2)
      HA2=SQRT(H2(1)**2+H2(2)**2+H2(3)**2)
      HAM1=HA1*PM1
      HAM2=HA2*PM2
      HAMX=MAX(HAM1,HAM2)
      IF(HAMX.EQ.0.) GO TO 45
*
*
*
* *** CHECK WHETHER H*ALFA/P IS TOO DIFFERENT AT X1 AND X2
*
*
      IF(HA2.NE.0.) THEN
         GAM=(H2(1)*T2(1)+H2(2)*T2(2)+H2(3)*T2(3))/HA2
      ELSE
         GAM=(H1(1)*T1(1)+H1(2)*T1(2)+H1(3)*T1(3))/HA1
      ENDIF
*
      ALFA2=1.-GAM**2
*
      DH2=(H1(1)*PM1-H2(1)*PM2)**2+
     1    (H1(2)*PM1-H2(2)*PM2)**2+
     1    (H1(3)*PM1-H2(3)*PM2)**2
      IF(DH2*ALFA2.GT.DELHP6**2) GO TO 903
*
* *** DEFINE AVERAGE MAGNETIC FIELD AND GRADIENT
*
      PM12=(PM1+PM2)*0.5
      P12=1./(2.*PM12)
      HN(1)=(H1(1)*PM1+H2(1)*PM2)*P12*CH*CFACT8
      HN(2)=(H1(2)*PM1+H2(2)*PM2)*P12*CH*CFACT8
      HN(3)=(H1(3)*PM1+H2(3)*PM2)*P12*CH*CFACT8
CC    HN(4)=(H1(4)*PM1+H2(4)*PM2)*P12*CH*CFACT8
CC    HN(5)=(H1(5)*PM1+H2(5)*PM2)*P12*CH*CFACT8
CC    HN(6)=(H1(6)*PM1+H2(6)*PM2)*P12*CH*CFACT8
CC    HN(7)=(H1(7)*PM1+H2(7)*PM2)*P12*CH*CFACT8
CC    HN(8)=(H1(8)*PM1+H2(8)*PM2)*P12*CH*CFACT8
CC    HN(9)=(H1(9)*PM1+H2(9)*PM2)*P12*CH*CFACT8
*
      HM = SQRT(HN(1)**2+HN(2)**2+HN(3)**2)
      OVER = 1./HM
      HN(1) = OVER*HN(1)
      HN(2) = OVER*HN(2)
      HN(3) = OVER*HN(3)
      PAV = .5*(PA1+PA2)
      Q = - HM/PAV
      THETA = Q*XL
      SINT = SIN(THETA)
      COST = COS(THETA)
      GAMMA=HN(1)*T2(1)+HN(2)*T2(2)+HN(3)*T2(3)
      AN2(1) = HN(2)*T2(3)-HN(3)*T2(2)
      AN2(2) = HN(3)*T2(1)-HN(1)*T2(3)
      AN2(3) = HN(1)*T2(2)-HN(2)*T2(1)
*
      AU = 1./SQRT(T1(1)**2+T1(2)**2)
      U1(1) = -AU*T1(2)
      U1(2) =  AU*T1(1)
      U1(3) =  0.D0
      V1(1) = -T1(3)*U1(2)
      V1(2) =  T1(3)*U1(1)
      V1(3) =  T1(1)*U1(2)-T1(2)*U1(1)
*
      AU = 1./SQRT(T2(1)**2+T2(2)**2)
      U2(1) = -AU*T2(2)
      U2(2) =  AU*T2(1)
      U2(3) =  0.D0
      V2(1) = -T2(3)*U2(2)
      V2(2) =  T2(3)*U2(1)
      V2(3) =  T2(1)*U2(2)-T2(2)*U2(1)
*
      DX(1) = X1(1) - X2(1)
      DX(2) = X1(2) - X2(2)
      DX(3) = X1(3) - X2(3)
*
*
* *** COMPLETE TRANSFORMATION MATRIX BETWEEN ERRORS AT X1 AND X2
* *** FIELD GRADIENT PERPENDICULAR TO TRACK IS PRESENTLY NOT
* *** TAKEN INTO ACCOUNT
*
   30 CONTINUE
      QP  = Q*PAV
      ANV = -(HN(1)*U2(1)+HN(2)*U2(2)            )
      ANU =  (HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3))
      OMCOST = 1.-COST
      TMSINT = THETA-SINT
*
      HU1(1) =            -HN(3)*U1(2)
      HU1(2) = HN(3)*U1(1)
      HU1(3) = HN(1)*U1(2)-HN(2)*U1(1)
*
      HV1(1) = HN(2)*V1(3)-HN(3)*V1(2)
      HV1(2) = HN(3)*V1(1)-HN(1)*V1(3)
      HV1(3) = HN(1)*V1(2)-HN(2)*V1(1)
*
***   1/P
*
      A(1,1) = 1.-DPM*PAV*(1.+(T2(1)*DX(1)+T2(2)*DX(2)+T2(3)*DX(3))/XL)
     +           +2.*DPM*PAV
*
      A(1,2) =  -DPM/THETA*
     1           ( TMSINT*GAMMA*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) +
     2             SINT*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3)) +
     3             OMCOST*(HV1(1)*T2(1)+HV1(2)*T2(2)+HV1(3)*T2(3)) )
*
      A(1,3) =  -COSL0*DPM/THETA*
     1           ( TMSINT*GAMMA*(HN(1)*U1(1)+HN(2)*U1(2)            ) +
     2             SINT*(U1(1)*T2(1)+U1(2)*T2(2)            ) +
     3             OMCOST*(HU1(1)*T2(1)+HU1(2)*T2(2)+HU1(3)*T2(3)) )
*
      A(1,4) =  -DPM/XL*(U1(1)*T2(1)+U1(2)*T2(2)            )
*
      A(1,5) =  -DPM/XL*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3))
*
***   Lambda
*
      A(2,1) = -QP*ANV*(T2(1)*DX(1)+T2(2)*DX(2)+T2(3)*DX(3))
     +         *(1.+DPM*PAV)
*
      A(2,2) = COST*(V1(1)*V2(1)+V1(2)*V2(2)+V1(3)*V2(3)) +
     +         SINT*(HV1(1)*V2(1)+HV1(2)*V2(2)+HV1(3)*V2(3)) +
     1         OMCOST*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3))*
     A                (HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3)) +
     2         ANV*( -SINT*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3)) +
     3         OMCOST*(V1(1)*AN2(1)+V1(2)*AN2(2)+V1(3)*AN2(3)) -
     4         TMSINT*GAMMA*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )
*
      A(2,3) = COST*(U1(1)*V2(1)+U1(2)*V2(2)            ) +
     +         SINT*(HU1(1)*V2(1)+HU1(2)*V2(2)+HU1(3)*V2(3)) +
     1         OMCOST*(HN(1)*U1(1)+HN(2)*U1(2)            )*
     A                (HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3)) +
     2         ANV*( -SINT*(U1(1)*T2(1)+U1(2)*T2(2)            ) +
     3         OMCOST*(U1(1)*AN2(1)+U1(2)*AN2(2)             ) -
     4         TMSINT*GAMMA*(HN(1)*U1(1)+HN(2)*U1(2)            ) )
      A(2,3) = COSL0*A(2,3)
*
      A(2,4) = -Q*ANV*(U1(1)*T2(1)+U1(2)*T2(2)            )
*
      A(2,5) = -Q*ANV*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3))
*
***   Phi
*
      A(3,1) = -QP*ANU*(T2(1)*DX(1)+T2(2)*DX(2)+T2(3)*DX(3))*COSL1
     +         *(1.+DPM*PAV)
*
      A(3,2) = COST*(V1(1)*U2(1)+V1(2)*U2(2)            ) +
     +         SINT*(HV1(1)*U2(1)+HV1(2)*U2(2)             ) +
     1         OMCOST*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3))*
     A                (HN(1)*U2(1)+HN(2)*U2(2)            ) +
     2         ANU*( -SINT*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3)) +
     3         OMCOST*(V1(1)*AN2(1)+V1(2)*AN2(2)+V1(3)*AN2(3)) -
     4         TMSINT*GAMMA*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )
      A(3,2) = COSL1*A(3,2)
*
      A(3,3) = COST*(U1(1)*U2(1)+U1(2)*U2(2)            ) +
     +         SINT*(HU1(1)*U2(1)+HU1(2)*U2(2)             ) +
     1         OMCOST*(HN(1)*U1(1)+HN(2)*U1(2)            )*
     A                (HN(1)*U2(1)+HN(2)*U2(2)            ) +
     2         ANU*( -SINT*(U1(1)*T2(1)+U1(2)*T2(2)            ) +
     3         OMCOST*(U1(1)*AN2(1)+U1(2)*AN2(2)             ) -
     4         TMSINT*GAMMA*(HN(1)*U1(1)+HN(2)*U1(2)            ) )
      A(3,3) = COSL1*COSL0*A(3,3)
*
      A(3,4) = -Q*ANU*(U1(1)*T2(1)+U1(2)*T2(2)            )*COSL1
*
      A(3,5) = -Q*ANU*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3))*COSL1
*
***   Yt
*
      A(4,1) = PAV*(U2(1)*DX(1)+U2(2)*DX(2)            )
     +         *(1.+DPM*PAV)
*
      A(4,2) = (   SINT*(V1(1)*U2(1)+V1(2)*U2(2)            ) +
     1           OMCOST*(HV1(1)*U2(1)+HV1(2)*U2(2)             ) +
     2           TMSINT*(HN(1)*U2(1)+HN(2)*U2(2)            )*
     3                  (HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )/Q
*
      A(4,3) = (   SINT*(U1(1)*U2(1)+U1(2)*U2(2)            ) +
     1           OMCOST*(HU1(1)*U2(1)+HU1(2)*U2(2)             ) +
     2           TMSINT*(HN(1)*U2(1)+HN(2)*U2(2)            )*
     3                  (HN(1)*U1(1)+HN(2)*U1(2)            ) )*COSL0/Q
*
      A(4,4) = (U1(1)*U2(1)+U1(2)*U2(2)            )
*
      A(4,5) = (V1(1)*U2(1)+V1(2)*U2(2)            )
*
***   Zt
*
      A(5,1) = PAV*(V2(1)*DX(1)+V2(2)*DX(2)+V2(3)*DX(3))
     +         *(1.+DPM*PAV)
*
      A(5,2) = (   SINT*(V1(1)*V2(1)+V1(2)*V2(2)+V1(3)*V2(3)) +
     1           OMCOST*(HV1(1)*V2(1)+HV1(2)*V2(2)+HV1(3)*V2(3)) +
     2           TMSINT*(HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3))*
     3                  (HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )/Q
*
      A(5,3) = (   SINT*(U1(1)*V2(1)+U1(2)*V2(2)            ) +
     1           OMCOST*(HU1(1)*V2(1)+HU1(2)*V2(2)+HU1(3)*V2(3)) +
     2           TMSINT*(HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3))*
     3                  (HN(1)*U1(1)+HN(2)*U1(2)            ) )*COSL0/Q
*
      A(5,4) = (U1(1)*V2(1)+U1(2)*V2(2)            )
*
      A(5,5) = (V1(1)*V2(1)+V1(2)*V2(2)+V1(3)*V2(3))
   45 CONTINUE
*
* *** NEW = 0  TRANSFORMATION MATRIX IS UPDATED
*           1  TRANSFORMATION MATRIX IS INITIALIZED
*
      IF(NEW.EQ.0) GO TO 23
      NEW=0
      DO 25 I=1,5
         DO 24 K=1,5
            B(I,K)=A(I,K)
   24    CONTINUE
   25 CONTINUE
      GO TO 27
   23 CONTINUE
*
      CALL XMM55(A,B,B)
*
   27 CONTINUE
   80 IF(ITRAN.EQ.0) GO TO 90
*
*
      J=0
      DO 22 I=1,5
         DO 21 K=I,5
            J=J+1
            S(J)=R(J)
   21    CONTINUE
   22 CONTINUE
*
*
* *** TRANSFORM ERROR MATRIX
*
      CALL SSMT5T(B,S,S)
*
      NEW=1
 
      J=0
      DO 41 I=1,5
         DO 40 K=I,5
            J=J+1
            R(J)=S(J)
   40    CONTINUE
   41 CONTINUE
*
   90 IF(IFLAG.LE.0) GO TO 900
*
*
* *** TRANSFORM ERROR MATRIX FROM INTERNAL TO EXTERNAL VARIABLES;
*
*
      NEW=1
      IF(MVAR.NE.1) GO TO 91
      PC(1)=PM2
      PC(2)=ASIN(P2(3)*PC(1))
      IF (ABS (P2(1)) .LT. 1.E-30) P2(1) = 1.E-30
      PC(3)=ATAN2(P2(2),P2(1))
      CALL TRSCSP(PC,R,PS,R,H2,CH,IERR,SPX)
      GO TO 900
*
   91 IF(MVAR.NE.0) GO TO 901
      GO TO 900
*
* *** ERROR EXITS
*
  901 IERR=1
      GO TO 999
  902 IERR=2
      GO TO 999
  903 IERR=3
C     IF(INIT.NE.0) GO TO 30
*     WRITE (LOUT, 998) DH2,ALFA2,XL
  998 FORMAT('0',' *** S/R TRPROP   DELTA(H*ALFA/P)',5X
     1,'EXCEEDS TOLERANCE    '/'0',3E12.5//' **********    ',///)
      INIT=1
      GO TO 30
  904 IERR=4
  999 WRITE (LOUT, 1000) IERR
 1000 FORMAT(1H ,' *** S/R ERPROP   IERR =',I5)
*
  900 CONTINUE
      END
 
+deck,trprop.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 26/08/95  00.38.03  by  Pavel Nevski
*-- Author :
C
      SUBROUTINE TRPROP(X1,P1,H1,X2,P2,H2,CH,XL,R,MVAR,IFLAG,ITRAN,IERR)
C
C *** ERROR PROPAGATION ALONG A PARTICLE TRAJECTORY IN A MAGNETIC FIELD
C     ROUTINE ASSUMES THAT IN THE INTERVAL (X1,X2) THE QUANTITIES 1/P
C     AND (HX,HY,HZ) ARE RATHER CONSTANT. DELTA(PHI) MUST NOT BE TOO LARGE
C
C     Authors: A. Haas and W. Wittek
C
C *** IFLAG  =  -1   INITIALIZATION, TRANSFORMATION OF ERROR MATRIX FROM
C                    EXTERNAL TO SC VARIABLES
C            =   0   ERROR PROPAGATION FROM X1 TO X2
C            =   1   TRANSFORMATION OF ERROR MATRIX FROM SC TO
C                    EXTERNAL VARIABLES
C
C     ITRAN          USED FOR IFLAG = 0 OR 1 ONLY
C            =   0   TRANSFORMATION MATRIX IS UPDATED ,BUT ERROR MATRIX IS NOT
C                    TRANSFORMED
C           =    1   TRANSF. MATRIX IS UPDATED  AND ERROR MATRIX IS TRANSFORMED
C
C     MVAR           SPECIFIES TYPE OF EXTERNAL VARIABLES
C            =   0   ( 1/P,LAMBDA,PHI,YT, ZT ;   SC   )
C            =   1   ( 1/P,  Y',  Z',  Y,  Z ; SPLINE )
C
C *** X1, P1, H1     X,Y,Z COMPONENTS OF POSITION, MOMENTUM AND MAGNETIC   INPUT
C                    FIELD VECTOR/GRADIENT AT STARTING POINT OF INTERVAL
C     X2, P2, H2     ......  AT END POINT OF INTERVAL                      INPUT
C     CH             CHARGE OF PARTICLE                                    INPUT
C     XL             PATHLENGTH FROM X1 TO X2   ( NEGATIVE IF OPPOSITE
C                    TO ACTUAL MOVEMENT OF PARTICLE )                      INPUT
C     R              ERROR MATRIX  (TRIANGLE)                       INPUT/OUTPUT
C     B              5 * 5 TRANSFORMATION MATRIX FOR ERRORS IN
C                    SC VARIABLES                                         OUTPUT
C
C *** IERR   =  1    ILLEGAL VALUE OF MVAR                                OUTPUT
C               2    MOMENTUM IS ZERO
C               3    H*ALFA/P AT X1 AND X2 DIFFER TOO MUCH
C                    OR DELTA PHI IS TOO LARGE
C               4    PARTICLE MOVES IN Z - DIRECTION
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  X1,P1,H1,X2,P2,H2,R,CH,PS,PC,XL,SPX
+CDE,TRCOM3.
+CDE,GCUNIT.
      DIMENSION X1(3),P1(3),H1(9),X2(3),P2(3),H2(9)
      DIMENSION R(15),PS(3),PC(3),HN(9)
C
      SAVE INIT,DELHP6,CFACT8
*
      DATA INIT/0/
      DATA DELHP6/300.D0/,DELFI6/0.1D0/
      DATA CFACT8 / 2.997925 D-4 /
C
      IERR=0
      IF(IFLAG) 10, 20, 80
C
C *** TRANSFORM ERROR MATRIX FROM EXTERNAL TO INTERNAL VARIABLES;
C
   10 NEW=1
      IF(MVAR.NE.1) GO TO 11
      PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      IF(PA1.EQ.0.) GO TO 902
      PS(1)=1./PA1
      IF(P1(1).EQ.0.) GO TO 904
      PS(2)=P1(2)/P1(1)
      PS(3)=P1(3)/P1(1)
      SPX=1.
      IF(P1(1).LT.0.) SPX=-1.
      CALL TRSPSC(PS,R,PC,R,H1,CH,IERR,SPX)
      GO TO 19
C
   11 IF(MVAR.NE.0) GO TO 901
   19 GO TO 900
C
C *** ERROR PROPAGATION ON A HELIX ASSUMING SC VARIABLES
 
C
   20 PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      PA2=SQRT(P2(1)**2+P2(2)**2+P2(3)**2)
      IF(PA1*PA2.EQ.0.) GO TO 902
      PM1=1./PA1
      PM2=1./PA2
C
      TN(1)=P1(1)+P2(1)
      TN(2)=P1(2)+P2(2)
      TN(3)=P1(3)+P2(3)
      PM12=1./SQRT(TN(1)**2+TN(2)**2+TN(3)**2)
      TN(1)=TN(1)*PM12
      TN(2)=TN(2)*PM12
      TN(3)=TN(3)*PM12
C
      SINL=TN(3)
      COSL=SQRT(ABS(1.-SINL**2))
      IF(COSL.EQ.0.) GO TO 904
      COSL1=1./COSL
      SINP=TN(2)*COSL1
      COSP=TN(1)*COSL1
C
C *** DEFINE TRANSFORMATION MATRIX BETWEEN X1 AND X2 FOR
C *** NEUTRAL PARTICLE OR FIELDFREE REGION
C
      DO 26 I=1,5
         DO 15 K=1,5
            A(I,K)=0.
   15    CONTINUE
         A(I,I)=1.
   26 CONTINUE
      A(4,3)=XL*COSL
      A(5,2)=XL
C
      IF(CH.EQ.0.) GO TO 45
      HA1=SQRT(H1(1)**2+H1(2)**2+H1(3)**2)
      HA2=SQRT(H2(1)**2+H2(2)**2+H2(3)**2)
      HAM1=HA1*PM1
      HAM2=HA2*PM2
      HAMX = MAX(HAM1,HAM2)
      IF(HAMX.EQ.0.) GO TO 45
C
C *** DEFINE AVERAGE MAGNETIC FIELD AND GRADIENT
C
      PM12=(PM1+PM2)*0.5
      P12=1./(2.*PM12)
      HN(1)=(H1(1)*PM1+H2(1)*PM2)*P12*CH*CFACT8
      HN(2)=(H1(2)*PM1+H2(2)*PM2)*P12*CH*CFACT8
      HN(3)=(H1(3)*PM1+H2(3)*PM2)*P12*CH*CFACT8
      HN(4)=(H1(4)*PM1+H2(4)*PM2)*P12*CH*CFACT8
      HN(5)=(H1(5)*PM1+H2(5)*PM2)*P12*CH*CFACT8
      HN(6)=(H1(6)*PM1+H2(6)*PM2)*P12*CH*CFACT8
      HN(7)=(H1(7)*PM1+H2(7)*PM2)*P12*CH*CFACT8
      HN(8)=(H1(8)*PM1+H2(8)*PM2)*P12*CH*CFACT8
      HN(9)=(H1(9)*PM1+H2(9)*PM2)*P12*CH*CFACT8
C
      B0=HN(1)*COSP+HN(2)*SINP
      B2=-HN(1)*SINP+HN(2)*COSP
      B3=-B0*SINL+HN(3)*COSL
      TGL=SINL*COSL1
C
C
C *** CHECK WHETHER H*ALFA/P IS TOO DIFFERENT AT X1 AND X2
C     AND WHETHER CHANGE OF TRACK DIRECTION DUE TO MAG.FIELD IS TOO LARGE
C
C
      IF(HA2.EQ.0.) GO TO 29
 
      GAM=(H2(1)*TN(1)+H2(2)*TN(2)+H2(3)*TN(3))/HA2
      GO TO 28
   29 GAM=(H1(1)*TN(1)+H1(2)*TN(2)+H1(3)*TN(3))/HA1
   28 CONTINUE
      ALFA=SQRT(ABS(1.-GAM**2))
C
      DH2=(H1(1)*PM1-H2(1)*PM2)**2+
     1    (H1(2)*PM1-H2(2)*PM2)**2+
     1    (H1(3)*PM1-H2(3)*PM2)**2
      IF(DH2*ALFA**2.GT.DELHP6**2) GO TO 903
      ALFAQ=-ALFA*CFACT8*(HAM1+HAM2)*0.5
      DFI=ABS(XL*ALFAQ)
      IF(DFI.GT.DELFI6) GO TO 903
C
C *** COMPLETE TRANSFORMATION MATRIX BETWEEN ERRORS AT X1 AND X2
C *** TAKING INTO ACCOUNT  FIELD GRADIENT PERPENDICULAR TO TRACK
C
   30 COSP2=COSP*COSP
      SINP2=SINP*SINP
      COSIP=COSP*SINP
C
      G22=SINP2*HN(9)+COSP2*HN(8)-2.0*COSIP*HN(7)
      G33=SINL*SINL*(COSP2*HN(9)+SINP2*HN(8)+2.0*COSIP*HN(7))
     ++COSL*(COSL*HN(6)-2.0*SINL*(COSP*HN(4)+SINP*HN(5)))
      G23=SINL*(COSIP*(HN(9)-HN(8))+(SINP2-COSP2)*HN(7))
     ++COSL*(COSP*HN(5)-SINP*HN(4))
C
      A(2,1)=XL*B2
      A(2,3)=-B0*XL*PM12
      A(2,4)=(B2*B3*PM12+G22)*XL*PM12
      A(2,5)=(-B2*B2*PM12+G23)*XL*PM12
C
      A(3,1)=-XL*B3*COSL1
      A(3,2)=B0*XL*PM12*COSL1**2
      A(3,3)=1.+TGL*B2*XL*PM12
      A(3,4)=(-B3*B3*PM12-G23)*XL*PM12*COSL1
      A(3,5)=(B3*B2*PM12-G33)*XL*PM12*COSL1
C
      A(4,5)=-B3*TGL*XL*PM12
      A(5,4)=B3*TGL*XL*PM12
C
   45 CONTINUE
C
C *** NEW = 0  TRANSFORMATION MATRIX IS UPDATED
C           1  TRANSFORMATION MATRIX IS INITIALIZED
C
      IF(NEW.EQ.0) GO TO 23
      NEW=0
      DO 25 I=1,5
         DO 24 K=1,5
            B(I,K)=A(I,K)
   24    CONTINUE
   25 CONTINUE
      GO TO 27
   23 CONTINUE
C
      CALL XMM55(A,B,B)
C
   27 CONTINUE
   80 IF(ITRAN.EQ.0) GO TO 90
C
C
      J=0
      DO 22 I=1,5
         DO 21 K=I,5
            J=J+1
            S(J)=R(J)
   21    CONTINUE
   22 CONTINUE
C
C
C *** TRANSFORM ERROR MATRIX
C
      CALL SSMT5T(B,S,S)
C
      NEW=1
 
      J=0
      DO 41 I=1,5
         DO 40 K=I,5
            J=J+1
            R(J)=S(J)
   40    CONTINUE
   41 CONTINUE
C
   90 IF(IFLAG.LE.0) GO TO 900
C
C
C *** TRANSFORM ERROR MATRIX FROM INTERNAL TO EXTERNAL VARIABLES;
C
C
      NEW=1
      IF(MVAR.NE.1) GO TO 91
      PC(1)=PM2
      PC(2)=ASIN(P2(3)*PC(1))
      IF (ABS (P2(1)) .LT. 1.E-30) P2(1) = 1.E-30
      PC(3) = ATAN2 (P2(2),P2(1))
      CALL TRSCSP(PC,R,PS,R,H2,CH,IERR,SPX)
      GO TO 900
C
   91 IF(MVAR.NE.0) GO TO 901
      GO TO 900
C
C *** ERROR EXITS
C
  901 IERR=1
      GO TO 999
  902 IERR=2
      GO TO 999
  903 IERR=3
      IF(INIT.NE.0) GO TO 30
C     WRITE (LOUT, 998) DH2,DFI,ALFA,XL
C 998 FORMAT(1H0,48H *** S/R TRPROP   DELTA(H*ALFA/P)  OR DELTA(PHI),5X
C    1,22HEXCEEDS TOLERANCE     /1H0,4E12.5//16H **********    ,
C    251HATTENTION !   NO FURTHER WARNINGS WILL BE GIVEN    ///)
      INIT=1
      GO TO 30
  904 IERR=4
  999 WRITE (LOUT, 1000) IERR
 1000 FORMAT(1H ,' *** S/R ERPROP   IERR =',I5)
C
  900 RETURN
      END
 
+deck,trscsp.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
C
      SUBROUTINE TRSCSP(PC,RC,PS,RS,H,CH,IERR,SPX)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM   SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C      TO  SPLINE VARIABLES (1/P,Y',Z',Y,Z)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PC(3)     1/P,LAMBDA,PHI                          INPUT
C     PS(3)     1/P,Y',Z'                              OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES        INPUT     (TRIANGLE)
C     RS(15)    ERROR MATRIX IN SPLINE VARIABLES       OUTPUT     (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (Y',YT),(Y',ZT),(Z',YT),(Z',ZT)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RS FOR FIXED X
C
C     IERR  =   1       PARTICLE MOVES PERPENDICULAR TO X-AXIS
C                      ( Y',Z' ARE NOT DEFINED )
C     SPX       SIGN OF X-COMPONENT OF PARTICLE MOMENTUM   OUTPUT
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PC,PS,H,RC,RS,CH,SPX
+CDE,TRCOM3.
      DIMENSION PC(3),PS(3),H(3),RC(15),RS(15)
      DIMENSION UN(3),VN(3)
C
      DATA CFACT8 / 2.997925 D-4 /
C
      IERR=0
      PM=PC(1)
      COSL=COS(PC(2))
      SINP=SIN(PC(3))
      COSP=COS(PC(3))
C
      TN(1)=COSL*COSP
      SPX=1.
      IF(TN(1).LT.0.) SPX=-1.
      IF(TN(1).EQ.0.) GO TO 901
      TN(2)=COSL*SINP
      TN(3)=SIN(PC(2))
C
      T1R=1./TN(1)
      PS(1)=PC(1)
      PS(2)=SINP/COSP
      PS(3)=TN(3)*T1R
C
      UN(1)=-SINP
      UN(2)=COSP
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
C
      J=0
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
      Q=-HAM*CFACT8
C
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)           )*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
 
      T3R=Q*T1R**3
      A(2,4)=-UN(1)*(VN(3)*COSZ           )*T3R
      A(2,5)=-VN(1)*(VN(3)*COSZ           )*T3R
      A(3,4)=UN(1)*(VN(2)*COSZ-UN(2)*SINZ)*T3R
      A(3,5)=VN(1)*(VN(2)*COSZ-UN(2)*SINZ)*T3R
C
    6 T2R=T1R**2
C
      A(1,1)=1.
      A(2,3)=VN(3)*COSL*T2R
      A(3,2)=UN(2)*T2R
      A(3,3)=-VN(2)*COSL*T2R
      A(4,4)=VN(3)*T1R
      A(5,4)=-VN(2)*T1R
      A(5,5)=UN(2)*T1R
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RS(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
C *** ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
      RETURN
      END
 
+deck,trspsc.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
C
      SUBROUTINE TRSPSC(PS,RS,PC,RC,H,CH,IERR,SPX)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM SPLINE VARIABLES (1/P,Y',Z',Y,Z)
C      TO    SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PS(3)     1/P,Y',Z'                               INPUT
C     PC(3)     1/P,LAMBDA,PHI                         OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RS(15)    ERROR MATRIX IN SPLINE VARIABLES        INPUT      (TRIANGLE)
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES       OUTPUT      (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (LAMBDA,Y),(LAMBDA,Z),(PHI,Y),(PHI,Z)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RS FOR FIXED X
C
C     IERR              NOT USED
C     SPX       SIGN OF X-COMPONENT OF PARTICLE MOMENTUM    INPUT
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PS,PC,H,RC,RS,CH,SPX
+CDE,TRCOM3.
      DIMENSION PS(3),PC(3),H(3),RC(15),RS(15)
      DIMENSION UN(3),VN(3)
C
      DATA CFACT8 / 2.997925 D-4 /
C
      IERR=0
      PM=PS(1)
      TN(1)=1./SQRT(1.+PS(2)**2+PS(3)**2)
      IF(SPX.LT.0.) TN(1)=-TN(1)
      TN(2)=PS(2)*TN(1)
      TN(3)=PS(3)*TN(1)
C
      PC(1)=PS(1)
      PC(2)=ASIN(TN(3))
      IF (ABS (TN(1)) .LT. 1.E-30) TN(1) = 1.E-30
      PC(3) = ATAN2 (TN(2),TN(1))
C
      COSL=SQRT(ABS(1.-TN(3)**2))
      IF (COSL .LT. 1.E-30) COSL = 1.E-30
      COSL1=1./COSL
      UN(1)=-TN(2)*COSL1
      UN(2)=TN(1)*COSL1
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RS(J)
    4    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
 
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
C
      Q=-HAM*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)           )*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(2,4)=-Q*TN(2)*SINZ
      A(2,5)=-Q*TN(3)*SINZ
      A(3,4)=-Q*TN(2)*COSZ*COSL1
      A(3,5)=-Q*TN(3)*COSZ*COSL1
C
    6 A(1,1)=1.
      A(2,2)=TN(1)*VN(2)
      A(2,3)=TN(1)*VN(3)
      A(3,2)=TN(1)*UN(2)*COSL1
      A(4,4)=UN(2)
      A(5,4)=VN(2)
      A(5,5)=VN(3)
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RC(J)=S(J)
   20    CONTINUE
   25 CONTINUE
*
* *** ERROR EXITS
*
      END
 
+deck,trscsd.
*CMZ :  1.00/00 26/08/95  01.41.40  by  Pavel Nevski
*-- Author :
C
      SUBROUTINE TRSCSD(PC,RC,PD,RD,H,CH,IERR,SPU,DJ,DK)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM   SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C      TO         VARIABLES (1/P,V',W',V,W)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PC(3)     1/P,LAMBDA,PHI                          INPUT
C     PD(3)     1/P,V',W'                              OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES        INPUT     (TRIANGLE)
C     RD(15)    ERROR MATRIX IN 1/P,V',W',V,W          OUTPUT     (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (V',YT),(V',ZT),(W',YT),(W',ZT)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RD FOR FIXED U
C     DJ(3)     UNIT VECTOR IN V-DIRECTION
C     DK(3)     UNIT VECTOR IN W-DIRECTION    OF DETECTOR SYSTEM
C
C     IERR  =   1       PARTICLE MOVES PERPENDICULAR TO U-AXIS
C                      ( V',W' ARE NOT DEFINED )
C     SPU       SIGN OF U-COMPONENT OF PARTICLE MOMENTUM   OUTPUT
C
+SELF,IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  PC,PD,H,RC,RD,CH,DJ,DK,SPU
+SELF.
+SEQ, TRCOM3.
      DIMENSION PC(3),PD(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
+SELF,IF= SINGLE.
      DATA CFACT8 / 2.997925 E-4 /
+SELF,IF=-SINGLE.
      DATA CFACT8 / 2.997925 D-4 /
+SELF.
C
      IERR=0
      PM=PC(1)
      COSL=COS(PC(2))
      SINP=SIN(PC(3))
      COSP=COS(PC(3))
C
      TN(1)=COSL*COSP
      TN(2)=COSL*SINP
      TN(3)=SIN(PC(2))
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      TVW(1)=TN(1)*DI(1)+TN(2)*DI(2)+TN(3)*DI(3)
      SPU=1.
      IF(TVW(1).LT.0.) SPU=-1.
      TVW(2)=TN(1)*DJ(1)+TN(2)*DJ(2)+TN(3)*DJ(3)
      TVW(3)=TN(1)*DK(1)+TN(2)*DK(2)+TN(3)*DK(3)
      IF(TVW(1).EQ.0.) GO TO 901
C
      T1R=1./TVW(1)
      PD(1)=PC(1)
      PD(2)=TVW(2)*T1R
      PD(3)=TVW(3)*T1R
C
      UN(1)=-SINP
      UN(2)=COSP
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
C
      J=0
 
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
      Q=-HAM*CFACT8
C
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      T3R=Q*T1R**3
      UI=UN(1)*DI(1)+UN(2)*DI(2)+UN(3)*DI(3)
      VI=VN(1)*DI(1)+VN(2)*DI(2)+VN(3)*DI(3)
      A(2,4)=-UI*(VK*COSZ-UK*SINZ)*T3R
      A(2,5)=-VI*(VK*COSZ-UK*SINZ)*T3R
      A(3,4)= UI*(VJ*COSZ-UJ*SINZ)*T3R
      A(3,5)= VI*(VJ*COSZ-UJ*SINZ)*T3R
C
    6 T2R=T1R**2
C
      A(1,1)=1.
      A(2,2)=-UK*T2R
      A(2,3)=VK*COSL*T2R
      A(3,2)=UJ*T2R
      A(3,3)=-VJ*COSL*T2R
      A(4,4)=VK*T1R
      A(4,5)=-UK*T1R
      A(5,4)=-VJ*T1R
      A(5,5)=UJ*T1R
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RD(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
C *** ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
      RETURN
      END
*
+DECK,TRSDSC.
*CMZ :  1.00/00 07/10/95  13.25.14  by  Pavel Nevski
*-- Author :   A. Haas and W. Wittek
C
      SUBROUTINE TRSDSC(PD,RD,PC,RC,H,CH,IERR,SPU,DJ,DK)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM        VARIABLES (1/P,V',W',V,W)
C      TO    SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PD(3)     1/P,V',W'                               INPUT
C     PC(3)     1/P,LAMBDA,PHI                         OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RD(15)    ERROR MATRIX IN 1/P,V',W',V,W           INPUT      (TRIANGLE)
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES       OUTPUT      (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (LAMBDA,V),(LAMBDA,W),(PHI,V),(PHI,W)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RD FOR FIXED U
C     DJ(3)     UNIT VECTOR IN V-DIRECTION
C     DK(3)     UNIT VECTOR IN W-DIRECTION    OF DETECTOR SYSTEM
C
C     IERR              NOT USED
C     SPU       SIGN OF U-COMPONENT OF PARTICLE MOMENTUM    INPUT
C
+SELF,IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PD,PC,H,RC,RD,CH,DJ,DK,SPU
+SELF.
+SEQ, TRCOM3.
      DIMENSION PD(3),PC(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
+SELF,IF= SINGLE.
      DATA CFACT8 / 2.997925 E-4 /
+SELF,IF=-SINGLE.
      DATA CFACT8 / 2.997925 D-4 /
+SELF.
C
      IERR=0
      PM=PD(1)
      TVW(1)=1./SQRT(1.+PD(2)**2+PD(3)**2)
      IF(SPU.LT.0.) TVW(1)=-TVW(1)
      TVW(2)=PD(2)*TVW(1)
      TVW(3)=PD(3)*TVW(1)
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      DO 5 I=1,3
         TN(I)=TVW(1)*DI(I)+TVW(2)*DJ(I)+TVW(3)*DK(I)
    5 CONTINUE
C
      PC(1)=PD(1)
      PC(2)=ASIN(TN(3))
      IF (ABS (TN(1)) .LT. 1.E-30) TN(1) = 1.E-30
      PC(3) = ATAN2 (TN(2),TN(1))
C
      COSL=SQRT(ABS(1.-TN(3)**2))
      IF (COSL .LT. 1.E-30) COSL = 1.E-30
      COSL1=1./COSL
      UN(1)=-TN(2)*COSL1
      UN(2)=TN(1)*COSL1
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
 
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RD(J)
    4    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
C
      Q=-HAM*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(2,4)=-Q*TVW(2)*SINZ
      A(2,5)=-Q*TVW(3)*SINZ
      A(3,4)=-Q*TVW(2)*COSZ*COSL1
      A(3,5)=-Q*TVW(3)*COSZ*COSL1
C
    6 A(1,1)=1.
      A(2,2)=TVW(1)*VJ
      A(2,3)=TVW(1)*VK
      A(3,2)=TVW(1)*UJ*COSL1
      A(3,3)=TVW(1)*UK*COSL1
      A(4,4)=UJ
      A(4,5)=UK
      A(5,4)=VJ
      A(5,5)=VK
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RC(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
C *** ERROR EXITS
C
      END
 
+deck,ssmt5t.
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
      SUBROUTINE SSMT5T(A,S,R)
C *** ------------------------------------------------------            05/07/81
C *** TRANSFORMATION OF SYMMETRIC 5X5 MATRIX S: A*S*AT -> R.
C *** A IS A GENERAL 5X5 MATRIX WHEREAS S,R ARE SYMMETRIC
C *** MATRICES STORED IN TRIANGULAR FORM. FOR:I,J=1,5
C *** R(I,J) = SUM:K=1,5(SUM:L=1,5(A(I,L)*S(L,K)*A(J,K))).
C *** NB: S AND R MAY WELL BE THE SAME MATRIX.
C
C        Author: A. Haas (Freiburg University)
C
C *** ------------------------------------------------------
      DOUBLE PRECISION A,S,R,Q,T1,T2,T3,T4,T5
      DIMENSION A(25),S(15),R(15),Q(15)
      DO 5 I=1,15
         Q(I)=S(I)
    5 CONTINUE
      K=1
      DO 15 J=1,5
         T1=A(J   )
         T2=A(J+ 5)
         T3=A(J+10)
         T4=A(J+15)
         T5=A(J+20)
         DO 10 I=J,5
            R(K)=A(I   )*(Q(1)*T1+Q(2)*T2+Q( 3)*T3+Q( 4)*T4+Q( 5)*T5)
     +          +A(I+ 5)*(Q(2)*T1+Q(6)*T2+Q( 7)*T3+Q( 8)*T4+Q( 9)*T5)
     +          +A(I+10)*(Q(3)*T1+Q(7)*T2+Q(10)*T3+Q(11)*T4+Q(12)*T5)
     +          +A(I+15)*(Q(4)*T1+Q(8)*T2+Q(11)*T3+Q(13)*T4+Q(14)*T5)
     +          +A(I+20)*(Q(5)*T1+Q(9)*T2+Q(12)*T3+Q(14)*T4+Q(15)*T5)
            K=K+1
   10    CONTINUE
   15 CONTINUE
*
      END
 
+deck,xmm55.
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
      SUBROUTINE XMM55(A,B,C)
C *** ---------------------------------------------                     05/07/81
C *** MULTIPLICATION OF 5X5 MATRICES: A*B -> C.
C *** FOR:I,J=1,5   C(I,J)=SUM:K=1,5(A(I,K)B(K,J))
C *** NB: B AND C MAY WELL BE THE SAME MATRIX
C
C        Author: A. Haas (Freiburg University)
C
C *** ---------------------------------------------
      DOUBLE PRECISION A,B,C,B1J,B2J,B3J,B4J,B5J
      DIMENSION A(25),B(25),C(25)
      DO 10 J5=5,25,5
         B5J=B(J5)
         J4=J5-1
         B4J=B(J4)
         J3=J4-1
         B3J=B(J3)
         J2=J3-1
         B2J=B(J2)
         J1=J2-1
         B1J=B(J1)
         C(J1)=A( 1)*B1J+A( 6)*B2J+A(11)*B3J+A(16)*B4J+A(21)*B5J
         C(J2)=A( 2)*B1J+A( 7)*B2J+A(12)*B3J+A(17)*B4J+A(22)*B5J
         C(J3)=A( 3)*B1J+A( 8)*B2J+A(13)*B3J+A(18)*B4J+A(23)*B5J
         C(J4)=A( 4)*B1J+A( 9)*B2J+A(14)*B3J+A(19)*B4J+A(24)*B5J
         C(J5)=A( 5)*B1J+A(10)*B2J+A(15)*B3J+A(20)*B4J+A(25)*B5J
   10 CONTINUE
*
      END
+DECK,GZEBRA.
*CMZ :          07/12/97  17.29.02  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GZEBRA(NZEB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to initialise ZEBRA store (//)                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    *       Modifications:                                           *
C.    *   PN: Ellastic zebra inspired by V.Perevozchikov               *
C.    ******************************************************************
C.
+CDE,TYPING,GCBANK,GCFLAG.
       INTEGER I1,I2,Itry,LL,KWW,memget,LOCF,NZEB
C.
C.    ------------------------------------------------------------------
C.
       NZEBRA = abs(NZEB)
       NZEBRA = max(NZEBRA,1000000)
       I1     = LOCF   (IQ)
       Do iTry=0,5
          I2  = memget (NZEBRA*4+1000)/4
          If (I2.GT.I1) GO TO 11
          NZEBRA = NZEBRA/2
          PRINT *,'* GZEBRA: requested memory size reduced to ',
     >               Nzebra,' *'
       enddo
       PRINT *,' iTRY,NZEBRA,I1,I2 =', iTRY,NZEBRA,I1,I2
       STOP    ' GZEBRA: FATAL - CAN NOT ALLOCATE MEMORY '
C
  11   LL     = max    (I2-I1,0)
       NZEBRA = LL + NZEBRA
       KWW    = LL + 100
C
       CALL MZSTOR (IXSTOR,'/GCBANK/',' ',FENDQ,LQ,LR1,WS,
     >                                    LQ(KWW+100),LQ(NZEBRA-100))
       IF (IDEBUG.GE.3) CALL MZLOGL(IXSTOR,0)
       I1     = KWBANK
       CALL MZWORK (IXSTOR,LQ(I1),LQ(KWW),5)
       CALL GWORK  (KWBANK-100)
C
      END
 
 
 
 
 
+DECK,GFINDS
*CMZ :          06/12/97  17.19.33  by  Pavel Nevski
*CMZ :  3.21/02 06/07/94  18.26.03  by  S.Giani
*-- Author :
      SUBROUTINE GFINDS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Returns the set/volume parameters corresponding to       *
C.    *       the current space point in /GCTRAK/                      *
C.    *       and fill common /GCSETS/                                 *
C.    *                                                                *
C.    *       IHSET  user set identifier                               *
C.    *       IHDET  user detector identifier                          *
C.    *       ISET set number in JSET                                  *
C.    *       IDET   detector number in JS=LQ(JSET-ISET)               *
C.    *       IDTYPE detector type (1,2)                               *
C.    *       NUMBV  detector volume numbers (array of length NVNAME)  *
C.    *       NVNAME number of volume levels                           *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *       Author    R.Brun  *********                              *
C.    *       Modified  V.Perev                                        *
C.    *       Jattf corrected by Bagdan Pavlik (Cracow)                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCSETS
+SEQ,GCVOLU
+SEQ,GCTMED
+SELF,IF=DEBUG
      INTEGER        LNAM(15), LNUM(15)
+SELF
      JATTF(JV) = JV + Nint(Q(JV+5)) + 6
C.
C.    ------------------------------------------------------------------
C.
*
+SELF, IF=DEBUG.
      WRITE(CHMAIL,1000)NLEVEL
      CALL GMAIL (0, 0)
      DO 5 I    = 1,NLEVEL
        WRITE(CHMAIL,1001)NAMES(I),NUMBER(I),LVOLUM(I),LINDEX(I)
        CALL GMAIL (0, 0)
        WRITE(CHMAIL,1002)(GTRAN(J,I),J = 1,3),(GRMAT(J,I),J=1,10)
        CALL GMAIL (0, 0)
    5   CONTINUE
 1000 FORMAT (' DEBUG : GFINDS =',I3)
 1001 FORMAT (5(1X,A4,3I3))
 1002 FORMAT (1X,13F9.4)
      NLEV = NLEVEL
      CALL UCOPY (NAMES (1),LNAM(1),NLEV)
      CALL UCOPY (NUMBER(1),LNUM(1),NLEV)
      NLEVEL    = 0
      CALL GLVOLU (NLEV, LNAM, LNUM, IER)
      IF (IER.NE.0)             STOP
+SELF.
*
      IHSET = 0
      IHDET = 0
      ISET  = 0
      IDET  = 0
      IDTYPE = 0
      NVNAME = 0
*
      DO 10 NLEV = NLEVEL,1,-1
         JVO = LQ(JVOLUM-LVOLUM(NLEV))
         JAT = JATTF(JVO)
         IDET = Q(JAT+8)
         IF(IDET.NE.0) THEN
            NL = NLEV
            GO TO 15
         ENDIF
  10  CONTINUE
      GOTO 99
  15  ISET   = Q(JAT+7)
      IDTYPE = Q(JAT+9)
      IHSET  = IQ(JSET+ISET)
      JS     = LQ(JSET-ISET)
      IHDET  = IQ(JS+IDET)
      JD     = LQ(JS-IDET)
      NVNAME = IQ(JD+2)
      DO 40 I=1,NVNAME
            NAME=IQ(JD+2*I+9)
            NUMBV(I)=0
            DO 30 J=1,NLEVEL
               IF(NAMES(J).EQ.NAME)THEN
                  NUMBV(I)=NUMBER(J)
                  GO TO 40
               ENDIF
  30        CONTINUE
  40  CONTINUE
C
   99 END
+DECK,FLUFIN,IF=hadron.
*CMZ :          29/01/98  13.12.38  by  Pavel Nevski
*CMZ :  3.21/02 19/05/94  13.35.12  by  S.Ravndal
*-- Author :
      SUBROUTINE FLUFIN
+CDE,GCBANK.
+CDE,GCCUTS.
+CDE,GCJLOC.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCTMED.
+CDE,GCUNIT.
+CDE,GFKDIS.
*CDE,DIMPAR,FINUCT,PART2T,COMCONT,FHEAVYT,PAPROPT
*CDE,       FINUC, PART2, COMCON, FHEAVY, PAPROP
*KEEP,DIMPAR.
*                                                                     *
*=== dimpar ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      DIMPAR: included in any routine                                *
*                                                                     *
*          Mxxrgn = maximum number of regions                         *
*          Mxxmdf = maximum number of media in Fluka                  *
*          Mxxmde = maximum number of media in Emf                    *
*          Mfstck = stack dimension in Fluka                          *
*          Mestck = stack dimension in Emf                            *
*          Nallwp = number of allowed particles                       *
*          Mpdpdx = number of particle types for which EM dE/dx pro-  *
*                   cesses (ion,pair,bremss) have to be computed      *
*          Icomax = maximum number of materials for compounds (equal  *
*                   to the sum of the number of materials for every   *
*                   compound )                                        *
*          Nstbis = number of stable isotopes recorded in common iso- *
*                   top                                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( MXXRGN = 500  )
      PARAMETER ( MXXMDF = 50   )
      PARAMETER ( MXXMDE = 18   )
      PARAMETER ( MFSTCK = 1000 )
      PARAMETER ( MESTCK = 100  )
      PARAMETER ( NALLWP = 39   )
      PARAMETER ( MPDPDX = 8    )
      PARAMETER ( ICOMAX = 120  )
      PARAMETER ( NSTBIS = 304  )
 
*KEEP,FINUCT.
      DOUBLE PRECISION CXR, CYR, CZR, TKI, PLR, WEI, TV, TVCMS,
     &                 TVRECL, TVHEAV, TVBIND
 
*KEEP,FINUC.
*
*=== finuc ============================================================*
*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990     by Alfredo Ferrari, INFN Milan   *
*     include file: finuc copy                   created 26/11/86 by pa*
*     note: if changed change finuc2 copy also                         *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        np        = number of secondaries                             *
*        kpart(ip) = type of the secondary ip                          *
*        cxr(ip)   = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyr(ip)   = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czr(ip)   = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        tki(ip)   = kinetic energy of secondary ip                    *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXR (MXP), CYR (MXP), CZR (MXP), TKI (MXP),
     &                 PLR (MXP), WEI (MXP), TV, TVCMS, TVRECL, TVHEAV,
     &                 TVBIND, NP0, NP, KPART (MXP)
 
      REAL RNDM(1)
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
*KEEP,PART2T.
      DOUBLE PRECISION AAM, GA, TAU, AAMDSC
 
*KEEP,PART2.
*
*=== part2 ============================================================*
*
*----------------------------------------------------------------------*
*     Include file: part2 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part3 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AAM  (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AAMDSC (IDMAX8), IICH   (IDMAX8), IIBAR  (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)
 
*KEEP,COMCONT.
      DOUBLE PRECISION AOCMBC, CONTNT, SUMACN, CABINX, CABELX,
     &                 ANXNOR, ELXNOR, CONA13, SUMZMF
 
*KEEP,COMCON.
*
*=== comcon ===========================================================*
*
*----------------------------------------------------------------------*
*                                                                      *
*     include file: comcon copy                 created 26/11/86 by pa *
*                                                                      *
*     Last change  on  30-oct-92   by   Alfredo Ferrari, INFN - Milan  *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /comcon/ contains information about compounds                    *
*         icompl(imat) = number of materials in a compound             *
*         matnum(i)    = material numbers (compounds consist of the    *
*                        materials)                                    *
*         aocmbc(i)    = atomic densities in barn**-1 cm**-1           *
*                        (Atoms Over Cm times Barn for Compounds)      *
*         cona13(i)    = A^1/3 of the constituents                     *
*         sumzmf(i)    = cumulative z^2 for multiple scattering        *
*         contnt(i)    = partial densities                             *
*         sumacn(i)    = cumulative atom contents of the compounds     *
*         cabinx(i)    = cumulative at.cont.*inelastic cross section   *
*         cabelx(i)    = cumulative at.cont.*  elastic cross section   *
*         anxnor       = total inelastic cross section                 *
*         elxnor       = total   elastic cross section                 *
*----------------------------------------------------------------------*
*
      COMMON /FKCOMC/ AOCMBC (ICOMAX), CONA13 (ICOMAX), SUMZMF (ICOMAX),
     &                CONTNT (ICOMAX), SUMACN (ICOMAX), CABINX (ICOMAX),
     &                CABELX (ICOMAX), ANXNOR, ELXNOR,  ICOMPL (MXXMDF),
     &                MATNUM (ICOMAX)
 
*KEEP,FHEAVYT.
      DOUBLE PRECISION CXHEAV, CYHEAV, CZHEAV, TKHEAV, PHEAVY,
     &                 WHEAVY, AMHEAV
 
*KEEP,FHEAVY.
*
*=== fheavy ===========================================================*
*
*----------------------------------------------------------------------*
*     Last change on 9 March 1993     by Alfredo Ferrari, INFN Milan   *
*     include file: fheavy copy       created 5/4/90 by A. Ferrari     *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /fheavy/ is the storage for heavy secondaries created in the     *
*              nuclear evaporation                                     *
*        npheav     = number of secondaries                            *
*        kheavy(ip) = type of the secondary ip                         *
*                   ( 3 = deuteron, 4 = 3-H, 5 = 3-He, 6 = 4-He,       *
*                     7-12 = "Heavy" fragment specified by Ibheav and  *
*                     Icheav )                                         *
*        cxheav(ip) = direction cosine of the secondary ip             *
*                     with respect to x-axis                           *
*        cyheav(ip) = direction cosine of the secondary ip             *
*                     with respect to y-axis                           *
*        czheav(ip) = direction cosine of the secondary ip             *
*                     with respect to z-axis                           *
*        tkheav(ip) = kinetic energy of secondary ip                   *
*        pheavy(ip) = momentum of the secondary ip                     *
*        wheavy(ip) = weight of the secondary ip                       *
*        amheav(ip) = atomic masses of the six types of evaporated     *
*                     particles                                        *
*        anheav(kp) = name of the kp-type heavy particle               *
*        icheav(kp) = charge of the kp-type heavy particle             *
*        ibheav(kp) = mass number of the kp-type heavy particle        *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*   !!! There is now the possibility to produce up to 6 "heavy" !!!!   *
*   !!! fragments besides the residual nucleus recorded in      !!!!   *
*   !!! Resnuc: they are identified by indeces 7-12, of course  !!!!   *
*   !!! the corresponding physical properties (Z,A,m..) must be !!!!   *
*   !!! updated every time they are produced                    !!!!   *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*----------------------------------------------------------------------*
*
      PARAMETER ( MXHEAV = 100 )
      CHARACTER*8 ANHEAV
      COMMON / FKHEAV / CXHEAV (MXHEAV), CYHEAV (MXHEAV),
     &                  CZHEAV (MXHEAV), TKHEAV (MXHEAV),
     &                  PHEAVY (MXHEAV), WHEAVY (MXHEAV),
     &                  AMHEAV  ( 12 ) ,
     &                  KHEAVY (MXHEAV), ICHEAV  ( 12 ) ,
     &                  IBHEAV  ( 12 ) , NPHEAV
      COMMON / FKHEAC / ANHEAV  ( 12 )
 
*KEEP,PAPROP.
*
*=== paprop ===========================================================*
*
*----------------------------------------------------------------------*
*     include file: paprop copy                   created 26/11/86 by p*
*     changes: on  16 december 1992 by Alfredo Ferrari                 *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /paprop/ contains particle properties                            *
*        btype  = literal name of the particle                         *
*        am     = particle mass in gev                                 *
*        ichrge = electric charge of the particle                      *
*        iscore = explanations for the scored distribution             *
*        genpar = names of the generalized particles                   *
*        ijdisc = list of the particle types to be discarded           *
*        thalf  = half life of the particle in sec                     *
*        biasdc = decay biasing factors                                *
*        biasin = inelastic interaction biasing factors                *
*        lhadro = flag for hadrons                                     *
*        jspinp = particle spin (in units of 1/2)                      *
*        lbsdcy = logical flag for biased decay: if .true. the biasing *
*                 factor is used as an upper limit to the decay length *
*        lprbsd = logical flag for biased decay: if .true. the biasing *
*                 factor is applied only to primaries                  *
*        lprbsi = logical flag for inelastic interaction biasing: if   *
*                 .true. the biasing factor is applied only to prima-  *
*                 ries                                                 *
*                                                                      *
*----------------------------------------------------------------------*
*
      LOGICAL LHADRO, LBSDCY, LPRBSD, LPRBSI
      CHARACTER*8 BTYPE,GENPAR
      COMMON / FKPAPR / AM  (NALLWP), AMDISC (NALLWP), THALF  (NALLWP),
     &               BIASDC (NALLWP), BIASIN (NALLWP), ICHRGE (NALLWP),
     &               ISCORE     (10), IJDISC (NALLWP), LHADRO (NALLWP),
     &               JSPINP (NALLWP), LBSDCY (NALLWP), LPRBSD, LPRBSI
      COMMON / FKCHPR / BTYPE  (NALLWP), GENPAR (30)
 
*KEEP,PAPROPT.
      DOUBLE PRECISION AM, AMDISC, THALF,BIASDC, BIASIN
*KEND.
 
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
+CDE,AGCHADR.
*
C     geant  message - NDONE positive
C     guhadr message - NREST positive
*
      IF (NDONE.GT.0 .AND. NREST.GT.0)  GO TO 81
      NDONE  = 0
      NREST  = 0
      NP     = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF ((IGF.EQ.1).OR.
     +      (GEKIN.EQ.0..AND.ITRTYP.EQ.3.AND.IPART.NE.25)) THEN
         CALL GHEISH
         IGF = 0
         GOTO 999
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         LMEC(NMEC)=30
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
         GO TO 105
      ENDIF
*
      NREST = NP+NPHEAV
      NDONE = 0
*
   81    ISTOP=1
         NSTAK1 = MIN(MAX(0,NP-NDONE),MXGKIN-NGKINE)
         DO 90  K=NDONE+1,NDONE+NSTAK1
            NREST  = NREST  - 1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NDONE2 = MAX(NDONE+NSTAK1-NP,0)
         NSTAK2 = MIN(MAX(0,NPHEAV-NDONE2),MXGKIN-NGKINE)
*
         DO 100 K=NDONE2+1,NDONE2+NSTAK2
            NREST  = NREST  - 1
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
  105  KCASE=NAMEC(12)
 
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
 
  999 END
 
+DECK,GHEISH,IF=hadron.
*CMZ :          16/12/97  13.31.05  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.38  by  S.Giani
*-- Author :
      SUBROUTINE GHEISH
C
C *** MAIN STEERING FOR HADRON SHOWER DEVELOPMENT ***
C *** NVE 15-JUN-1988 CERN GENEVA ***
C
C CALLED BY : GUHADR (USER ROUTINE)
C ORIGIN : F.CARMINATI, H.FESEFELDT
C                       ROUTINES : CALIM  16-SEP-1987
C                                  SETRES 19-AUG-1985
C                                  INTACT 06-OCT-1987
C
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCCUTS.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTMED.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCUNIT.
C --- GHEISHA COMMONS ---
*KEEP,MXGKGH.
      PARAMETER (MXGKGH=100)
*KEEP,/BLANKP.
      PARAMETER (MXGKPV=MXGKGH)
      COMMON /VECUTY/ PV(10,MXGKPV)
C
*KEEP,/CONSTS.
      COMMON/CONSTS/ PI,TWPI,PIBTW,MP,MPI,MMU,MEL,MKCH,MK0,SMP,SMPI,
     $               SMU,CT,CTKCH,CTK0,
     $               ML0,MSP,MS0,MSM,MX0,MXM,CTL0,CTSP,CTSM,CTX0,CTXM,
     $               RMASS(35),RCHARG(35)
C
                     REAL MP,MPI,MMU,MEL,MKCH,MK0,
     *                    ML0,MSP,MS0,MSM,MX0,MXM
C
*KEEP,/EVENT.
      PARAMETER (MXEVEN=12*MXGKGH)
      COMMON/EVENT / NSIZE,NCUR,NEXT,NTOT,EVE(MXEVEN)
C
*KEEP,/PRNTFL.
      COMMON/PRNTFL/INBCD,NEWBCD,INBIN,NEWBIN,NPEVT,NEVTP,LPRT,NPRT(10)
                    LOGICAL LPRT,NPRT
C
*KEND.
C
C --- "NEVENT" CHANGED TO "KEVENT" IN COMMON /CURPAR/ DUE TO CLASH ---
C --- WITH VARIABLE "NEVENT" IN GEANT COMMON ---
C
      PARAMETER (MXGKCU=MXGKGH)
      COMMON /CURPAR /WEIGHT(10),DDELTN,IFILE,IRUN,NEVT,KEVENT,SHFLAG,
     $                ITHST,ITTOT,ITLST,IFRND,TOFCUT,CMOM(5),CENG(5),
     $                RS,S,ENP(10),NP,NM,NN,NR,NO,NZ,IPA(MXGKCU),
     $                ATNO2,ZNO2
C
C --- "IPART" CHANGED TO "KPART" IN COMMON /RESULT/ DUE TO CLASH ---
C --- WITH VARIABLE "IPART" IN GEANT COMMON ---
C
      COMMON /RESULT/ XEND,YEND,ZEND,RCA,RCE,AMAS,NCH,TOF,PX,PY,PZ,
     $                USERW,INTCT,P,EN,EK,AMASQ,DELTN,ITK,NTK,KPART,IND,
     $                LCALO,ICEL,SINL,COSL,SINP,COSP,
     $                XOLD,YOLD,ZOLD,POLD,PXOLD,PYOLD,PZOLD,
     $                XSCAT,YSCAT,ZSCAT,PSCAT,PXSCAT,PYSCAT,PZSCAT
                      REAL NCH,INTCT
C
C --- "ABSL(21)" CHANGED TO "ABSLTH(21)" IN COMMON /MAT/ DUE TO CLASH ---
C --- WITH VARIABLE "ABSL" IN GEANT COMMON ---
C
      COMMON /MAT/ LMAT,
     $             DEN(21),RADLTH(21),ATNO(21),ZNO(21),ABSLTH(21),
     $             CDEN(21),MDEN(21),X0DEN(21),X1DEN(21),RION(21),
     $             MATID(21),MATID1(21,24),PARMAT(21,10),
     $             IFRAT,IFRAC(21),FRAC1(21,10),DEN1(21,10),
     $             ATNO1(21,10),ZNO1(21,10)
C
      DIMENSION IPELOS(35)
      SAVE IDEOL
C
C --- TRANSFER GEANT CUT-OFFS INTO GHEISHA VALUES ---
      DIMENSION CUTS(5)
      EQUIVALENCE (CUTS(1),CUTGAM)
      DIMENSION RNDM(1)
C
*KEEP,PCODIM.
C --- DIMENSION STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DIMENSION KIPART(48),IKPART(35)
C
*KEEP,PCODAT.
C --- DATA STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DATA KIPART/
     $               1,   3,   4,   2,   5,   6,   8,   7,
     $               9,  12,  10,  13,  16,  14,  15,  11,
     $              35,  18,  20,  21,  22,  26,  27,  33,
     $              17,  19,  23,  24,  25,  28,  29,  34,
     $              35,  35,  35,  35,  35,  35,  35,  35,
     $              35,  35,  35,  35,  30,  31,  32,  35/
C
      DATA IKPART/
     $               1,   4,   2,   3,   5,   6,   8,   7,
     $               9,  11,  16,  10,  12,  14,  15,  13,
     $              25,  18,  26,  19,  20,  21,  27,  28,
     $              29,  22,  23,  30,  31,  45,  46,  47,
     $              24,  32,  48/
C
*KEND.
C
C --- DENOTE STABLE PARTICLES ACCORDING TO GHEISHA CODE ---
C --- STABLE : GAMMA, NEUTRINO, ELECTRON, PROTON AND HEAVY FRAGMENTS ---
C --- WHEN STOPPING THESE PARTICLES ONLY LOOSE THEIR KINETIC ENERGY ---
      DATA IPELOS/
     $             1,   1,   0,   1,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   0,   0,
     $             0,   0,   0,   0,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   1,   1,
     $             0,   0,   1/
C
C --- LOWERBOUND OF KINETIC ENERGY BIN IN N CROSS-SECTION TABLES ---
      DATA TEKLOW /0.0001/
C
C --- KINETIC ENERGY TO SWITCH FROM "CASN" TO "GNSLWD" FOR N CASCADE ---
      DATA SWTEKN /0.05/
C
      DATA IDEOL/0/
C
C --- INITIALIZE RELEVANT GHEISHA VARIABLES IN CASE NOT DONE ALREADY ---
      IF (IFINIT(4) .EQ. 0) CALL GHEINI
C
C --- SET THE INTERACTION MECHANISM TO "HADR" ---
      KCASE=NAMEC(12)
C
C --- SET GHEISHA PRINTING FLAGS ACCORDING TO "DEBUG" STEERING CARD --
      IF (IDEOL .EQ. IDEBUG) GO TO 9000
C
      IF (IDEBUG .NE. 1) GO TO 9001
C
C --- SET SELECTED DEBUGGING FLAGS ---
      DO 9002 LL=1,10
      IF ((ISWIT(LL) .LE. 100) .OR. (ISWIT(LL) .GT. 110)) GO TO 9002
      JJ=ISWIT(LL)-100
      NPRT(JJ)=.TRUE.
 9002 CONTINUE
      GO TO 9000
C
C --- NO DEBUGGING SELECTED ---
 9001 CONTINUE
      DO 9003 LL=1,10
      NPRT(LL)=.FALSE.
 9003 CONTINUE
      IDEOL=IDEBUG
C
 9000 CONTINUE
C
C --- SET THE GHEISHA PARTICLE TYPE TO THE ONE OF GEANT ---
      IF(IPART.GT.48) THEN
         IF(ISTOP.EQ.0) GOTO 9999
         JPA = LQ(JPART-IPART)
         AMAS=Q(JPA+7)
         NCH =Q(JPA+8)
         KPART=-IPART
         GOTO 107
      ENDIF
      NETEST=IKPART(KPART)
      IF ((NETEST .EQ. IPART) .OR. (ISTOP .NE. 0)) GO TO 9004
C
      PRINT 8881,IPART,KPART,ISTOP
 8881 FORMAT(' *GHEISH* IPART,KPART = ',2(I3,1X),' ISTOP = ',I3/
     $ ' *GHEISH* ======> PARTICLE TYPES DO NOT MATCH <=======')
      STOP
C
 9004 CONTINUE
      KPART=KIPART(IPART)
      KKPART=KPART
      AMAS=RMASS(KPART)
      NCH=RCHARG(KPART)
C
C --- TRANSPORT THE TRACK NUMBER TO GHEISHA AND INITIALISE SOME NUMBERS
 107  NTK=ITRA
      INTCT=0.0
      NEXT=1
      NTOT=0
      TOF=0.0
C
C --- FILL RESULT COMMON FOR THIS TRACK WITH GEANT VALUES ---
C --- CALIM CODE ---
      XEND=VECT(1)
      YEND=VECT(2)
      ZEND=VECT(3)
      PX=VECT(4)
      PY=VECT(5)
      PZ=VECT(6)
      USERW=UPWGHT
C --- SETRES CODE ---
      P=VECT(7)
      AMASQ=AMAS*AMAS
      EN=SQRT(AMASQ+P*P)
      EK=ABS(EN-ABS(AMAS))
      ENOLD=EN
C
      SINL=0.0
      COSL=1.0
      SINP=0.0
      COSP=1.0
C
      IF (ABS(P) .LE. 1.0E-10) GO TO 1
      SINL=PZ
      COSL=SQRT(ABS(1.0-SINL**2))
C
 1    CONTINUE
      CALL GRNDM(RNDM,1)
      PHI=RNDM(1)*TWPI
      IF ((PX .EQ. 0.0) .AND. (PY .EQ. 0.0)) GOTO 3
      IF (ABS(PX) .LT. 1.E-10) GOTO 2
      PHI=ATAN2(PY,PX)
      GOTO 3
C
 2    CONTINUE
      IF (PY .GT. 0.0) PHI=PI/2.0
      IF (PY .LE. 0.0) PHI=3.0*PI/2.0
C
 3    CONTINUE
      SINP=SIN(PHI)
      COSP=COS(PHI)
C
C --- SET GHEISHA INDEX FOR THE CURRENT MEDIUM ALWAYS TO 1 ---
      IND=1
C
C --- TRANSFER GLOBAL MATERIAL CONSTANTS FOR CURRENT MEDIUM ---
C --- DETAILED DATA FOR COMPOUNDS IS OBTAINED VIA ROUTINE COMPO ---
      ATNO(IND+1)=A
      ZNO(IND+1)=Z
      DEN(IND+1)=DENS
      RADLTH(IND+1)=RADL
      ABSLTH(IND+1)=ABSL
C
C --- SETUP PARMAT FOR PHYSICS STEERING ---
      PARMAT(IND+1,5)=0.0
      PARMAT(IND+1,8)=IPFIS
      PARMAT(IND+1,9)=0.0
      PARMAT(IND+1,10)=0.0
      JTMN=LQ(JTM)
      IF (JTMN .LE. 0) GO TO 4
      PARMAT(IND+1,5)=Q(JTMN+26)
 4    CONTINUE
C
C --- CHECK WHETHER PARTICLE IS STOPPING OR NOT ---
      IF (ISTOP .EQ. 0) GO TO 5
C
      IF (NPRT(9)) PRINT 1000,KPART
 1000 FORMAT(' *GHEISH* STOPPING GHEISHA PARTICLE ',I3)
      CALL GHSTOP
C --- IN CASE OF DECAY OF PARTICLE OR USER PARTICLE ==> RETURN ---
      IF (LMEC(NMEC) .EQ. 5 .OR. KPART .LT. 0) GO TO 9999
C --- IN CASE OF HAD. INT. WITH GENERATION OF SEC. ==> GO TO 40 ---
      IF (IHADR .NE. 2) GO TO 40
C --- ALSO DEPOSIT REST MASS ENERGY FOR IN-STABLE PARTICLES ---
      IF (IPELOS(KPART) .EQ. 0) DESTEP=DESTEP+ABS(RMASS(KPART))
      GO TO 9999
  5   CONTINUE
C
C --- INDICATE LIGHT (<= PI) AND HEAVY PARTICLES (HISTORICALLY) ---
C --- CALIM CODE ---
      J=2
      TEST=RMASS(7)-0.001
      IF (ABS(AMAS) .LT. TEST) J=1
C
C *** DIVISION INTO VARIOUS INTERACTION CHANNELS DENOTED BY "INT" ***
C THE CONVENTION FOR "INT" IS THE FOLLOWING
C
C INT  = -1 REACTION CROSS SECTIONS NOT YET TABULATED/PROGRAMMED
C      =  0 NO INTERACTION
C      =  1 ELEASTIC SCATTERING
C      =  2 INELASTIC SCATTERING
C      =  3 NUCLEAR FISSION WITH INELEASTIC SCATTERING
C      =  4 NEUTRON CAPTURE
C
C --- INTACT CODE ---
      KK=ABS(Q(JMA+11))
      ALAM1=0.0
      CALL GRNDM(RNDM,1)
      RAT=RNDM(1)*ALAM
      NMEC=NMEC+1
      ATNO2=A
      ZNO2 =Z
C
      DO 6 K=1,KK
      IF (KK .LE. 0) GO TO 6
C
      IF (KK .EQ. 1) GO TO 7
      ATNO2=Q(JMIXT+K)
      ZNO2 =Q(JMIXT+K+KK)
C
 7    CONTINUE
C
C --- TRY FOR ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
      ALAM1=ALAM1+AIEL(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR INELASTIC SCATTERING ---
      INT=2
      LMEC(NMEC)=20
      ALAM1=ALAM1+AIIN(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NUCLEAR FISSION WITH INELASTIC SCATTERING ---
      INT=3
      LMEC(NMEC)=15
      ALAM1=ALAM1+AIFI(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NEUTRON CAPTURE ---
      INT=4
      LMEC(NMEC)=18
      ALAM1=ALAM1+AICA(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
 6    CONTINUE
C --- NO REACTION SELECTED ==> ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
C
C *** TAKE ACTION ACCORDING TO SELECTED REACTION CHANNEL ***
C --- FOLLOWING CODE IS A TRANSLATION OF "CALIM" INTO GEANT JARGON ---
C
 8    CONTINUE
      IF (NPRT(9)) PRINT 1001,INT
 1001 FORMAT(' *GHEISH* INTERACTION TYPE CHOSEN INT = ',I3)
C
C --- IN CASE OF NO INTERACTION OR UNKNOWN CROSS SECTIONS ==> DONE ---
      IF (INT .LE. 0) GO TO 40
C
C --- IN CASE OF NON-ELASTIC SCATTERING AND NO GENERATION OF SEC. ---
C --- PARTICLES DEPOSIT TOTAL PARTICLE ENERGY AND RETURN ---
      IF ((INT .EQ. 1) .OR. (IHADR .NE. 2)) GO TO 9
      ISTOP=2
      DESTEP=DESTEP+EN
      NGKINE=0
      GO TO 9999
C
 9    CONTINUE
      IF (INT .NE. 4) GO TO 10
C
C --- NEUTRON CAPTURE ---
      IF (NPRT(9)) PRINT 2000
 2000 FORMAT(' *GHEISH* ROUTINE CAPTUR WILL BE CALLED')
      ISTOP=1
      CALL CAPTUR(NOPT)
      GO TO 40
C
 10   CONTINUE
      IF (INT .NE. 3) GO TO 11
C --- NUCLEAR FISSION ---
      IF (NPRT(9)) PRINT 2001
 2001 FORMAT(' *GHEISH* ROUTINE FISSIO WILL BE CALLED')
      ISTOP=1
      TKIN=FISSIO(EK)
      GO TO 40
C
 11   CONTINUE
C
C --- ELASTIC AND INELASTIC SCATTERING ---
      PV( 1,MXGKPV)=P*PX
      PV( 2,MXGKPV)=P*PY
      PV( 3,MXGKPV)=P*PZ
      PV( 4,MXGKPV)=EN
      PV( 5,MXGKPV)=AMAS
      PV( 6,MXGKPV)=NCH
      PV( 7,MXGKPV)=TOF
      PV( 8,MXGKPV)=KPART
      PV( 9,MXGKPV)=0.
      PV(10,MXGKPV)=USERW
C
C --- ADDITIONAL PARAMETERS TO SIMULATE FERMI MOTION AND EVAPORATION ---
      DO 111 JENP=1,10
         ENP(JENP)=0.
 111  CONTINUE
      ENP(5)=EK
      ENP(6)=EN
      ENP(7)=P
C
      IF (INT .NE. 1) GO TO 12
C
C *** ELASTIC SCATTERING PROCESSES ***
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C --- NORMAL ELASTIC SCATTERING FOR LIGHT MEDIA ---
      IF (ATNO2 .LT. 1.5) GO TO 35
C
C --- COHERENT ELASTIC SCATTERING FOR HEAVY MEDIA ---
      IF (NPRT(9)) PRINT 2002
 2002 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED')
      CALL COSCAT
      GO TO 40
C
C *** NON-ELASTIC SCATTERING PROCESSES ***
 12   CONTINUE
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C *** USE SOMETIMES NUCLEAR REACTION ROUTINE "NUCREC" FOR LOW ENERGY ***
C *** PROTON AND NEUTRON SCATTERING ***
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=4.5*(EK-0.01)
      IF ((KPART .EQ. 14) .AND. (TEST1 .GT. TEST2)) GO TO 85
      IF ((KPART .EQ. 16) .AND. (TEST1 .GT. TEST2)) GO TO 86
C
C *** FERMI MOTION AND EVAPORATION ***
      TKIN=CINEMA(EK)
      PV( 9,MXGKPV)=TKIN
      ENP(5)=EK+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=FERMI(ENP(5))
      ENP(5)=ENP(5)+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=EXNU(ENP(5))
      ENP(5)=ENP(5)-TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
C
C *** IN CASE OF ENERGY ABOVE CUT-OFF LET THE PARTICLE CASCADE ***
      TEST=ABS(CHARGE)
      IF ((TEST .GT. 1.0E-10) .AND. (ENP(5) .GT. CUTHAD)) GO TO 35
      IF ((TEST .LE. 1.0E-10) .AND. (ENP(5) .GT. CUTNEU)) GO TO 35
C
C --- SECOND CHANCE FOR ANTI-BARYONS DUE TO POSSIBLE ANNIHILATION ---
      IF ((AMAS .GE. 0.0) .OR. (KPART .LE. 14)) GO TO 13
      ANNI=1.3*P
      IF (ANNI .GT. 0.4) ANNI=0.4
      CALL GRNDM(RNDM,1)
      TEST=RNDM(1)
      IF (TEST .GT. ANNI) GO TO 35
C
C *** PARTICLE WITH ENERGY BELOW CUT-OFF ***
C --- ==> ONLY NUCLEAR EVAPORATION AND QUASI-ELASTIC SCATTERING ---
 13   CONTINUE
C
      ISTOP=3
C
      IF (NPRT(9)) PRINT 1002,KPART,EK,EN,P,ENP(5),ENP(6),ENP(7)
 1002 FORMAT(' *GHEISH* ENERGY BELOW CUT-OFF FOR GHEISHA PARTICLE ',I3/
     $ ' EK,EN,P,ENP(5),ENP(6),ENP(7) = ',6(G12.5,1X))
C
      IF ((KPART .NE. 14) .AND. (KPART .NE. 16)) GO TO 14
      IF (KPART .EQ. 16) GO TO 86
C
C --- SLOW PROTON ---
 85   CONTINUE
      IF (NPRT(9)) PRINT 2003,EK,KPART
 2003 FORMAT(' *GHEISH* ROUTINE NUCREC WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL NUCREC(NOPT,2)
C
      IF (NOPT .NE. 0) GO TO 50
C
      IF (NPRT(9)) PRINT 2004,EK,KPART
 2004 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL COSCAT
      GO TO 40
C
C --- SLOW NEUTRON ---
 86   CONTINUE
      IF (NPRT(9)) PRINT 2015
      NUCFLG=0
      CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- OTHER SLOW PARTICLES ---
 14   CONTINUE
      IPA(1)=KPART
C --- DECIDE FOR PROTON OR NEUTRON TARGET ---
      IPA(2)=16
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=ZNO2/ATNO2
      IF (TEST1 .LT. TEST2) IPA(2)=14
      AVERN=0.0
      NFL=1
      IF (IPA(2) .EQ. 16) NFL=2
      IPPP=KPART
      IF (NPRT(9)) PRINT 2005
 2005 FORMAT(' *GHEISH* ROUTINE TWOB WILL BE CALLED')
      CALL TWOB(IPPP,NFL,AVERN)
      GOTO 40
C
C --- INITIALISATION OF CASCADE QUANTITIES ---
 35   CONTINUE
C
C *** CASCADE GENERATION ***
C --- CALCULATE FINAL STATE MULTIPLICITY AND LONGITUDINAL AND ---
C --- TRANSVERSE MOMENTUM DISTRIBUTIONS ---
C
C --- FIXED PARTICLE TYPE TO STEER THE CASCADE ---
      KKPART=KPART
C
C --- NO CASCADE FOR LEPTONS ---
      IF (KKPART .LE. 6) GO TO 9999
C
C *** WHAT TO DO WITH "NEW PARTICLES" FOR GHEISHA ?????? ***
C --- RETURN FOR THE TIME BEING ---
      IF (KKPART .GE. 35) GO TO 9999
C
C --- CASCADE OF HEAVY FRAGMENTS
      IF ((KKPART .GE. 30) .AND. (KKPART .LE. 32)) GO TO 390
C
C --- INITIALIZE THE IPA ARRAY ---
      CALL VZERO(IPA(1),MXGKCU)
C
C --- CASCADE OF OMEGA - AND OMEGA - BAR ---
      IF (KKPART .EQ. 33) GO TO 330
      IF (KKPART .EQ. 34) GO TO 331
C
      NVEPAR=KKPART-17
      IF (NVEPAR .LE. 0) GO TO 15
      GO TO (318,319,320,321,322,323,324,325,326,327,328,329),NVEPAR
C
 15   CONTINUE
      NVEPAR=KKPART-6
      GO TO (307,308,309,310,311,312,313,314,315,316,317,318),NVEPAR
C
C --- PI+ CASCADE ---
 307  CONTINUE
      IF (NPRT(9)) PRINT 2006
 2006 FORMAT(' *GHEISH* ROUTINE CASPIP WILL BE CALLED')
      CALL CASPIP(J,INT,NFL)
      GO TO 40
C
C --- PI0 ==> NO CASCADE ---
 308  CONTINUE
      GO TO 40
C
C --- PI- CASCADE ---
 309  CONTINUE
      IF (NPRT(9)) PRINT 2007
 2007 FORMAT(' *GHEISH* ROUTINE CASPIM WILL BE CALLED')
      CALL CASPIM(J,INT,NFL)
      GO TO 40
C
C --- K+ CASCADE ---
 310  CONTINUE
      IF (NPRT(9)) PRINT 2008
 2008 FORMAT(' *GHEISH* ROUTINE CASKP WILL BE CALLED')
      CALL CASKP(J,INT,NFL)
      GO TO 40
C
C --- K0 CASCADE ---
 311  CONTINUE
      IF (NPRT(9)) PRINT 2009
 2009 FORMAT(' *GHEISH* ROUTINE CASK0 WILL BE CALLED')
      CALL CASK0(J,INT,NFL)
      GO TO 40
C
C --- K0 BAR CASCADE ---
 312  CONTINUE
      IF (NPRT(9)) PRINT 2010
 2010 FORMAT(' *GHEISH* ROUTINE CASK0B WILL BE CALLED')
      CALL CASK0B(J,INT,NFL)
      GO TO 40
C
C --- K- CASCADE ---
 313  CONTINUE
      IF (NPRT(9)) PRINT 2011
 2011 FORMAT(' *GHEISH* ROUTINE CASKM WILL BE CALLED')
      CALL CASKM(J,INT,NFL)
      GO TO 40
C
C --- PROTON CASCADE ---
 314  CONTINUE
      IF (NPRT(9)) PRINT 2012
 2012 FORMAT(' *GHEISH* ROUTINE CASP WILL BE CALLED')
      CALL CASP(J,INT,NFL)
      GO TO 40
C
C --- PROTON BAR CASCADE ---
 315  CONTINUE
      IF (NPRT(9)) PRINT 2013
 2013 FORMAT(' *GHEISH* ROUTINE CASPB WILL BE CALLED')
      CALL CASPB(J,INT,NFL)
      GO TO 40
C
C --- NEUTRON CASCADE ---
 316  CONTINUE
      NUCFLG=0
      IF (EK .GT. SWTEKN) THEN
         CALL CASN(J,INT,NFL)
         IF (NPRT(9)) PRINT 2014
 2014 FORMAT(' *GHEISH* ROUTINE CASN WILL BE CALLED')
      ELSE
         CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
         IF (NPRT(9)) PRINT 2015
 2015 FORMAT(' *GHEISH* ROUTINE GNSLWD WILL BE CALLED')
      ENDIF
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- NEUTRON BAR CASCADE ---
 317  CONTINUE
      IF (NPRT(9)) PRINT 2016
 2016 FORMAT(' *GHEISH* ROUTINE CASNB WILL BE CALLED')
      CALL CASNB(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA CASCADE ---
 318  CONTINUE
      IF (NPRT(9)) PRINT 2017
 2017 FORMAT(' *GHEISH* ROUTINE CASL0 WILL BE CALLED')
      CALL CASL0(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA BAR CASCADE ---
 319  CONTINUE
      IF (NPRT(9)) PRINT 2018
 2018 FORMAT(' *GHEISH* ROUTINE CASAL0 WILL BE CALLED')
      CALL CASAL0(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + CASCADE ---
 320  CONTINUE
      IF (NPRT(9)) PRINT 2019
 2019 FORMAT(' *GHEISH* ROUTINE CASSP WILL BE CALLED')
      CALL CASSP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 ==> NO CASCADE ---
 321  CONTINUE
      GO TO 40
C
C --- SIGMA - CASCADE ---
 322  CONTINUE
      IF (NPRT(9)) PRINT 2020
 2020 FORMAT(' *GHEISH* ROUTINE CASSM WILL BE CALLED')
      CALL CASSM(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + BAR CASCADE ---
 323  CONTINUE
      IF (NPRT(9)) PRINT 2021
 2021 FORMAT(' *GHEISH* ROUTINE CASASP WILL BE CALLED')
      CALL CASASP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 BAR ==> NO CASCADE ---
 324  CONTINUE
      GO TO 40
C
C --- SIGMA - BAR CASCADE ---
 325  CONTINUE
      IF (NPRT(9)) PRINT 2022
 2022 FORMAT(' *GHEISH* ROUTINE CASASM WILL BE CALLED')
      CALL CASASM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 CASCADE ---
 326  CONTINUE
      IF (NPRT(9)) PRINT 2023
 2023 FORMAT(' *GHEISH* ROUTINE CASX0 WILL BE CALLED')
      CALL CASX0(J,INT,NFL)
      GO TO 40
C
C --- XI - CASCADE ---
 327  CONTINUE
      IF (NPRT(9)) PRINT 2024
 2024 FORMAT(' *GHEISH* ROUTINE CASXM WILL BE CALLED')
      CALL CASXM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 BAR CASCADE ---
 328  CONTINUE
      IF (NPRT(9)) PRINT 2025
 2025 FORMAT(' *GHEISH* ROUTINE CASAX0 WILL BE CALLED')
      CALL CASAX0(J,INT,NFL)
      GO TO 40
C
C --- XI - BAR CASCADE ---
 329  CONTINUE
      IF (NPRT(9)) PRINT 2026
 2026 FORMAT(' *GHEISH* ROUTINE CASAXM WILL BE CALLED')
      CALL CASAXM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - CASCADE ---
 330  CONTINUE
      IF (NPRT(9)) PRINT 2027
 2027 FORMAT(' *GHEISH* ROUTINE CASOM WILL BE CALLED')
      CALL CASOM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - BAR CASCADE ---
 331  CONTINUE
      IF (NPRT(9)) PRINT 2028
 2028 FORMAT(' *GHEISH* ROUTINE CASAOM WILL BE CALLED')
      CALL CASAOM(J,INT,NFL)
      GO TO 40
C
C --- HEAVY FRAGMENT CASCADE ---
 390  CONTINUE
      IF (NPRT(9)) PRINT 2090
 2090 FORMAT(' *GHEISH* ROUTINE CASFRG WILL BE CALLED')
      NUCFLG=0
      CALL CASFRG(NUCFLG,INT,NFL)
      IF (NUCFLG .NE. 0) GO TO 50
C
C *** CHECK WHETHER THERE ARE NEW PARTICLES GENERATED ***
 40   CONTINUE
      IF ((NTOT .NE. 0) .OR. (KKPART .NE. KPART)) GO TO 50
C
C --- NO SECONDARIES GENERATED AND PARTICLE IS STILL THE SAME ---
C --- ==> COPY EVERYTHING BACK IN THE CURRENT GEANT STACK ---
      NGKINE=0
      TOFG=TOFG+TOF*0.5E-10
C --- In case of crazy momentum value ==> no change to GEANT stack ---
      IF (P .LT. 0.) GO TO 41
      VECT(4)=PX
      VECT(5)=PY
      VECT(6)=PZ
      VECT(7)=P
      GETOT=EN
      GEKIN=EK
C --- CHECK KINETIC ENERGY ---
      CALL GEKBIN
      EDEP=ABS(ENOLD-EN)
      RMASSI=EN-EK
      IF (NPRT(9) .AND. (EN .GT. ENOLD))
     $ PRINT 8888,EDEP,ENOLD,EN,EK,RMASSI
 8888 FORMAT(' *GHEISH* EDEP,ENOLD,EN,EK,M = ',5(G12.5,1X)/
     $ ' *GHEISH* =======> EDEP WOULD BE NEGATIVE <========')
      IF (ISTOP .EQ. 0) DESTEP=DESTEP+EDEP
C
C --- RE-INITIALIZE THE PROBABILITY FOR HADRONIC INTERACTION ---
 41   CONTINUE
      CALL GRNDM(RNDM,1)
      IF ((RNDM(1) .LE. 0.) .OR. (RNDM(1) .GE. 1.)) GO TO 41
      ZINTHA=-LOG(RNDM(1))
      SLHADR=SLENG
      STEPHA=1.0E10
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1003,NTOT,IPART,KPART,KKPART,NVEDUM
 1003 FORMAT(' *GHEISH* NO SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X)/
     $ ' CURRENT PARTICLE ON THE STACK AGAIN')
      GO TO 9999
C
C *** CURRENT PARTICLE IS NOT THE SAME AS IN THE BEGINNING OR/AND ***
C *** ONE OR MORE SECONDARIES HAVE BEEN GENERATED ***
 50   CONTINUE
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1004,NTOT,IPART,KPART,KKPART,NVEDUM
 1004 FORMAT(' *GHEISH* SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X))
C
C --- INITIAL PARTICLE TYPE HAS BEEN CHANGED ==> PUT NEW TYPE ON ---
C --- THE GEANT TEMPORARY STACK ---
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((KPART .NE. 11) .AND. (KPART .NE. 12)) GO TO 52
      CALL GRNDM(RNDM,1)
      KPART=11.5+RNDM(1)
C
 52   CONTINUE
      ITY=IKPART(KPART)
      LNVE=LQ(JPART-ITY)
      IF (LNVE .LE. 0) PRINT 1234,NTOT,ITY,LNVE
 1234 FORMAT('0*GHEISH* 1234 NTOT,ITY,LNVE = ',3(I10,1X))
      IF (LNVE .LE. 0) STOP
      IF (ISTOP .EQ. 0) ISTOP=1
C
C --- IN CASE THE NEW PARTICLE IS A NEUTRINO ==> FORGET IT ---
      IF (KPART .EQ. 2) GO TO 60
C
C --- PUT PARTICLE ON THE STACK ---
      GKIN(1,1)=PX*P
      GKIN(2,1)=PY*P
      GKIN(3,1)=PZ*P
      GKIN(4,1)=SQRT(P*P+RMASS(KPART)**2)
      GKIN(5,1)=ITY
      TOFD(1)=TOF*0.5E-10
      NGKINE = 1
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
      IF (NPRT(9)) PRINT 1005,ITY,NGKINE
 1005 FORMAT(' *GHEISH* GEANT PART. ',I3,' PUT ONTO STACK AT POS. ',I3)
C
C *** CHECK WHETHER SECONDARIES HAVE BEEN GENERATED AND COPY THEM ***
C *** ALSO ON THE GEANT STACK ***
 60   CONTINUE
C
C --- ALL QUANTITIES ARE TAKEN FROM THE GHEISHA STACK WHERE THE ---
C --- CONVENTION IS THE FOLLOWING ---
C
C EVE(INDEX+ 1)= X
C EVE(INDEX+ 2)= Y
C EVE(INDEX+ 3)= Z
C EVE(INDEX+ 4)= NCAL
C EVE(INDEX+ 5)= NCELL
C EVE(INDEX+ 6)= MASS
C EVE(INDEX+ 7)= CHARGE
C EVE(INDEX+ 8)= TOF
C EVE(INDEX+ 9)= PX
C EVE(INDEX+10)= PY
C EVE(INDEX+11)= PZ
C EVE(INDEX+12)= TYPE
C
      IF (NTOT .LE. 0) GO TO 9999
C
C --- ONE OR MORE SECONDARIES HAVE BEEN GENERATED ---
      DO 61 L=1,NTOT
      INDEX=(L-1)*12
      JND=EVE(INDEX+12)
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((JND .NE. 11) .AND. (JND .NE. 12)) GO TO 63
      CALL GRNDM(RNDM,1)
      JND=11.5+RNDM(1)
C
C --- FORGET ABOUT NEUTRINOS ---
 63   CONTINUE
      IF (JND .EQ. 2) GO TO 61
C
C --- SWITH TO GEANT QUANTITIES ---
      ITY=IKPART(JND)
      JTY=LQ(JPART-ITY)
      IF (JTY .LE. 0) PRINT 1235,NTOT,ITY,JTY
 1235 FORMAT('0*GHEISH* 1235 NTOT,ITY,JTY = ',3(I10,1X))
      IF (JTY .LE. 0) STOP
*     ITRT=Q(JTY+6)
      PLX=EVE(INDEX+9)
      PLY=EVE(INDEX+10)
      PLZ=EVE(INDEX+11)
      ELT=SQRT(PLX*PLX+PLY*PLY+PLZ*PLZ+Q(JTY+7)**2)
C
C --- ADD PARTICLE TO THE STACK IF STACK NOT YET FULL ---
      IF (NGKINE .GE. MXGKIN) THEN
          WRITE(CHMAIL,1236) NTOT, L
 1236     FORMAT(' *** GHEISH: ',I9,' particle produced but only ',
     +           I9,' put on the GEANT stack!')
          CALL GMAIL(1,1)
          GO TO 9999
      ENDIF
      NGKINE=NGKINE+1
      GKIN(1,NGKINE)=PLX
      GKIN(2,NGKINE)=PLY
      GKIN(3,NGKINE)=PLZ
      GKIN(4,NGKINE)=ELT
      GKIN(5,NGKINE)=ITY
      TOFD(NGKINE)=EVE(INDEX+8)*0.5E-10
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
      IF (NPRT(9)) PRINT 1006,ITY,NGKINE,L,(EVE(INDEX+J),J=1,12)
 1006 FORMAT(' *GHEISH* GEANT PART. ',I3,' ALSO PUT ONTO STACK AT',
     $ ' POS. ',I3/
     $ ' EVE(',I2,') = '/12(1H ,12X,G12.5/))
C
 61   CONTINUE
C
 9999 CONTINUE
C --- LIMIT THE VALUE OF NGKINE IN CASE OF OVERFLOW ---
      NGKINE=MIN(NGKINE,MXGKIN)
      END
 
+DECK,GCALOR,IF=GCALOR,If=hadron.
*CMZ :          25/03/98  17.47.04  by  Pavel Nevski
*CMZ :  1.04/08 31/08/95  12.01.02  by  Christian Zeitnitz
*-- Author : Christian Zeitnitz
      SUBROUTINE GCALOR
********************************************************************
*                                                                  *
* PURPOSE: GEANT interface to CALOR                                *
*                                                                  *
* CALLED BY : GUHADR                                               *
*                                                                  *
* INPUT :  particle, material, and probabilities via GEANT common  *
*                                                                  *
* OUTPUT : COMMON GCKING, DESTEP                                   *
*          KCALL  = -1  : Nothing done                             *
*                 =  0  : NMTC has been called                     *
*                 =  1  : MICAP has been called                    *
*                 =  2  : HETC/SKALE has been called               *
*                 =  3  : FLUKA has been called                    *
*                                                                  *
* AUTHOR : C.Zeitnitz (University of Arizona)                      *
*                                                                  *
********************************************************************
C.
C. --- GEANT Commons
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCONST.
+CDE,GCCUTS.
+CDE,GCFLAG.
C --- CALOR - GEANT Interface common
*KEEP,CALGEA.
C***************************************************************
C
C       CALOR-GEANT Interface common
C
C parameters of incident particle :
C                   IPinc   = particle type a la CALOR
C                   Einc    = kinetic energy
C                   Uinc(3) = direction cosines
C material parameters:
C                   NCEL    = number of elements in mixture (NMTC)
C                             GEANT material no. for MICAP
C                   Amed(I) = mass number
C                   Zmed(I) = charge number
C                   Dmed(I) = Atoms/cm**3 * 1E-24
C                   Hden    = Atoms/cm**3 * 1E-24
C                             of H-Atoms in mixture
C
C particle stack:
C            NPHETC           = number of particles
C            Ekinet(1:NPHETC) = kinetic energy of part.
C            IPCAL(1:NPHETC)  = particle type a la CALOR (extended)
C            UCAL(1:NPHETC,3) = direction cosines
C            CALTIM(1:NPHETC) = age of particle (nsec)
C
C            ATARGT = A no. of target nucleus
C            ZTARGT = Z no. of target nucleus
C
C return of residual nucleus information
C            NRECOL  = no. of heavy recoil products
C            Amed(I) = mass number of residual nucleus
C            Zmed(I) = charge number "          "
C            EXmed   = exitation energy of nucleus
C            ERmed(I)= recoil energy of nucleus
C            IntCal  = type of interaction (GEANT NAMEC index)
C return of cross section of hadronic interaction (CALSIG called)
C            SIG =  x-section
C
C set by CALSIG:
C            ICPROC = -1   undefined
C                   =  0   NMTC called for cross-section
C                   =  1   MICAP called for cross-section
C                   =  2   SKALE(NMTC at 3 GeV) called for cross-section
C                   =  3   FLUKA called for cross-section
C            KCALL : same coding as ICPROC, but is only valid after a
C                    call to GCALOR
C       18/8/92  C.Zeitnitz University of Arizona
C****************************************************************
C
      PARAMETER(EMAXP  = 3.495)
      PARAMETER(EMAXPI = 2.495)
C transition upper limit (GeV) NMTC-FLUKA
      PARAMETER(ESKALE = 10.0)
      PARAMETER(MXCP = 300)
C
      COMMON/ CALGEA / IPINC  , EINC       , UINC(3)   ,NCEL        ,
     +                 HDEN   , AMED(100)  , ZMED(100) ,DMED(100)   ,
     +                 NPHETC ,EKINET(MXCP),IPCAL(MXCP),UCAL(MXCP,3),
     +                 INTCAL , EXMED      , ERMED(100),SIG         ,
     +                 CALTIM(MXCP), ICPROC, NRECOL    ,KCALL       ,
     +                 ATARGT , ZTARGT
C
*KEEP,CERRCM.
      LOGICAL CERRF
      COMMON/CERRCM/CERRF,IERRU
*KEEP,CAMASS.
      REAL*4 XMASS(0:11)
      COMMON/CMASS/XMASS
*KEND.
C
C  Avogadro number multiplied by 1.E-24
      PARAMETER(XNAVO = 0.60221367)
C
      DIMENSION NNPART(12)
      LOGICAL INIT,GOFLUK,DOSKAL,SKALEF,NABSOR,FSTOP
      DOUBLE PRECISION DECIN,DMASS
C
      DATA INIT /.TRUE./
      SAVE INIT
C
      IF ( INIT ) THEN
C
C     initialize CALOR
         CALL CALINI
C
         INIT = .FALSE.
C
      ENDIF
      KCALL = -1
C
C get CALOR particle type
      IPINC = -1
      IF(IPART .LE. 48 )  IPINC = IGECAL(IPART)
C
C energy in MeV
 
      EINC   =GEKIN * 1000.0
      UINC(1)=VECT(4)
      UINC(2)=VECT(5)
      UINC(3)=VECT(6)
      KCASE=NAMEC(12)
      NGKINE = 0
      NABSOR = .FALSE.
      FSTOP = .FALSE.
C ----- particle has to be stopped ? -------
      IF(GEKIN.LT.CUTHAD.AND.ITRTYP.EQ.4) THEN
         FSTOP = .TRUE.
         ISTOP = 2
         IF(IPART .EQ. 9) THEN
            NABSOR = .TRUE.
            ISTOP = 1
            EINC = 1.0
            IF(GEKIN.GT.EINC/1000.) DESTEP = DESTEP + GEKIN - EINC/
     +      1000.0
            GEKIN = 0.0
            VECT(7) = 0.0
            KCASE = NAMEC(18)
            NMEC = NMEC + 1
            LMEC(NMEC) = 18
         ELSE
            DESTEP = DESTEP + GEKIN
            GEKIN = 0.0
            VECT(7) = 0.0
            IF(IPART.EQ.8.OR.IPART.EQ.11.OR.IPART.EQ.12) THEN
              CALL GDECAY
              KCASE = NAMEC(5)
              NMEC = NMEC + 1
              LMEC(NMEC) = 5
            ENDIF
            RETURN
         ENDIF
      ELSE IF(GEKIN.LT.CUTNEU.AND.IPART.EQ.13) THEN
         IF(GEKIN.LT.1.E-14) EINC=1.E-11
         ISTOP = 1
         NABSOR = .TRUE.
      ENDIF
      IF(ISTOP.EQ.2.OR.GEKIN.EQ.0.0) RETURN
C
C ------------- check if FLUKA has to be called ---------
C ------------------------------------------------- Goto FLUKA ?
C
      DOSKAL = (IPINC.EQ.0 .OR. IPINC.EQ.1) .AND. GEKIN.GT.EMAXP
      DOSKAL = DOSKAL .OR. (GEKIN .GT. EMAXPI .AND. (IPINC .GT. 1))
      IF(ICPROC.GE.0) THEN
         GOFLUK = ICPROC.EQ.3 .OR. IPINC.EQ.-1
         DOSKAL = DOSKAL .AND. ICPROC.EQ.2
      ELSE
         GOFLUK = IPINC .EQ. -1 .OR. GEKIN .GE. ESKALE
         DOSKAL = DOSKAL .AND. .NOT.GOFLUK
         GOFLUK = GOFLUK .OR. (DOSKAL.AND.SKALEF(IPINC,GEKIN,ESKALE))
         GOFLUK = GOFLUK .AND. .NOT.FSTOP .AND. .NOT.NABSOR
      ENDIF
      ICPROC = -1
C ------------------------------------------- call FLUKA
      IF(GOFLUK) THEN
         CALL FLUFIN
         KCALL = 3
         RETURN
      ENDIF
      CERRF = .FALSE.
      IF(IPINC .EQ. 1 .AND. EINC .LE. 20.0) THEN
C MICAP needs only GEANT material number
         NCEL = NMAT
C --- low energetic neutron -> call micap
         CALL MICAP
         KCALL = 1
      ELSE
         NCEL = 1
         AMED(1) = A
         ZMED(1) = Z
         DMED(1) = DENS/A*XNAVO
         IF(INT(A) .EQ. 1) THEN
            HDEN = DMED(1)
         ELSE
            HDEN = 0.0
         ENDIF
C ------- get material parameter for a mixture---------------------
         KK=MIN1(ABS(Q(JMA+11)),100.)
         NCEL = 1
         IF(KK.GT.1) THEN
            HDEN = 0.0
            NCEL = 0
            AMOL = Q(LQ(JMIXT-1) + 2)
            DO 10 K=1,KK
               IF(NINT(Q(JMIXT+K)).EQ.1) THEN
C                           hydrogen density
                  XMOLCM = DENS/AMOL*XNAVO
                  WI = Q(JMIXT+K+2*KK)*AMOL/Q(JMIXT+K)
                  HDEN = HDEN + XMOLCM * WI
               ELSE
                  NCEL = NCEL + 1
                  AMED(NCEL) = Q(JMIXT+K)
                  ZMED(NCEL) = Q(JMIXT+K+KK)
C                                        molekuls/cm^3
                  XMOLCM = DENS/AMOL*XNAVO
C                                     number of atoms per molecule
                  WI = Q(JMIXT+K+2*KK)*AMOL/AMED(NCEL)
C                                        atoms/cm^3
                  DMED(NCEL) = XMOLCM * WI
               ENDIF
   10       CONTINUE
         ENDIF
         CALL CHETC(DOSKAL)
         KCALL = 0
         IF(DOSKAL) KCALL = 2
      ENDIF
C error ocurred in CALOR ?
      IF(CERRF) THEN
         WRITE(IERRU,'('' NEVT,IPART,Ek,NMED,ISTOP,NABSOR,FSTOP :'',   '
     +   //'          I10,I5,G15.6,2I6,2L6)') IEVENT,IPART,GEKIN,NMAT,
     +   ISTOP,NABSOR,FSTOP
      ENDIF
      ESUM =0.
      EKSUM = 0.
      PX = 0.
      PY = 0.
      PZ = 0.
      NGKINE = 0
      PSUM = 0.
C
      ZINTHA=GARNDM(6)
      SLHADR=SLENG
      STEPHA=BIG
C
      IF(NPHETC.EQ.0.AND.NABSOR) ISTOP = 2
C neutron has been absorbed -> INTCAL=18
      IF(INTCAL.EQ.18) ISTOP = 1
      IF(NPHETC.LE.0) GOTO 160
C
C too many particles in the CALOR array for GEANT
C happens sometimes with deexitation gammas and evaporation neutrons
C simple approach to combine particles and sum up their energies, but
C forget about momentum conservation
C
      IF(NPHETC.GT.MXGKIN) THEN
   20    CONTINUE
         DO 30 I=1,12
            NNPART(I)=0
   30    CONTINUE
         NNTOT = 0
         DO 40 I=1,NPHETC
            IF(IPCAL(I).NE.-1) THEN
               NNPART(IPCAL(I)+1)=NNPART(IPCAL(I)+1)+1
               NNTOT = NNTOT + 1
            ENDIF
   40    CONTINUE
         IF(NNTOT.LE.MXGKIN) GOTO 100
         JMAX=0
         IMAX=0
         DO 50 I=1,12
            IF(JMAX.LT.NNPART(I)) THEN
               JMAX=NNPART(I)
               IPI=I-1
            ENDIF
   50    CONTINUE
         DO 60 I=1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 70
   60    CONTINUE
   70    I1=I
         DO 80 I=I1+1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 90
   80    CONTINUE
   90    I2=I
         ECINI = EKINET(I1)
         DMASS = DBLE(XMASS(IPI))*1.D3
         DECIN = DBLE(ECINI)
         PPI = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         IPJ = IPCAL(I2)
         ECINJ = EKINET(I2)
         DECIN = DBLE(ECINJ)
         PPJ = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         ECIN = SNGL(DBLE(ECINI)+DBLE(ECINJ)+DMASS)
         EKINET(I1) = ECIN
         PP = SNGL(DSQRT(DBLE(ECIN*ECIN) + 2.D0*DBLE(ECIN)*DMASS))
C determine new direction cosines
         UCAL(I1,1) = (PPI*UCAL(I1,1)+PPJ*UCAL(I2,1))/PP
         UCAL(I1,2) = (PPI*UCAL(I1,2)+PPJ*UCAL(I2,2))/PP
         UCAL(I1,3) = (PPI*UCAL(I1,3)+PPJ*UCAL(I2,3))/PP
         USUM = SQRT(UCAL(I1,1)**2+UCAL(I1,2)**2+UCAL(I1,3)**2)
C normalize direction cosines
         IF(USUM.LT.0.0001) THEN
C direction is isotropic distributed
            CALL AZIRN(SINA,COSA)
            COSP = SFLRAF(DUM)
            SINP = SQRT(1.0-COSP*COSP)
            UCAL(I1,1) = SINP * COSA
            UCAL(I1,2) = SINP * SINA
            UCAL(I1,3) = COSP
         ELSE
            UCAL(I1,1) = UCAL(I1,1)/USUM
            UCAL(I1,2) = UCAL(I1,2)/USUM
            UCAL(I1,3) = UCAL(I1,3)/USUM
         ENDIF
C particle I2 vanished
         IPCAL(I2)=-1
         GOTO 20
C end of particle combination
  100    CONTINUE
C sort particles
         I2=NPHETC
         DO 120 I = 1,NPHETC
            IF(I.GE.I2) GOTO 130
            IF(IPCAL(I).EQ.-1) THEN
               DO 110 J = I2,I,-1
                  IF(IPCAL(J).NE.-1) THEN
                     IPCAL(I) = IPCAL(J)
                     EKINET(I) = EKINET(J)
                     UCAL(I,1) = UCAL(J,1)
                     UCAL(I,2) = UCAL(J,2)
                     UCAL(I,3) = UCAL(J,3)
                     I2 = J-1
                     GOTO 120
                  ENDIF
  110          CONTINUE
            ENDIF
  120    CONTINUE
  130    CONTINUE
         NPHETC=MXGKIN
      ENDIF
C
      IF(INTCAL.LT.1.OR.INTCAL.GT.30) INTCAL=12
      KCASE = NAMEC(INTCAL)
      IF(INTCAL.NE.12) THEN
        NMEC = NMEC + 1
        LMEC(NMEC) = INTCAL
      ENDIF
      DO 140 I=1,NPHETC
         IP=IPCAL(I)
         IGPART=ICALGE(IP)
         IF ( IGPART.EQ.0 ) THEN
            PRINT*,'>>> ERROR GCALOR: Particle type ',IP, ' not '
     +      //'implemented in GEANT'
            GOTO 140
         ENDIF
C
C store particle
         ECIN = EKINET(I)/1000.0
         IF(ECIN.LT.1.E-15) GOTO 140
         DECIN = DBLE(ECIN)
         DMASS = DBLE(XMASS(IP))
         PP = SNGL(DSQRT(DECIN*DECIN + 2.0D0*DECIN*DMASS))
         PX = PX + PP*UCAL(I,1)
         PY = PY + PP*UCAL(I,2)
         PZ = PZ + PP*UCAL(I,3)
C generated particle eq incoming
         IF(NPHETC.EQ.1 .AND. IGPART.EQ.IPART) THEN
            VECT(4) = UCAL(I,1)
            VECT(5) = UCAL(I,2)
            VECT(6) = UCAL(I,3)
            VECT(7) = PP
            GEKIN = ECIN
            GETOT = SNGL(DECIN + DMASS)
            TOFG = TOFG + CALTIM(I)
            ISTOP = 0
            IF(NABSOR) ISTOP = 2
            GOTO 160
         ENDIF
C
         NGKINE=NGKINE+1
         GKIN(1,NGKINE) = PP*UCAL(I,1)
         GKIN(2,NGKINE) = PP*UCAL(I,2)
         GKIN(3,NGKINE) = PP*UCAL(I,3)
C the total energy is critical for ECIN below 1.E-8 GeV because of
C single precision of GKIN (normalization when mass is added)!!
C luckely GEANT does use only the momentum components when storing the
C particle on the stack.
         GKIN(4,NGKINE) = SNGL(DECIN+DMASS)
         GKIN(5,NGKINE) = FLOAT(IGPART)
         TOFD(NGKINE)   = CALTIM(I)
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(NGKINE.GE.MXGKIN) GOTO 150
C
  140 CONTINUE
  150 CONTINUE
C particle lost its identity
      ISTOP=1
  160 CONTINUE
C
C
      NGKINE = MIN(NGKINE,MXGKIN)
C
C score kinetic energy of recoil nucleus (given in MeV)
CZ      DESTEP = DESTEP + ERMED * 1.E-3
  170 RETURN
      END
 
+DECK,GFMFIN,If=hadron.
*CMZ :          16/12/97  13.31.05  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.47  by  S.Giani
*-- Author :
      SUBROUTINE GFMFIN
+CDE,GCBANK.
+CDE,GCCUTS.
+CDE,GCJLOC.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCTMED.
+CDE,GCUNIT.
*KEEP,DIMPAR.
*                                                                     *
*=== dimpar ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      DIMPAR: included in any routine                                *
*                                                                     *
*          Mxxrgn = maximum number of regions                         *
*          Mxxmdf = maximum number of media in Fluka                  *
*          Mxxmde = maximum number of media in Emf                    *
*          Mfstck = stack dimension in Fluka                          *
*          Mestck = stack dimension in Emf                            *
*          Nallwp = number of allowed particles                       *
*          Mpdpdx = number of particle types for which EM dE/dx pro-  *
*                   cesses (ion,pair,bremss) have to be computed      *
*          Icomax = maximum number of materials for compounds (equal  *
*                   to the sum of the number of materials for every   *
*                   compound )                                        *
*          Nstbis = number of stable isotopes recorded in common iso- *
*                   top                                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( MXXRGN = 500  )
      PARAMETER ( MXXMDF = 50   )
      PARAMETER ( MXXMDE = 18   )
      PARAMETER ( MFSTCK = 1000 )
      PARAMETER ( MESTCK = 100  )
      PARAMETER ( NALLWP = 39   )
      PARAMETER ( MPDPDX = 8    )
      PARAMETER ( ICOMAX = 120  )
      PARAMETER ( NSTBIS = 304  )
 
*KEEP,FINUCT.
      DOUBLE PRECISION CXR, CYR, CZR, TKI, PLR, WEI, TV, TVCMS,
     &                 TVRECL, TVHEAV, TVBIND
 
*KEEP,FINUC.
*
*=== finuc ============================================================*
*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990     by Alfredo Ferrari, INFN Milan   *
*     include file: finuc copy                   created 26/11/86 by pa*
*     note: if changed change finuc2 copy also                         *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        np        = number of secondaries                             *
*        kpart(ip) = type of the secondary ip                          *
*        cxr(ip)   = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyr(ip)   = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czr(ip)   = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        tki(ip)   = kinetic energy of secondary ip                    *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXR (MXP), CYR (MXP), CZR (MXP), TKI (MXP),
     &                 PLR (MXP), WEI (MXP), TV, TVCMS, TVRECL, TVHEAV,
     &                 TVBIND, NP0, NP, KPART (MXP)
 
*KEND.
      REAL RNDM(1)
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
*KEEP,PART2T.
      DOUBLE PRECISION AAM, GA, TAU, AAMDSC
 
*KEEP,PART2.
*
*=== part2 ============================================================*
*
*----------------------------------------------------------------------*
*     Include file: part2 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part3 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AAM  (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AAMDSC (IDMAX8), IICH   (IDMAX8), IIBAR  (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)
 
*KEEP,COMCONT.
      DOUBLE PRECISION AOCMBC, CONTNT, SUMACN, CABINX, CABELX,
     &                 ANXNOR, ELXNOR, CONA13, SUMZMF
 
*KEEP,COMCON.
*
*=== comcon ===========================================================*
*
*----------------------------------------------------------------------*
*                                                                      *
*     include file: comcon copy                 created 26/11/86 by pa *
*                                                                      *
*     Last change  on  30-oct-92   by   Alfredo Ferrari, INFN - Milan  *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /comcon/ contains information about compounds                    *
*         icompl(imat) = number of materials in a compound             *
*         matnum(i)    = material numbers (compounds consist of the    *
*                        materials)                                    *
*         aocmbc(i)    = atomic densities in barn**-1 cm**-1           *
*                        (Atoms Over Cm times Barn for Compounds)      *
*         cona13(i)    = A^1/3 of the constituents                     *
*         sumzmf(i)    = cumulative z^2 for multiple scattering        *
*         contnt(i)    = partial densities                             *
*         sumacn(i)    = cumulative atom contents of the compounds     *
*         cabinx(i)    = cumulative at.cont.*inelastic cross section   *
*         cabelx(i)    = cumulative at.cont.*  elastic cross section   *
*         anxnor       = total inelastic cross section                 *
*         elxnor       = total   elastic cross section                 *
*----------------------------------------------------------------------*
*
      COMMON /FKCOMC/ AOCMBC (ICOMAX), CONA13 (ICOMAX), SUMZMF (ICOMAX),
     &                CONTNT (ICOMAX), SUMACN (ICOMAX), CABINX (ICOMAX),
     &                CABELX (ICOMAX), ANXNOR, ELXNOR,  ICOMPL (MXXMDF),
     &                MATNUM (ICOMAX)
 
*KEEP,FHEAVYT.
      DOUBLE PRECISION CXHEAV, CYHEAV, CZHEAV, TKHEAV, PHEAVY,
     &                 WHEAVY, AMHEAV
 
*KEEP,FHEAVY.
*
*=== fheavy ===========================================================*
*
*----------------------------------------------------------------------*
*     Last change on 9 March 1993     by Alfredo Ferrari, INFN Milan   *
*     include file: fheavy copy       created 5/4/90 by A. Ferrari     *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /fheavy/ is the storage for heavy secondaries created in the     *
*              nuclear evaporation                                     *
*        npheav     = number of secondaries                            *
*        kheavy(ip) = type of the secondary ip                         *
*                   ( 3 = deuteron, 4 = 3-H, 5 = 3-He, 6 = 4-He,       *
*                     7-12 = "Heavy" fragment specified by Ibheav and  *
*                     Icheav )                                         *
*        cxheav(ip) = direction cosine of the secondary ip             *
*                     with respect to x-axis                           *
*        cyheav(ip) = direction cosine of the secondary ip             *
*                     with respect to y-axis                           *
*        czheav(ip) = direction cosine of the secondary ip             *
*                     with respect to z-axis                           *
*        tkheav(ip) = kinetic energy of secondary ip                   *
*        pheavy(ip) = momentum of the secondary ip                     *
*        wheavy(ip) = weight of the secondary ip                       *
*        amheav(ip) = atomic masses of the six types of evaporated     *
*                     particles                                        *
*        anheav(kp) = name of the kp-type heavy particle               *
*        icheav(kp) = charge of the kp-type heavy particle             *
*        ibheav(kp) = mass number of the kp-type heavy particle        *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*   !!! There is now the possibility to produce up to 6 "heavy" !!!!   *
*   !!! fragments besides the residual nucleus recorded in      !!!!   *
*   !!! Resnuc: they are identified by indeces 7-12, of course  !!!!   *
*   !!! the corresponding physical properties (Z,A,m..) must be !!!!   *
*   !!! updated every time they are produced                    !!!!   *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*----------------------------------------------------------------------*
*
      PARAMETER ( MXHEAV = 100 )
      CHARACTER*8 ANHEAV
      COMMON / FKHEAV / CXHEAV (MXHEAV), CYHEAV (MXHEAV),
     &                  CZHEAV (MXHEAV), TKHEAV (MXHEAV),
     &                  PHEAVY (MXHEAV), WHEAVY (MXHEAV),
     &                  AMHEAV  ( 12 ) ,
     &                  KHEAVY (MXHEAV), ICHEAV  ( 12 ) ,
     &                  IBHEAV  ( 12 ) , NPHEAV
      COMMON / FKHEAC / ANHEAV  ( 12 )
 
*KEEP,PAPROP.
*
*=== paprop ===========================================================*
*
*----------------------------------------------------------------------*
*     include file: paprop copy                   created 26/11/86 by p*
*     changes: on  16 december 1992 by Alfredo Ferrari                 *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /paprop/ contains particle properties                            *
*        btype  = literal name of the particle                         *
*        am     = particle mass in gev                                 *
*        ichrge = electric charge of the particle                      *
*        iscore = explanations for the scored distribution             *
*        genpar = names of the generalized particles                   *
*        ijdisc = list of the particle types to be discarded           *
*        thalf  = half life of the particle in sec                     *
*        biasdc = decay biasing factors                                *
*        biasin = inelastic interaction biasing factors                *
*        lhadro = flag for hadrons                                     *
*        jspinp = particle spin (in units of 1/2)                      *
*        lbsdcy = logical flag for biased decay: if .true. the biasing *
*                 factor is used as an upper limit to the decay length *
*        lprbsd = logical flag for biased decay: if .true. the biasing *
*                 factor is applied only to primaries                  *
*        lprbsi = logical flag for inelastic interaction biasing: if   *
*                 .true. the biasing factor is applied only to prima-  *
*                 ries                                                 *
*                                                                      *
*----------------------------------------------------------------------*
*
      LOGICAL LHADRO, LBSDCY, LPRBSD, LPRBSI
      CHARACTER*8 BTYPE,GENPAR
      COMMON / FKPAPR / AM  (NALLWP), AMDISC (NALLWP), THALF  (NALLWP),
     &               BIASDC (NALLWP), BIASIN (NALLWP), ICHRGE (NALLWP),
     &               ISCORE     (10), IJDISC (NALLWP), LHADRO (NALLWP),
     &               JSPINP (NALLWP), LBSDCY (NALLWP), LPRBSD, LPRBSI
      COMMON / FKCHPR / BTYPE  (NALLWP), GENPAR (30)
 
*KEEP,PAPROPT.
      DOUBLE PRECISION AM, AMDISC, THALF,BIASDC, BIASIN
 
*KEEP,GFKDIS.
*KEND.
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
      NP = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF (IGF.EQ.2.OR.(GEKIN.EQ.0.0.AND.IPART.EQ.13)) THEN
         IF (GEKIN.LT.CUTNEU) THEN
            GEKIN = MAX(GEKIN,1E-14)
* should kinetic energy be deposited?
            ISTOP = 2
            IGF = 0
            GOTO 110
         ENDIF
         CALL GMICAP
         IGF = 0
         GOTO 110
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
      ELSE
         ISTOP=1
         NSTAK1 = MIN(NP,MXGKIN-NGKINE)
         IF(NP.GT.NSTAK1) THEN
            WRITE(CHMAIL,10000) NP-NSTAK1
            CALL GMAIL(0,0)
         ENDIF
         DO 90  K=1,NSTAK1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NSTAK2 = MIN(NPHEAV,MXGKIN-NGKINE)
         IF(NPHEAV.GT.NSTAK2) THEN
            WRITE(CHMAIL,10100) NPHEAV-NSTAK2
            CALL GMAIL(0,0)
         ENDIF
         DO 100 K=1,NSTAK2
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
         KCASE=NAMEC(12)
      END IF
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
10000 FORMAT(' **** FLUFIN: Stack overflow, ',I6,' particles lost')
10100 FORMAT(' **** FLUFIN: Stack overflow, ',I6,
     +' heavy particles lost')
  999 END
+DECK, GTCKOV
*CMZ :          09/02/98  16.15.20  by  Pavel Nevski
*CMZ :  3.21/04 13/12/94  15.17.13  by  S.Giani
*-- Author :
      SUBROUTINE GTCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine is called to follow the Cherenkov photons       *
C.    *   created during the tracking of charged particles and         *
C.    *   simulate the relevant processes along the way, until either  *
C.    *   the photon is absorbed or exits the detector. Processes      *
C.    *   currently simulated are absorption in-flight, and reflection *
C.    *   /transmission/absorption at a medium boundary. There are two *
C.    *   boundary types: dielectric-metal and dielectric-dielectric.  *
C.    *   For each of these there is a continuum of reflectivity       *
C.    *   and of surface quality from mirror finish to matte. The      *
C.    *   surface model is contained in routine GHSURF.                *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors    F.Carminati, R.Jones ************              *
C.    *                                                                *
C.    *   Modifications:                                               *
C.    *   Nicola.Colonna@ba.infn.it                                    *
C.    *          - more generalized formula for refraction             *
C.    *   PN, 9-feb-98: Let c-photons inter non-transparent media      *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU
+CDE, GCNUM
+CDE, GCVOL1
+CDE, GCUNIT
 
+SELF, IF=-OLD
+SEQ, GCVDMA.
+SELF
*
* ** The following common is in GTMEDI. LSAMVL is set to true if
* ** we did not change volume yet
*
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      REAL  R(3),U(3),QQ(3),vin(3),u_v(3)
*     REAL  D(3)
 
      LOGICAL LOLDTR
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
      PARAMETER (MXPUSH=10)
      SAVE RIN1,EFFIC
C.
C.    ------------------------------------------------------------------
*
* *** Update local pointers if medium has changed
*
      LOLDTR=.FALSE.
      IF(IUPD.EQ.0)THEN
         IUPD  = 1
         JTCKOV = LQ(JTM-3)
         IF(JTCKOV.EQ.0) THEN
*
* *** This Cerenkov photon has crossed into a black medium.
* *** Just absorb it.
            IPROC = 101
            SLABS = 0.
            ISTOP = 2
            STEP  = 0.0001
            DESTEP = VECT(7)
            GOTO 110
         ENDIF
         NPCKOV = Q(JTCKOV+1)
         JABSCO = LQ(JTCKOV-1)
         JEFFIC = LQ(JTCKOV-2)
         JINDEX = LQ(JTCKOV-3)
         JPOLAR = LQ(JSTAK-1)
      ENDIF
      IF(SLENG.LE.0.) THEN
*
* *** Calculate GEKRAT for the particle
         IF(VECT(7).GE.Q(JTCKOV+NPCKOV+1)) THEN
            GEKRAT=1.
            IEKBIN=NPCKOV-1
         ELSEIF(VECT(7).LT.Q(JTCKOV+2)) THEN
*
* *** Particle below energy threshold ?  Short circuit
* *** This should never happen because the photons are generated
* *** only above threshold
*
*            GEKIN = 0.
*            GETOT = 0.
*            VECT(7)= 0.
*            ISTOP = 2
*            NMEC = 1
*            LMEC(1)= 30
*            GO TO 110
 
            GEKRAT=0.
            IEKBIN=1
         ELSE
            JMIN = 1
            JMAX = NPCKOV
   10       JMED = (JMIN+JMAX)/2
            IF(Q(JTCKOV+JMED+1).LT.VECT(7)) THEN
               JMIN = JMED
            ELSE
               JMAX = JMED
            ENDIF
            IF(JMAX-JMIN.GT.1) GO TO 10
            IEKBIN = JMIN
            GEKRAT = (VECT(7) - Q(JTCKOV+IEKBIN+1))/
     +      (Q(JTCKOV+IEKBIN+2)-Q(JTCKOV+IEKBIN+1))
         ENDIF
         GEKRT1=1.-GEKRAT
         RIN1=Q(JINDEX+IEKBIN)*GEKRT1+Q(JINDEX+IEKBIN+1)*GEKRAT
         EFFIC=Q(JEFFIC+IEKBIN)*GEKRT1+Q(JEFFIC+IEKBIN+1)*GEKRAT
         STEPLA=Q(JABSCO+IEKBIN)*GEKRT1+Q(JABSCO+IEKBIN+1)*GEKRAT
      ENDIF
*
* *** Compute current step size
*
      IPROC  = 103
      STEP   = STEMAX
*
*  **   Step limitation due to in flight absorbtion ?
*
      IF (ILABS.GT.0) THEN
         SLABS  = STEPLA*ZINTLA
         IF (SLABS.LT.STEP) THEN
            STEP  = SLABS
            IPROC = 101
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      STEPT=0.
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
*
* **    We are going to cross a boundary, so we need to simulate
* **    boundary effects and to know what is on the other side.
* **    For the moment save the current vector in the geometry tree.
*
+SELF, IF=-OLD
         if(mycoun.gt.1.and.nfmany.gt.0)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF
            NLEVL1 = NLEVEL
            DO 20   I=1,NLEVEL
               NAMES1(I) = NAMES(I)
               NUMBR1(I) = NUMBER(I)
               LVOLU1(I) = LVOLUM(I)
   20       CONTINUE
*
* *** This is different from the other tracking routines.
* *** We get to the boundary and then we just jump over it
* *** So, linear transport till we are very near the boundary
*
+SELF,IF=-IBM
            STEP = MAX(SNEXT-PREC,0.)
+SELF,IF=IBM
            STEP = MAX(SNEXT-2.*PREC,0.)
+SELF
            IF(STEP.GT.0.) THEN
               DO 30 I=1,3
                  VECT(I)=VECT(I)+STEP*VECT(I+3)
   30          CONTINUE
            ENDIF
            STEPT=STEP
+SELF,IF=-IBM
            STEP  = SNEXT - STEP + PREC
+SELF,IF=IBM
            STEP  = SNEXT - STEP + 2.*PREC
+SELF
            IPROC = 0
            INWVOL= 2
            NMEC =  1
            LMEC(1)=1
         ENDIF
*
*        Update SAFETY in stack companions, if any
*        This may well not work.
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 40 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   40       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      VIN(1) = VECT(1)
      VIN(2) = VECT(2)
      VIN(3) = VECT(3)
      IF (INWVOL.EQ.2) THEN
         NBPUSH = 0
   50    DO 60 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTCKOV: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
               ENDIF
            ENDIF
            VOUT(I) = VECTMP
   60    CONTINUE
         NUMED1=NUMED
         CALL GTMEDI(VOUT,NUMED2)
         LOLDTR=.TRUE.
         IF(NUMED2.LE.0) THEN
            VECT(1) = VOUT(1)
            VECT(2) = VOUT(2)
            VECT(3) = VOUT(3)
            GO TO 110
         ENDIF
         JVO=LQ(JVOLUM-LVOLUM(NLEVEL))
         IF(LSAMVL.AND.Q(JVO+2).NE.12.) THEN
*
* *** In spite of our efforts we have not crossed the boundary
* *** we increase the step size and try again
*
            NBPUSH = NBPUSH + 1
            IF (NBPUSH.LE.MXPUSH) THEN
              STEP = STEP + NBPUSH*PREC
              GOTO 50
            ELSE
              INWVOL = 0
            ENDIF
 
         ENDIF
         IF(NUMED1.EQ.NUMED2) THEN
*
* *** If we are in the same medium, nothing needs to be done!
*
            VECT(1)=VOUT(1)
            VECT(2)=VOUT(2)
            VECT(3)=VOUT(3)
            IPROC=0
         ELSE
            JTM2 = LQ(JTMED-NUMED2)
            IF(IQ(JTM2-2).GE.3) THEN
               JTCKV2 = LQ(JTM2-3)
            ELSE
               JTCKV2 = 0
            ENDIF
            IF(JTCKV2.GT.0) THEN
               NPCKV2 = Q(JTCKV2+1)
               JABSC2 = LQ(JTCKV2-1)
               JEFFI2 = LQ(JTCKV2-2)
               JINDX2 = LQ(JTCKV2-3)
               IF(VECT(7).GE.Q(JTCKV2+NPCKV2+1)) THEN
                  GEKRT2=1.
                  IEKBI2=NPCKV2-1
               ELSEIF(VECT(7).LT.Q(JTCKV2+2)) THEN
                  GEKRT2=0.
                  IEKBI2=1
               ELSE
                  JMIN = 1
                  JMAX = NPCKV2
   64             JMED = (JMIN+JMAX)/2
                  IF(Q(JTCKV2+JMED+1).LT.VECT(7)) THEN
                     JMIN = JMED
                  ELSE
                     JMAX = JMED
                  ENDIF
                  IF(JMAX-JMIN.GT.1) GO TO 64
                  IEKBI2 = JMIN
                  GEKRT2 = (VECT(7) - Q(JTCKV2+IEKBI2+1))/
     +            (Q(JTCKV2+IEKBI2+2)-Q(JTCKV2+IEKBI2+1))
               ENDIF
               GEKRT1=1.-GEKRT2
               ABSCO2=Q(JABSC2+IEKBI2)*GEKRT1+Q(JABSC2+IEKBI2+1)*GEKRT2
               EFFIC2=Q(JEFFI2+IEKBI2)*GEKRT1+Q(JEFFI2+IEKBI2+1)*GEKRT2
               IF(JINDX2.GT.0) THEN
                 RIN2=Q(JINDX2+IEKBI2)*GEKRT1+Q(JINDX2+IEKBI2+1)*GEKRT2
               ELSE
                 RIN2=0.
               ENDIF
               IPROC = 102
            ELSE
* do nothing - let it be absobed there
*              ISTOP  = 2
*              DESTEP = VECT(7)
*              NMEC   = NMEC+1
*              LMEC(NMEC)=30
               VECT(1)=VOUT(1)
               VECT(2)=VOUT(2)
               VECT(3)=VOUT(3)
               GOTO 110
            ENDIF
         ENDIF
      ELSE
         DO 70 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   70    CONTINUE
      ENDIF
*
      STEP = STEPT + STEP
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      TOFG = TOFG +STEP*RIN1/CLIGHT
*
* *** Update interaction probabilities
*
      IF (ILABS.GT.0)    ZINTLA = ZINTLA -STEP/STEPLA
*
      IF (IPROC.EQ.0) GO TO 110
      NMEC = NMEC+1
      LMEC(NMEC) = IPROC
*
*  ** Absorbtion in flight ?
*
      IF (IPROC.EQ.101) THEN
         ISTOP=2
         CALL GRNDM(RNDM,1)
         IF(RNDM.LT.EFFIC) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
            DESTEP=VECT(7)
         ELSE
            DESTEP=0.
         ENDIF
*
*  ** Boundary action?
*
      ELSE IF (IPROC.EQ.102) THEN
         IF(JINDX2.EQ.0) THEN
*
* *** Case dielectric -> metal
*
            CALL GRNDM(RNDM,1)
            IF(RNDM.LT.ABSCO2) THEN
*
* *** Photon is absorbed in the next medium
*
               NMEC=NMEC+1
               LMEC(NMEC)=101
               ISTOP = 2
               CALL GRNDM(RNDM,1)
               IF(RNDM.LT.EFFIC2) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
                  DESTEP=VECT(7)
               ELSE
                  DESTEP = 0.
               END IF
               VECT(1) = VOUT(1)
               VECT(2) = VOUT(2)
               VECT(3) = VOUT(3)
               GOTO 110
            ELSE
*
* *** Photon is reflected (no polarization effects)
*
               CALL GLISUR(VECT,VOUT,NUMED1,NUMED2,U,PDOTU,IERR)
               IF (IERR.NE.0) THEN
                  WRITE(CHMAIL,10200) IERR
                  CALL GMAIL(0,0)
                  GO TO 110
               END IF
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   80          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 80
                  ENDIF
               ENDIF
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
               EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL  = 0
            ENDIF
         ELSE
*
*  case dielectric-dielectric:
*
            CALL GLISUR(VECT,VOUT,NUMED1,NUMED2,U,PDOTU,IERR)
            IF (IERR.NE.0) THEN
               WRITE(CHMAIL,10200) IERR
               CALL GMAIL(0,0)
               GO TO 110
            END IF
            EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
            COST1 = -PDOTU
            IF (ABS(COST1).LT.1.) THEN
               SINT1 = SQRT((1-COST1)*(1+COST1))
               SINT2 = SINT1*RIN1/RIN2
            ELSE
               SINT1 = 0.0
               SINT2 = 0.0
            END IF
            IF (SINT2.GE.1) THEN
*
* ***  Simulate total internal reflection
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   90          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 90
                  ENDIF
               ENDIF
*
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL = 0
            ELSE
*
* ***  Calculate amplitude for transmission (Q = P x U)
*
               COST2 = SIGN(1.0,COST1)*SQRT((1-SINT2)*(1+SINT2))
               IF (SINT1.GT.1.E-4) THEN
                  QQ(1) = VECT(5)*U(3) - VECT(6)*U(2)
                  QQ(2) = VECT(6)*U(1) - VECT(4)*U(3)
                  QQ(3) = VECT(4)*U(2) - VECT(5)*U(1)
                  EPERP1 = (POLAR(1)*QQ(1) + POLAR(2)*QQ(2) + POLAR(3)*
     +            QQ(3))
                  ENORM  = SQRT(EPERP1**2+EDOTU**2)
                  EPERP1 = EPERP1/ENORM
                  EPARL1 = EDOTU/ENORM
               ELSE
                  QQ(1) = POLAR(1)
                  QQ(2) = POLAR(2)
                  QQ(3) = POLAR(3)
*
*     Here we follow Jackson's conventions and we set the parallel
*     component = 1 in case of a ray perpendicular to the surface
                  EPERP1 = 0.
                  EPARL1 = 1.
               END IF
               IF(COST1.NE.0.) THEN
                  S1 = RIN1*COST1
                  EPERP2 = 2*S1*EPERP1/(RIN1*COST1+RIN2*COST2)
                  EPARL2 = 2*S1*EPARL1/(RIN2*COST1+RIN1*COST2)
                  E2 = EPERP2**2 + EPARL2**2
                  S2 = RIN2*COST2*E2
                  TCOEF = S2/S1
               ELSE
                  TCOEF = 0.
               ENDIF
               CALL GRNDM(RNDM,1)
               IF (RNDM.GT.TCOEF) THEN
*
* *** Simulate reflection
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=106
*
* *** Restore old volume tree, the photon does not cross the boundary
*
*                 CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
                  CALL GTMEDI(VIN,N)
                  LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
                  NBPUSH = 0
  100             NBPUSH = NBPUSH+1
                  IF(NBPUSH.GT.MXPUSH) THEN
                     WRITE(CHMAIL,10300) NTMULT,NSTEP
                     CALL GMAIL(0,0)
                     ISTOP=1
                     GOTO 110
                  ELSE
                     CALL GINVOL(VECT,ISAME)
                     IF(ISAME.EQ.0) THEN
                        PRECN = NBPUSH*PREC
                        VECT(1) = VECT(1) - PRECN*VECT(4)
                        VECT(2) = VECT(2) - PRECN*VECT(5)
                        VECT(3) = VECT(3) - PRECN*VECT(6)
                        GO TO 100
                     ENDIF
                  ENDIF
*
                  VECT(4) = VECT(4) - 2*PDOTU*U(1)
                  VECT(5) = VECT(5) - 2*PDOTU*U(2)
                  VECT(6) = VECT(6) - 2*PDOTU*U(3)
                  IF(SINT1.GT.1E-4) THEN
                     EPARL2 = RIN2*EPARL2/RIN1-EPARL1
                     EPERP2 = EPERP2-EPERP1
                     E2 = EPERP2**2 + EPARL2**2
                     R(1) = U(1) + PDOTU*VECT(4)
                     R(2) = U(2) + PDOTU*VECT(5)
                     R(3) = U(3) + PDOTU*VECT(6)
                     EABS = SQRT(E2)*SINT1
                     CPARL = EPARL2/EABS
                     CPERP = EPERP2/EABS
                     POLAR(1) = CPARL*R(1) - CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) - CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) - CPERP*QQ(3)
                  ELSEIF(RIN2.GT.RIN1) THEN
*
* *** Case of ray perpendicular to the surface. No change or
* *** an inversion of phase.
                     POLAR(1) = -POLAR(1)
                     POLAR(2) = -POLAR(2)
                     POLAR(3) = -POLAR(3)
                  ENDIF
                  INWVOL = 0
               ELSE
*
* *** Simulate transmission/refraction
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=107
                  VECT(1) = VOUT(1)
                  VECT(2) = VOUT(2)
                  VECT(3) = VOUT(3)
                  GEKRAT = GEKRT2
                  IEKBIN = IEKBI2
                  STEPLA = ABSCO2
                  EFFIC = EFFIC2
                  RIN1 = RIN2
                  IF(SINT1.GT.1E-4) THEN
c                     ALPHA = COST1-COST2*(RIN2/RIN1)
c                     D(1) = VECT(4) + ALPHA*U(1)
c                     D(2) = VECT(5) + ALPHA*U(2)
c                     D(3) = VECT(6) + ALPHA*U(3)
c                     DABS = SQRT(D(1)**2+D(2)**2+D(3)**2)
c                     VECT(4) = D(1)/DABS
c                     VECT(5) = D(2)/DABS
c                     VECT(6) = D(3)/DABS
 
c ... more generalized formula for refraction ...		nc
 
		     costp = - cost2
	             cost_rel=cosd(acosd(cost1)-acosd(cost2))
		     if(u(1).gt.-1.e-5.and.u(1).lt.1.e-5.and.
     +                  u(2).gt.-1.e-5.and.u(2).lt.1.e-5)then
		      vectn3 = cost2
	 	      cy = (cost_rel-vect(6)*cost2)/(1.-vect(6)**2)
		      vectn2 = vect(5)*cy
		      vectn1 = vect(4) * vectn2 / vect(5)
		     else if(u(2).gt.-1.e-5.and.u(2).lt.1.e-5.and.
     +                       u(3).gt.-1.e-5.and.u(3).lt.1.e-5)then
		      vectn1 = costp
		      cz = (cost_rel-vect(4)*costp)/(1.-vect(4)**2)
		      vectn3 = vect(6) * cz
		      vectn2 = vect(5) * vectn3 /vect(6)
		     else
		      u_v(1) = u(2)*vect(6) - u(3)*vect(5)
		      u_v(2) = u(3)*vect(4) - u(1)*vect(6)
		      u_v(3) = u(1)*vect(5) - u(2)*vect(4)
	 	      c1 = u_v(1)*u(2) - u_v(2)*u(1)
	 	      c2 = u_v(3)*u(1) - u(3)*u_v(1)
	 	      c3 = costp * u_v(1)
	 	      c4 = c2/c1
	 	      c5 = c3/c1
	 	      c1p = u_v(1)*vect(5) - u_v(2)*vect(4)
	 	      c2p = u_v(3)*vect(4) - vect(6)*u_v(1)
	 	      c3p = cost_rel * u_v(1)
	 	      c4p = c2p/c1p
	 	      c5p = c3p/c1p
 
		      vectn3 = (c5p - c5) / (c4 - c4p)
	 	      vectn2 = vectn3 * c4 + c5
		      if(vect(4).eq.0.)return
		vectn1 = (cost_rel-vect(5)*vectn2-vect(6)*vectn3)/vect(4)
		     endif
		      vect(4) = vectn1
		      vect(5) = vectn2
		      vect(6) = vectn3
 
c ... end correction					nc
	 	
		     PDOTU = -COST2
                     R(1) = U(1) - PDOTU*VECT(4)
                     R(2) = U(2) - PDOTU*VECT(5)
                     R(3) = U(3) - PDOTU*VECT(6)
                     EABS = SQRT(E2)
                     CPARL = EPARL2/(EABS*SINT2)
                     CPERP = EPERP2/(EABS*SINT1)
                     POLAR(1) = CPARL*R(1) + CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) + CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) + CPERP*QQ(3)
                  ENDIF
               END IF
            END IF
         END IF
      ENDIF
*                                                             END GTCKOV
  110 IF(LOLDTR) CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
10200  FORMAT(' **** GTCKOV: error from GLISUR = ',I10)
10300  FORMAT(' **** GTCKOV: unable to reflect at NTMULT = ',
     +        I8,' step No. ',I8,' photon abandoned!')
      END
+DECK, GSCKOV.
*CMZ :          09/02/98  16.09.29  by  Pavel Nevski
*CMZ :  3.21/02 21/03/94  17.01.28  by  Rene Brun
*-- Author :
      SUBROUTINE GSCKOV(ITMED, NPCKOV, PPCKOV, ABSCO, EFFIC, RINDEX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Stores the tables for UV photon tracking in medium ITMED    *
C.    *    Please note that it is the user's responsability to         *
C.    *    provide all the coefficients:                               *
C.    *                                                                *
C.    *                                                                *
C.    *       ITMED       Tracking medium number                       *
C.    *       NPCKOV      Number of bins of each table                 *
C.    *       PPCKOV      Value of photon momentum (in GeV)            *
C.    *       ABSCO       Absorbtion coefficents                       *
C.    *                   dielectric: absorbtion length in cm          *
C.    *                   metals    : absorbtion fraction (0<=x<=1)    *
C.    *       EFFIC       Detection efficiency for UV photons          *
C.    *       RINDEX      Refraction index (if=0 metal)                *
C.    *                                                                *
C.    *       Called by : <USER>                                       *
C.    *                                                                *
C.    *       Authors: F.Carminati, R.Jones  ************              *
C.    *                                                                *
C.    *       Modifications:                                           *
C.    *       PN, 9-feb-98:   multiple calls subsitute same banks      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
C
      DIMENSION PPCKOV(*), ABSCO(*), EFFIC(*), RINDEX(*)
C.
C.    ------------------------------------------------------------------
C.
      JTM = 0
      IF(ITMED.GT.0) THEN
         IF(JTMED.GT.0) THEN
            IF(IQ(JTMED-2).GE.ITMED) THEN
               JTM = LQ(JTMED-ITMED)
            ENDIF
         ENDIF
      ENDIF
      IF(JTM.LE.0) THEN
         WRITE(CHMAIL,10000)
10000   FORMAT(' **** GSCKOV Tracking medium ',I10,' not defined')
         CALL GMAIL(0,0)
         GO TO 999
      ENDIF
      IF(IQ(JTM-2).LT.3) THEN
         CALL MZPUSH(IXSTOR,JTM,3-IQ(JTM-2),0,' ')
      ENDIF
      JTCKOV=LQ(JTM-3)
      IF (JTCKOV.le.0)
     +   CALL MZBOOK(IXCONS,JTCKOV,JTM, -3,'CKOV',4,4,NPCKOV+1,3,-1)
      JABSCO=LQ(JTCKOV-1)
      IF (JABSCO.le.0)
     +   CALL MZBOOK(IXCONS,JABSCO,JTCKOV,-1,'ABSC',0,0,NPCKOV,3,-1)
      JEFFIC=LQ(JTCKOV-2)
      IF (JEFFIC.le.0)
     +   CALL MZBOOK(IXCONS,JEFFIC,JTCKOV,-2,'EFFI',0,0,NPCKOV,3,-1)
      IF(RINDEX(1).GE.1.) THEN
         JINDEX=LQ(JTCKOV-3)
         IF (JINDEX.le.0)
     +    CALL MZBOOK(IXCONS,JINDEX,JTCKOV,-3,'RIND',0,0,NPCKOV,3,-1)
         JCURIN=LQ(JTCKOV-4)
         IF (JCURIN.le.0)
     +    CALL MZBOOK(IXCONS,JCURIN,JTCKOV,-4,'ABCU',0,0,NPCKOV,3,-1)
      ENDIF
      Q(JTCKOV+1)=NPCKOV
      DO 10 J=1, NPCKOV
         Q(JTCKOV+1+J) = PPCKOV(J)
         Q(JABSCO+  J) = MAX(1E-10,ABSCO(J))
         Q(JEFFIC+  J) = EFFIC(J)
         IF(RINDEX(1).GE.1.) THEN
            Q(JINDEX+ J) = RINDEX(J)
            IF(J.GT.1) THEN
               Q(JCURIN+J)=0.5*((1/RINDEX(J-1)**2)+(1./RINDEX(J)**2))
               Q(JCURIN+J)=Q(JCURIN+J-1)+(PPCKOV(J)-PPCKOV(J-1))*
     +                     Q(JCURIN+J)
            ELSE
               Q(JCURIN+J)=0.
            ENDIF
         ENDIF
   10 CONTINUE
*
  999 END
+DECK,GPHOT
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHOT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  GENERATES PHOTO ELECTRIC MECHANISM                            *
C.    *  Corrected version of L. Urban's routine.                      *
C.    *  Improvements:                                                 *
C.    *    1. Angular distributions of photoelectrons from K-L3 shells *
C.    *    2. Generation of shell decay mode                           *
C.    *    3. Probability of interactioon with a shell = function      *
C.    *       of photon energy                                         *
C.    *                                                                *
C.    *    ==>CALLED BY : GTGAMA                                       *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCPHYS
+SEQ,GCONSP
+SEQ,GCKING
+SEQ,GCCUTS
+SEQ,GCJLOC
+SEQ,GCUNIT
      DIMENSION POT(4),PROB(4),RNA(9)
      EQUIVALENCE (RNA(1),RN01),(RNA(2),RN02),(RNA(3),RN03)
      EQUIVALENCE (RNA(4),RN04),(RNA(5),RN05),(RNA(6),RN06)
      EQUIVALENCE (RNA(7),RN07),(RNA(8),RN08),(RNA(9),RN09)
      EQUIVALENCE (POT(1),POTK),(POT(2),POTL1)
      EQUIVALENCE (POT(3),POTL2),(POT(4),POTL3)
      EQUIVALENCE (PROB(1),PROBK),(PROB(2),PROBL1)
      EQUIVALENCE (PROB(3),PROBL2),(PROB(4),PROBL3)
      SAVE ZINOLD,POT,NSHELL
      DATA ZINOLD / 0.0 /
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(8)
C
C             STOP ELECTRON ?
C
C Check if the photoelectric effect was activated. If not deposit
C gamma & return
      IF(IPHOT.NE.1) THEN
         ISTOP = 2
         NGKINE= 0
         DESTEP = DESTEP + VECT(7)
         VECT(7) = 0.
         GEKIN = 0.
         GETOT = 0.
      ELSE
         E=VECT(7)
         CALL GRNDM(RNA,9)
         JPHXS = LQ(JPHOT-1)
         NZ = Q(JPHXS+1)
         IF(NZ.GT.1) THEN
            QS = 0.0
            QS2 = GPHSG1(E)*RN01
            DO 10 I = 1,NZ-1
               QS1 = GPHSGP(I,E)
               QS = QS+QS1
               IF(QS2.LE.QS) THEN
                  K = I
                  GO TO 20
               ENDIF
   10       CONTINUE
            K = NZ
   20       CONTINUE
            JPHFN = LQ(JPHXS-K)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+K)
         ELSE
            JPHFN = LQ(JPHXS-1)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+1)
         ENDIF
C COPY SHELLS POTENTIALS FROM THE ZEBRA STUCTURE
C Check if this atom was used in last entry
         IF(ZINT.NE.ZINOLD) THEN
            NSHELL = Q(JFN+1)
            DO 30 I = 1,NSHELL
               POT(I) = Q(JFN+1+I)
   30       CONTINUE
            ZINOLD = ZINT
         ENDIF
C Check if E-gamma is bigger than the L3 ionization potential.
C This will make GPHOT a little faster.
         ISHELL = 0
         PROB(1) = 0.
         PROB(2) = 0.
         PROB(3) = 0.
         PROB(4) = 0.
         IF(E.GE.POTL3) THEN
C If ZINT < 5 we can have K shell only, so
            IF(ZINT.LT.5) THEN
               IF(E.GT.POTK) THEN
                  PROBK = 1.
                  TK = E-POTK
                  ISHELL = 1
               ENDIF
            ELSE
C The probabilities given below come from crude approximation
C It uses the jump ratios and assumes that they are valid for the whole energy
C range.
               IF(E.LT.POTL2) THEN
                  PROBL3 = 1.0
                  TK = E-POTL3
                  ISHELL = 4
               ELSE
                  E3 = E-POTL3
                  GAMAL3 = E3/EMASS+1.
                  BETAL3 = SQRT(E3*(E3+2.0*EMASS))/(E+EMASS)
                  E2 = E-POTL2
                  GAMAL2 = E2/EMASS+1.
                  BETAL2 = SQRT(E2*(E2+2.0*EMASS))/(E+EMASS)
                  EFRAC = EMASS/E
                  PROBL3 = GAVRL3(GAMAL3,BETAL3,EFRAC)
                  PROBL2 = GAVRL2(GAMAL2,BETAL2,EFRAC)
                  ANOR = 1./(PROBL3+PROBL2)
                  PROBL3 = PROBL3*ANOR
                  PROBL2 = PROBL2*ANOR
                  IF(E.LT.POTL1) THEN
                     IF(RN02.LT.PROBL3) THEN
                        ISHELL = 4
                        TK = E-POTL3
                     ELSE
                        ISHELL = 3
                        TK = E-POTL2
                     ENDIF
                  ELSE
C Parametrization of L1 jump ratio gives constant 1.2
                     PROBL1 = 1.-1./1.2
                     IF(E.LT.POTK) THEN
                        PROBL2 = (1.-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBL1)*PROBL3
                     ELSE
                        PROBK = 125./ZINT+3.5
                        PROBK = 1.-1/PROBK
                        PROBL1 = (1.-PROBK)*PROBL1
                        PROBL2 = (1.-PROBK-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBK-PROBL1)*PROBL3
                     ENDIF
                     IF(POTL3.LE.0.0) PROBL3 = 0.0
                     IF(POTL2.LE.0.0) PROBL2 = 0.0
                     IF(POTL1.LE.0.0) PROBL1 = 0.0
                     ANOR = PROBK+PROBL1+PROBL2+PROBL3
                     IF(ANOR.GT.0.0) THEN
                        ANOR = 1./ANOR
                        PROBK = PROBK*ANOR
                        PROBL1 = PROBL1*ANOR+PROBK
                        PROBL2 = PROBL2*ANOR+PROBL1
                        PROBL3 = PROBL3*ANOR+PROBL2
                        ISHELL = 4
                        TK = E-POTL3
                        IF(RN02.LE.PROBK) THEN
                           ISHELL = 1
                           TK = E-POTK
                        ELSEIF(RN02.LE.PROBL1) THEN
                           ISHELL = 2
                           TK = E-POTL1
                        ELSEIF(RN02.LE.PROBL2) THEN
                           ISHELL = 3
                           TK = E-POTL2
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
            IF(TK.LE.CUTELE) ISHELL = -ISHELL
         ENDIF
         IF(ISHELL.LT.1) THEN
C None of the shells was chosen because of the CUTELE
            ISTOP = 2
            IF(ISHELL.LT.0) THEN
               DESTEP = DESTEP+TK
            ELSEIF(ISHELL.EQ.0) THEN
               DESTEP = DESTEP+VECT(7)
            ENDIF
            NGKINE= 0
            VECT(7) = 0.
            GEKIN = 0.
            GETOT = 0.
         ELSE
C
C             ENERGY AND MOMENTUM OF PHOTOELECTRON
C
            EEL=TK + EMASS
            PEL=SQRT((TK+2.*EMASS)*TK)
            BETA = PEL/EEL
            ISTOP = 1
            NGKINE = 1
            IF(ISHELL.EQ.1) THEN
               COST = GPHAK(BETA)
            ELSEIF(ISHELL.EQ.2) THEN
               COST = GPHAL1(BETA)
            ELSEIF(ISHELL.EQ.3) THEN
               COST = GPHAL2(BETA)
            ELSEIF(ISHELL.EQ.4) THEN
               COST = GPHAL3(BETA)
            ENDIF
            PHI = TWOPI*RN03
            COSPHI = COS(PHI)
            SINPHI = SIN(PHI)
            SINT = SQRT((1.-COST)*(1.+COST))
            GKIN(1,NGKINE) = PEL*SINT*COSPHI
            GKIN(2,NGKINE) = PEL*SINT*SINPHI
            GKIN(3,NGKINE) = PEL*COST
            GKIN(4,NGKINE) = EEL
            GKIN(5,NGKINE) = 3.
            TOFD(NGKINE) = 0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
C
C             ROTATE ELECTRON AND SCATTERED PHOTON INTO GEANT SYSTEM
C
            CALL GVROT(VECT(4),GKIN)
         ENDIF
         IF(ISHELL.NE.0) THEN
            ISHELL = ABS(ISHELL)
            IF(ZINT.GE.5.AND.POT(ISHELL).GT.MIN(CUTGAM,CUTELE)) THEN
C Generate shell decay mode
               IF(RN04.LE.Q(JFN+1+NSHELL+ISHELL)) THEN
                  IF(POT(ISHELL).LE.CUTGAM) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
C Radiative shell decay
                     JS = JFN+1+2*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 40 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 50
                        ENDIF
   40                CONTINUE
   50                CONTINUE
                  ENDIF
               ELSE
                  IF(POT(ISHELL).LE.CUTELE) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
c Nonradiative decay
                     JS = JFN+1+3*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 60 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTELE) THEN
                              EEL=TSEC + EMASS
                              PEL=SQRT((TSEC+2.*EMASS)*TSEC)
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = PEL*SINT*COSPHI
                              GKIN(2,NGKINE) = PEL*SINT*SINPHI
                              GKIN(3,NGKINE) = PEL*COST
                              GKIN(4,NGKINE) = EEL
                              GKIN(5,NGKINE) = 3.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 70
                        ENDIF
   60                CONTINUE
   70                CONTINUE
                  ENDIF
               ENDIF
            ELSE
               DESTEP = DESTEP+POT(ISHELL)
            ENDIF
         ENDIF
      ENDIF
      END
+DECK,GPART
*CMZ :          25/03/98  12.07.16  by  Pavel Nevski
*CMZ :  3.21/03 14/09/94  14.33.42  by  S.Ravndal
*-- Author :
      SUBROUTINE GPART
C.
C.    *******************************************************************
C.    *                                                                 *
C.    *  Define standard GEANT particles plus selected decay modes      *
C.    *  and branching ratios.                                          *
C.    *                                                                 *
C.    *  All data taken from : M. AGUILAR-BENITEZ et al,                *
C.    *                        Review of Particle Properties,           *
C.    *                        Rev. Mod. Phys. 56(1984).                *
C.    *                                                                 *
C.    *  Updated to:           Phys.Rev. D50,1173(1994)                 *
C.    *                        S. Ravndal                               *
C.    *  PN: activate paricles from Geant 3.16 with crude decay guess   *
C.    *                                                                 *
C.    *  In the case of W and Z, the lifetimes are calculated from      *
C.    *  quoted upper limits on widths.                                 *
C.    *                                                                 *
C.    *  NPAR           Number of parent particles defined for decay.   *
C.    *  IPAR           List of parent partilces allowed to decay.      *
C.    *                 Currently set up for pi0,pi+,pi-,K0long,K+,K-,  *
C.    *                 K0short,eta,lambda,sigma+,sigma0,sigma-,xi0,    *
C.    *                 xi-,omega-,antilambda,antisigma -,antisigma 0,  *
C.    *                 antisigma +,antixi 0,antixi +,antiomega +       *
C.    *                 decays.                                         *
C.    *  MODE(I,J)      I'th decay mode of J'th particle defined in     *
C.    *                 IPAR.                                           *
C.    *  BRATIO(I,J)    Branching ratio for I'th decay mode of J'th     *
C.    *                 particle in IPAR.                               *
C.    *                                                                 *
C.    *    ==>Called by : <USER>, UGINIT                                *
C.    *       Author    G.Patrick  *********                            *
C.    *                                                                 *
C.    *******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCONSP
C                       do not activate additional decays
      DATA     NPAR/24/
      INTEGER  IPAR(36),UBUF(1)
      REAL     BRATIO(6,36),BRTIO1(6,20),BRTIO2(6,16)
      INTEGER  MODE(6,36),  MODE1(6,20), MODE2(6,16)
      DATA     UBUF/0./
C
      EQUIVALENCE(BRTIO1(1,1),BRATIO(1,1)),(BRTIO2(1,1),BRATIO(1,21))
      EQUIVALENCE(MODE1(1,1), MODE(1,1)),  (MODE2(1,1), MODE(1,21))
C
      DATA IPAR/ 7, 8, 9,10,11,12,16,17,18,19,20,
     *          21,22,23,24,26,27,28,29,30,31,32,5,6,
     *          33,34,35,36,37,38,39,40,41,42,43,44/
      DATA BRTIO1/ 98.802, 1.198, 0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *             21.60, 19.35, 19.35, 13.50, 13.50, 12.38,
     *             63.51, 21.17,  5.59,  4.82,  3.18,  1.73,
     *             63.51, 21.17,  5.59,  4.82,  3.18,  1.73,
     *             68.61, 31.39,  0.,    0.,    0.,    0.,
     *             38.80, 31.90, 23.6,   4.88,  0.5,   0.071,
     *             63.90, 35.80,  0.,    0.,    0.,    0.,
     *             51.57, 48.30,  0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *             67.80, 23.60,  8.60,  0.,    0.,    0.,
     *             63.90, 35.80,  0.,    0.,    0.,    0.,
     *             51.57, 48.30,  0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0./
      DATA BRTIO2/100.00,  0.,    0.,    0.,    0.,    0.,
     *             67.80, 23.60,  8.60,  0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            100.00,  0.,    0.,    0.,    0.,    0.,
     *            25.2,  17.65, 18.01,  11.7,  13.0,  13.0,
     *            25.2,  17.65, 18.01,  11.7,  13.0,  13.0,
     *            100.0,   0.,    0.,    0.,    0.,    0.,
     *            100.0,   0.,    0.,    0.,    0.,    0.,
     *            100.0,   0.,    0.,    0.,    0.,    0.,
     *            100.0,   0.,    0.,    0.,    0.,    0.,
     *            100.0,   0.,    0.,    0.,    0.,    0.,
     *            100.0,   0.,    0.,    0.,    0.,    0.,
     *            63.90, 35.80,   0.,    0.,    0.,    0.,
     *            10.8,  10.6,  10.8,  67.8,    0.,    0.,
     *            10.8,  10.6,  10.8,  67.8,    0.,    0.,
     *            3.37,  3.37,  3.36,  69.9,  20.01,   0./
 
      DATA MODE1/  101,30201,    0,    0,    0,    0,
     *             405,    0,    0,    0,    0,    0,
     *             406,    0,    0,    0,    0,    0,
     *             70707,40308,40209,40608,40509,70908,
     *             405,  708,90808,70402,70405,70708,
     *             406,  709,80909,70403,70406,70709,
     *             908,  707,    0,    0,    0,    0,
     *             101,70707,70908,10908,10302,10107,
     *             914,  713,    0,    0,    0,    0,
     *             714,  813,    0,    0,    0,    0,
     *             118,    0,    0,    0,    0,    0,
     *             913,    0,    0,    0,    0,    0,
     *             718,    0,    0,    0,    0,    0,
     *             918,    0,    0,    0,    0,    0,
     *            1218,  922,  723,    0,    0,    0,
     *             815,  725,    0,    0,    0,    0,
     *             715,  925,    0,    0,    0,    0,
     *             126,    0,    0,    0,    0,    0,
     *             825,    0,    0,    0,    0,    0,
     *             726,    0,    0,    0,    0,    0/
      DATA MODE2/  826,    0,    0,    0,    0,    0,
     *            1126,  830,  731,    0,    0,    0,
     *           40402,    0,    0,    0,    0,    0,
     *           40403,    0,    0,    0,    0,    0,
     *          080704, 050404, 020404, 0804, 090808, 080707,     !Tau+
     *          090704, 060404, 030404, 0904, 090908, 090707,     !Tau-
     *            1608,    0,    0,    0,    0,    0,             !D+->K0s+pi
     *            1609,    0,    0,    0,    0,    0,             !D_->K0s+pi
     *            1208,    0,    0,    0,    0,    0,             !D0->K_+pi+
     *            1109,    0,    0,    0,    0,    0,             !D0->K++pi_
     *            1608,    0,    0,    0,    0,    0,             !Ds+->K0s+pi
     *            1609,    0,    0,    0,    0,    0,             !Ds_->K0s+pi
     *            141208,180807, 0,    0,    0,    0,             !Lc+
     *            0204,  0604, 3304, 90908,  0,    0,             !W+
     *            0304,  0504, 3404, 90908,  0,    0,             !W-
     *            0203,  0506, 3334, 90807, 0404,  0/             !Z
C.
C.    -------------------------------------------------------------------
C.
      REMASS=EMASS
      REMMU =EMMU
      RPMASS=PMASS
      CALL GSPART( 1,'GAMMA$      ',1,0.       , 0., 1.E+15,    UBUF,0)
      CALL GSPART( 2,'POSITRON$   ',2,REMASS   , 1., 1.E+15,    UBUF,0)
      CALL GSPART( 3,'ELECTRON$   ',2,REMASS   ,-1., 1.E+15,    UBUF,0)
      CALL GSPART( 4,'NEUTRINO$   ',3,0.       , 0., 1.E+15,    UBUF,0)
      CALL GSPART( 5,'MUON +$     ',5,REMMU    , 1., 2.19703e-6,UBUF,0)
      CALL GSPART( 6,'MUON -$     ',5,REMMU    ,-1., 2.19703e-6,UBUF,0)
      CALL GSPART( 7,'PION 0$     ',3,0.1349764, 0., 0.84E-16,  UBUF,0)
      CALL GSPART( 8,'PION +$     ',4,0.1395700, 1., 2.603E-08, UBUF,0)
      CALL GSPART( 9,'PION -$     ',4,0.1395700,-1., 2.603E-08, UBUF,0)
      CALL GSPART(10,'KAON 0 LONG$',3,0.497672 , 0., 5.17E-08,  UBUF,0)
      CALL GSPART(11,'KAON +$     ',4,0.493677 , 1., 1.237E-08, UBUF,0)
      CALL GSPART(12,'KAON -$     ',4,0.493677 ,-1., 1.237E-08, UBUF,0)
      CALL GSPART(13,'NEUTRON$    ',3,.93956563, 0., 8.870E+02, UBUF,0)
      CALL GSPART(14,'PROTON$     ',4,RPMASS   , 1., 1.000e+15, UBUF,0)
      CALL GSPART(15,'ANTIPROTON$ ',4,RPMASS   ,-1., 1.000e+15, UBUF,0)
      CALL GSPART(16,'KAON 0 SHORT$',3,0.497672, 0., 8.926E-11, UBUF,0)
      CALL GSPART(17,'ETA$        ',3,0.54745  , 0., 5.485E-19, UBUF,0)
      CALL GSPART(18,'LAMBDA$     ',3,1.115684 , 0., 2.632E-10, UBUF,0)
      CALL GSPART(19,'SIGMA +$    ',4,1.18937  , 1., 0.799E-10, UBUF,0)
      CALL GSPART(20,'SIGMA 0$    ',3,1.19255  , 0., 7.4E-20,   UBUF,0)
      CALL GSPART(21,'SIGMA -$    ',4,1.197436 ,-1., 1.479E-10, UBUF,0)
      CALL GSPART(22,'XI 0$       ',3,1.3149   , 0., 2.9E-10,   UBUF,0)
      CALL GSPART(23,'XI -$       ',4,1.32132  ,-1., 1.639E-10, UBUF,0)
      CALL GSPART(24,'OMEGA -$    ',4,1.67245  ,-1., 0.822E-10, UBUF,0)
      CALL GSPART(25,'ANTINEUTRON$',3,.93956563, 0., 8.870E+02, UBUF,0)
      CALL GSPART(26,'ANTILAMBDA$ ',3,1.115684 , 0., 2.632E-10, UBUF,0)
      CALL GSPART(27,'ANTISIGMA -$',4,1.18937  ,-1., 0.799E-10, UBUF,0)
      CALL GSPART(28,'ANTISIGMA 0$',3,1.19255  , 0., 7.4E-20,   UBUF,0)
      CALL GSPART(29,'ANTISIGMA +$',4,1.197436 , 1., 1.479E-10, UBUF,0)
      CALL GSPART(30,'ANTIXI 0$   ',3,1.3149   , 0., 2.9E-10,   UBUF,0)
      CALL GSPART(31,'ANTIXI +$   ',4,1.32132  , 1., 1.639E-10, UBUF,0)
      CALL GSPART(32,'ANTIOMEGA +$',4,1.67245  , 1., 0.822E-10, UBUF,0)
      CALL GSPART(33,'TAU +$      ',4,1.7771   , 1., 2.956e-13, UBUF,0)
      CALL GSPART(34,'TAU -$      ',4,1.7771   ,-1., 2.956e-13, UBUF,0)
      CALL GSPART(35,'D +$        ',4,1.8694   , 1., 1.062e-12, UBUF,0)
      CALL GSPART(36,'D -$        ',4,1.8694   ,-1., 1.062e-12, UBUF,0)
      CALL GSPART(37,'D 0$        ',3,1.8646   , 0., 4.280e-13, UBUF,0)
      CALL GSPART(38,'ANTI D 0$   ',3,1.8646   , 0., 4.280e-13, UBUF,0)
      CALL GSPART(39,'DS+$        ',4,1.9685   , 1., 4.360e-13, UBUF,0)
      CALL GSPART(40,'DS-$        ',4,1.9685   ,-1., 4.360e-13, UBUF,0)
      CALL GSPART(41,'LAMBDA C +$ ',4,2.2851   , 1., 1.790e-13, UBUF,0)
      CALL GSPART(42,'W +$        ',4,80.220   , 1., 3.160e-25, UBUF,0)
      CALL GSPART(43,'W -$        ',4,80.220   ,-1., 2.640e-25, UBUF,0)
      CALL GSPART(44,'Z 0$        ',3,91.187   , 0., 7.740e-26, UBUF,0)
      CALL GSPART(45,'DEUTERON$   ',8,1.875613 ,+1., 1.000e+15, UBUF,0)
      CALL GSPART(46,'TRITON$     ',8,2.80925  ,+1., 1.000e+15, UBUF,0)
      CALL GSPART(47,'ALPHA$      ',8,3.727417 ,+2., 1.000e+15, UBUF,0)
      CALL GSPART(48,'GEANTINO$   ',6,0.       , 0., 1.000e+15, UBUF,0)
      CALL GSPART(49,'HE3$        ',8,2.80923  ,+2., 1.000e+15, UBUF,0)
      CALL GSPART(50,'Cerenkov$   ',7,0.       , 0., 1.000e+15, UBUF,0)
c     CALL GSPART(51,'phi$        ',3,1.019    , 0., 1.000e-15, UBUF,0)
c     CALL GSPART(52,'J/psi$      ',3,3.09688  , 0., 1.000e-15, UBUF,0)
c     CALL GSPART(53,'Ypsilon$    ',3,9.46037  , 0., 1.000e-15, UBUF,0)
 
C
C     Define decay modes.
C
      DO 10 I=1,NPAR
      CALL GSDK(IPAR(I),BRATIO(1,I),MODE(1,I))
   10 CONTINUE
C
  99  RETURN
      END
 
 
 
+DECK,GTMED1,IF=-OLD.
*CMZ :          26/03/98  12.57.30  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.22.08  by  S.Giani
*-- Author :
      SUBROUTINE GTMED1 (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Note : For INWVOL = 2, INFROM set to a positive number is    *
C.    *      interpreted by GTMEDI as the number IN of the content     *
C.    *      just left by the current track within the mother volume   *
C.    *      where the point X is assumed to be.                       *
C.    *                                                                *
C.    *   Note : INFROM is set correctly by this routine but it is     *
C.    *      used on entrance only in the case GSNEXT has been called  *
C.    *      by the user. In other words the value of INFROM received  *
C.    *      on entrance is not considered necessarily valid. This     *
C.    *      assumption has been made for safety. A wrong value of     *
C.    *      INFROM can cause wrong tracking.                          *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *               S.Giani.                                         *
C.    *                                                                *
C.    *   Modified by S.Giani (1993) to perform the search according   *
C.    *    to the new 'virtual divisions' algorithm and to build the   *
C.    *    stack of the 'possible overlapping volumes' in the case of  *
C.    *    MANY volumes. Any kind of boolean operation is now possible.*
C.    *    Divisions along arbitrary axis are now possible.            *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCFLAG.
+SEQ, GCKINE.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
+SEQ, GCVDMA.
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
C.
      CHARACTER*4 NAME
      DIMENSION  X(*)
      REAL       XC(6), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
      nvmany=0
      nfmany=0
      new2fl=0
      neufla=0
      if(raytra.eq.1.)then
        JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
        if(ingoto.eq.-1.and.q(jvo+3).lt.0)then
          neufla=1
        elseif(ingoto.eq.0)then
              call ggperp(x,veccos,ierr)
              veccos(1)=-veccos(1)
              veccos(2)=-veccos(2)
              veccos(3)=-veccos(3)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
        endif
      endif
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
* *** Check if point is in current volume
*
      INFR = 0
      INGT = 0
      JVIN = 0
*
* *** LSAMVL is a logical variable that indicates whether we are still
* *** in the current volume or not. It is used in GTRACK to detect
* *** precision problems.
      LSAMVL = .TRUE.
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
 
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 189
      endif
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            LSAMVL = .FALSE.
            NL1 = NLEVEL +1
            LVOLUM(NL1) = IVOT
            NAMES(NL1)  = IQ(JVOLUM+IVOT)
            NUMBER(NL1) = Q(JIN+3)
            LINDEX(NL1) = INGOTO
            LINMX(NL1)  = Q(JVO+3)
            GONLY(NL1)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NL1) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NL1) = NL1
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NL1), GRMAT(1,NL1))
            NLEVEL = NL1
            XC(1) = XT(1)
            XC(2) = XT(2)
            XC(3) = XT(3)
            JVO = JVOT
            INFROM = 0
            if(raytra.eq.1.)then
              call ggperp(x,veccos,ierr)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
            endif
            GO TO 190
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
 189  JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         LSAMVL = .FALSE.
         INGOTO = 0
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
               INFROM=LINDEX(NLEVEL+1)
            ELSE
               INFROM=0
            ENDIF
            INFR = INFROM
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ELSE
*
*   *      Point in current volume but not in INGOTO. We block the
*   *      corresponding volume
*
         IF (INGOTO.GT.0) THEN
            INGT = INGOTO
            JIN = LQ(JVO-INGOTO)
            IQ(JIN) = IBSET(IQ(JIN),4)
         ENDIF
      ENDIF
*
*   *      Found a volume up the tree which contains our point. We block
*   *      the branch we came up from.
*
      IF(INFR.GT.0) THEN
         JIN=LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
*
*  **   Point is in current volume
*
  190 INGOTO = 0
      NLMIN = NLEVEL
      IF (INWVOL.NE.2) INFROM = 0
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            if(raytra.eq.1..and.neufla.eq.1)then
              neufla=0
              call ggperp(x,veccos,ierr)
              if(ierr.eq.1)then
                veccos(1)=1.
                veccos(2)=0.
                veccos(3)=0.
              endif
            endif
            INFROM = 0
            INFR   = 0
            INGT   = 0
            LSAMVL = .FALSE.
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  new2fl=0
                  IF (GONLY(NLEVEL).NE.0.) THEN
                    NLMANY = 0
                    nvmany = 0
                    nfmany = 0
                  ENDIF
                  INFROM = 0
                  INGT   = 0
                  INFR   = 0
                  LSAMVL = .FALSE.
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INFR = 0
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INGT = 0
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
            nfmany=nvmany+1
         ENDIF
         if(new2fl.eq.0)then
            nvmany=nvmany+1
            manyle(nvmany)=nlevel
            do 401 i = 1,nlevel
              manyna(nvmany,i)=names(i)
              manynu(nvmany,i)=number(i)
 401        continue
         endif
*
*   *   Go up the tree up to a volume with positioned contents
*
         new2fl=-1
  310    INFROM = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         INFR = INFROM
         JIN = LQ(JVO-INFROM)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      if(nlmany.eq.0)then
        nvmany=0
        nfmany=0
      endif
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GTMEDI
  999 IF(JGSTAT.NE.0) CALL GFSTAT(4)
      END
+DECK,GTMED2.  IF=OLD.
*CMZ :          26/03/98  12.40.25  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTMED2 (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Note : For INWVOL = 2, INFROM set to a positive number is    *
C.    *      interpreted by GTMEDI as the number IN of the content     *
C.    *      just left by the current track within the mother volume   *
C.    *      where the point X is assumed to be.                       *
C.    *                                                                *
C.    *   Note : INFROM is set correctly by this routine but it is     *
C.    *      used on entrance only in the case GSNEXT has been called  *
C.    *      by the user. In other words the value of INFROM received  *
C.    *      on entrance is not considered necessarily valid. This     *
C.    *      assumption has been made for safety. A wrong value of     *
C.    *      INFROM can cause wrong tracking.                          *
C.    *                                                                *
C.    *   Called by : GTRACK                                           *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant, A.McPherson       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
C.
      DIMENSION  X(*)
      REAL       XC(3), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
* *** Check if point is in current volume
*
      INFR = 0
      INGT = 0
      JVIN = 0
*
* *** LSAMVL is a logical variable that indicates whether we are still
* *** in the current volume or not. It is used in GTRACK to detect
* *** precision problems.
      LSAMVL = .TRUE.
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
 
      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            LSAMVL = .FALSE.
            NL1 = NLEVEL +1
            LVOLUM(NL1) = IVOT
            NAMES(NL1)  = IQ(JVOLUM+IVOT)
            NUMBER(NL1) = Q(JIN+3)
            LINDEX(NL1) = INGOTO
            LINMX(NL1)  = Q(JVO+3)
            GONLY(NL1)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NL1) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NL1) = NL1
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NL1), GRMAT(1,NL1))
            NLEVEL = NL1
            XC(1) = XT(1)
            XC(2) = XT(2)
            XC(3) = XT(3)
            JVO = JVOT
            INFROM = 0
            GO TO 190
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         LSAMVL = .FALSE.
         INGOTO = 0
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
               INFROM=LINDEX(NLEVEL+1)
            ELSE
               INFROM=0
            ENDIF
            INFR = INFROM
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ELSE
*
*   *      Point in current volume but not in INGOTO. We block the
*   *      corresponding volume
*
         IF (INGOTO.GT.0) THEN
            INGT = INGOTO
            JIN = LQ(JVO-INGOTO)
            IQ(JIN) = IBSET(IQ(JIN),4)
         ENDIF
      ENDIF
*
*   *      Found a volume up the tree which contains our point. We block
*   *      the branch we came up from.
*
      IF(INFR.GT.0) THEN
         JIN=LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
*
*  **   Point is in current volume
*
  190 INGOTO = 0
      NLMIN = NLEVEL
      IF (INWVOL.NE.2) INFROM = 0
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            INFROM = 0
            INFR   = 0
            INGT   = 0
            LSAMVL = .FALSE.
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               CX   = XC(IAX)
            ELSE
               CALL GFCOOR (XC, IAX, CX)
            ENDIF
            IDIV = ABS(LOCATF (Q(JSB+3), NSB, CX))
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=USRJMP
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF
            ELSEIF (INFROM.GT.0) THEN
               JNUP = LQ(LQ(JVO-INFROM)-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF (GONLY(NLEVEL).NE.0.) NLMANY = 0
                  INFROM = 0
                  INGT   = 0
                  INFR   = 0
                  LSAMVL = .FALSE.
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INFR = 0
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
            INGT = 0
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFROM = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         INFR = INFROM
         JIN = LQ(JVO-INFROM)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GTMEDI
  999 IF(JGSTAT.NE.0) CALL GFSTAT(4)
      END
+DECK,GGCLOS,IF=-OLD.
*CMZ :          06/04/98  12.37.16  by  Pavel Nevski
*CMZ :  3.21/04 13/12/94  15.29.27  by  S.Giani
*-- Author :
      SUBROUTINE GGCLOS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Closes off the geometry setting.                            *
C.    *    Initializes the search list for the contents of each        *
C.    *    volume following the order they have been positioned, and   *
C.    *    inserting the content '0' when a call to GSNEXT (-1) has    *
C.    *    been required by the user.                                  *
C.    *    Performs the development of the JVOLUM structure for all    *
C.    *    volumes with variable parameters, by calling GGDVLP.        *
C.    *    Interprets the user calls to GSORD, through GGORD.          *
C.    *    Computes and stores in a bank (next to JVOLUM mother bank)  *
C.    *    the number of levels in the geometrical tree and the        *
C.    *    maximum number of contents per level, by calling GGNLEV.    *
C.    *    Sets status bit for CONCAVE volumes, through GGCAVE.        *
C.    *    Completes the JSET structure with the list of volume names  *
C.    *    which identify uniquely a given physical detector, the      *
C.    *    list of bit numbers to pack the corresponding volume copy   *
C.    *    numbers, and the generic path(s) in the JVOLUM tree,        *
C.    *    through the routine GHCLOS.                                 *
C.    *                                                                *
C.    *    Called by : <USER>                                          *
C.    *    Authors   : R.Brun, F.Bruyant, S.Giani  *********           *
C.    *                                                                *
C.    *    Modified by S.Giani for automatic initialization of the new *
C.    *    tracking based on virtual divisions (1993).                 *
C.    *    PN: reset tmpmax (for CRAY)                                 *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+CDE, GCLIST.
+CDE, GCNUM.
+CDE, GCUNIT.
+CDE, GCOPTI.
+SEQ, GCHVIR.
      CHARACTER*4 NAME
      LOGICAL BTEST
C.
C.    ------------------------------------------------------------------
      dimension dx(3),tmpmax(7),ndivto(7),qualit(7),ivoaxi(7)
      data jfirst/0/
      save jfirst
      COMMON /QUEST/ IQUEST(100)
      COMMON/GCDINA/jphi2,jclow,jchig,jbuff
*
* *** Stop the run in case of serious anomaly during initialization
*
      IF (IEORUN.NE.0) THEN
         WRITE (CHMAIL, 1001)
         CALL GMAIL (0, 0)
         STOP
      ENDIF
*
      IF (NVOLUM.LE.0) THEN
         WRITE (CHMAIL, 1002) NVOLUM
         CALL GMAIL (0, 0)
         GO TO 999
      ENDIF
*
      NPUSH = NVOLUM -IQ(JVOLUM-2)
      CALL MZPUSH (IXCONS, JVOLUM, NPUSH, NPUSH,'I')
*
* *** Loop over volumes, create default JNear banks as relevant,
*      and release unused bank space
*
      IDO = 0
      DO 80 IVO = 1,NVOLUM
         JVO = LQ(JVOLUM-IVO)
*
* *** Check if Tracking medium has been defined
*
         NMED=Q(JVO+4)
         IF(NMED.LE.0.OR.NMED.GT.IQ(JTMED-2))THEN
            WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
            CALL GMAIL (0, 0)
         ELSE
            IF(LQ(JTMED-NMED).EQ.0)THEN
               WRITE(CHMAIL,1003)IQ(JVOLUM+IVO)
               CALL GMAIL (0, 0)
            ENDIF
         ENDIF
         IF (BTEST(IQ(JVO),0)) GO TO 80
         IDO = 1
         IQ(JVO) = IBSET(IQ(JVO),0)
         NINL  = IQ(JVO-2)
         NIN   = Q(JVO+3)
         NUSED = IABS(NIN)
         IF (NIN.GT.0) THEN
*           reserve enough additional space for sorted volumes
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
              NUSED=NUSED+1
            ELSE
              NUSED=NUSED+2
            ENDIF
         ENDIF
*
         NPUSH = NUSED -NINL
         DO 90 IN=NINL,NUSED+1,-1
            JIN = LQ(JVO-IN)
            IF(JIN.GT.0) THEN
               CALL MZDROP(IXCONS,JIN,'L')
            ENDIF
  90     CONTINUE
         CALL MZPUSH (IXCONS, JVO, NPUSH, 0, 'I')
         IF (NIN.LE.0) GO TO 80
*
         IF(BTEST(IQ(JVO),3)) THEN
            IZERO=1
         ELSE
            IZERO=0
         ENDIF
         NEL = NIN +IZERO
         JN = LQ(JVO-NIN-1)
         IF(JN.EQ.0) THEN
            CALL MZBOOK (IXCONS,JN,JVO,-NIN-1,'VONE',0,0,NEL+1,2,0)
         ENDIF
         IQ(JN-5) = IVO
         IQ(JN+1) = NEL
         JN = JN +1
         DO 29 I = 1,NIN
            IQ(JN+IZERO+I) = I
   29    CONTINUE
         IF (IZERO.NE.0) IQ(JN+1) = 0
*
   80 CONTINUE
*
      IF (IDO.NE.0) THEN
*
* ***    Perform development of JVOLUM structure where necessary
*
         CALL GGDVLP
*
* ***    Fill GSORD ordering banks if required
*
* Modified by S.Egli to allow GGORDQ to find the optimum sorting for
* all volumes
*
         IF(IOPTIM.GE.1)THEN
            WRITE(6,'(A)')' GGCLOS: Start automatic volume ordering:'
         ENDIF
         DO 91 IVO = 1,NVOLUM
            JVO = LQ(JVOLUM-IVO)
            NIN = Q(JVO+3)
            ISEARC=Q(JVO+1)
            IF(ISEARC.GT.0) GO TO 91
*           check if sorting not possible or not wanted
            IF(NIN.LE.1.OR.NIN.GT.500.OR.IOPTIM.LT.0)THEN
               Q(JVO+1)=0.
               IF(NIN.GT.500.AND.IOPTIM.GE.1)THEN
                 CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
                 WRITE (CHMAIL,1004) NAME,NIN
                 CALL  GMAIL (0, 0)
               ENDIF
            ELSEIF(IOPTIM.EQ.0)THEN
               IF(ISEARC.LT.0)CALL GGORD (IVO)
            ELSEIF(IOPTIM.EQ.1)THEN
               IF(ISEARC.EQ.0) THEN
                  CALL GGORDQ(IVO)
               ELSE
                  CALL GGORD (IVO)
               END IF
            ELSE
               CALL GGORDQ(IVO)
            ENDIF
   91    CONTINUE
*
* ***    Set status bit for concave volumes
*
         CALL GGCAVE
*
* ***    Compute maximum number of levels and of contents per level
*
         CALL GGNLEV
*
      ENDIF
*
********************************************************************************
*
      if(jfirst.eq.0)then
        jfirst=1
        call mzlink(ixcons,'/GCHVIR/',jvirt,jvdiv,jcont)
        call mzlink(ixstor,'/GCDINA/',jphi2,jbuff,jphi2)
      endif
      jflag=0
      nwjvdi=0
      jphi2=0
      jclow=0
      jchig=0
      jbuff=0
      if(jvirt.ne.0)call mzdrop(ixcons,jvirt,' ')
      nwjvir=5*nvolum+20
      call mzneed(ixcons,nwjvir,'G')
      if(iquest(11).lt.0)then
          print *,'No space for jvirt bank'
      else
          call mzbook(ixcons,jvirt,jvirt,1,'VIRT',nvolum,nvolum,
     +              4*nvolum+20,0,0)
      endif
      dx(1)=0.
      dx(2)=0.
      dx(3)=0.
      ndivst=0
      ndioff=0
      ninmax=0
      do 101 ivo=1,nvolum
        jvo=lq(jvolum-ivo)
        call uhtoc(iq(jvolum+ivo),4,NAME,4)
*         print *,'VOLUME ',NAME
*         print *,' '
        nin=q(jvo+3)
        isearc=q(jvo+1)
*        if(nin.eq.0)then
*          print *,'No daughters.'
*        elseif(nin.lt.0)then
*          print *,'Divided volume.'
*        elseif(nin.le.1)then
*          print *,'Only 1 daughter.'
*        endif
 1      continue
        if(nin.gt.1)then
         if(jflag.eq.0)then
          if(iswit(9).eq.12345)then
            print *,'VOLUME ',NAME
            print *,' '
          endif
         endif
         if(jflag.eq.1)then
           q(jvirt+4*(ivo-1)+1)=itmpq
           iaxlo=itmpq
           iaxhi=itmpq
         else
           iaxlo=1
           iaxhi=7
         endif
          if(nin.gt.ninmax)then
           if(jphi2.ne.0)call mzdrop(ixstor,jphi2,' ')
           if(jclow.ne.0)call mzdrop(ixstor,jclow,' ')
           if(jchig.ne.0)call mzdrop(ixstor,jchig,' ')
           call mzbook(ixstor,jphi2,jphi2,2,'PHI2',0,0,
     +                 nin+20,2,-1)
           call mzbook(ixstor,jclow,jclow,2,'CLOW',0,0,
     +                 nin+20,3,-1)
           call mzbook(ixstor,jchig,jchig,2,'CHIG',0,0,
     +                 nin+20,3,-1)
           if(jflag.eq.1)then
             if(jbuff.ne.0)call mzdrop(ixstor,jbuff,' ')
             call mzbook(ixstor,jbuff,jbuff,2,'BUFF',0,0,
     +                   nin+20,2,-1)
           endif
          endif
         do 110 iaxis=iaxlo,iaxhi
          tmpmax(iaxis)=0
          myphif=0
*          print *,'Quality search for axis ',iaxis
          ish=q(jvo+2)
          if(iaxis.le.3)then
            call gvdcar(iaxis,ish,0,q(jvo+7),clmoth,chmoth,ierr)
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          elseif(iaxis.le.5)then
            call gvdrad(iaxis,ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
             if(iaxis.eq.5)ierr=1
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          elseif(iaxis.eq.6)then
            call gvdphi(ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            elseif((chmoth-clmoth).gt.360..or.chmoth.gt.360)then
              print *,'(chmoth-clmoth).gt.360.or.chmoth.gt.360'
            elseif((chmoth-clmoth).eq.360.)then
              myphif=1
            endif
          elseif(iaxis.eq.7)then
            call gvdthe(ish,0,dx,q(jvo+7),clmoth,chmoth,ierr)
            ierr=1
            if(ierr.eq.1.or.(chmoth.le.clmoth))then
*              print *,'Not convenient: abandoned!',iaxis
*              print *,' '
              qualit(iaxis)=10000
              goto 110
            endif
          endif
          if(jflag.eq.1)then
            q(jvirt+4*(ivo-1)+3)=clmoth
            q(jvirt+4*(ivo-1)+4)=chmoth
          endif
          thimot=abs(chmoth-clmoth)
          thimin=100000.
          do 102 in=1,nin
            iq(jphi2+in)=0
            jin=lq(jvo-in)
            call gvdlim(jvo,in,iaxis,clow,chigh,ierr)
            if(ierr.eq.1.or.(chigh.le.clow))then
*              if(ierr.eq.0)print *,'Error in gvdlim: corrected',iaxis
              clow=clmoth
              chigh=chmoth
            elseif(myphif.eq.1)then
              clowm=clow
              chighm=chigh
              sg=sign(1.0,clow)
              clow=mod(abs(clow),360.0)
              if(chigh.ne.360.0)then
               if(sg.le.0.0)clow=360.-clow
               sg=sign(1.0,chigh)
               chigh=mod(abs(chigh),360.0)
               if(sg.le.0.0)chigh=360.-chigh
              endif
              if(chigh.lt.clow)then
                iq(jphi2+in)=1
              endif
            elseif(iaxis.eq.6.and.myphif.eq.0)then
             if((chigh-chmoth).gt..01.or.(clmoth-clow).gt..01)then
               if(clmoth.lt.0..and.clow.gt.0.)then
                clow=clow-360.
                chigh=chigh-360.
                if((chigh-chmoth).gt..01)then
                  chigh=chmoth
                  if(chigh.le.clow)clow=clmoth
                elseif((clmoth-clow).gt..01)then
                  clow=clmoth
                  if(clow.ge.chigh)chigh=chmoth
                endif
               elseif(chigh.lt.0..and.chmoth.gt.0.)then
                clow=clow+360.
                chigh=chigh+360.
                if((chigh-chmoth).gt..01)then
                  chigh=chmoth
                  if(chigh.le.clow)clow=clmoth
                elseif((clmoth-clow).gt..01)then
                  clow=clmoth
                  if(clow.ge.chigh)chigh=chmoth
                endif
               endif
             endif
            endif
            if((chigh-chmoth).gt..01)then
*** ONLY FOR DEBUG
*              print *,'iaxis =',iaxis,'protuding daughter',in
**              print *,'myphif =',myphif,'myphi2 =',iq(jphi2+in)
*              print *,'Dhigh=',chigh-chmoth
*              print *,'Dlow=',clmoth-clow
***
              chigh=chmoth
              if(chigh.le.clow)clow=clmoth
            elseif((clmoth-clow).gt..01)then
*** ONLY FOR DEBUG
*              print *,'iaxis =',iaxis,'protuding daughter',in
**              print *,'myphif =',myphif,'myphi2 =',iq(jphi2+in)
*              print *,'Dhigh=',chigh-chmoth
*              print *,'Dlow=',clmoth-clow
***
              clow=clmoth
              if(clow.ge.chigh)chigh=chmoth
            endif
            q(jclow+in)=clow
            q(jchig+in)=chigh
            if(iq(jphi2+in).eq.0)then
             tmpthi=abs(chigh-clow)
            else
             tmpthi=abs(chighm-clowm)
            endif
            if(thimin.gt.tmpthi)thimin=tmpthi
 102      continue
          if((thimin-thimot).gt.1)then
*            print *,'thimin.gt.thimot',thimin-thimot,'iax=',iaxis
            qualit(iaxis)=10000
            goto 110
          endif
          if(thimin.lt.0.04)thimin=0.04
          tmpndi=2.*thimot/thimin
          nditmp=tmpndi+1
*****          print *,nditmp,' divisions asked for ',nin,' daughters.'
*****           if(nditmp.lt.nin)then
*****             nditmp=nin
*****             print *,'Number of divisions corrected to be = ',nin
*****           endif
*****          if(nditmp.gt.1000.)print *,'1000 divisions are enough.'
          ndivto(iaxis)=min(nditmp,1000)
          if(jflag.eq.1)then
            q(jvirt+4*(ivo-1)+2)=ndivto(iaxis)
           jvdiv=lq(jvirt-ivo)
           if(jvdiv.ne.0)call mzdrop(ixcons,jvdiv,' ')
           nwvili=ndivto(iaxis)+ivoaxi(itmpq)+11
           nwjvdi=nwjvdi+nwvili
           call mzneed(ixcons,nwvili,'G')
           if(iquest(11).lt.0)then
            print *,'No space for jvdiv bank',ivo
           else
            call mzbook(ixcons,jvdiv,jvirt,-ivo,'VLIST',0,0,
     +                  nwvili,2,0)
           endif
          endif
          thisli=thimot/ndivto(iaxis)
          clslic=clmoth
          chslic=clmoth+thisli
          avelis=0.
          aveave=0.
          avesta=0.
          ii=0
          tmpmax(iaxis)=0.
          import=0
          if(jflag.eq.1)ioff=ndivto(iaxis)
          do 103 i=1,ndivto(iaxis)
            j=1
            do 104 in=1,nin
             if(iq(jphi2+in).eq.0)then
              if(q(jchig+in).ge.clslic.and.
     +           q(jclow+in).le.chslic)then
                j=j+1
                if(jflag.eq.1)then
                  iq(jbuff+j)=in
                endif
              endif
             else
              if(q(jchig+in).ge.clslic.or.
     +           q(jclow+in).le.chslic)then
                j=j+1
                if(jflag.eq.1)then
                  iq(jbuff+j)=in
                endif
              endif
             endif
 104        continue
            inbuf1=j-1
            if(jflag.eq.1)then
             if(i.gt.1.and.iq(jbuff+1).eq.(j-1))then
               if(j-1.eq.0)then
                 import=1
               elseif(j-1.eq.1)then
                 if(iq(jbuff+2).eq.iq(jvdiv+ioff-nposti+2))then
                   import=1
                 else
                   import=0
                 endif
               else
                import=1
                do 234 ijk=2,nposti-2
                 do 432 kji=2,nposti-2
                  if(iq(jbuff+ijk).eq.iq(jvdiv+ioff-nposti+kji))then
                    goto 234
                  endif
 432             continue
                 import=0
                 goto 235
 234            continue
 235            continue
               endif
               if(import.eq.1)then
                 iq(jvdiv+ioff-nposti+nposti)=i
                 iq(jvdiv+i)=ioff-nposti
                 goto 145
               endif
             else
               import=0
             endif
             iq(jbuff+1)=j-1
             nposti=j+2
             iq(jbuff+j+1)=i
             iq(jbuff+j+2)=i
             iq(jvdiv+i)=ioff
             do 144 m=1,nposti
               iq(jvdiv+ioff+m)=iq(jbuff+m)
 144         continue
             ioff=ioff+nposti
            else
             aveinc=j+2
             avesta=avesta+aveinc
            endif
 145        continue
            if(inbuf1.gt.tmpmax(iaxis))then
             tmpmax(iaxis)=inbuf1
            endif
            if(inbuf1.ne.0.)ii=ii+1
            avelis=avelis+inbuf1
            clslic=chslic
            chslic=clslic+thisli
 103      continue
          if(jflag.eq.1)then
             ndioff=ndioff+ioff
             if(iswit(9).eq.12345)then
              print *,'words booked =',nwvili,'; words used =',ioff
              print *,' '
          endif
*** ONLY FOR DEBUG
**             mymyof=0
**             do 2 mm=1,ndivto(iaxis)
**               myoff=iq(jvdiv+mm)
**              if(myoff.ne.mymyof)then
**               if(iq(jvdiv+myoff+1).eq.0)then
**                 print *,'Lower div =',iq(jvdiv+myoff+2)
**                 print *,'Upper div =',iq(jvdiv+myoff+3)
**               elseif(iq(jvdiv+myoff+1).eq.1)then
**                 print *,'Lower div =',iq(jvdiv+myoff+3)
**                 print *,'Upper div =',iq(jvdiv+myoff+4)
**               endif
**             endif
**               mymyof=iq(jvdiv+mm)
** 2           continue
***
          endif
          if(ii.eq.0)then
            print *,iaxis,'=iax: not filled divisions: error!'
            print *,' '
            aveave=10000
            avelis=10000
            goto 105
          endif
          if(jflag.eq.0)then
            ivoaxi(iaxis)=avesta
          endif
          aveave=avelis/ndivto(iaxis)
          avelis=avelis/ii
 105      continue
          qualit(iaxis)=avelis
*** ONLY FOR DEBUG
**      print *,'Max n. of objects per div = ',tmpmax(iaxis)
**      print *,'Aver. n. of obj. per not-empty div = ',avelis
**      print *,'Average n. of objects per div = ',aveave
**            print *,' '
***
 110     continue
        if(jflag.eq.0)then
         tmpq=10000
         tmpm=10000
         itmpq=0
         itmpm=0
         do 111 iaxis=1,7
          if(qualit(iaxis).lt.tmpq)then
           tmpq=qualit(iaxis)
           itmpq=iaxis
          endif
          if(tmpmax(iaxis).lt.tmpm)then
           tmpqm=tmpmax(iaxis)
           itmpm=iaxis
          endif
 111     continue
         if(iswit(9).eq.12345)then
          print *,'nin=',nin,' iax=',itmpq,' ndiv=',ndivto(itmpq)
          print *,'Max n. of objects per div = ',tmpmax(itmpq)
          print *,'Average n. of objects per div = ',tmpq
         endif
*** ONLY FOR DEBUG
**         if(isearc.lt.0)then
**           jsb=lq(lq(jvo-nin-1))
**           iaxor=q(jsb+1)
**           ndivor=q(jsb+2)-1
**           jsco=lq(jvo-nin-2)
**           tmpqor=0.
**           tmpmor=0.
**           do 133 idivor=1,ndivor
**             if(iq(jsco+idivor).gt.tmpmor)tmpmor=iq(jsco+idivor)
**             tmpqor=tmpqor+iq(jsco+idivor)
** 133       continue
**           tmpqor=tmpqor/ndivor
**           print *,'Gsord: iax=',iaxor,' ndiv=',ndivor
**           print *,'Gsord: Max n. of obj. per div = ',tmpmor
**           print *,'Gsord: Aver. n. of obj. per div = ',tmpqor
**         endif
***
         ndivst=ndivst+(ndivto(itmpq)+ndivto(itmpq)*(3.+tmpq)+10.)
         jflag=1
         goto 1
        else
          jflag=0
*** ONLY FOR DEBUG
**          print *,'nin=',nin,' iax=',q(jvirt+4*(ivo-1)+1),' ndiv=',
**     +q(jvirt+4*(ivo-1)+2)
**          ittmp=0
**          iind=q(jvirt+4*(ivo-1)+2)
**          do 155 n=1,iind
**           jvdiv=lq(jvirt-ivo)
**           iofset=iq(jvdiv+n)
**           nnobj=iq(jvdiv+iofset+1)
**           if(nnobj.gt.ittmp)ittmp=nnobj
** 155      continue
**          print *,'Max n. of objects per div = ',ittmp
**          print *,' '
**          print *,' '
***
        endif
        endif
        if(nin.gt.ninmax)ninmax=nin
 101  continue
       nwtota=ndivst+nvolum*5+10.
       if(iswit(9).eq.12345)then
        print *,'Computed number of words foreseen = ',nwtota
       endif
       nwreal=nwjvir+nwjvdi
       if(iswit(9).eq.12345)then
        print *,'Computed number of words booked = ',nwreal
       endif
       nwneed=nwjvir+ndioff
       if(iswit(9).eq.12345)then
        print *,'Computed number of words needed = ',nwneed
       endif
       if(jphi2.ne.0)call mzdrop(ixstor,jphi2,' ')
       if(jclow.ne.0)call mzdrop(ixstor,jclow,' ')
       if(jchig.ne.0)call mzdrop(ixstor,jchig,' ')
       if(jbuff.ne.0)call mzdrop(ixstor,jbuff,' ')
*
********************************************************************************
*
* *** Scan the volume structure to retrieve the path through
*      the physical tree for all sensitive detectors
*
       CALL GHCLOS
*
* *** Books STAT banks if data card STAT is submitted
*
      IF (NSTAT.GT.0)  CALL GBSTAT
*
      CALL MZGARB (IXCONS, 0)
*
 1001 FORMAT (' Severe diagnostic in initialization phase. STOP')
 1002 FORMAT (' GGCLOS : NVOLUM =',I5,' *****')
 1003 FORMAT (' Illegal tracking medium number in volume : ',A4)
 1004 FORMAT (' GGORDQ : Volume ',A4,' has more than 500 (',
     +        I3,') daughters ; volume sorting not possible !')
*                                                             END GGCLOS
  999 END
 
+PATCH,DZDOC. =================================================================
*CMZ :  1.00/01 02/02/96  12.36.40  by  G. Poulard
+DECK,DZE2HT. ----------------------------------------------------------------
*CMZ :  1.30/00 11/02/96  22.08.12  by  Pavel Nevski
*CMZ :  1.00/01 09/12/95  16.20.44  by  Pavel Nevski
*-- Author :    O.Schaile
************************************************************************
*                                                                      *
      SUBROUTINE DZE2HT(LUNIN,LUNUSE, FLAG, UPUP1)
*                                                                      *
*     convert DZEDIT SGML to HTML, plug in links                       *
*                                                                      *
*     flag:       Steering flag:                                       *
*                 0 make all hyperlinks internal only                  *
*                 1 add file name in first up bank                     *
*                 2 add file names in all links                        *
*                 3 as 2 and make 1 file/bank                          *
*     upup1:      Id of Upbank of Upbank of top bank                   *
*                                                                      *
*     output file name(s): BankId//UpId.html                           *
*                                                                      *
*     Author: O.Schaile                                                *
*                                                                      *
************************************************************************
      IMPLICIT NONE
 
      INTEGER       LUNIN,LUNUSE
      CHARACTER*80  CFOUT
      CHARACTER*4   UPUP1
      INTEGER       FLAG
      INTEGER       ML, MS
      PARAMETER     (ML=2000, MS=5000)
      CHARACTER*132 CB(ML), CL
      CHARACTER*8   CSTACK(MS), CLIST(MS)
      CHARACTER*4   BANKID, UPID, UPUPID, DOWNID
      CHARACTER*13  CF
      CHARACTER*4   DZE2US
      INTEGER IPBKID,IPUP,IPLSTA,IPLLAS, ISTAT, IP, IPSTAC,I,J,K,NC
     +        ,INDEXA,INDEXN,INDEXC,LNBLNK, IS, NUP,NCUPID,NCCF,IPLIST
     +        ,LUNOUT, NBANKS, NFILES
      LOGICAL EOF, IGNORE
*---
      IF(UPUP1.EQ.' ')THEN
         UPUP1='NONE'
      ELSE
         UPUP1=DZE2US(UPUP1)
      ENDIF
      EOF=.FALSE.
      IGNORE=.FALSE.
      NUP = 0
      NBANKS=0
      NFILES=0
      LUNOUT=0
 
*     Run through files and find all banks
      IPBKID=0
      IPUP=0
      IPLIST=0
*  10    READ(LUNIN,'(A)',END=50)CL
10    CALL DZDCRD(LUNIN,CL,ISTAT)
      IF(ISTAT.NE.0)GOTO 50
      IF(CL(2:9).EQ.'Bank IDH')THEN
         IPBKID=1
         CB(1)=CL
         BANKID=CL(12:15)
      ELSE IF(CL(2:5).EQ.'Up  ')THEN
         IF(IPBKID.EQ.0)THEN
            WRITE(*,*)'Prescan: Upbank appears before bank'
            GOTO 999
         ENDIF
         UPID=CL(12:15)
         BANKID=DZE2US(BANKID)
         UPID  =DZE2US(UPID)
         IPLIST=IPLIST+1
         IF(IPLIST.GT.MS)THEN
            WRITE(*,*)'Too many banks',IPLIST
            GOTO 999
         ENDIF
         CLIST(IPLIST)=BANKID//UPID
         IPBKID=0
      ENDIF
      GOTO 10
 
 50   CONTINUE
 
      REWIND(LUNIN)
*     LOOP ON BANKS
 
      IPSTAC=0
 100  CONTINUE
      IP=0
      IPBKID=0
      IPUP=0
      IPLSTA=0
      IPLLAS=0
*   110  READ(LUNIN,'(A)',END=150)CL
 110    CALL DZDCRD(LUNIN,CL,ISTAT)
      IF(ISTAT.NE.0)GOTO 150
*     IGNORE ALL CONTROL LINES
      IF(CL(1:4).EQ.'<FIG')IGNORE=.TRUE.
      IF(CL(1:5).EQ.'</FIG')IGNORE=.FALSE.
      IF(IGNORE)GOTO 110
      IF(CL(1:1).EQ.'<')GOTO 110
      IF(CL(1:2).EQ.' |')GOTO 110
      IF(CL(1:11).EQ.' ----------')GOTO 110
*     GET HERE FOR START OF A NEW BANK
 115  CONTINUE
      IF(CL(2:9).EQ.'Bank IDH')THEN
*        ONE FILE/BANK
         IF(FLAG.GE.3)THEN
            IF(LUNOUT.NE.0)THEN
               CLOSE(LUNOUT)
               LUNOUT=0
            ENDIF
         ENDIF
         IF(IPBKID.NE.0)THEN
            NBANKS=NBANKS+1
            IF(IPLSTA.NE.0 .AND. IPLLAS.EQ.0)IPLLAS=IP
            IPSTAC=IPSTAC+1
            IF(IPSTAC.GT.MS)THEN
               WRITE(*,*)'Too many banks'
               GOTO 999
            ENDIF
*
            NCUPID=LNBLNK(UPID)
            BANKID=DZE2US(BANKID)
            UPID  =DZE2US(UPID)
            IF(LUNOUT.LE.0)THEN
               LUNOUT=LUNUSE
               CALL CUTOL(CFOUT)
+SELF,IF=-QMIBM.
               CFOUT=BANKID//UPID//'.html'
               CALL KUOPEN(LUNOUT,CFOUT(1:LNBLNK(CFOUT)),
     +                    'UNKNOWN',ISTAT)
+SELF,IF=QMIBM.
               CFOUT=BANKID//UPID//' html'
               CALL FILEINF(ISTAT,'LRECL',256,'RECFM','V')
               OPEN(LUNOUT,FILE='/'//CFOUT(1:LNBLNK(CFOUT)),
     +         ACCESS='SEQUENTIAL',
     +          STATUS='UNKNOWN',FORM='FORMATTED',IOSTAT=ISTAT)
+SELF.
               NFILES=NFILES+1
               WRITE(LUNOUT,'(A)')'<html>'
               WRITE(LUNOUT,'(A)')'<head>'
               WRITE(LUNOUT,'(A)')'<body>'
               WRITE(LUNOUT,'(A)')'<isindex>'
               WRITE(LUNOUT,'(A)')'</head>'
               WRITE(LUNOUT,'(A)')'<body>'
               WRITE(LUNOUT,'(A)')'<pre>'
            ENDIF
            CSTACK(IPSTAC)=BANKID//UPID
            DO I=1,IP
               NC = LNBLNK(CB(I))
               IF(I.EQ.IPBKID)THEN
                  WRITE(LUNOUT,'(A)')'<hr>'
                  WRITE(LUNOUT,'(A)')'<a name="'
     +            //BANKID//UPID//'"><b>'//
     +            CB(I)(1:NC)//'</b></a>'
               ELSE IF(I.EQ.IPUP .AND. UPID.NE.'NONE')THEN
*                 FIRST FIND UP BANK OF IT
                  IF(IPSTAC.EQ.1 .AND. UPUP1.NE.' ')THEN
                     UPUPID=UPUP1
                  ELSE
                     UPUPID='NONE'
                     IF(IPSTAC.GT.1)THEN
                        DO K=IPSTAC-1,1,-1
                           IF(CSTACK(K)(1:4).EQ.UPID)THEN
                              UPUPID=CSTACK(K)(5:8)
                              GOTO 120
                           ENDIF
                        ENDDO
 120                    CONTINUE
                     ENDIF
                  ENDIF
                  IF((FLAG.GE.1 .AND. NUP .EQ.0) .OR.
     +                FLAG.GE.2) THEN
                     CF=UPID//UPUPID//'.html'
                     CALL CUTOL(CF)
                     NCCF=LNBLNK(CF)
                  ELSE
                     NCCF=0
                  ENDIF
                  NUP=NUP+1
                  NC=MAX(NC,16)
                  IF(NCCF.GT.0)THEN
                     WRITE(LUNOUT,'(A)')' Up        <a href="'//
     +                           CF//'#'//UPID//UPUPID//
     +                      '"><b>'//CB(I)(12:15)//'</b></a>'//
     +                        CB(I)(16:NC)
                  ELSE
                     WRITE(LUNOUT,'(A)')' Up        <a href="'//
     +                                       '#'//upid//upupid//
     +                      '"><b>'//CB(I)(12:15)//'</b></a>'//
     +                        CB(I)(16:NC)
                  ENDIF
               ELSEIF(IPLSTA.NE.0.AND.I.GE.IPLSTA.AND.I.LE.IPLLAS)THEN
                  IS=INDEXC(CB(I),' ')
                  IF(IS.LE.0)GOTO 145
*                 is it an integer, i.e. only numbers or space?
                  DO 126 J=IS,IS+4
                     IF(CB(I)(J:J).NE.' ')THEN
                        IF(INDEXN(CB(I)(J:J)).NE.1)GOTO 130
                     ENDIF
126               CONTINUE
*                  READ(CB(I)(IS:IS+4),'(I5)',ERR=130)K
*                 yes, where does name start?
                  IS = INDEXA(CB(I))
                  IF(IS.LE.0)THEN
                     WRITE (*,*)' Down link has no name ', BANKID, UPID
                     WRITE(*,*) CB(I)
                     IS=10
                  ENDIF
                  DOWNID=CB(I)(IS:IS+3)
                  DOWNID=DZE2US(DOWNID)
                  IF(FLAG.GE.2)THEN
                     CF=DOWNID//BANKID//'.html'
                     CALL CUTOL(CF)
                     NCCF=13
                  ELSE
                     NCCF=0
                  ENDIF
                  IF(NCCF.GT.0)THEN
                     NC=MAX(NC,IS+4)
                     WRITE(LUNOUT,'(A)')CB(I)(1:IS-1)//
     +                           '<a href="'//CF//'#'//
     +                           DOWNID//BANKID//'"><b>'//
     +                           CB(I)(IS:IS+3)//'</b></a>'//
     +                           CB(I)(IS+4:NC)
                  ELSE
*                    is there doc?
                     DO K=1,IPLIST
                        IF(CLIST(K).EQ.DOWNID//BANKID)THEN
                           WRITE(LUNOUT,'(A)')CB(I)(1:IS-1)//
     +                           '<a href="#'//
     +                           DOWNID//BANKID//'"><b>'//
     +                           CB(I)(IS:IS+3)//'</b></a>'//
     +                           CB(I)(IS+4:NC)
                            GOTO 125
                         ENDIF
                     ENDDO
*                    fallen through do loop, no doc there
                     WRITE(LUNOUT,'(A)')CB(I)(1:IS-1)//
     +                           '<a href="nodoc.html"><b>'//
     +                           CB(I)(IS:IS+3)//'</b></a>'//
     +                           CB(I)(IS+4:NC)
                     WRITE(*,'(A)')' No doc for: '
     +               //DOWNID//' '//BANKID//
     +               ' will make a reference to: "nodoc.html"'
 125                 CONTINUE
                  ENDIF
                  GOTO 140
 130              CONTINUE
                  NC=MAX(NC,1)
                  WRITE(LUNOUT,'(A)')CB(I)(1:NC)
 140              CONTINUE
               ELSE
                  NC=MAX(NC,1)
                  WRITE(LUNOUT,'(A)')CB(I)(1:NC)
               ENDIF
 145           CONTINUE
            ENDDO
            IF(EOF) GOTO 900
            IPBKID=0
            IP=0
            IPBKID=0
            IPUP=0
            IPLSTA=0
            IPLLAS=0
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPBKID=IP
         BANKID=CL(12:15)
         CALL CLTOU(BANKID)
      ELSE IF(CL(2:5).EQ.'Up  ')THEN
         IF(IPUP.NE.0)THEN
            WRITE(*,*)'More then 1 Up bank'
            GOTO 999
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPUP=IP
         UPID=CL(12:15)
         CALL CLTOU(UPID)
      ELSE IF(INDEX(CL,'Description of the links') .NE. 0)THEN
         IF(IPLSTA.NE.0)THEN
            WRITE(*,*)'More then 1 Link block start'
            GOTO 999
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPLSTA=IP+1
      ELSE IF(INDEX(CL,'Description of the data') .NE. 0)THEN
         IF(IPLLAS.NE.0)THEN
            WRITE(*,*)'More then 1 Link block end'
            GOTO 999
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPLLAS=IP-1
      ELSE
         IP=IP+1
         CB(IP)=CL
      ENDIF
      GOTO 110
 150  EOF=.TRUE.
*     DO THE LAST BANK
      CL(2:9)='Bank IDH'
      GOTO 115
 
900   CONTINUE
      WRITE(LUNOUT,'(A)')'</pre>'
      WRITE(LUNOUT,'(A)')'</body>'
      WRITE(LUNOUT,'(A)')'</html>'
      CLOSE(LUNIN)
      CLOSE(LUNOUT)
999   END
 
      CHARACTER*(*) FUNCTION DZE2US(CH)
      CHARACTER*(*) CH
      DO I=1,LEN(CH)
         IF(CH(I:I).EQ.' ')THEN
            DZE2US(I:I)='_'
         ELSE
            DZE2US(I:I)=CH(I:I)
         ENDIF
      ENDDO
      RETURN
      END
+DECK, DZDENT. ----------------------------------------------------------------
*CMZ :  1.30/00 11/02/96  22.08.12  by  Pavel Nevski
*CMZU:  1.00/01 21/01/96  20.40.48  by  Sasha Vanyashin
*CMZ :          09/12/95  16.20.44  by  Pavel Nevski
*-- Author :    M. Goossens DD/US
      SUBROUTINE DZDENT
************************************************************************
*.                                                                     *
*...DZDENT outputs the link,data and status bit information for a bank *
*.                                                                     *
*.  DZDENT is a daugther routine of DZDOCO                             *
*.  It prints the information about the link, status bit and data      *
*.  part of a given bank identifier                                    *
*.                                                                     *
*. BANKS  R : QBKD                                                     *
*. CALLS    : DZDLIN,INDXBC                                            *
*. CALLED   : DZDOCO                                                   *
*. COMMON   : DZDOCC,DZDTAP,MZCN                                       *
*.                                                                     *
*. AUTHOR   : M. Goossens DD/US                                        *
*. VERSION  : 2.03(47)  / 11 Oct 1987                                  *
*.                                                                     *
*. UPDATE   : 21 Mar 1988                                              *
*. BY       : O.Schaile                                                *
*.            Allow return of all described links if B-option is       *
*.            given (rather then only announced one)                   *
*.            Use link in link area (LBQBKD, LQBKD) for all references *
*.            Suppress printing at various places if B-option given    *
*.            3 Dec 88                                                 *
*.            simplify SGML, remove all SGML from this routine         *
*.            21-Nov-95 PN:  Z option supress data description dump    *
*.**********************************************************************
C     SAVE
 
+CDE, BKWRP,TAPES.
+CDE,ZBCDK.         From DZEBRA
+CDE,LINOUT.
      LOGICAL BTEST, LTHERE, RTHERE,BTHERE,DTHERE
*--     General information
      CHARACTER CFORM*4
+SEQ,DOCPARQ,DZDOCOBK.
+SEQ,BKNUPARQ,BKFOPARQ.
+SEQ,BKSTPARQ,BKTGPARQ,BKTGDATQ.
 
      LTHERE=.FALSE.
      RTHERE=.FALSE.
      BTHERE=.FALSE.
      DTHERE=.FALSE.
   10 CONTINUE
 
*--     Loop over the link, status bit and data information
 
      II     = NBHEAQ
      IF (IFLOPT(MPOSBQ).NE.0) THEN
*--         Link description bank option
*--           Number of links announced
          NLLINK = IQ(KQSP+LBQBKD+MONLQ)
          NSLINK = IQ(KQSP+LBQBKD+MONSQ)
          NLLL = MAX(NLLINK,NSLINK)
*--           Get the number ow words required in the bank
          NLPUSH = NLLL + MOLK0Q - IQWND(KQSP+LBQBKD)
*--           If number of link > 0 -- Push bank, otherwise noopt
 
*--- OTTO    allow return of non announced links
 
*--          CALL DZVERI('Before MZPUSH',0,'CFLSU')
         IF (NLLL.GE.0) CALL MZPUSH(0,LBQBKD,0,NLPUSH,'I')
*--      PRINT '('' NLLINK NLPUSH '',2I5)',NLLINK,NLPUSH
*--      CALL DZSHOW('After PUSH',0,L,' ',0,0,0,0)
*--           Local working variables
*--            0th address and max. nb. entries in link description bank
*          MBLK0  = KQSP + LBQBKD + MOLK0Q
          NBLMAX = IQWND(KQSP+LBQBKD) - MOLK0Q
 
          IHLPUT = 0
 
      ENDIF
      ITAG   = IOTAGQ
      IF (IFLOPT(MPOSIQ).NE.0) THEN
         IREP   = 0
      ELSE
         IREP   = 5
      ENDIF
 
      DO 120 I=MBLINQ,MBDATQ
          IF (IFLOPT(MPOSBQ).NE.0.AND.I.NE.MBLINQ)         GO TO 120
          II     = II + IQ(KQSP+LQBKD+I-1)
          INSERT = II + 1
          IREPLO = 0
          INDENT = 0
          IF (I.EQ.MBLINQ .AND. IFLOPT(MPOSBQ).EQ.0) THEN
              IF (IQ(KQSP+LQBKD+I).GT.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     WRITE(LUNUSR,'(''*B.LINK'')')
                     LTHERE=.TRUE.
                 ELSE
                     WRITE(LUNUSR,10102) 'links'
10102                format(T15,' ---------- Description of the ',a,
     +                          ' ----------')
                 ENDIF
             ELSE
C--              No link description
                                                           GO TO 120
             ENDIF
 
          ELSEIF (I.EQ.MBRLIQ) THEN
              IF (IQ(KQSP+LQBKD+I).GT.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     RTHERE=.TRUE.
                     IF(LTHERE)THEN
                        WRITE(LUNUSR,'(''*B/LINK'')')
                        LTHERE=.FALSE.
                     ENDIF
                     WRITE(LUNUSR,'(''*B.RLINK'')')
                 ELSE
                     WRITE(LUNUSR,10102) 'Reference links'
                 ENDIF
             ELSE
C--              No ref link description
                                                           GO TO 120
             ENDIF
 
          ELSEIF (I.EQ.MBBITQ) THEN
            IF (IQ(KQSP+LQBKD+I).GT.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     WRITE(LUNUSR,'(''*B.BI'')')
                     BTHERE=.TRUE.
                     IF(LTHERE)THEN
                        WRITE(LUNUSR,'(''*B/LINK'')')
                        LTHERE=.FALSE.
                     ENDIF
                     IF(RTHERE)THEN
                        WRITE(LUNUSR,'(''*B/RLINK'')')
                        RTHERE=.FALSE.
                     ENDIF
                 ELSE
                     WRITE(LUNUSR,10102) 'status bits'
                 ENDIF
            ELSE
C--               No status bit description
                                                           GO TO 120
            ENDIF
          ELSEIF (I.EQ.MBDATQ) THEN
            IF (IQ(KQSP+LQBKD+I).GT.0 .AND. IFLOPT(MPOSZQ).EQ.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     WRITE(LUNUSR,'(''*B.DATA'')')
                     DTHERE=.TRUE.
                     IF(LTHERE)THEN
                        WRITE(LUNUSR,'(''*B/LINK'')')
                        LTHERE=.FALSE.
                     ENDIF
                     IF(RTHERE)THEN
                        WRITE(LUNUSR,'(''*B/RLINK'')')
                        RTHERE=.FALSE.
                     ENDIF
                     IF(BTHERE)THEN
                        WRITE(LUNUSR,'(''*B/BI'')')
                        BTHERE=.FALSE.
                     ENDIF
                 ELSE
                     WRITE(LUNUSR,10102) 'data words'
                 ENDIF
            ELSE
C--            No data description
                                                           GO TO 120
            ENDIF
          ENDIF
   20     IF (INSERT.GT.II+IQ(KQSP+LQBKD+I))               GO TO 100
          JTAG   = IQ(KQSP+LQBKD+INSERT+MBPATQ)
          NWTAG  = IBITS(JTAG,ICHTGQ,NCHTGQ)
          ICHOIC = IBITS(JTAG,ICHBTQ,1)
          IDTAG  = IBITS(JTAG,ICHIDQ,NCHIDQ)
          IREPLV = IBITS(JTAG,IRPLVQ,NRPLVQ)
          IF (IREPLO.LT.IREPLV) THEN
*----           Repetition field descriptor
*--                  Start of higher level
               IF (IFLOPT(MPOSIQ).NE.0) THEN
                  COUT   = '*B.REP '
                  INDENT = 8
               ELSE
                  INDENT = IREPLO*INDENQ
                  COUT   = ' '
                  COUT(INDENT+2:)='--REP level='//
     +                         CHAR(ICHAR('0')+IREPLV)
               ENDIF
 
*1810               IF    (IREPLO.EQ.0)THEN
*1810                  COUT(INDENT+2:)='-- Do I = 1,'
*1810               ELSE IF(IREPLO.EQ.1)THEN
*1810                  COUT(INDENT+2:)='-- Do K = 1,'
*1810               ELSE
*1810                  COUT(INDENT+2:)='-- Do J = 1,'
*1810               ENDIF
              IREPLO = IREPLV
              INUM1  = IQ(KQSP+LQBKD+INSERT+MBIX1Q)
              IF (INUM1.GT.0) THEN
*--               Given as real number
                  WRITE(COUT(ITAG+IREP+INDENT:),'(I8)') INUM1
              ELSEIF (INUM1.EQ.INUINQ) THEN
*--                 Indefinite (variable) number
                  COUT(ITAG+IREP+INDENT:) = 'infinite'
              ELSE
*--                 Information is in form of Hollerith text
                  NWTAG = -INUM1/JFOSEQ
              ENDIF
*--             Skip I self-describing sector
              INSERT = INSERT + NBDSCQ
*--             If not Hollerith self-describing sector -- SKIP
              IF (MOD(IQ(KQSP+LQBKD+INSERT),JFOSEQ).NE.IFOHOQ) THEN
                  IF (NWTAG.GT.0) THEN
*--                     Inconsistency: Tag announced and non present
                      WRITE(LUNUSR,10103)
10103                 format('0?? DZDENT: Inconsistency: ',
     +                'Tag information announced and non present')
                                                           GO TO 130
                  ENDIF
                  IF(IFLOPT(MPOSBQ).EQ.0)THEN
*                     IF (INUM1.NE.0)
                      WRITE(LUNUSR,'(A)') COUT
                  ENDIF
                                                           GO TO 20
              ENDIF
*--             Total number of Hollerith words
              NWHOLL = IQ(KQSP+LQBKD+INSERT)/JFOSEQ
              INSERT = INSERT + 1
*--             When there is tag info
              IF (NWTAG.GT.0) THEN
*--                Numbers given as Hollerith text
                 INLINE=ITAG+IREP+INDENT
                 CALL UHTOC(IQ(KQSP+LQBKD+INSERT),4,
     +                      COUT(INLINE:),NWTAG*4)
                 INSERT = INSERT + NWTAG
                 NWHOLL = NWHOLL - NWTAG
              ENDIF
*--             Is there some text left
              IF (NWHOLL.GT.0) THEN
*--                 More text in the buffer
                  INLINE = INLINE+NWTAG*4
*                  INLINE = IOENTQ + IREP + INDENT
                  IEWORK = 0
                  NOUTF  = NOUTQ - INLINE + 1
                  CALL DZDLIN
              ELSE
                  IF(IFLOPT(MPOSBQ).EQ.0)WRITE(LUNUSR,'(A)') COUT
              ENDIF
 
*------------------ End of loop over Hollerith text
              INDENT = IREPLV*INDENQ
          ELSEIF (IREPLO.GT.IREPLV) THEN
*----           End of repetition field
              IF (IFLOPT(MPOSBQ) .EQ. 0)THEN
*--              Level goes down --> close present level
                  INDENT = IREPLV*INDENQ
                  IF (IFLOPT(MPOSIQ).NE.0) THEN
                     COUT   = '*B/REP '
                  ELSE
                     COUT   = ' '
                     COUT(INDENT+2:)='--REP level='//
     +                       CHAR(ICHAR('0')+IREPLO)//' -- End --'
*1810               COUT(INDENT+2:)='-- End Do -----------------------'
                 ENDIF
                 WRITE (LUNUSR,'(A)') COUT
              ENDIF
              IREPLO = IREPLV
*--             Cross check on EOFS flag
              IF (.NOT.BTEST(JTAG,IBEOSQ)) THEN
                   WRITE (LUNUSR,10101)
*                  WRITE (LUNOUT,10101)
10101              format('0??? DZDENT- Illegal repetition level',
     +                    ' counting (only 1 item allowed')
                                                          GO TO 130
              ELSE
*--                 Skip I self-describing sector
                  INSERT = INSERT + NBEOSQ
              ENDIF
          ELSE
*----           Entry documentation
              INUM1  = IQ(KQSP+LQBKD+INSERT+MBIX1Q)
              INUM2  = IQ(KQSP+LQBKD+INSERT+MBIX2Q)
              IF (INUM1.GT.0) THEN
*--               Get number of characters in INUM1
                  ICH    = INUM1
                  DO 30  IW1=1,8
                      ICH = ICH/10
                      IF (ICH.EQ.0)                        GO TO 40
   30             CONTINUE
                  IW1 = 8
   40         ENDIF
              IF (INUM2.GT.0) THEN
*--               Get number of characters in INUM2
                  ICH    = INUM2
                  DO 50  IW2=1,8
                      ICH = ICH/10
                      IF (ICH.EQ.0)                        GO TO 60
   50             CONTINUE
                  IW2 = 8
   60         ENDIF
*--             Indent for each new repetition level
              COUT   = ' '
              IF (IFLOPT(MPOSIQ).NE.0) THEN
                 COUT='*B.'
                 INLINE=3
                 IW1=IW1-1
              ELSE
                 COUT   = ' '
                 INLINE = INDENT*INDENQ
              ENDIF
              IF (INUM2.EQ.0) THEN
*--                 Case of only one number given
                  IF (INUM1.GE.0) THEN
*--                   Given as real number
                      CFORM  = '(I'//CHAR(ICHAR('1')+IW1)//')'
                      WRITE(COUT(INLINE+1:),CFORM) INUM1
                      INLINE = INLINE + IW1 + 1
                  ELSEIF (INUM1.EQ.INUINQ) THEN
*--                     Indefinite (variable) number
                      INLINE = INLINE + 1
                      COUT(INLINE:) = '*'
                  ENDIF
              ELSE
*--                 Case of two numbers
                  IF (INUM1.GE.0) THEN
*--                   Given as real number
                      CFORM  = '(I'//CHAR(ICHAR('1')+IW1)//')'
                      WRITE(COUT(INLINE+1:),CFORM) INUM1
                      INLINE = INLINE + IW1 + 1
                  ELSEIF (INUM1.EQ.INUINQ) THEN
*--                     Indefinite (variable) number
                      INLINE = INLINE + 1
                      COUT(INLINE:) = '*'
                  ENDIF
                  IF (INUM2.GE.0) THEN
*--                   Given as real number
                      INLINE = INLINE + 1
                      COUT(INLINE:INLINE) = '-'
                      CFORM  = '(I'//CHAR(ICHAR('0')+IW2)//')'
                      WRITE(COUT(INLINE+1:),CFORM) INUM2
                      INLINE = INLINE + IW2
                  ELSEIF (INUM2.EQ.INUINQ) THEN
*--                     Indefinite (variable) number
                      COUT(INLINE+1:INLINE+2) = '-*'
                      INLINE = INLINE + 2
                  ENDIF
              ENDIF
*--             Skip I self-describing sector
              INSERT = INSERT + NBDSCQ
*--             If not Hollerith self-describing sector -- SKIP
              IF (MOD(IQ(KQSP+LQBKD+INSERT),JFOSEQ).NE.IFOHOQ) THEN
*                  WRITE(LUNOUT,'(''0?? DZDENT -- Incomplete data'')')
                  WRITE(LUNUSR,'(''0?? DZDENT -- Incomplete data'')')
                  WRITE(LUNUSR,'(A,A4)')' Previous error occured in',
     +                      IQ(KQSP+LBQBKD+MOIDHQ)
                                                           GO TO 20
              ENDIF
*--             Total number of Hollerith words
              NWHOLL = IQ(KQSP+LQBKD+INSERT)/JFOSEQ
              IITAG  = INSERT + 1
              INSERT = IITAG
              IF (INUM2.EQ.0) THEN
*--                 Case of only one number given
                  IF (INUM1.LE.-JFOSEQ) THEN
*--                     Information is in form of Hollerith text
                      NWN1   = -INUM1/JFOSEQ
                      CALL UHTOC(IQ(KQSP+LQBKD+INSERT+NWTAG),4,
     +                           COUT(INLINE+1:),NWN1*4)
                      INLINE = INDXBC(COUT(:INLINE+NWN1*4),' ')
                      INSERT = INSERT + NWN1
                      NWHOLL = NWHOLL - NWN1
                  ENDIF
              ELSE
*--                 Case of two numbers
                  IF (INUM1.LE.-JFOSEQ) THEN
*--                     Information is in form of Hollerith text
                      NWN1   = -INUM1/JFOSEQ
                      CALL UHTOC(IQ(KQSP+LQBKD+INSERT+NWTAG),4,
     +                           COUT(INLINE+1:),NWN1*4)
                      INLINE = INDXBC(COUT(:INLINE+NWN1*4),' ')
                      INSERT = INSERT + NWN1
                      NWHOLL = NWHOLL - NWN1
                  ENDIF
                  IF (INUM2.LE.-JFOSEQ) THEN
*--                     Information is in form of Hollerith text
                      INLINE = INLINE + 1
                      COUT(INLINE:INLINE) = '-'
                      NWN2   = -INUM2/JFOSEQ
                      CALL UHTOC(IQ(KQSP+LQBKD+INSERT+NWTAG),4,
     +                           COUT(INLINE+1:),NWN2*4)
                      INLINE = INDXBC(COUT(:INLINE+NWN2*4),' ')
                      INSERT = INSERT + NWN2
                      NWHOLL = NWHOLL - NWN2
                  ENDIF
              ENDIF
              INLINE = INDENT + ITAG
 
*--             Special case for the link descriptor bank
 
              IF (IFLOPT(MPOSBQ).EQ.0)                     GO TO 90
*--                Update pointer in input bank and test tag information
                  INSERT = INSERT + NWHOLL
                  LENBKD = IQWND(LBQBKD+KQSP)
                  IF (NWTAG.LE.0)                          GO TO 20
*--                Now cases for link numbers
                  IF (INUM1.LE.0)                          GO TO 20
                  IF (INUM2.LT.INUINQ) THEN
                                                           GO TO 20
                  ELSEIF (INUM2.EQ.INUINQ) THEN
*--                     Undefined --> Fill bank up to end and exit
                      DO 70  IINUM=INUM1,NBLMAX
   70                 IQ(KQSP + LBQBKD + MOLK0Q+IINUM) =
     +                                      IQ(KQSP+LQBKD+IITAG)
                                                           GO TO 120
                  ELSEIF (INUM2.EQ.0) THEN
*--                     Only one number given - Inside allowed offsets?
                      IF(INUM1+MOLK0Q .GT. LENBKD)THEN
                          NLPUSH=INUM1+MOLK0Q - LENBKD
                          CALL MZPUSH(0,LBQBKD,0,NLPUSH,'I')
                      ENDIF
                      IQ(KQSP + LBQBKD + MOLK0Q+INUM1)=
     +                                      IQ(KQSP+LQBKD+IITAG)
                      IF(INUM1 .GT. IHLPUT)IHLPUT = INUM1
                  ELSE
*--                     Range of numbers given - Inside allowed offsets?
                      DO 80  IINUM=MIN(INUM1,NBLMAX),MIN(INUM2,NBLMAX)
   80                 IQ(KQSP + LBQBKD + MOLK0Q+IINUM) =
     +                                     IQ(KQSP+LQBKD+IITAG)
                  ENDIF
                                                           GO TO 20
   90         CONTINUE
*--             When there is tag info  <===========
              IF (NWTAG.GT.0) THEN
*--                 Numbers given as Hollerith text
                  CALL UHTOC(IQ(KQSP+LQBKD+IITAG),4,
     +                       COUT(INLINE:),MIN(NENTIQ-2,NWTAG*4))
*1810
                  IF(INDEX(COUT,'L:').NE.0)THEN
                     IF (IFLOPT(MPOSIQ).NE.0) THEN
                        COUT(1:4)  = '*B.*'
                     ELSE
                        WRITE(LUNUSR,'(A)')' '
                        COUT(1:INDEX(COUT,'L:')-1)='--Label:'
                     ENDIF
                  ENDIF
                  INSERT = INSERT + NWTAG
*--                 Is there some text left
                  NWHOLL = NWHOLL - NWTAG
              ENDIF
*--             Remaining text
              IF (NWHOLL.GT.0) THEN
*--                 Copy text according to output type desired
                  INLINE = IOENTQ + INDENT
                  IF (NWHOLL.EQ.1.AND.IQ(KQSP+LQBKD+INSERT).EQ.IDEMTX)
     +                                                           THEN
*--                     Repetition of the previous line
                      COUT(INLINE:) = '  idem'
                      INSERT = INSERT + 1
                      NWHOLL = 0
                      IF(IFLOPT(MPOSBQ).EQ.0)WRITE(LUNUSR,'(A)') COUT
                  ELSE
                      IEWORK = 0
                      NOUTF  = NOUTQ  - INLINE + 1
*--                     General case with text
                      CALL DZDLIN
                  ENDIF
              ELSE
*--             For tags only
                  IF(IFLOPT(MPOSBQ).EQ.0)WRITE(LUNUSR,'(A)') COUT
*------------------ End of field with text information
              ENDIF
*--------------- Multiple choice present ?
              IF (ICHOIC.NE.0) THEN
*--                 Still more text to read?
                  IF (MOD(IQ(KQSP+LQBKD+INSERT),JFOSEQ).EQ.IFOHOQ) THEN
*--                   Indent for each new repetition level
                      COUT   = ' '
                      INLINE = INDENT + ITAG
*--                     Total number of Hollerith words
                      NWHOLL = IQ(KQSP+LQBKD+INSERT)/JFOSEQ
                      IITAG  = INSERT + 1
                      INSERT = IITAG
*--  ==============     Alternative choice for entry      ==============
                                                           GO TO 90
*--          >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                  ENDIF
              ENDIF
*-------------- End of entry (repetition or information tag) [below 110]
          ENDIF
                                                           GO TO 20
*--         Close the description level if needed
  100     CONTINUE
          IF(IFLOPT(MPOSBQ) .EQ. 0)THEN
              DO 110 IR=IREPLV,1,-1
                  IF (IFLOPT(MPOSIQ).NE.0) THEN
                     COUT   = '*B/REP '
                     INDENT = 10
                  ELSE
                     INDENT = (IR-1)*INDENQ
                     COUT   = ' '
                     COUT(INDENT+2:)='--REP level='//
     +                            CHAR(ICHAR('0')+IR)//' -- End --'
*1810                COUT(INDENT+2:)='-- End Do -----------------------'
                  ENDIF
                  WRITE (LUNUSR,'(A)') COUT
  110         CONTINUE
          ENDIF
          IF(LTHERE)THEN
             WRITE(LUNUSR,'(''*B/LINK'')')
             LTHERE=.FALSE.
          ENDIF
          IF(RTHERE)THEN
             WRITE(LUNUSR,'(''*B/RLINK'')')
             RTHERE=.FALSE.
          ENDIF
          IF(BTHERE)THEN
             WRITE(LUNUSR,'(''*B/BI'')')
             BTHERE=.FALSE.
          ENDIF
          IF(DTHERE)THEN
             WRITE(LUNUSR,'(''*B/DATA'')')
             DTHERE=.FALSE.
          ENDIF
*---------- End of loop over link/status bits/data info (400)
  120 CONTINUE
 
      GOTO 140
 
  130 CONTINUE
 
      WRITE(LUNOUT,'(A,A4)')' Previous error occured in: ',
     +                      IQ(KQSP+LQBKD+1)
 
  140 CONTINUE
 
*--- OTTO tell highest link number
 
      IQ(LBQBKD+KQSP+5) = IHLPUT
      IQUEST(MOQUEQ) = LBQBKD
 
      END
+DECK,DZDDOC. -----------------------------------------------------------------
*CMZ :  1.30/00 14/06/96  12.56.57  by  Pavel Nevski
*CMZU:  1.00/01 21/01/96  23.17.55  by  Sasha Vanyashin
*-- Author :
      SUBROUTINE DZDDOC(IXSTOR,L,CHBANK,CHOPT,IF1,IL1,LUN,CHPF,NKEEPS)
*.
*. INPUT     :  IXSTOR  store index
*.              L       link to bank to be dumped
*.              CHOPT   character option
*.                      'U' suppress list of UNDEFIND
*.                      'K' Keep sequences
*.                      'D' INTEGER statements for data offsets
*.                      'O' Parameter statements for data offsets
*.                      'Z' force hexadecimal (DZSHOW)
*.                      'T' list also pure Character banks 1 word/line
*.                      'C'  list value only (useful for output read by
*.                           another program
*.                      '='  list as IQ(LCHBANK(1)+IOFF)=value
*.                      'R'  try to recover from incomplete doc
*.                      'V'  return data word values into VVAR
*.                      'P'  return path to data word into VVAR
*.                      'I'  return IO char into CHPF
*.                      'E'  examine, check range
*.              IFIRST   first word to dump
*.              ILAST    last word
*.              LUN      output unit
*.              CHPF     prefix when making FORTRAN code (data words)
*.              NKEEPS   # of data words for which offsets
*.                       have been gen
*. OUTPUT    :
*.
*. CALLS     : DZSHOW UOPTC ,MZDROP,RZIN,UCTOH, DZSHOW
*. CALLED    : DZDISP, USER
*.
*. AUTHOR    : O.Schaile
*. VERSION   : 1.00
*. CREATED   : 7-Aug-88
*. LAST MOD  : 18-OCT-92
*.           : 14-jun-96, PN : INDEXN has 1 argument only
*.**********************************************************************
      CHARACTER*(*) CHOPT, CHPF
      CHARACTER*40 CHPFI
      CHARACTER*8  CHBANK
      INTEGER KEYVEC(2), IWHOLL, NLSKIP,IDELAY
      CHARACTER*11 CVAL, CVALSA
      CHARACTER*21 CLOOP
      CHARACTER*1 COPTDZ
      CHARACTER*80 CLINE, CLINSA, CLINDE
      CHARACTER*8 CVAR, CVAR1
      CHARACTER*12 CTEMP
      SAVE LUNINT, IOCH
      PARAMETER (LUNINV=41)
      LOGICAL NEWVAL,KEEPSQ,INHOLL,REPEND, NEWPNT, LRECOV, ENDED
*     pointer stuff
      INTEGER MAXP, IPOINT
      PARAMETER (MAXP=200)
      CHARACTER*8 CVARP, CHREPC
      CHARACTER*8 CPOINT(MAXP)
      INTEGER POINT(MAXP),NPOINT(MAXP), IWDOC,IWDOCO,IWORD, IF11,IL11,
     +        NSTYP, IPCHPF
      CHARACTER*1 CHARIO,CHARIS
      CHARACTER*7 CHARIA
      CHARACTER*32 CVARNM
 
*     for returning values
      INTEGER IENTRY,ITYYY
      INTEGER VVAR(100), NVAL,ITY, MAXVAL
      INTEGER VALINT
      REAL    VALREA
      EQUIVALENCE (VALINT,VALREA)
      CHARACTER*8 CVREQ
      LOGICAL REPATH, NOTFIL
      CHARACTER*13 SPACES
      EXTERNAL SPACES
+SEQ,NONEWL2,IF= NONEWL.
+SEQ,NONEWL1,IF=-NONEWL.
*
+CDE, BKWRP,TAPES.
+CDE,ZBCDK.         From DZEBRA
+SEQ,ZUNIT
+SEQ,DZDPRM
+CDE,LINOUT.
+SEQ,DOCPARQ.
      CHARACTER CQSTAK*13,CQINFO*40
      PARAMETER (NLICHQ=130,NSTCHQ=8,NDVCHQ=8,NBKCHQ=4 )
      CHARACTER CQLINE*(NLICHQ),CQMAP(10)*(NLICHQ)
      CHARACTER CQSTOR*(NSTCHQ),CQDIV*(NDVCHQ),CQID*(NBKCHQ)
      COMMON /DZC1CH/ CQSTOR,CQDIV,CQID,CQMAP,CQSTAK,CQINFO
      EQUIVALENCE (CQLINE,CQMAP)
+SEQ,BKNUPARQ,BKFOPARQ.
+SEQ,BKSTPARQ,BKTGPARQ,BKTGDATQ.
*
      DATA CHARIA/'BIFDHUR'/
      DATA LUNINT/0/
*------
      IENTRY = 1
      ITY    = 0
      IF11=IF1
      IL11=IL1
      IF(INDEX(CHOPT,'K').NE.0 .OR. INDEX(CHOPT,'I').NE.0)THEN
         KEEPSQ=.TRUE.
      ELSE
+SEQ,QSTORE.
         IF(IL11.GT.IQ(KQS+L-1))IL11=IQ(KQS+L-1)
         KEEPSQ=.FALSE.
      ENDIF
      NSTYP=0
      CHARIS=' '
      CHARIO=' '
      IF(INDEX(CHOPT,'D').NE.0)THEN
         IF(INDEX(CHOPT,'R').NE.0)THEN
            CHARIO='R'
         ELSE
            CHARIO='I'
         ENDIF
      ENDIF
      IF(INDEX(CHOPT,'I').NE.0)THEN
         IPCHPF=1
         CHPF=' '
      ELSE
         CALL UCTOH(CHBANK,KEYVEC,4,8)
      ENDIF
      LUC = LUN
      REPATH=.FALSE.
      MAXVAL=0
      GOTO 2
 
      ENTRY DZDGVA(IXSTOR, L, CHOPT,CVREQ,NVAL,VVAR,ITYYY)
      IENTRY = 2
      ITY    = 0
      IF(L.EQ.0)GOTO 990
+SEQ,QSTORE.
      LUC = 6
      IF11=1
      IL11=IQ(KQS+L-1)
      MAXVAL=NVAL
      NVAL=0
      ITY=-1
      IPREP0=0
      IPREP1=0
      IPDRE0=0
      IPDRE1=0
      NOTFIL=.TRUE.
      IF(INDEX(CHOPT,'P').NE.0)THEN
         REPATH=.TRUE.
      ELSE
         REPATH=.FALSE.
      ENDIF
      KEYVEC(1)=IQ(KQS+L-4)
      LUP=LQ(KQS+L+1)
      IF(LUP.NE.0)THEN
         KEYVEC(2)=IQ(KQS+LUP-4)
      ELSE
         CALL UCTOH('NONE',KEYVEC(2),4,4)
      ENDIF
 
2     LUNINT = LUNINV
      LUNSAV = IQPRNT
      IDENTF=0
      IWDOCO=0
      NEXTRA=0
      IMBED2=0
      IOCH = -1
      IPOINT=0
      DO 5 I=1,MAXP
         POINT(I)  = -1
         CPOINT(I) = ' '
5        NPOINT(I) = -1
 
*      IREPC=-2
      IPRKEE=0
      NLSKIP=0
      IDELAY=0
      CLINSA=' '
      LCLINE  = LEN(CLINE)
      IPLINE = 1
      INHOLL = .FALSE.
      IF(INDEX(CHOPT,'R').NE.0)THEN
         LRECOV=.TRUE.
      ELSE
         LRECOV=.FALSE.
      ENDIF
      ENDED =.FALSE.
      REPEND=.FALSE.
      NEWPNT=.FALSE.
      IF(KEEPSQ)THEN
          NBLENG = IL1
      ELSE
         NBLENG = IQ(KQS+L-1)
         KEEPSQ=.FALSE.
*         CALL CLTOU(CHOPT)
         IF(INDEX(CHOPT,'Z').NE.0)THEN
            COPTDZ='Z'
         ELSE
            COPTDZ=' '
         ENDIF
         CALL UCTOH ('$LF/',IILFLF,4,4)
      ENDIF
      IF(INDEX(CHOPT,'C').NE.0 .AND. .NOT.KEEPSQ)THEN
         IQPRNT=LUC
         IW1=IF11
         GOTO 90
      ENDIF
      IF(INDEX(CHOPT,'I').EQ.0)
     +CALL  DZDGDO(0,LQBKD1,KEYVEC,CLINE,IFC,ILC,ICYCLE)
      IF(LQBKD1.EQ.0)THEN
         IF(KEEPSQ  .OR. INDEX(CHOPT,'V').NE.0)THEN
            WRITE(LUC,'(A)')'*   No documentation for '//CHBANK(1:4)
            GOTO 990
         ENDIF
         NDATA = 0
      ELSE
 
         IF(ICYCLE.LT.0)WRITE(LUC,'(A)')
     &  ' **** Requested version not found ****'
         IPDATA = IQ(KQS+LQBKD1+MBHEAQ) + IQ(KQS+LQBKD1+MBGENQ)
     +           +IQ(KQS+LQBKD1+MBLINQ) + IQ(KQS+LQBKD1+MBRLIQ)
     &           +IQ(KQS+LQBKD1+MBBITQ) + 1
         IP1 = 0
         IP2 = 0
         IC1 = 0
         IC2 = 0
         IWORD = 0
         IWORDR=0
         IREPL=0
         IFREPL = 0
         CHREPC=' '
         ILOWRC=0
         IUPERC=0
         LOOPC1=-1
         LOOPC2=-1
         IPFORM=0
         ICFORM=0
         IMFORM=0
         LALILE=0
         IP = KQS+LQBKD1+IPDATA
         IPSAVE=IP
         NDATA = IQ(KQS+LQBKD1+MBDATQ)
      ENDIF
 
      IF(INDEX(CHOPT,'Q').EQ.0 .AND.
     &   INDEX(CHOPT,'V').EQ.0 .AND.
     &  .NOT.KEEPSQ)THEN
         IF(INDEX(CHOPT,'E').EQ.0)THEN
            WRITE(LUC,'(10A)')
     &' -------- Data of Bank/UpBank: ',CHBANK(1:4),'/',CHBANK(5:8),
     &     ' Doc Version: ',CLINE(IFC:ILC), ' ----------'
         ELSE
            WRITE(LUC,'(10A)')
     &   '  Checking data of Bank/UpBank: ',CHBANK(1:4),'/',CHBANK(5:8)
         ENDIF
      ENDIF
 
      IF(NDATA.GT.0)THEN
          IC9 = 10
      ELSE
          IQPRNT = LUC
          IW1 = IF11
          WRITE(LUC,'(A)')
     +    '* Data words not documented for '//CHBANK(1:4)
          IF(KEEPSQ .OR. INDEX(CHOPT,'V').NE.0)THEN
             GOTO 990
          ELSE
             GOTO 90
          ENDIF
      ENDIF
      LDATUM = IP + NDATA
      IWDOC = 0
 
*      IF(.NOT.KEEPSQ) WRITE(LUC,*)' '
*
*     IF11,IL11 first, last word to be doc'td
*     IWORD   current word in data
*     IWORDR   current word in rep section
*     IWDOC   word announced in documentation
*     IWDOCO  remember announced word (for cont lines)
*     IP      pointer in documentation
*     IP1     remember IP for start of rep lev 1
*     IP2     remember IP for start of rep lev 2
*     IC1,IC2 repetition counter 1, 2
*     IT      type of info in doc
*             2 integer
*             5 holl
*     NW      # of words in doc
*     IDENT   ITGREQ describe rep
*             ITGENQ describe seq # of data
*     NEWVAL  if false: cont card
*     INHOLL  holl text in data words started
*     IPFORM  pointer to a key descriptor format (see RZ)
*     LOOPC1  or LOOPC2)loop counters in rep section
*
 
 
   10 CONTINUE
      IF(IP .GE. LDATUM)THEN
          IF(.NOT.KEEPSQ)THEN
              IQPRNT = LUC
               ENDED=.TRUE.
               NEWVAL=.TRUE.
               IP=IPSAVE
          ENDIF
          IF(KEEPSQ)GOTO 990
      ENDIF
      IT = MOD(IQ(IP),16)
      NW = IQ(IP)/16
*      WRITE(*,*)' IT,NW,IP ',IT,NW,IP
      IF(NW .LE. 0)THEN
         WRITE(LUC,'(A,2I9)')' Illegal NW at IPDATA ',NW,IPDATA
         GOTO 990
      ENDIF
 
*     start hollerith sector
 
      IF(IT .EQ. 5)THEN
*         WRITE(*,*)' IDENTF= ',IDENTF
*        try to get rep count name and range
         IF(KEEPSQ .AND. ABS(IDENTF).EQ. ITGREQ)THEN
            NCH=MIN(NW*4,LEN(CLINE))
            CLINE=' '
            CALL UHTOC(IQ(IP+1),4,CLINE,NCH)
            NCH=LNBLNK(CLINE)
            ICOLON=INDEX(CLINE(1:8),':')+1
            CHREPC=CLINE(ICOLON:8)
            IFC=INDEX(CLINE,'[')
            ILC=INDEX(CLINE,']')
            IFC=IFC+1
            ILC=ILC-1
            NC=INDEX(CLINE(IFC:ILC),',')
            IF(NC.EQ.0)NC=INDEX(CLINE(IFC:ILC),':')
            IF(IFC.GT.1 .AND. ILC.GT.IFC+2 .AND. NC.NE.0)THEN
               ILC1=IFC+NC-2
               IFC2=ILC1+2
               CALL DZDCTI(CLINE(IFC:ILC1),ILOWRC)
               CALL DZDCTI(CLINE(IFC2:ILC),IUPERC)
            ENDIF
         ENDIF
         IF(IDENTF .NE. ITGENQ) GOTO 80
 
*        rep count = 0 calc from data word
*         IF(IREPC .EQ. 0)GOTO 80
 
         IF(      IWORD+1 .NE. IWDOC
     +      .AND. IP1+IP2 .EQ. 0
     +      .AND. IWDOC   .NE. IWDOCO )THEN
              IWDOCO = -1
         ENDIF
 
*        rep section ended already?
 
         IF(REPEND)GOTO 80
 
*        look if more words documented then announced
 
         IF(NEXTRA.LT.0 .AND. LRECOV)THEN
            IF(IWDOC.GT.ABS(NEXTRA))THEN
               GOTO 80
            ENDIF
         ENDIF
 
*        is it not continuation card for same item
*        or not a start of rep section
 
         NEWVAL = .FALSE.
*         WRITE(*,*)'IWDOCO ,IWDOC, IWORD', IWDOCO ,IWDOC, IWORD
         IF(IWDOCO .NE. IWDOC .OR. IWDOCO .LE. 0 .OR. NEWPNT)THEN
            IWORD = IWORD+1
            IWORDR = IWORDR+1
            NEWVAL = .TRUE.
         ENDIF
*        remember possible repetition count
         IVALLW = IQ(KQS+L+IWORD)
 
         IF(IWORD .GT. IL11)GOTO 990
         IF(IWORD .LT. IF11)GOTO 80
 
*         look if all words are hollerith
 
         IF(IOCH .LT. 0)THEN
            NIO = JBYT(IQ(KQS+L),19,4)
            NL =  IQ(KQS+L-3)
            IOFFBS = - (NIO + NL + 8 + 1)
            IOCH = JBYT(IQ(KQS+L+IOFFBS),17,16)
            IF(IOCH .EQ. 5 .AND. INDEX(CHOPT,'Z').EQ. 0
     +      .AND. INDEX(CHOPT,'T').EQ. 0)THEN
               IF(.NOT.KEEPSQ)THEN
                   WRITE(LUC,'(1X,2A4,1X,100(15A4/7X))')
     +             (IQ(IP+K),K=1,NW)
                   WRITE(LUC,'(A)')'---- '
               ENDIF
               NEWVAL = .TRUE.
            ENDIF
         ENDIF
 
*        loop here if all words are hollerith
 
   20    CONTINUE
*        empty text buffer at end
          IF(IWORD .GT. IL11)THEN
            IF(IPLINE .GT. 1)THEN
               IF(.NOT.KEEPSQ)
     +          WRITE(LUC,'(14X,A)')CLINE(1:IPLINE-1)
                IPLINE = 1
            ENDIF
            GOTO 990
         ENDIF
 
*        get the printed value from CQLINE of DZSHOW  (Quiet option)
         IF(NEWVAL     .AND.
     &     .NOT.KEEPSQ .OR.
     &     (NEWVAL .AND. INDEX(CHOPT,'V').NE.0 .AND. ITY.EQ.-1)
     &     )THEN
             IF(IC9 .GE. 9 .OR. NEWPNT)THEN
                CALL DZSHOW(' ',IXSTOR, L,COPTDZ//'Q',1,0,IWORD,IWORD+8)
                IC9 = 1
             ELSE
                IC9 = IC9+1
             ENDIF
             IBV1 = IC9*12
             IBV2 = IBV1+10
             CVAL = CQLINE(IBV1:IBV2)
             CVALSA=CVAL
         ELSE
             CVAL = '          '
         ENDIF
*        collect text on CLINE
         IF(IOCH .EQ. 5            .AND.
     +      INDEX(CHOPT,'Z').EQ.0  .AND.
     +      INDEX(CHOPT,'T').EQ. 0 )THEN
            IF(IPLINE .GE. LCLINE)THEN
               IF(.NOT.KEEPSQ)
     +         WRITE(LUC,'(14X,A)')CLINE(1:IPLINE-1)
               IPLINE = 1
            ENDIF
            CLINE(IPLINE:IPLINE+3)=CVAL(8:11)
            IPLINE = IPLINE+4
            IF(INHOLL)THEN
               IWORD = IWORD+1
               GOTO 20
            ELSE
               INHOLL = .TRUE.
               CVAL = ' '
            ENDIF
         ELSE
 
*        output other then pure text, empty text buffer
 
             IF(IPLINE .GT. 1)THEN
                IF(.NOT.KEEPSQ .AND.INDEX(CHOPT,'V').EQ.0)
     &          WRITE(LUC,'(14X,A)')CLINE(1:IPLINE-1)
                IPLINE= 1
             ENDIF
             INHOLL = .FALSE.
         ENDIF
 
         CALL UHTOC(IQ(IP+1),4,CVAR,8)
 
*        return value?
 
         IF(INDEX(CHOPT,'V').NE.0)THEN
            IF(CVAR.EQ.CVREQ)THEN
*              find data type
               IF(ITY.LT.0)THEN
                  IF     (INDEX(CVAL,'"').NE.0)THEN
                     ITY=5
                  ELSE IF(INDEX(CVAL,'.').NE.0)THEN
                     ITY=3
                  ELSE
                     ITY=2
                  ENDIF
               ENDIF
*              return path only?
               IF(REPATH)THEN
                  IF(NOTFIL)THEN
                     NOTFIL=.FALSE.
                     NVAL=NVAL+1
                     IF(IREPL.LE.1)THEN
                        VVAR(NVAL)=IWORD-IPREP0
                     ELSE
                        VVAR(NVAL)=IWORD-IPREP1
                     ENDIF
                  ENDIF
               ELSE
                  IF(ITY.EQ.5)THEN
                     WRITE(*,*)'Holleriths not yet supported'
                     ITY=5
                     GOTO 80
                  ENDIF
                  NVAL=NVAL+1
                  VVAR(NVAL)=IQ(KQS+L+IWORD)
               ENDIF
            ENDIF
            IF(NVAL.EQ.MAXVAL)THEN
               IF(MAXVAL.GT.1)WRITE(*,*)
     &         'Max number of values reached', MAXVAL
                GOTO 990
            ELSE
               GOTO 80
            ENDIF
         ENDIF
 
         CVAR1 = CVAR
         CALL CLTOU(CVAR1)
 
*        conVert it by ZITOH?
 
         IF     (CVAR1(1:2).EQ.'Z:')THEN
            CALL ZITOH(IQ(KQS+L+IWORD),IWHOLL,1)
            CVAL=' '
            CALL UHTOC(IWHOLL,4,CVAL,4)
*        format of a Key descriptor
         ELSE IF(CVAR1(1:2).EQ.'F:')THEN
            IF(IPFORM.EQ.0)IPFORM=KQS+L+IWORD
            DO 15 I=1,10
               IFM=JBYT(IQ(KQS+L+IWORD),(I-1)*3+1,3)
               IF     (IFM.EQ.1)THEN
                  CVAL(I:I)='I'
                  IMFORM=IMFORM+1
               ELSE IF(IFM.EQ.3)THEN
                  CVAL(I:I)='H'
                  IMFORM=IMFORM+1
                ELSE
                  CVAL(I:I)=' '
               ENDIF
               CVAL(11:11)=' '
15          CONTINUE
         ELSE IF(CVAR1(1:2).EQ.'K:')THEN
            ICFORM=ICFORM+1
            IF(ICFORM.GT.IMFORM)ICFORM=1
            IFC2=ICFORM/10
            IFC1=MOD(ICFORM,10)
            IF(IFC1.EQ.0)THEN
               IFC1=10
               IFC2=IFC2-1
            ENDIF
            IFM=JBYT(IQ(IPFORM+IFC2),(IFC1-1)*3+1,3)
            IF(IFM.EQ.3)THEN
               CALL ZITOH(IQ(KQS+L+IWORD),IWHOLL,1)
               CVAL=' '
               CALL UHTOC(IWHOLL,4,CVAL,4)
            ENDIF
         ELSE IF(CVAR1(1:2).EQ.'B:')THEN
             WRITE(CVAL,'(Z9)')IQ(KQS+L+IWORD)
             CVALSA=CVAL
         ELSE IF(CVAR1(1:2).EQ.'D:')THEN
             CALL RZDATE(IQ(KQS+L+IWORD),IDATX,ITIMX,1)
             WRITE(CVAL(1:6),'(I6)')MOD(IDATX,1000000)
             WRITE(CVAL(8:11),'(I4)')MOD(ITIMX,10000)
             CVAL(7:7)='/'
         ENDIF
*     pointer stuff
 
*     look if a label is reached
 
      IF(NEWPNT .OR. .NOT. NEWVAL)THEN
        NEWPNT=.FALSE.
      ELSE
       IF(IPOINT.GT.0)THEN
         DO I=1,IPOINT
            IF(IWORD.EQ.POINT(I) .AND. NPOINT(I).NE.0)THEN
*           skip in doc until label is found
               IF(ENDED)ENDED=.FALSE.
               IPP=IPSAVE
               NWP=-1
21             IPP=IPP+NWP+1
               IF(IPP.GE.LDATUM)THEN
                  WRITE(*,*)'No label found for : ',CPOINT(I)
                  GOTO 26
               ENDIF
               ITP = MOD(IQ(IPP),16)
               NWP = IQ(IPP)/16
               IF(ITP.NE.5)GOTO 21
               CALL UHTOC(IQ(IPP+1),4,CVARP,8)
               CALL CLTOU(CVARP)
               IF(CVARP(1:2).NE.'L:')GOTO 21
 
               IF(CVARP(3:).EQ.CPOINT(I)(3:))THEN
*                 remember for later in case identical lines are skipped
                  WRITE(CLINDE,'(2A4,13X,14A4)')
     +            (IQ(IPP+K),K=1,NWP)
                  IDELAY=1
                  IP=IPP+NWP+1
                  NEWPNT=.TRUE.
*                 end a possible infinite repetition
                  IF(IFREPL.EQ.0)THEN
                     IWORD=IWORD-1
                  ELSE
                     IWORD=IWORD-1
                     IFREPL=0
                  ENDIF
*                  WRITE(*,*)'Label found',IWORD,' ',CPOINT(I)
                  IWDOCO=-1
                  GOTO 10
               ELSE
                  GOTO 21
               ENDIF
            ENDIF
         ENDDO
         IF(ENDED)THEN
            IW1=IWORD
            GOTO 90
         ENDIF
       ENDIF
      ENDIF
 
*     is the pointer bit coded in cont card?
      IF(INDEX(CVALSA,'.').NE.0)THEN
         IF(Q(KQS+L+IWORD).GT.0. .AND. Q(KQS+L+IWORD).LT.1000000.)THEN
            IBVAL=Q(KQS+L+IWORD)
         ELSE
            IBVAL=0
         ENDIF
      ELSE
         IBVAL=IQ(KQS+L+IWORD)
      ENDIF
      IF(.NOT.NEWVAL)THEN
         IF(CVAR1(2:4).EQ.':BI')THEN
            READ(CVAR1(5:6),'(I2)',ERR=40  )I1BIT
            IF(I1BIT.GT.31)GOTO 24
            READ(CVAR1(7:8),'(I2)',ERR=24  )I2BIT
            IF(I2BIT.GT.31)GOTO 24
            IF(I2BIT.LT.I1BIT)GOTO 24
            IBVAL = JBYT(IQ(KQS+L+IWORD),I1BIT+1,I2BIT-I1BIT+1)
            IF(INDEX(CHOPT,'Z').NE.0)THEN
               WRITE(CVAL,'(Z11)')IBVAL
            ELSE
               WRITE(CVAL,'(I11)')IBVAL
            ENDIF
*           get the name
            IF(NW.LT.3)THEN
               CTEMP='XXXXXX'
            ELSE
               NCH=MIN(NW-2,2)*4
               IF(NCH.GT.6)NCH=6
               CALL UHTOC(IQ(IP+3),4,CTEMP,NCH)
*              embedded space
               IPSP=INDEX(CTEMP,' ')
               IF(IPSP.NE.0)CTEMP(IPSP:)=' '
            ENDIF
            CVAR1(3:8)=CTEMP
         ENDIF
      ENDIF
 
24    CONTINUE
 
*     if it is a pointer or rep count of it, remember its value
 
      IF(CVAR1(1:2).EQ.'P:' .OR. CVAR1(1:2).EQ.'N:')THEN
*        already there?
         IF(IPOINT.GT.0)THEN
            DO I=1,IPOINT
               IF(CPOINT(I).EQ.CVAR1)THEN
*                  IF(CVAR1(1:2).EQ.'P:')THEN
*                     IF(POINT(I).GE.0)THEN
*                        IF(POINT(I) .LT. IQ(KQS+L+IWORD))
*     &                  POINT(I)=IQ(KQS+L+IWORD)
*                        WRITE(*,*)'Ambigous pointer: ', CPOINT(I)
*                     ELSE
*                        POINT(I)=IBVAL
*                        GOTO  25
*                     ENDIF
*                  ELSE
                  IF(CVAR1(1:2).EQ.'N:')THEN
                     IF(NPOINT(I).GE.0)THEN
                        WRITE(*,*)'Ambigous rep count: ', CPOINT(I)
                     ELSE
*                       may be a simple expression of the value
                        CALL DZDGRC(IQ(IP),2,IBVAL,IREPC,NEXTRA,
     &                  IDUMMY,0,NDUMMY)
                        IF(IREPC.GT.0)IBVAL=IREPC
                        NPOINT(I)=IBVAL
                        GOTO  25
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
         IPOINT=IPOINT+1
         IF(IPOINT.GT.MAXP)THEN
            WRITE(*,*)'Too many pointers:',IPOINT
         ELSE
            CPOINT(IPOINT)=CVAR1
            IF(CVAR1(1:2).EQ.'P:')THEN
               POINT (IPOINT)=IBVAL
*              does it point to same as previous
               IF(IPOINT.GT.1)THEN
                  DO I=1,IPOINT-1
                     IF(POINT(I).EQ.POINT(IPOINT)
     &               .AND. POINT(I).NE.0)THEN
                        POINT(I)=-1
                       WRITE(*,*)'Pointer: ',CPOINT(I),
     &                  ' overwritten by: ',CPOINT(IPOINT)
                     ENDIF
                  ENDDO
               ENDIF
            ELSE
*              may be a simple expression of the value
               CALL DZDGRC(IQ(IP),2,IBVAL,IREPC,NEXTRA,
     &         IDUMMY,0,NDUMMY)
               IF(IREPC.GT.0)IBVAL=IREPC
               NPOINT (IPOINT)=IBVAL
            ENDIF
         ENDIF
25       CONTINUE
      ENDIF
 
26    CONTINUE
 
*     pointer stuff end
 
*       if cont line then look if its mask, bitvalue or choice
         LENMSK=0
         IF(.NOT.NEWVAL)THEN
*            wildchar mask
             IF(CVAR(1:8) .EQ. 'WILDCHAR' .OR.
     &          CVAR(1:4) .EQ. 'MASK')THEN
                IF(KEEPSQ)GOTO 80
*               get the mask
                IF(NW.LT.3)THEN
*                  no mask provided
                   GOTO 80
                ELSE
                   CVAR1 = ' '
                   CTEMP=' '
                   NCH=MIN(NW-2,2)*4
                   IF(NCH.GT.11)NCH=11
                   CALL UHTOC(IQ(IP+3),4,CTEMP,NCH)
*                  embedded space
                   NCH=INDEX(CTEMP,' ')-1
                   IF(NCH.LE.0)NCH=11
                   LENMSK=NCH
                   CTEMP(NCH+1:)=' '
*                  look if it matches
                   DO 28 I=11,1,-1
*                     mask ended?
                      IF(NCH.LE.0)THEN
                         IF(CVALSA(I:I).EQ. ' ')THEN
                            GOTO 29
                         ELSE
                            GOTO 80
                         ENDIF
                      ENDIF
*                     value ended, is rest of mask *?
                      IF(CVALSA(I:I).EQ. ' ')THEN
                         DO 27 J=NCH,1,-1
                           IF(CTEMP(J:J).NE.'*')GOTO 80
27                       CONTINUE
                         GOTO 29
                      ENDIF
                      IF(CTEMP(NCH:NCH).EQ.'*')GOTO 28
                      IF(CTEMP(NCH:NCH).NE.CVALSA(I:I))GOTO 80
28                 NCH=NCH-1
29                 CONTINUE
*                  all matched, does it still fit on line?
                   NCH=(NW-2)*4
                   IF(NCH+LALILE-LENMSK.GT.80)GOTO 50
 
                   CLINE=' '
                   CALL UHTOC(IQ(IP+3),4,CLINE,NCH)
                   NCH=LENOCC(CLINE)
                   LALILE=LALILE+NCH-LENMSK
                   WRITE(LUC,'(A'//NONEWL//')')CLINE(LENMSK+1:NCH)
                   LENMSK=0
                   GOTO 80
                ENDIF
            ENDIF
 
*            choice
             IF(CVAR(1:6) .EQ. 'BITVAL')THEN
                 IF(KEEPSQ)GOTO 80
                 READ(CVAR(7:8),'(I2)')IBIT
                 IF(IAND(IQ(KQS+L+IWORD),ISHFT(1,IBIT)).EQ.0)THEN
                     GOTO 80
                 ELSE
                     CVAR1 = ' '
                     GOTO 50
                 ENDIF
             ENDIF
*            choice starts with C, and
*            contains only numbers or  _  + -
*
             IF(CVAR(1:1).EQ.'C')THEN
                 ILC = INDXBC(CVAR,' ')
                 IF(ILC.LE.1)GOTO 40
                 IFNUM = 2
                 DO 30   K=2,ILC
                     IF(INDXNC(CVAR(K:K)) .NE. 0
     +               .AND.      CVAR(K:K) .NE. '_'
     +               .AND.      CVAR(K:K) .NE. '-'
     +               .AND.      CVAR(K:K) .NE. '+')GOTO 40
                     IF(CVAR(K:K) .EQ. '_')IFNUM=K+1
   30            CONTINUE
                 IF(IFNUM.GT.ILC)GOTO 40
                 IF(KEEPSQ)GOTO 80
                 READ(CVAR(IFNUM:ILC),'(I8)')IVAL
                 IF(INDEX(CVALSA,'.').NE.0)THEN
                    IBVAL=Q(KQS+L+IWORD)
                 ELSE
                    IBVAL=IQ(KQS+L+IWORD)
                 ENDIF
                 IF(IBVAL .NE. IVAL)THEN
                     GOTO 80
                 ELSE
                     CVAR1 = ' '
                     GOTO 50
                 ENDIF
             ENDIF
             IF(CVAR(1:4).EQ.'BITS')THEN
                 READ(CVAR(5:6),'(I2)',ERR=40  )I1BIT
                 IF(I1BIT.GT.31)GOTO 40
                 READ(CVAR(7:8),'(I2)',ERR=40  )I2BIT
                 IF(I2BIT.GT.31)GOTO 40
                 IF(I2BIT.LT.I1BIT)GOTO 40
                 IBVAL = JBYT(IQ(KQS+L+IWORD),I1BIT+1,I2BIT-I1BIT+1)
                 IF(INDEX(CHOPT,'Z').NE.0)THEN
                     WRITE(CVAL,'(Z11)')IBVAL
                 ELSE
                     WRITE(CVAL,'(I11)')IBVAL
                 ENDIF
             ENDIF
         ENDIF
   40    CONTINUE
*
   50    CONTINUE
         IF(IWORD .LT. IF11)GOTO 80
         IF(CVAR .EQ. 'UNDEFIND' .AND. INDEX(CHOPT,'U').NE. 0)GOTO 80
         IF(KEEPSQ)THEN
*           generate FORTRAN code
            IF(NEWVAL .AND. CVAR.NE.'UNDEFIND')THEN
               ILC = INDXBC(CVAR,' ')
*              suppress D:, P: etc
               IFNCOL=MAX(1,INDEX(CVAR(1:ILC),':')+1)
*              get IO-char
               NCH=MIN((NW-2)*4,60)
               CLINE=' '
               CALL UHTOC(IQ(IP+3),4,CLINE,NCH)
               ICOLON=INDEX(CLINE,'IO:')
               IF(ICOLON.NE.0)THEN
*                 skip space
                  ICOLON=ICOLON+2+INDEXC(CLINE(ICOLON:),' ')
                  CHARIO=CLINE(ICOLON:ICOLON)
                  IF(CHARIO.EQ.'U')CHARIO='B'
                  IF(CHARIO.EQ.'R')CHARIO='F'
                  IOLCHA=ICOLON+INDEX(CLINE(ICOLON:),' ')-1
               ENDIF
               IF(INDEX(CHOPT,'I').NE.0)THEN
                  IF(ICOLON.NE.0)THEN
                     IF(INDEX(CHARIA,CHARIO).EQ.0)THEN
                        WRITE(*,*)'Illegal IO-char: ',CHARIO
                        CHPF=' '
                        GOTO 995
                     ENDIF
                     IF(CHARIO.EQ.CHARIS)THEN
                        NSTYP=NSTYP+1
                     ELSE
                        IF(NSTYP.NE.0)THEN
                           CALL DZDFIO(CHPF,IPCHPF,NSTYP,CHARIS)
                           IF(IPCHPF.LE.0)GOTO 995
                        ENDIF
                        NSTYP=1
                     ENDIF
                  ELSE
                     IF(NSTYP.GT.0)THEN
                        NSTYP=NSTYP+1
                     ELSE
                        WRITE(*,*)'No IO-char given yet'
                     ENDIF
                  ENDIF
*                 end of get IO-char
               ELSE
*                 if parameter statements required force Integers
                  IF(INDEX(CHOPT,'p').NE.0) CHARIO='I'
*                 data word offsets, assignments
                  ISKC=INDEXN(CHOPT)
*                 skip first ISKCC characters in data word name
                  IF(ISKC.NE.0)THEN
                     CALL DZDCTI(CHOPT(ISKC:ISKC),ISKCC)
                     IFNCOL=MIN(IFNCOL+ISKCC,ILC)
                  ENDIF
*                 prepare pre or postfix
                  ILPF = MIN(LNBLNK(CHPF),LEN(CHPFI))
                  IF(ILPF.GT.0)THEN
                     CHPFI(1:ILPF)=CHPF(1:ILPF)
                  ELSE
                     IF(INDEX(CHOPT,'=').NE.0)THEN
                        IF(IREPL.GT.0)THEN
                           CHPFI='(I)= Q(NOFF+'
                           IF(CHARIO.EQ.'I')CHPFI(5:5)='I'
                           ILPF=12
                        ELSE
                           CHPFI='= Q(NOFF+'
                           IF(CHARIO.EQ.'I')CHPFI(2:2)='I'
                           ILPF=9
                        ENDIF
                     ELSE IF((INDEX(CHOPT,'C').NE.0 .OR.
     +               INDEX(CHOPT,'H').NE.0)
     +               .AND.IREPL.GT.0)THEN
                        IF(CHREPC.EQ.' ')THEN
                           CHPFI='(MW)'
                        ELSE
                           CHPFI='('//CHREPC(1:2)//')'
                        ENDIF
                        ILPF=4
                     ENDIF
                  ENDIF
                  IF(ILPF.GT.0)THEN
                     IF(INDEX(CHOPT,'Z').EQ.0 .AND.
     +                  INDEX(CHOPT,'=').EQ.0 .AND.
     +                  INDEX(CHPFI,'(').EQ.0)THEN
                        CVARNM(1:ILPF)=CHPFI(1:ILPF)
                        CVARNM(ILPF+1:)=CVAR(IFNCOL:ILC)
                     ELSE
                        CVARNM(1:ILC-IFNCOL+1)=CVAR(IFNCOL:ILC)
                        CVARNM(ILC-IFNCOL+2:)=CHPFI(1:ILPF)
                     ENDIF
                     ILC=ILC-IFNCOL+1+ILPF
                  ELSE
                     CVARNM=CVAR(IFNCOL:ILC)
                     ILC=ILC-IFNCOL+1
                  ENDIF
                  WRITE(CVAR1,'(I8)')IWORDR
*  PN: compilation problem on sp2
*                 IFC = INDEXN(CVAR1,' ')
                  IFC = INDEXN(CVAR1)
                  IF(INDEX(CHOPT,'=').NE.0)THEN
*                    data assignments
                     IF(NKEEPS.EQ.0)THEN
                        ILC1 = INDXBC(CHBANK(1:4),' ')
                        IF(IPRKEE.LE.0)THEN
                           IPRKEE=IPRKEE+1
                           WRITE(LUC,'(A)')
     +                    'C +KEEP,'//'DAASS'//CHBANK(1:ILC1)
                        ENDIF
                     ENDIF
                     CALL DZDPLN(LUC,
     +               CVARNM(1:ILC)//CVAR1(IFC:8)//')',2)
                  ELSE IF(INDEX(CHOPT,'D').NE.0)THEN
*                    declarations, commons
                     IF(NKEEPS.EQ.0)THEN
                        ILC1 = INDXBC(CHBANK(1:4),' ')
                        IF(IPRKEE.LE.0)THEN
                           IPRKEE=IPRKEE+1
                           WRITE(LUC,'(A)')
     +                     'C +KEEP,'//'DAOFF'//CHBANK(1:ILC1)
                        ENDIF
                        IF(INDEX(CHOPT,'C').NE.0)THEN
*                          commons
                           IF(CHPFI(1:1).EQ.'(' .AND.
     +                     CHPFI(ILPF:ILPF).EQ.')')THEN
*                             parameter statement for dimension
                              CALL DZDPLN(LUC,'INTEGER ',2)
                              CHPFI(1:1)=' '
                              CALL DZDPLN(LUC,CHPFI(1:ILPF-1),1)
                              CHPFI(1:1)='('
                              CALL DZDPLN(LUC,'PARAMETER (',2)
                              CALL DZDPLN(LUC,CHPFI(2:ILPF-1)//'=',1)
                              IF(IUPERC.GT.0)THEN
                                 WRITE(CTEMP,'(I12)')IUPERC
                                 IFC=INDEXC(CTEMP,' ')
                                 CALL DZDPLN(LUC,CTEMP(IFC:)//')',1)
                              ELSE
                                 CALL DZDPLN(LUC,'??)',1)
                              ENDIF
                           ENDIF
                           CALL DZDPLN(LUC,
     +                     'COMMON/CO'//CHBANK(1:ILC1)//'/',2)
                           CALL DZDPLN(LUC,
     +                     ' '//CVARNM(1:ILC),1)
                           ILC=0
                        ENDIF
                        IF(INDEX(CHOPT,'H').NE.0)THEN
*                          hbname
                           CALL DZDPLN(LUC,
     +                     'CALL HBNAME (ID'//CHBANK(1:ILC1)//
     +                     ','''//CHBANK(1:ILC1)//''',',2)
*                          if its an array fill dimension first
                           IF(CHPFI(1:1).EQ.'(' .AND.
     +                     CHPFI(ILPF:ILPF).EQ.')')THEN
                              CALL DZDPLN(LUC,
     +                        CHPFI(2:ILPF-1)//','''//CHPFI(2:ILPF-1),1)
                              IF(IUPERC.GT.0)THEN
                                 WRITE(CTEMP,'(I12)')ILOWRC
                                 IFC=INDEXC(CTEMP,' ')
                                 CALL DZDPLN(LUC,'['//CTEMP(IFC:),1)
                                 WRITE(CTEMP,'(I12)')IUPERC
                                 IFC=INDEXC(CTEMP,' ')
                                 CALL DZDPLN(LUC,
     +                           ','//CTEMP(IFC:)//']',1)
                              ELSE
                                 CALL DZDPLN(LUC,'[0,??]',1)
                              ENDIF
                           ELSE
                              CALL DZDPLN(LUC,
     +                        CVARNM(1:ILC)//',''',1)
                              CALL DZDPLN(LUC,CVARNM(1:ILC),1)
                              ILC=0
                           ENDIF
                        ENDIF
                     ENDIF
                     IF(INDEX(CHOPT,'C').EQ.0 .AND.
     +                  INDEX(CHOPT,'H').EQ.0)THEN
                        IF(CHARIO.NE.CHARIS)THEN
                           IF(CHARIO.EQ.'F')THEN
                              CALL DZDPLN(LUC,'REAL ',2)
                           ELSE
                              CALL DZDPLN(LUC,'INTEGER ',2)
                           ENDIF
                           CALL DZDPLN(LUC,
     +                     ' '//CVARNM(1:ILC),1)
                           ILC=0
                        ENDIF
                     ENDIF
                     IF(ILC.GT.0)THEN
                        CALL DZDPLN(LUC,
     +                  ','//CVARNM(1:ILC),1)
                     ENDIF
                     IF(INDEX(CHOPT,'H').NE.0)THEN
                        IF(ICOLON.GT.1)THEN
                           CALL DZDPLN(LUC,':'//CLINE(ICOLON:IOLCHA),1)
                        ENDIF
                     ENDIF
                  ELSE
*                    PARAMETER statements
                     IF(NKEEPS.EQ.0)THEN
                        CALL DZDPLN(LUC,'PARAMETER(',2)
                     ELSE
                        CALL DZDPLN(LUC,',',1)
                     ENDIF
                     CALL DZDPLN(LUC,
     +               CVARNM(1:ILC)//'='//CVAR1(IFC:8)
     +               ,1)
                  ENDIF
                  NKEEPS = NKEEPS+1
                  CHARIS=CHARIO
               ENDIF
            ENDIF
         ELSE
            MC1 = MIN(NW,17)
            MC=MC1
            DO 60   K=3,MC1
               IF(IQ(IP+K).EQ.IILFLF)THEN
                 MC=K-1
                 GOTO 70
               ENDIF
   60       CONTINUE
   70       CONTINUE
*           examine/check value against range
            IF(INDEX(CHOPT,'E').NE.0)THEN
*              get [ , ]
               NCH=MIN((NW-2)*4,LEN(CLINE))
               CLINE=' '
               CALL UHTOC(IQ(IP+3),4,CLINE,NCH)
               IFC=INDEX(CLINE,'[')
               ILC=INDEX(CLINE,']')
               IFC=IFC+1
               ILC=ILC-1
               NC=INDEX(CLINE(IFC:ILC),',')
               IF(NC.EQ.0)NC=INDEX(CLINE(IFC:ILC),':')
               IF(IFC.EQ.1 .OR. ILC.LE.0 .OR. NC.EQ.0)THEN
                  WRITE(LUC,'(A,I6)')
     +            'No range defined for word:',IWORD
                   GOTO 80
               ENDIF
               ILC1=IFC+NC-2
               IFC2=ILC1+2
               IOUT=0
               IF(INDEX( CVAL,'.').EQ.0)THEN
*                 INTEGER
                  IF(CLINE(IFC:IFC).NE.'*')THEN
                     CALL DZDCTI(CLINE(IFC:ILC1),IVAL1)
                     IF(IQ(KQS+L+IWORD).LT.IVAL1)THEN
                        IOUT=1
                     ELSE IF(CLINE(IFC2:IFC2).NE.'*')THEN
                        CALL DZDCTI(CLINE(IFC2:ILC),IVAL2)
                        IF(IQ(KQS+L+IWORD).GT.IVAL2)IOUT=1
                     ENDIF
                  ENDIF
                  IF(IOUT.GT.0)THEN
                     WRITE(LUC,'(A,I10,A,I6,A,2(I10,A))')
     +               CVAR1,IQ(KQS+L+IWORD),' at:',IWORD,
     +               ' out of range [', IVAL1,',' ,IVAL2,']'
                  ENDIF
               ELSE
                  IF(CLINE(IFC:IFC).NE.'*')THEN
                     CALL IZCTOR(CLINE(IFC:ILC1),VAL1)
                     IF(Q(KQS+L+IWORD).LT.VAL1)THEN
                        IOUT=1
                     ELSE IF(CLINE(IFC2:IFC2).NE.'*')THEN
                        CALL IZCTOR(CLINE(IFC2:ILC),VAL2)
                        IF(Q(KQS+L+IWORD).GT.VAL2)IOUT=1
                     ENDIF
                  ENDIF
                  IF(IOUT.GT.0)THEN
                     WRITE(LUC,'(A,E10.4,A,I6,A,2(E10.4,A))')
     +               CVAR1,Q(KQS+L+IWORD),' at:',IWORD,
     +               ' out of range [', VAL1,',' ,VAL2,']'
                  ENDIF
               ENDIF
*           print the value
            ELSE IF(INDEX(CHOPT,'=').EQ.0)THEN
*               fill in a possible index
                CLOOP=CVAR1
                IF(LOOPC1.GT.0)THEN
                   CLOOP(9:9)='('
                   CLOOP(21:21)=')'
                   WRITE(CLOOP(10:14),'(I5)')LOOPC1
                   IF(LOOPC2.GT.0)THEN
                      CLOOP(15:15)=','
                      WRITE(CLOOP(16:20),'(I5)')LOOPC2
                   ENDIF
                   CLOOP=SPACES(CLOOP,0)
                ENDIF
*               indent
                NCLOOP=LENOCC(CLOOP)
                IF(NCLOOP.LE.12)THEN
                     NCLOOP=12
                ELSE IF(NCLOOP.LE.16)THEN
                     NCLOOP=16
                ENDIF
                CLINE=' '
                WRITE(CLINE,'(1X,I5)')IWORD
 
                CLINE(9:9+NCLOOP-1)=CLOOP(1:NCLOOP)
                CLINE(9+NCLOOP:9+NCLOOP+10)=CVAL
                MC=(MC-2)*4
                MC=MIN(MC,LEN(CLINE)-21-NCLOOP)
                CALL UHTOC(IQ(IP+3),4,CLINE(22+NCLOOP-LENMSK:),MC)
*               remove leading part if its MASK
                IF(LENMSK.GT.0)CLINE(1:22+NCLOOP-1)=' '
                IF(CLINE (9+NCLOOP-1:MC+35).NE.
     &             CLINSA(9+NCLOOP-1:MC+35))THEN
                   IF(NLSKIP.GT.0)THEN
                      WRITE(LUC,'(/26X,A,I5,A)')'---',NLSKIP,
     &                ' lines with same value skipped ---'
*                      IF(IDELAY.LE.0)WRITE(LUC,'(A)')' '
                      NLSKIP=0
                   ENDIF
                   IF(IDELAY.GT.0)THEN
                      WRITE(LUC,'(/11X,A)')CLINDE
                      IDELAY=IDELAY-1
                   ENDIF
                   LALILE=LENOCC(CLINE)
                   WRITE(LUC,'(/A'//NONEWL//')')CLINE(1:LALILE)
*             only if bank has more then 100 words
                   IF(NBLENG.GT.100)CLINSA(1:MC+35)=CLINE(1:MC+35)
                ELSE
                   NLSKIP=NLSKIP+1
                ENDIF
             ELSE
                IF(INDEX( CVAL,'.').EQ.0)THEN
                   WRITE(LUC,'(6X,A,A4,A,A8,A,A11)')
     +             'IQ(L',CHBANK(1:4), '+', CVAR1, ') = ', CVAL
                ELSE
                   WRITE(LUC,'(6X,A,A4,A,A8,A,A11)')
     +             'Q(L',CHBANK(1:4), '+', CVAR1, ') = ', CVAL
                ENDIF
             ENDIF
         ENDIF
         GOTO 80
      ENDIF
 
*     end of hollerith sector
 
      IF(IT .NE. 2)THEN
         WRITE(LUC,'(/A,2I9)')' Unexpected IT,NW ',IT,NW
         WRITE(LUC,'(1X,100Z8)')(IQ(IP+K),K=1,NW)
         GOTO 80
      ENDIF
 
*     start of integer sector
*     i.e. word # documented or rep level change
 
*     WRITE(*,'(1X,Z8,100I8)')(IQ(IP+K),K=1,NW)
      ICHOIC = IQ(IP+1)
*      IBIT13 = JBYT(ICHOIC,1,3)
      IDENTF = JBYT(ICHOIC,11,5)
      IF(KEEPSQ )THEN
         IF(IREPL.NE.JBYT(ICHOIC,16,3))THEN
            IF(INDEX(CHOPT,'C').NE.0)NKEEPS=0
            IF(INDEX(CHOPT,'H').NE.0)THEN
               IF(NKEEPS.GT.0)CALL DZDPLN(LUC,''')',1)
               NKEEPS=0
            ENDIF
         ENDIF
      ENDIF
 
      IREPL=JBYT(ICHOIC,16,3)
*      IESEQ  = JBYT(ICHOIC,19,1)
*      WRITE(*,*)' IBIT13, IDENTF, IREPL, IESEQ',
*     &               IBIT13, IDENTF, IREPL, IESEQ
*     remember sequence number of data word documented
      IWDOCO = IWDOC
      IF(IDENTF .EQ. ITGENQ)THEN
*        remember start of rep section in doc
         IF(IC1.GT.0 .AND. IP1 .EQ. 0)IP1 =IP
         IF(IC2.GT.0 .AND. IP2 .EQ. 0)IP2 =IP
         IWDOC = IQ(IP+2)
         GOTO 80
      ENDIF
 
*     repetition level
 
      IF(IDENTF .EQ. ITGREQ)THEN
          IF(REPEND)THEN
             REPEND=.FALSE.
          ELSE
             IF(KEEPSQ)IWORDR=0
          ENDIF
*         end of infinite rep loop (IFREPL=1), check if doc is uptodate
 
          IF(IFREPL.NE.0 .AND. NEXTRA.EQ.0 .AND. LRECOV
     &     .AND. IMBED2.EQ.0 .AND. NW.EQ.1 .AND. IREPL.EQ.0)THEN
             NTRIAL=0
             NDREST=IQ(L+KQS-1)-IWORIF
             NNREP=FLOAT(NDREST)/FLOAT(IWDOC)+0.5
74           NDEXT=NDREST-IWDOC*NNREP
             IF(NDEXT.NE.0 .AND. NNREP.GT.0)THEN
                NEXTRA=NDEXT/NNREP
                IF(NNREP*NEXTRA.EQ.NDEXT)THEN
                   IF(INDEX(CHOPT,'Q').EQ.0)
     &             CALL DZDPRW(LUC,NEXTRA+IWDOC)
                ELSE
                   IF(NTRIAL.EQ.0)THEN
                      NNREP=NNREP+1
                      NTRIAL=1
                      GOTO 74
                   ELSEIF(NTRIAL.EQ.1)THEN
                      NNREP=NNREP-2
                      NTRIAL=-1
                      GOTO 74
                   ELSE
                      NEXTRA=0
                   ENDIF
                ENDIF
             ELSE
                NEXTRA=0
             ENDIF
             IF(NEXTRA.LT.0)THEN
                 WRITE(LUC,'(/A,I5,A)')
     &           ' Ignore last',-NEXTRA,' words'
                 IWORD=IWORD+NEXTRA
                 IWORDR=IWORDR+NEXTRA
*                force new retrieval of formatted values
                 IC9=10
                 NEXTRA=-(NEXTRA+IWDOC)
             ENDIF
             IF(NEXTRA.EQ.0 .AND. NDEXT.NE.0)THEN
                   CALL DZDPRW(LUC,-1000000)
             ENDIF
          ENDIF
*     look if enough data words are documented for this section
          IF(NEXTRA.GT.0 .AND. LRECOV)THEN
             DO 75 II=IWORD+1,IWORD+NEXTRA
                CALL DZSHOW(' ',IXSTOR, L,COPTDZ//'Q',1,0,II,II)
                CVAL = CQLINE(12:22)
                IF(INDEX(CHOPT,'C').EQ.0)THEN
                   IF(INDEX(CHOPT,'Q').EQ.0)
     &             WRITE(LUC,'(/1X,I5,16X,A11,A)') II, CVAL,
     &            '  not documented'
                ELSE
                   WRITE(LUC,'(A11)')CVAL
                ENDIF
   75        CONTINUE
             IWORD=IWORD+NEXTRA
             IWORDR=IWORDR+NEXTRA
*            force new retrieval of formatted values
             IC9=10
          ENDIF
 
*
76        IWDOC = -1
 
*     end of rep level
 
          IF(NW .EQ. 1)THEN
 
             IF(IREPL .EQ. 1)THEN
*               end rep lev 2
                IF(REPATH)THEN
                   IF(IP.NE.IPDRE1)THEN
                      IF(IPRL1.LE.0)THEN
                         NVAL=-1
                         GOTO 990
                      ENDIF
                      VVAR(IPRL2)=IWORD-IPREP1
                      IPRL2=0
                      IPDRE1=IP
                      IF(NOTFIL)THEN
                         NVAL=NVAL+1
                         VVAR(NVAL)=0
                      ENDIF
                   ENDIF
                   IPREP1=IWORD
                ENDIF
                IC2 = IC2 -1
                LOOPC2=LOOPC2+1
*                IREPC=-2
                IF(IC2 .GT. 0)THEN
                    IP = IP2
                    IDENTF = ITGENQ
                    GOTO 10
                ENDIF
                LOOPC2=-1
                NEXTRA=0
                GOTO 80
             ELSE
                IF(IREPL .EQ. 0)THEN
                   IF(REPATH)THEN
*                     all done
                      IF(IP.NE.IPDRE0)THEN
                         IF(IPRL1.LE.0)THEN
                            NVAL=-1
                            GOTO 990
                         ENDIF
                         VVAR(IPRL1)=IWORD-IPREP0
                         IPDRE0=IP
                         IPRL1=0
                         IF(NOTFIL)THEN
                            NVAL=NVAL+1
                            VVAR(NVAL)=0
                         ENDIF
                      ENDIF
                      IF(.NOT.NOTFIL)GOTO 990
                      IPREP0=IWORD
                   ENDIF
                   IC1=IC1-1
                   LOOPC1=LOOPC1+1
*                   IREPC=-2
                   IF(IC1 .GT. 0)THEN
                      IF(KEEPSQ)GOTO 990
                      IP = IP1
                      IDENTF = ITGENQ
                      GOTO 10
                   ENDIF
                   LOOPC1=-1
                   NEXTRA=0
                   IMBED2=0
                   GOTO 80
                ELSE
                   WRITE(LUC,'(/A,I9)')' Illegal end of rep at',IP
                   GOTO 990
                ENDIF
             ENDIF
          ENDIF
 
* start of rep
 
          IREPC = IQ(IP+2)
 
*         return path?
 
          IF(REPATH)THEN
             NVAL=NVAL+1
*            offset from previous to start of rep
             VVAR(NVAL)= - (IWORD-IPREP0)
*            remember start of section
             IF(IREPL.EQ.2)THEN
                IPREP1=IWORD
             ELSE
                IPREP0=IWORD
             ENDIF
             NVAL=NVAL+1
             VVAR(NVAL)=4
             NVAL=NVAL+1
             VVAR(NVAL)=IREPC
             MGEVAL=MAXVAL-NVAL
          ELSE
             MGEVAL=0
          ENDIF
 
          IF(IREPC.LT.0 .AND. .NOT. KEEPSQ)THEN
*            was it given in previous data word?
             ITP = MOD(IQ(IP+NW+1),16)
             NWP = IQ(IP+NW+1)/16
             NCOP=MIN(15,NWP)*4
             IF(ITP.EQ.5)THEN
                CLINE=' '
                CALL UHTOC(IQ(IP+NW+2),4,CLINE,NCOP)
                IF(CLINE(1:2).EQ.'N:'.AND.IPOINT.GT.0)THEN
                   DO I=1,IPOINT
                      NCH=LENOCC(CPOINT(I))
                      IF(CPOINT(I)(1:NCH).EQ.CLINE(1:NCH))THEN
                         IREPC=NPOINT(I)
                         IF(LENOCC(CLINE).GT.NCH)THEN
                            IVALRC=IREPC
                            IF(REPATH)THEN
                               CALL DZDGR1
     &                         (CLINE(NCH+1:),IVALRC,IREPC,NEX,
     &                          VVAR(NVAL+1),MGEVAL,NGEVAL)
                            ELSE
                               CALL DZDGR1
     &                         (CLINE(NCH+1:),IVALRC,IREPC,NEX,
     &                          IDUMMY,0,NDUMMY)
                            ENDIF
                         ENDIF
                         GOTO 77
                      ENDIF
                   ENDDO
                ENDIF
             ENDIF
 
*            try to get rep count from variable
 
             IF(REPATH)THEN
                CALL DZDGRC(IQ(IP+NW+1),0,IVALLW,IREPC,NEXTRA,
     &          VVAR(NVAL+1),MGEVAL,NGEVAL)
                IF(NGEVAL.LE.0)THEN
                   VVAR(NVAL)=1000000
                ELSE
                   VVAR(NVAL-1)=VVAR(NVAL-1)+NGEVAL
                   NVAL=NVAL+NGEVAL
                ENDIF
             ELSE
                CALL DZDGRC(IQ(IP+NW+1),0,IVALLW,IREPC,NEXTRA,
     &          IDUMMY,0,NDUMMY)
             ENDIF
 
             IF(NEXTRA.LT.0 .AND.INDEX(CHOPT,'Q').EQ.0 .AND. LRECOV)
     &       CALL DZDPRW(LUC,NEXTRA)
             IF(NEXTRA.GT.0 .AND. LRECOV)THEN
                IF(INDEX(CHOPT,'Q').EQ.0)WRITE(*,*)
     &          ' WARNING: Assume EXTRA',NEXTRA,' words not documented'
             ENDIF
 
             IF(IREPC.EQ.0)THEN
                REPEND=.TRUE.
             ENDIF
          ENDIF
77        CONTINUE
 
          IF(REPATH)THEN
             NVAL=NVAL+1
             IF(IREPL.EQ.1)THEN
                IPRL1=NVAL
             ELSE
                IPRL2=NVAL
             ENDIF
          ENDIF
 
          IF(IREPL.EQ.1)THEN
             IP1 = 0
             LOOPC1=1
             IC1 = IREPC
*             IC1 = IQ(IP+2)
             IF(IC1 .LT. 0)THEN
                IF(IFREPL .EQ. 0)THEN
                   IF(KEEPSQ)THEN
                      IC1 = 1
                   ELSE
*                    variable (infinite)rep
                      IFREPL =1
                      IC1 = 10000000
                   ENDIF
                   IDENTF = -ITGREQ
                   IF(NEWPNT)THEN
                      IWORIF=IWORD+1
                   ELSE
                      IWORIF=IWORD
                   ENDIF
                ELSE
                   WRITE(LUC,'(/A,I9)')
     &             ' Illegal var Rep count at ',IP
                   GOTO 990
                ENDIF
             ENDIF
             GOTO 80
          ELSE
             IF(IREPL.EQ.2)THEN
                IP2 = 0
                LOOPC2=1
                IC2 = IREPC
*               flag imbedded rep level 2
                IMBED2=1
*                IC2 = IQ(IP+2)
                IF(IC2 .LT. 0)THEN
                   WRITE(LUC,'(/A,I9)')
     &             ' Illegal var Rep count at ',IP
                   GOTO 990
                ENDIF
             ELSE
                WRITE(LUC,'(/A,I9)')' Repl>2 at ',IP
                GOTO 990
             ENDIF
          ENDIF
      ENDIF
 
   80 CONTINUE
      IP = IP+NW+1
      IF(IWORD.LT.IL11 .OR. IP.LT.LDATUM)THEN
          GOTO 10
      ELSE
          GOTO 990
      ENDIF
 
   90 CONTINUE
      IF(NLSKIP.GT.0)THEN
         WRITE(LUC,'(/A,I5,A)')'       ---',NLSKIP,
     &   ' identical lines skipped ---'
         NLSKIP=0
      ELSE
         WRITE(LUC,'(/A)')' '
      ENDIF
      DO 100 IWORD=IW1,IL11
      CALL DZSHOW(' ',IXSTOR, L,COPTDZ//'Q',1,0,IWORD,IWORD)
      CVAL = CQLINE(12:22)
      IF(INDEX(CHOPT,'C').EQ.0)THEN
          WRITE(LUC,'(1X,I5,16X,A11)') IWORD, CVAL
      ELSE
          WRITE(LUC,'(A11)')CVAL
      ENDIF
  100 CONTINUE
 
  990 CONTINUE
      IF( .NOT. KEEPSQ)THEN
         IF(NLSKIP.GT.0)THEN
            WRITE(LUC,'(/A,I5,A)')'       ---',NLSKIP,
     &      ' identical lines skipped ---'
            NLSKIP=0
         ELSE
            WRITE(LUC,'(/A)')
     &     '-----------------------------------------------------------'
         ENDIF
      ENDIF
  995 CONTINUE
      IF(INDEX(CHOPT,'I').NE.0 .AND. NSTYP.GT.0)THEN
          CALL DZDFIO(CHPF,IPCHPF,NSTYP,CHARIS)
      ENDIF
      IF(KEEPSQ .AND. INDEX(CHOPT,'H').NE.0 .AND. NKEEPS.GT.0)THEN
         CALL DZDPLN(LUC,''')',1)
      ENDIF
      IF(LQBKD1.NE.0 .AND.INDEX(CHOPT,'I').EQ.0)THEN
         CALL MZDROP(0,LQBKD1,'L')
         LQBKD1=0
      ENDIF
      IQPRNT =LUNSAV
      IF (IENTRY.EQ.2) ITYYY=ITY
      END
 
+DECK,DZIOPH. -----------------------------------------------------------------
*CMZ :  1.30/00 11/02/96  22.08.12  by  Pavel Nevski
*CMZU:  1.00/01 22/01/96  00.49.05  by  Sasha Vanyashin
*-- Author :
+SEQ,DEBUGVF1,IF=DEBUGON,IF=VFORT.
      SUBROUTINE DZIOPH (IFIRST,ILAST)
      SAVE KFOTYP
+CDE,MQSYS,QEQU,MZIOC,ZBCDK,ZUNIT.
+CDE,DZC1,BKFOPARQ.
 
      CHARACTER CHROUT*(*),CHSTAK*6,KFOTYP(0:11)*1
+SELF,IF=QMCRY,QMCDC.
      CHARACTER CDWORD*36
+SELF,IF=-QMCRY,IF=-QMCDC.
      CHARACTER CDWORD*20
+SELF.
      DOUBLE PRECISION DWORD
      INTEGER                IWORD
      REAL                         RWORD
      EQUIVALENCE     (DWORD,IWORD,RWORD)
      PARAMETER (CHROUT = 'DZIOPH')
      DATA KFOTYP /'U','B','I','F','D','H','*','S','*','N','*','L'/
 
+SEQ,DEBUGVF2,IF=DEBUGON,IF=VFORT.
*SEQ, Q$JBIT.
 
      CHSTAK          = CQSTAK(MCQSIQ:)
      CQSTAK(MCQSIQ:) = CHROUT
 
      CALL ZPAGE(IQPRNT,MIN((ILAST-IFIRST)/10+2,5))
      CQLINE = ' --------  DATA part of bank  --------'
      IF (IFLOPT(MPOSQQ).EQ.0) CALL DZTEXT(0,CDUMMQ,1)
 
      WRITE (CQLINE,'(1X,I7,'' /'',120X)') IFIRST
      INLINE =11
 
      JDATA  = 0
      JFOCUR = 0
      NWPRNT = 0
 
 
   10 ITYPE  = MFO(JFOCUR+1)
      IF (ITYPE.EQ.7)                                      GO TO 40
      NWSEC = MFO(JFOCUR+2)
      IF   (NWSEC)           20, 30, 60
 
   20 NWSEC = ILAST - JDATA
                                                           GO TO 60
 
   30 JDATA = JDATA + 1
      IWORD = IQ(KQS+LS+JDATA)
      NWSEC = IWORD
      IF (JDATA.GE.IFIRST) THEN
+SELF,IF=QMCRY,QMCDC.
          WRITE(CQLINE(INLINE:INLINE+19),'('' *'',A1,''('',I15,'')'')')
     +     KFOTYP(MIN(ITYPE,6)),NWSEC
+SELF,IF=-QMCRY,IF=-QMCDC.
          WRITE(CQLINE(INLINE:INLINE+11),'('' *'',A1,''('', I7,'')'')')
     +     KFOTYP(MIN(ITYPE,6)),NWSEC
+SELF.
          NWPRNT = NWPRNT + 1
      ENDIF
                                                           GO TO 50
 
   40 JDATA = JDATA + 1
      IWORD = IQ(KQS+LS+JDATA)
      ITYPE = MOD (IWORD,16)
      NWSEC = IWORD/16
      IF (JDATA.GE.IFIRST) THEN
+SELF,IF=QMCRY,QMCDC.
         WRITE(CQLINE(INLINE:INLINE+19),'('' *S('',A1,'','',I13,'')'')')
+SELF,IF=-QMCRY,IF=-QMCDC.
         WRITE(CQLINE(INLINE:INLINE+11),'('' *S('',A1,'','', I5,'')'')')
+SELF.
     +     KFOTYP(MIN(ITYPE,6)),NWSEC
          NWPRNT = NWPRNT + 1
      ENDIF
 
   50 IF (JDATA.GE.IFIRST) THEN
+SELF,IF=QMCRY,QMCDC.
          IF (MOD(NWPRNT,6).EQ.0)  THEN
+SELF,IF=-QMCRY,IF=-QMCDC.
          IF (MOD(NWPRNT,10).EQ.0)  THEN
+SELF.
              IF (IFLOPT(MPOSQQ).NE.0)                    GO TO 999
              CALL DZTEXT(0,CDUMMQ,1)
              WRITE (CQLINE,'(1X,I7,'' /'',120X)') NWPRNT+IFIRST
              INLINE =11
          ELSE
+SELF,IF=QMCRY,QMCDC.
              INLINE = INLINE + 20
+SELF,IF=-QMCRY,IF=-QMCDC.
              INLINE = INLINE + 12
+SELF.
          ENDIF
      ENDIF
 
      IF (ITYPE.GE.8) THEN
          ITYPE      = 0
          NWSEC      = ILAST - JDATA
          IQUEST(11) = -ITYPE
      ELSEIF (NWSEC.EQ.0) THEN
          ITYPE      = 0
                                                           GO TO 900
      ELSEIF (NWSEC.LT.0) THEN
          ITYPE      = 0
          NWSEC      = ILAST - JDATA
          IQUEST(11) = -ITYPE-32
      ENDIF
 
 
   60 IDBLE  = 0
      DO 100 I=MAX(JDATA+1,IFIRST),MIN(JDATA+NWSEC,ILAST)
          IWORD = IQ(KQS+LS+I)
          IF (IDBLE.EQ.1)           THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(A,'')'')') CDWORD(18:)
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(A,'')'')') CDWORD(10:)
+SELF.
              IDBLE  = 0
          ELSEIF (ITYPE.EQ.IFOHOQ)  THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(7X,''"'',A12)') IWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(7X,''"'',A4)')  IWORD
+SELF.
          ELSEIF (ITYPE.EQ.IFOINQ)  THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(I20)')          IWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(I12)')          IWORD
+SELF.
          ELSEIF (ITYPE.EQ.IFOFLQ)  THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(G20.14)')       RWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              if (Rword.EQ.0.0) then
                 CQLINE(INLINE:INLINE+11)='  0.0  '
              else if (abs(Rword).LT.1.e-3.or.abs(Rword).GT.1.e8) then
                 WRITE(CQLINE(INLINE:INLINE+11),'(G12.4)')     RWORD
              else if (abs(Rword).LT.1) then
                 WRITE(CQLINE(INLINE:INLINE+11),'(F12.8)')     RWORD
              else
                 WRITE(CQLINE(INLINE:INLINE+15),'(G16.9)')     RWORD
                 CQLINE(INLINE+12:INLINE+15)=' '
              endif
+SELF.
          ELSEIF (ITYPE.EQ.IFODOQ)  THEN
              CALL UCOPY(Q(KQS+LS+I),DWORD,2)
+SELF,IF=QMCRY,QMCDC.
              WRITE(CDWORD,'(D36.29)') DWORD
              WRITE(CQLINE(INLINE:INLINE+19),'('' D('',A)') CDWORD(:17)
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CDWORD,'(D20.13)') DWORD
              WRITE(CQLINE(INLINE:INLINE+11),'('' D('',A)') CDWORD(:9)
+SELF.
              IDBLE  = 1
          ELSE
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(''  Z '',Z16)') IWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(''  Z '',Z8)')  IWORD
+SELF.
          ENDIF
          NWPRNT = NWPRNT + 1
 
+SELF,IF=QMCRY,QMCDC.
          IF (MOD(NWPRNT,6).EQ.0)  THEN
+SELF,IF=-QMCRY,IF=-QMCDC.
          IF (MOD(NWPRNT,10).EQ.0)  THEN
+SELF.
              IF (IFLOPT(MPOSQQ).NE.0)                    GO TO 999
              CALL DZTEXT(0,CDUMMQ,1)
              WRITE (CQLINE,'(1X,I7,'' /'',120X)') NWPRNT+IFIRST
              INLINE =11
          ELSE
+SELF,IF=QMCRY,QMCDC.
              INLINE = INLINE + 20
+SELF,IF=-QMCRY,IF=-QMCDC.
              INLINE = INLINE + 12
+SELF.
          ENDIF
 
  100 CONTINUE
 
 
      JDATA = JDATA + NWSEC
 
      IF (JDATA.GE.ILAST)                                  GO TO 900
 
      IF (JDATA.LT.ILAST)   THEN
          JFOCUR = JFOCUR + 2
          IF (JFOCUR.LT.JFOEND)                            GO TO 10
          JFOCUR = JFOREP
                                                           GO TO 10
      ENDIF
 
 
  900 IF (INLINE.NE.11.AND.IFLOPT(MPOSQQ).EQ.0) CALL DZTEXT(0,CDUMMQ,1)
 
  999 CQSTAK(MCQSIQ:) = CHSTAK
      END
 
+DECK,dzdpsc.
*CMZ :  1.30/00 14/02/96  21.04.12  by  Pavel Nevski
*-- Author :    Otto Schaile  14/02/96
******************************************************************************
*                                                                            *
      SUBROUTINE DZDPSC(ISTORE,LEV,CF)
*                                                                            *
* draw bank tree below LEV in store ISTORE in PostScript format into file CF *
******************************************************************************
      INTEGER LEV
      INTEGER LUNTRE, IRET
      PARAMETER (LUNTRE=65)
      CHARACTER*(*) CF
      CALL KUOPEN(LUNTRE,CF,'UNKNOWN',IRET)
      CALL IOPWK(2,LUNTRE,-111)
      CALL IDAWK(1)
      CALL IACWK(2)
      CALL RZCDIR('//RZDOC',' ')
      CALL DZDDTR(ISTORE,LEV,0,0,0,2,-111,'MPR')
      CALL IUWK(0,1)
      CALL IDAWK(2)
      CALL IACWK(1)
      CALL ICLWK(2)
      END
 
+DECK,dzdhtm.
*CMZ :  1.30/00 28/05/96  23.54.26  by  Unknown
*-- Author :    Otto Schaile   14/02/96
*******************************************************************
*                                                                 *
      SUBROUTINE DZDHTM(ISTORE,L,CFLAG)
*                                                                 *
*     walk through a d/s at L and write doc in html               *
*     CFLAG  'S' one bank only                                    *
*            'T' bank tree (default)                              *
*            'N' no data words                                    *
*            'P' plain text (no hyperlinks)                       *
*                                                                 *
*******************************************************************
C+SEQ,ZUNIT.
+SEQ,ZEBQ
+SEQ,MZCA
+SEQ,MZCB
C++CDE,ZBCDK.         From DZEBRA
C++SEQ,DZDPRM
C++SEQ,DZDOCC.
      CHARACTER*(*) CFLAG
      CHARACTER*16 CLTOP
      INTEGER L,LN,LGO,LRET,LDOWN, IFC,ILC, IHNONE, LUN
      PARAMETER (LUN=65)
      CHARACTER*8 ANCHOR
      CHARACTER*80 CGET
      CHARACTER*4 CLINK
      CHARACTER*5 CSUFFI
      CHARACTER*16 CLDOWN
      CHARACTER*16 DZE2US
      INTEGER KEYVEC(2)
*---
      CALL MZSDIV(ISTORE,-7)
      CALL UCTOH('NONE',IHNONE,4,4)
      IF(INDEX(CFLAG,'P').EQ. 0)THEN
         CSUFFI='.html'
      ELSE
         CSUFFI='.txt'
      ENDIF
      WRITE(CLTOP,'(A4,I7.7,A)')IQ(KQS+L-4),L,CSUFFI
      CLTOP=DZE2US(CLTOP)
      OPEN(LUN,FILE=CLTOP,STATUS='UNKNOWN')
*      CALL KUOPEN(LUN,CLTOP,'UNKNOWN',IRET)
      IF(LQ(KQS+L+1).EQ.0)THEN
         CLTOP=' '
      ELSE
         WRITE(CLTOP,'(A4,I7.7,A)')
     +   IQ(KQS+LQ(KQS+L+1)-4),LQ(KQS+L+1),CSUFFI
         CLTOP=DZE2US(CLTOP)
      ENDIF
      IF(INDEX(CFLAG,'P').EQ. 0)THEN
         WRITE(LUN,'(A)')'<html>'
         WRITE(LUN,'(A)')'<head>'
         WRITE(LUN,'(A)')'<body>'
         WRITE(LUN,'(A)')'<isindex>'
         WRITE(LUN,'(A)')'</head>'
         WRITE(LUN,'(A)')'<body>'
         WRITE(LUN,'(A)')'<pre>'
         ENDIF
      LRET=-L
 20   CONTINUE
      LGO=LRET
      CALL DZDWTR(ISTORE,LGO,LRET)
      IF(LRET.NE.0)THEN
*         WRITE(*,'(A,A4,I10)')'Found ',IQ(KQS+LRET-4),LRET
         KEYVEC(1)=IQ(KQS+LRET-4)
         IF(LQ(KQS+LRET+1).GT.1)THEN
            KEYVEC(2)=IQ(KQS+LQ(KQS+LRET+1)-4)
         ELSE
            KEYVEC(2)=IHNONE
         ENDIF
         I1000=100000
         LQBKD=0
         CALL RZIN(0,LQBKD,2,KEYVEC,I1000,'D')
         IF (LQBKD .EQ. 0)THEN
            NLT = 0
            NLU = 0
            WRITE(*,'(A,A4)')'No doc for bank ',KEYVEC(1)
         ELSE
            IP0=KQSP+LQBKD+1
 
            CALL DZDGGI(IQ(IP0),'CL',' ',CGET,IFC,ILC)
            WRITE(ANCHOR,'(I8.8)')LRET
            IF(INDEX(CFLAG,'P').EQ. 0)
     +      WRITE(LUN,'(A)')'<a name="L'//ANCHOR//'"><b>'
            IF(ILC.GT.0)WRITE(LUN,'(A)')
     +      'Bank IDH '//CGET(1:4)//' '//CGET(5:ILC)
            IF(INDEX(CFLAG,'P').EQ. 0)
     +      WRITE(LUN,'(A)')'</b></a>'
            CALL DZDGGI(IQ(IP0),'AU',' ',CGET,IFC,ILC)
            IF(ILC.GT.0)WRITE(LUN,'(A,A,A)')'Author(s) ',CGET(IFC:ILC)
            CALL DZDGGI(IQ(IP0),'VE',' ',CGET,IFC,ILC)
            IF(ILC.GT.0)WRITE(LUN,'(A,A,A)')'Version  ',CGET(IFC:ILC)
            NID=IQ(KQS+LRET-5)
            WRITE(LUN,'(A,I6)')'NumId     ',NID
            NL=IQ(KQS+LRET-3)
            NS=IQ(KQS+LRET-2)
            WRITE(LUN,'(A,I6)')'Str Links ',NS
            NR=NL-NS
            WRITE(LUN,'(A,I6)')'Ref Links ',NR
            ND=IQ(KQS+LRET-1)
            WRITE(LUN,'(A,I6)')'NData     ',ND
            NIO = JBYT(IQ(KQS+LRET),19,4)
            IOFFBS = - (NIO + NL + 8 + 1)
            CALL DZDIOC(IQ(KQS+LRET+IOFFBS),CGET,ILC)
            IF(ILC.GT.0)WRITE(LUN,'(A,A,A)')'IO-Char   ',CGET(1:ILC)
 
            WRITE(LUN,'(A)')'----------  System links ----------'
            CALL UHTOC(KEYVEC(2),4,CLINK,4)
            IF(CLINK.NE.'NONE')THEN
               IF(INDEX(CFLAG,'P').EQ. 0)THEN
                  WRITE(ANCHOR,'(I8.8)')LQ(KQS+LRET+1)
*                 is it very first bank
                  IF(LRET.EQ.L)THEN
                     NCH=LNBLNK(CLTOP)
                     WRITE(LUN,'(A,A)')'Up-Link   '//
     +               '<a href="'//CLTOP(1:NCH)//'#L'//ANCHOR//'"><b>'//
     +               CLINK//'</b></a>'
                  ELSE
                     WRITE(LUN,'(A,A)')'Up-Link   '//
     +               '<a href="#L'//ANCHOR//'"><b>'//
     +               CLINK//'</b></a>'
 
                  ENDIF
               ELSE
                  WRITE(LUN,'(A,A)')'Up-Link   '//CLINK
               ENDIF
*              handle Origin link eventually
            ELSE
               WRITE(LUN,'(A,A)')'Up-Link   '//CLINK
            ENDIF
            LN=LQ(KQS+LRET)
            IF(LN.NE.0)THEN
               CALL UHTOC(IQ(KQS+LN-4),4,CLINK,4)
               IF(INDEX(CFLAG,'P').EQ. 0)THEN
                  WRITE(ANCHOR,'(I8.8)')LN
                  WRITE(LUN,'(A,A)')'Next-Link '//
     +            '<a href="#L'//ANCHOR//'"><b>'//
     +            CLINK//'</b></a>'
               ELSE
                   WRITE(LUN,'(A,A)')'Next-Link '//CLINK
               ENDIF
            ENDIF
            IF(NS.GT.0)THEN
               WRITE(LUN,'(A)')'--------- Struct links ----------'
               DO I=1,NS
                  LDOWN=LQ(KQS+LRET-I)
                  IF(LDOWN.NE.0)THEN
                     CALL UHTOC(IQ(KQS+LDOWN-4),4,CLINK,4)
                     CALL DZDGGI(IQ(IP0),'LI',CLINK,CGET,IFC,ILC)
                     IF(INDEX(CFLAG,'P').EQ. 0)THEN
                        WRITE(ANCHOR,'(I8.8)')LDOWN
                        IF(INDEX(CFLAG,'S').NE.0)THEN
                           WRITE(CLDOWN,'(A4,I7.7,A5)')
     +                     CLINK,LDOWN,'.html'
                           CLDOWN=DZE2US(CLDOWN)
                           WRITE(LUN,'(I6,A)')I,
     +                     ' <a href="'//CLDOWN//'#L'//
     +                     ANCHOR//'"><b>'//
     +                     CLINK//'</b></a> '//CGET(1:ILC)
                        ELSE
                           WRITE(LUN,'(I6,A)')I,
     +                     ' <a href="#L'//
     +                     ANCHOR//'"><b>'//
     +                     CLINK//'</b></a> '//CGET(1:ILC)
                        ENDIF
                     ELSE
                        WRITE(LUN,'(I6,A)')I,CLINK//' '//CGET(1:ILC)
                     ENDIF
                  ENDIF
               ENDDO
            ENDIF
            IF(ND.GT.0 .AND. INDEX(CFLAG,'N').EQ. 0)THEN
               CALL DZDDWD(ISTORE,LRET,' ',1,ND,LUN)
            ENDIF
            CALL MZDROP(0,LQBKD,' ')
            LQBKD=0
         ENDIF
         IF(INDEX(CFLAG,'S').EQ.0)GOTO 20
      ENDIF
      IF(INDEX(CFLAG,'P').EQ. 0)THEN
         WRITE(LUN,'(A)')'</pre>'
         WRITE(LUN,'(A)')'</body>'
         WRITE(LUN,'(A)')'</html>'
      ENDIF
  999 CONTINUE
      RETURN
      END
 
 
+DECK,dzdwtr.
*CMZ :  1.30/00 14/02/96  21.11.15  by  Pavel Nevski
*-- Author :    Otto Schaile   14/02/96
**************************************************************************
*                                                                        *
       SUBROUTINE DZDWTR(ISTORE,L,LRET)
*                                                                        *
*     walk through a d/s at L, return link to the next bank in LRET      *
**************************************************************************
+SEQ,ZEBQ
+SEQ,MZCA
+SEQ,MZCB
      INTEGER L,LIN,LRET,JB
      INTEGER LORIG, LUP, LFROM
      SAVE    LORIG, LUP, LFROM
*---
      CALL MZSDIV(ISTORE,-7)
*     init links and return
      IF(L.LT.0)THEN
         LRET=-L
         LORIG = LRET
         LUP = LRET
         LFROM = LQ(KQS+LRET+1)
         GOTO 90
      ENDIF
*
      LIN=L
      JB = LUP - LORIG + 1
   10 CONTINUE
      NS = IQ(KQS+LUP -2)
      IF(JB .LE. NS)THEN
*        go down
         LD1 = LQ(KQS+ LIN - JB)
*        look if this link is used
         IF(LD1 .EQ. 0)THEN
            JB = JB + 1
            GOTO 10
         ENDIF
         LUP = LD1
         LORIG = LD1
         LRET = LD1
         GOTO 90
      ENDIF
 
*     look if its part of linear structure
 
      LN = LQ(KQS+LIN)
      IF(LN .NE. 0)THEN
         LUP = LN
         LORIG = LN
         LRET = LN
         GOTO 90
      ENDIF
 
*     look if it is end of a linear structure
*     i.e. origin and up link are in different banks
 
   50 CONTINUE
      LUP = LQ(KQS+LIN+1)
      LORIG = LQ(KQS+LIN+2)
*     look if back at top bank or if it would move above top bank
      IF(LUP .LE. 1 .OR. LUP .EQ. LFROM) THEN
         LRET=0
         GOTO 99
      ENDIF
      NSU = IQ(KQS+LUP-2)
      IF(LORIG .GE. LUP .OR. LORIG .LT. LUP-NSU)THEN
*        its different, step back
         LIN = LORIG
         GOTO 50
      ENDIF
*     go up
      LRET = LUP
   90 CONTINUE
      JB = LUP - LORIG + 1
      IF(JB.NE.1) THEN
         LIN=LRET
         GOTO 10
      ENDIF
   99 CONTINUE
      END
+DECK, ZFATAL.
*CMZ :  1.30/00 01/04/97  18.15.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   16/03/97
      SUBROUTINE ZFATAL
 
C-    FATAL PROGRAM TERMINATION
 
+CDE, ZMACH, ZSTATE, ZUNIT, MQSYS.
C--------------    END CDE                             --------------
+SEQ, ZFATALCH.
+SEQ, ZFATALRE.
 
      IF (NQERR.GT.0)              GO TO 71
      NQERR = NQERR+1
      LUN   = IQTYPE
      IF (LUN.NE.0)                GO TO 22
 
   21 LUN  = IQLOG
   22 IF (NQTRAC.EQ.0)             GO TO 31
 
C----              PRINT ZEBRA TRACE-BACK
 
+SELF, IF=QPRINT, IF=-QTRHOLL, A6M.
      JT = NQTRAC - 1
      WRITE (LUN,9024) MQTRAC(JT+1)
 9024 FORMAT (1X/' !!!!! ZFATAL called from ',A6)
      GO TO 28
 
   25 WRITE (LUN,9025) MQTRAC(JT+1)
 9025 FORMAT (14X,'called from ',A6)
   28 JT = JT - 1
+SELF, IF=QPRINT, IF=QTRHOLL, IF=-A6M.
      JT = NQTRAC - 2
      WRITE (LUN,9024) MQTRAC(JT+1),MQTRAC(JT+2)
 9024 FORMAT (1X/' !!!!! ZFATAL called from ',2A4)
      GO TO 28
 
   25 WRITE (LUN,9025) MQTRAC(JT+1),MQTRAC(JT+2)
 9025 FORMAT (14X,'called from ',2A4)
   28 JT = JT - 2
+SELF, IF=QPRINT.
      IF (JT.GE.0)                 GO TO 25
      IF (NQFATA.EQ.0)             GO TO 49
      GO TO 41
+SELF.
 
C--                EXTERNAL CALL TO ZFATAL
 
   31 IF (NQFATA.NE.0)             GO TO 41
+SELF, IF=QPRINT.
      WRITE (LUN,9031)
 9031 FORMAT (1X/' !!!!! ZFATAL reached.')
+SELF.
      GO TO 49
 
C--                ZEBRA INTERNAL CALL TO ZFATAL
 
   41 CONTINUE
+SELF, IF=QPRINT, IF=QTRHOLL, IF=A6M.
      WRITE (LUN,9041) IQUEST(10),NQCASE
 9041 FORMAT (1X/' !!!!! ZFATAL reached from ',A6,'  for Case=',I3/1X)
+SELF, IF=QPRINT, IF=QTRHOLL, IF=-A6M.
      WRITE (LUN,9041) IQUEST(9),IQUEST(10),NQCASE
 9041 FORMAT (1X/' !!!!! ZFATAL reached from ',2A4,'  for Case=',I3/1X)
+SELF, IF=QPRINT, IF=-QTRHOLL.
      WRITE (LUN,9041) IQUEST(9),IQUEST(10),NQCASE
 9041 FORMAT (1X/' !!!!! ZFATAL reached from ',2A4,'  for Case=',I3/1X)
+SELF, IF=QPRINT.
 
      JPOS = IQBITW - 7
 
      DO 47  JW=11,10+NQFATA
      IT = IQUEST(JW)
      J  = JBYT (IT,JPOS,8)
      IF (J.EQ.0)                  GO TO 44
      IF (J.EQ.255)                GO TO 44
 
      WRITE (LUN,9043,ERR=47)  JW,IT,IT,IT
      GO TO 47
 
   44 WRITE (LUN,9044,ERR=47)  JW,IT,IT
+SELF, IF=QPRINT, IF=-HEX.
 9043 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,O22,1X,A6)
 9044 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,O22)
+SELF, IF=QPRINT, IF=HEX.
 9043 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,Z16,1X,A6)
 9044 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,Z16)
+SELF.
   47 CONTINUE
 
   49 WRITE (LUN,9049) JQSTOR,JQDIVI
 9049 FORMAT (1X/10X,'Current Store number =',I3,'  (JQDIVI=',I2,')')
 
      IF (IQVID(2).EQ.0)           GO TO 59
 
      WRITE (LUN,9051) IQVID
      WRITE (LUN,9052) (J,IQVREM(1,J),IQVREM(2,J),J=1,6)
 
 9051 FORMAT (1X/10X,'Automatic Verification Identifiers :'
     F/10X,'Current :',2X,2I11)
 9052 FORMAT (10X,'Stacked, J =',I2,' :',I6,I11,5(/22X,I2,' :',I6,I11))
 
   59 IF (LUN.NE.IQLOG)            GO TO 21
 
*PN: trying to do something, at least provide an extended diagnostoc
      CALL ZABEND (NQCASE,LQSYSR(KQT+1))
*     print *,' ==> NQCASE,NQERR after ZABEND =',NQCASE,NQERR
      IF (NQCASE.EQ.0) RETURN
*
      NQCASE = 0
      NQFATA = 0
 
 
C----              RECOVERY LOOP
 
   71 NQERR = NQERR + 1
      IF (NQERR.GE.4)              GO TO 79
      WRITE (IQLOG,9071)
      IF (IQTYPE.EQ.0)             GO TO 79
      IF (IQTYPE.EQ.IQLOG)         GO TO 79
      WRITE (IQTYPE,9071)
 9071 FORMAT (1X/' !!!!! break for re-entry to ZFATAL !!!!!')
   79 CONTINUE
*
* PN: regain control as in arithmetic trap
      CALL TRACEQ
+SELF, QTOABEND.
      CALL ABEND
+SELF.
* PN: never reached, for reference only
      CALL ZPHASE(0)
      END
 
+DECK,RZINK
*CMZ :  1.30/00 15/04/97  17.42.11  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZINK(KEYU,ICYCLE,CHOPT)
*
************************************************************************
*
*         To find and decode KEYU,ICYCLE
* Input:
*   KEYU    Keyword vector of the information to be read
*   ICYCLE  Cycle number of the key to be read
*           ICYCLE > highest cycle number means read the highest cycle
*           ICYCLE = 0 means read the lowest cycle
*   CHOPT   Character variable specifying the options selected.
*           data structure
*             default
*                   Same as 'D' below
*             'A'   Read continuation of the previously read data structure
*                   with identifier KEYU,ICYCLE
*                   Given that option implies that the record was written with
*                   the same option by a call to RZOUT.
*             'C'   Provide   information   about   the   cycle   numbers
*                   associated with KEY.
*                   The  total number  of  cycles  and the  cycle  number
*                   identifiers of the 19 highest  cycles are returned in
*                   IQUEST(50) and IQUEST(51..89) respectively
*             'D'   Read the  Data structure  with the  (key,cycle)  pair
*                   specified.
*             'N'   Read the neighbouring. keys (i.e. those preceding and
*                   following KEY).
*                   The  key-vectors of  the previous  and  next key  are
*                   available   respectively   as   IQUEST(31..35)    and
*                   IQUEST(41..45), see below.
*             'R'   Read data into existing bank at LSUP,JBIAS
*             'S'   KEYU(1) contains the key serial number
*                   IQUEST(20)= serial number of the key in directory
*                   IQUEST(21..20+NWKEY)=KEY(1....NWKEY)
*
* Called by RZIN,RZVIN
*
*  Author  : R.Brun DD/US/PD
*  Written : 09.05.86
*  Last mod: 11.09.89
*          : 04.03.94 S.Banerjee (Change in cycle structure)
*          : 15.04.97 P.Nevski   accept both selection KEY versions
************************************************************************
+SEQ,RZCL,RZCLUN,RZCOUT,RZK,RZCKEY,RZCYCLE.
      CHARACTER*(*) CHOPT
      DIMENSION KEYU(*)
      EQUIVALENCE (IOPTA,IQUEST(91)), (IOPTC,IQUEST(92))
     +,    (IOPTD,IQUEST(93)), (IOPTN,IQUEST(94)), (IOPTR,IQUEST(95))
     +,    (IOPTS,IQUEST(96))
*
*-----------------------------------------------------------------------
*
+SEQ,Q$JBIT.
*
      IQUEST(1)=0
      CALL UOPTC(CHOPT,'ACDNRS',IQUEST(91))
*
*           Search KEY and CYCLE
*
      LK=IQ(KQSP+LCDIR+KLK)
      NKEYS=IQ(KQSP+LCDIR+KNKEYS)
      NWKEY=IQ(KQSP+LCDIR+KNWKEY)
      IQUEST(7)=NKEYS
      IQUEST(8)=NWKEY
      IF(NKEYS.EQ.0)GO TO 90
*
      IF(IOPTS.NE.0)THEN
         IK1=KEYU(1)
         IK2=IK1
         IF(IK1.GT.NKEYS.OR.IK1.LE.0)THEN
            IQUEST(1)=1
            IQUEST(2)=IK1
            RETURN
         ENDIF
      ELSE
         IK1=1
         IK2=NKEYS
         DO 5 I=1,NWKEY
            IKDES=(I-1)/10
            IKBIT1=3*I-30*IKDES-2
            IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).LT.3)THEN
               KEY(I)=KEYU(I)
            ELSE
               CALL ZHTOI(KEYU(I),KEY(I),1)
            ENDIF
   5     CONTINUE
      ENDIF
      DO 30 I=IK1,IK2
         LKC=LK+(NWKEY+1)*(I-1)
         IF(IOPTS.EQ.0)THEN
            DO 10 K=1,NWKEY
               IF(IQ(KQSP+LCDIR+LKC+K).NE.KEY(K))GO TO 30
  10        CONTINUE
         ELSE
            DO 15 K=1,NWKEY
               IF(K.LT.10)THEN
                  IKDES=(K-1)/10
                  IKBIT1=3*K-30*IKDES-2
                  IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).LT.3)THEN
                     IQUEST(20+K)=IQ(KQSP+LCDIR+LKC+K)
                  ELSE
                     CALL ZITOH(IQ(KQSP+LCDIR+LKC+K),IQUEST(20+K),1)
                  ENDIF
               ENDIF
  15        CONTINUE
         ENDIF
         IQUEST(20)=I
         LCYC=IQ(KQSP+LCDIR+LKC)
         IF (KVSCYC.NE.0) THEN
            II=I
            IF (IQUEST(99).GE.96) II=IQ(KQSP+LCDIR+LKC+1)
            IF (IQ(KQSP+LCDIR+LCYC+KKYCYC).NE.II) THEN
               IQUEST(1) = 11
               GO TO 99
            ENDIF
         ENDIF
         NC=0
  20     NC=NC+1
         ICY = JBYT(IQ(KQSP+LCDIR+LCYC+KCNCYC),21,12)
         IF(ICY.EQ.ICYCLE)GO TO 50
         IF(NC.EQ.1.AND.ICYCLE.GT.ICY)GO TO 50
         IF (KVSCYC.EQ.0) THEN
            LCOLD = JBYT(IQ(KQSP+LCDIR+LCYC+KPPCYC),1,16)
         ELSE
            LCOLD = IQ(KQSP+LCDIR+LCYC+KPPCYC)
         ENDIF
         IF(LCOLD.EQ.0.AND.LCOLD.NE.LCYC.AND.ICYCLE.EQ.0)GO TO 50
         LCYC=LCOLD
         IF(LCYC.NE.0)GO TO 20
         GO TO 90
  30  CONTINUE
      GO TO 90
*
*           Cycle has been found
*           Read record descriptor
*
  50  IF (KVSCYC.EQ.0) THEN
         IR1   = JBYT(IQ(KQSP+LCDIR+LCYC+KFRCYC),17,16)
         IR2   = JBYT(IQ(KQSP+LCDIR+LCYC+KSRCYC),17,16)
         IP1   = JBYT(IQ(KQSP+LCDIR+LCYC+KORCYC), 1,16)
         NW    = JBYT(IQ(KQSP+LCDIR+LCYC+KNWCYC), 1,20)
      ELSE
         IR1   = IQ(KQSP+LCDIR+LCYC+KFRCYC)
         IR2   = IQ(KQSP+LCDIR+LCYC+KSRCYC)
         IP1   = JBYT(IQ(KQSP+LCDIR+LCYC+KORCYC), 1,20)
         NW    = IQ(KQSP+LCDIR+LCYC+KNWCYC)
      ENDIF
      N1    = NW
      IQUEST(2)=1
      IF(IR2.NE.0)IQUEST(2)=(NW-N1-1)/LREC+2
      IQUEST(3)=IR1
      IQUEST(4)=IP1
      IQUEST(5)=IR2
      IQUEST(6)=ICY
      IQUEST(12)=NW
      IQUEST(14)=IQ(KQSP+LCDIR+LCYC+1)
      IQUEST(15)=LCYC
C
C           C option given
C
      IF(IOPTC.NE.0)THEN
         IQUEST(50)=0
         LC1=LCYC
  51     IQUEST(50)=IQUEST(50)+1
         IF (KVSCYC.EQ.0) THEN
            LCOLD = JBYT(IQ(KQSP+LCDIR+LC1+KPPCYC),1,16)
         ELSE
            LCOLD = IQ(KQSP+LCDIR+LC1+KPPCYC)
         ENDIF
         IF(IQUEST(50).LE.19)THEN
            NC=IQUEST(50)
            IQUEST(50+NC)=JBYT(IQ(KQSP+LCDIR+LC1+KCNCYC),21,12)
            IQUEST(70+NC)=IQ(KQSP+LCDIR+LC1+KFLCYC)
         ENDIF
         IF(LCOLD.NE.0.AND.LCOLD.NE.LC1)THEN
            LC1=LCOLD
            GO TO 51
         ENDIF
      ENDIF
C
C           N option given. return neighbours
C
      IF(IOPTN.NE.0)THEN
         IF(I.EQ.1)THEN
            IQUEST(30)=0
         ELSE
            IQUEST(30)=NWKEY
            DO 52 J=1,NWKEY
               IF(J.LT.10)THEN
                  LKCJ=LK+(NWKEY+1)*(I-2)
                  IQUEST(30+J)=IQ(KQSP+LCDIR+LKCJ+J)
                  IKDES=(J-1)/10
                  IKBIT1=3*J-30*IKDES-2
                  IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).GE.3)THEN
                     CALL ZITOH(IQUEST(30+J),IQUEST(30+J),1)
                  ENDIF
               ENDIF
  52        CONTINUE
         ENDIF
         IF(I.EQ.NKEYS)THEN
            IQUEST(40)=0
         ELSE
            IQUEST(40)=NWKEY
            DO 53 J=1,NWKEY
               IF(J.LT.10)THEN
                  LKCJ=LK+(NWKEY+1)*I
                  IQUEST(40+J)=IQ(KQSP+LCDIR+LKCJ+J)
                  IKDES=(J-1)/10
                  IKBIT1=3*J-30*IKDES-2
                  IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).GE.3)THEN
                     CALL ZITOH(IQUEST(40+J),IQUEST(40+J),1)
                  ENDIF
               ENDIF
  53        CONTINUE
         ENDIF
      ENDIF
      GO TO 99
*
*           Error
*
  90  IQUEST(1)=1
      IF(IOPTN.NE.0)THEN
         IF(NKEYS.GT.0)THEN
            IQUEST(30)=NWKEY
            IQUEST(40)=NWKEY
            DO 91 J=1,NWKEY
               IF(J.GE.10)GO TO 91
               LKCJ=LK+(NWKEY+1)*(NKEYS-1)
               IQUEST(30+J)=IQ(KQSP+LCDIR+LK+J)
               IQUEST(40+J)=IQ(KQSP+LCDIR+LKCJ+J)
               IKDES=(J-1)/10
               IKBIT1=3*J-30*IKDES-2
               IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).GE.3)THEN
                  CALL ZITOH(IQUEST(30+J),IQUEST(30+J),1)
                  CALL ZITOH(IQUEST(40+J),IQUEST(40+J),1)
               ENDIF
  91        CONTINUE
         ENDIF
      ENDIF
*
  99  RETURN
      END
+DECK, MZPUSH.
*CMZ :  1.30/00 18/03/97  19.04.33  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZPUSH (IXDIV,LORGP,INCNLP,INCNDP,CHOPT)
 
C-    Change the size of a bank, user called
 
+CDE, ZBCD, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCL, MZCN, MZCT.
C--------------    End CDE                             --------------
      DIMENSION    IXDIV(9),LORGP(9),INCNLP(9),INCNDP(9)
      CHARACTER    *(*) CHOPT
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZPU, 4HSH   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZPUSH /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZPUSH  ')
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT, Q$SBYT.
 
+SEQ, QTRACE.
 
      IF (IXDIV(1).EQ.-7)          GO TO 12
      CALL MZSDIV (IXDIV,0)
 
   12 CALL MZCHNB (LORGP)
      LORG  = LORGP(1)
      INCNL = INCNLP(1)
      INCND = INCNDP(1)
 
      CALL UOPTC (CHOPT,'RI',IQUEST)
      IFLAG = MIN (2, IQUEST(1)+2*IQUEST(2))
 
C-         IFLAG = 0  general
C-                 1  R-educe
C-                 2  I-solated
 
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.NE.0)
     +WRITE (IQLOG,9809) LORG,INCNL,INCND,IFLAG
 9809 FORMAT (1X/' DEVZE MZPUSH,  Entry for LORG,INCNL,INCND,IFLAG= '
     F,5I8)
+SELF, IF=QDEBUG.
      IF (IQVSTA.NE.0)       CALL ZVAUTX
+SELF.
      IF ((INCNL.EQ.0) .AND. (INCND.EQ.0))  GO TO 999
      LQSYSR(KQT+1) = LORG
 
C--                Find division
 
      JQDIVI = MZFDIV (-7, LORG)
      IF (JQDIVI.EQ.0)             GO TO 91
 
C--                Set bank parameters
 
+SELF,             IF=QDEBUG.
      CALL MZCHLS (-7,LORG)
      IF (IQFOUL.NE.0)             GO TO 91
      NL    = IQNL
      NS    = IQNS
      ND    = IQND
      NQNIO = IQNIO
      NQID  = IQID
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9831) JQDIVI,IQLS,IQID,IQNL,IQNS,IQND
 9831 FORMAT (16X,'JQDIVI,IQLS,IQID,IQNL,IQNS,IQND=',I3,I7,1X,A4,4I8)
+SELF,             IF=-QDEBUG.
      NQID  = IQ(KQS+LORG-4)
      NL    = IQ(KQS+LORG-3)
      NS    = IQ(KQS+LORG-2)
      ND    = IQ(KQS+LORG-1)
      NQNIO = JBYT (IQ(KQS+LORG),19,4)
+SELF.
      NQNL = NL + INCNL
      NQNS = MIN (NS,NQNL)
      NQND = ND + INCND
      IF (NS.EQ.NL)  NQNS = NQNL
+SELF, IF=QDEBPRI.
      IF (NQLOGL.GE.2)
     + WRITE (IQLOG,9032) JQSTOR,JQDIVI,LORG,NQID,INCNL,INCND,CHOPT
 9032 FORMAT (' MZPUSH-  Store/Div',2I3,' L/ID/INCNL/INCND/OPT=',
     FI9,1X,A4,2I7,1X,A)
+SELF.
      IF (JBIT(IQ(KQS+LORG),IQDROP).NE.0)   GO TO 92
 
C--                Check for bad parameters
 
      IF (NQND+NQNL.GE.LQSTA(KQT+21)) GO TO 93
      IF (NQND.LT.0)               GO TO 93
      IF (NQNL.GT.64000)           GO TO 93
      IF (NQNS.LT.0)               GO TO 93
 
      NLC = MIN (NL,NQNL)
      NSC = MIN (NS,NQNS)
      NDC = MIN (ND,NQND)
 
C--                Check giving up non-zero structural links
 
      IF (NQNS.GE.NS)              GO TO 36
      L  = LORG - NS - 1
      LD = LORG - NQNS
   34 L  = L + 1
      IF (L.GE.LD)                 GO TO 36
      LNZ = LQ(KQS+L)
   35 IF (LNZ.EQ.0)                GO TO 34
      IF (LQ(KQS+LNZ+2).NE.L)         GO TO 34
      IF (JBIT(IQ(KQS+LNZ),IQDROP).EQ.0)   GO TO 94
      LNZ = LQ(KQS+LNZ)
      GO TO 35
 
C--                Ready I/O characteristic
 
   36 LN = LORG - NL - NQNIO - 1
      CALL UCOPY (LQ(KQS+LN),NQIOCH,NQNIO+1)
      IF (NQNIO.NE.0)  NQIOSV(1)=0
      NQIOCH(1) = MSBYT (NQNL+NQNIO+12,NQIOCH(1),1,16)
 
C--                Re-enter after garbage collection, if any
 
   41 LE = LORG + ND + 9
 
C------            Check for short-cuts
 
      INCTT = INCNL + INCND
      INCMX = MAX (INCNL,INCND)
      INCMI = MIN (INCNL,INCND)
      CALL MZRESV
      IF (JQMODE.NE.0)             GO TO 45
 
C--                Last bank in forward division
 
      IF (LE.NE.LQEND(KQT+JQDIVI))    GO TO 51
      IF (INCNL.GE.0)              GO TO 42
      IF (IFLAG.NE.1)              GO TO 42
      IF ((NQRESV.GE.INCTT).AND.(NQRESV.LT.INCND))  GO TO 42
 
      LNN = LN - INCNL
      CALL UCOPY (NQIOCH,LQ(KQS+LNN),NQNIO+1)
      IQ(KQS+LORG-3) = NQNL
      IQ(KQS+LORG-2) = NQNS
 
      NWD = -INCNL
      CALL MZPUDX (LN,NWD)
      INCNL = 0
      INCTT = INCND
      LN    = LNN
      NL    = NQNL
 
   42 NQRESV = NQRESV - INCTT
      IF (NQRESV.LT.0)             GO TO 49
      NDELTA = INCNL
      LNEW   = LORG + NDELTA
      LQEND(KQT+JQDIVI) = LQEND(KQT+JQDIVI) + INCTT
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)  WRITE (IQLOG,9848) NDELTA,LNEW
+SELF.
      IF (NDELTA.EQ.0)  THEN
          IQ(KQS+LNEW-1) = NQND
          IF (IFLAG.NE.0)          GO TO 81
          IF (INCMI.GE.0)          GO TO 81
          GO TO 71
        ELSE
          CALL UCOPY2 (LQ(KQS+LORG-NLC),LQ(KQS+LNEW-NLC),NLC+NDC+9)
          IF (INCNL.GT.0)  CALL VZERO (LQ(KQS+LNEW-NQNL),INCNL)
          LQ(KQS+LN)     = NQIOCH(1)
          IQ(KQS+LNEW-3) = NQNL
          IQ(KQS+LNEW-2) = NQNS
          IQ(KQS+LNEW-1) = NQND
          GO TO 61
        ENDIF
 
C--                First bank in reverse division
 
   45 IF (LN.NE.LQSTA(KQT+JQDIVI))    GO TO 51
      IF (INCND.GE.0)              GO TO 47
      IF (IFLAG.NE.1)              GO TO 47
      IF ((NQRESV.GE.INCTT).AND.(NQRESV.LT.INCNL))  GO TO 47
      IQ(KQS+LORG-1) = NQND
 
      L   = LE + INCND
      NWD = -INCND
      CALL MZPUDX (L,NWD)
      INCND = 0
      INCTT = INCNL
      ND    = NQND
 
   47 NQRESV = NQRESV - INCTT
      IF (NQRESV.LT.0)             GO TO 49
      LNN    = LN - INCTT
      NDELTA = -INCND
      LQSTA(KQT+JQDIVI) = LNN
 
      LNEW  = LORG + NDELTA
 
      IF (NDELTA.NE.0)  CALL UCOPY2 (LQ(KQS+LORG-NLC)
     +,                              LQ(KQS+LNEW-NLC), NLC+NDC+9)
 
      IF (INCNL.GT.0)  CALL VZERO (LQ(KQS+LNEW-NQNL),INCNL)
      CALL UCOPY (NQIOCH,LQ(KQS+LNN),NQNIO+1)
 
      IQ(KQS+LNEW-3) = NQNL
      IQ(KQS+LNEW-2) = NQNS
      IQ(KQS+LNEW-1) = NQND
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)  WRITE (IQLOG,9848) NDELTA,LNEW
 9848 FORMAT (' DEVZE MZPUSH,  Edge bank with NDELTA,LNEW=',2I8)
+SELF.
 
      IF (NDELTA.NE.0)             GO TO 61
      IF (IFLAG.NE.0)              GO TO 81
      IF (INCMI.GE.0)              GO TO 81
      GO TO 71
 
C--                Garbage collection
*     IQUEST(1)=0
   49 CALL MZGAR1
      IF (IQUEST(1).EQ.0 .and. IQUEST(11).LT.0) then
         print *,' ***** error in mzpush after mzgar1, iquest(1,11)=',
     >            iquest(1),iquest(11)
         IQUEST(1)=-1
         return
      ENDIF
*
      LORG = LQSYSR(KQT+1)
      LN   = LORG - NL - NQNIO - 1
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9849)
 9849 FORMAT (1X/' DEVZE MZPUSH,  Garbage collected for edge bank')
+SELF.
      GO TO 41
 
C----              Reduction only
 
   51 IF (INCMX.GT.0)              GO TO 56
      IF (INCNL.EQ.0)              GO TO 52
 
C--                Link part
 
      LNN = LN - INCNL
      CALL UCOPY (NQIOCH,LQ(KQS+LNN),NQNIO+1)
      IQ(KQS+LORG-3)= NQNL
      IQ(KQS+LORG-2)= NQNS
 
      CALL MZPUDX (LN,-INCNL)
 
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9851) INCNL
 9851 FORMAT (' DEVZE MZPUSH,  In-situ links with INCNL=',I8)
+SELF.
      IF (INCND.EQ.0)              GO TO 54
 
C--                Data part
 
   52 IQ(KQS+LORG-1) = NQND
      LD  = LE + INCND
      NWD = -INCND
      CALL MZPUDX (LD,NWD)
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9852) INCND
 9852 FORMAT (' DEVZE MZPUSH,  In-situ data with INCND=',I8)
+SELF.
 
   54 LNEW   = LORG
      NDELTA = 0
      IF (IFLAG.NE.0)              GO TO 999
      GO TO 71
 
C------            Lift replacement bank
 
   56 J = 64*(32*NQNIO + NQNIO + 1) + 1
      NQIOCH(1) = MSBYT (J,NQIOCH(1),1,16)
 
      NQBIA = 2
      CALL MZLIFT (-7,LNEW,0,63,NQID,-1)
      LORG   = LQSYSR(KQT+1)
      NDELTA = LNEW - LORG
 
      CALL UCOPY (LQ(KQS+LORG-NLC),LQ(KQS+LNEW-NLC),NLC+4)
      CALL UCOPY (IQ(KQS+LORG),    IQ(KQS+LNEW),    NDC+1)
      IQ(KQS+LORG) = MSBIT1 (IQ(KQS+LORG),IQDROP)
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9857) LORG,LNEW
 9857 FORMAT (' DEVZE MZPUSH,  Push by copy LORG -> LNEW=',2I8)
+SELF.
 
C------            Up-date immediate links only
 
   61 IF (IFLAG.LT.2)              GO TO 71
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9861)
 9861 FORMAT (' DEVZE MZPUSH,  Update immediate links only')
+SELF.
 
C----              Update according to k-link in pushed bank
 
      K = LQ(KQS+LNEW+2)
      IF (K.EQ.0)                  GO TO 62
      IF (LQ(KQS+K).NE.LORG)          GO TO 95
      LQ(KQS+K) = LNEW
 
C----              Update according to link 0
 
   62 K = LNEW
      L = LQ(KQS+K)
      IF (L.EQ.0)                  GO TO 65
      IF (L.EQ.LORG)               GO TO 64
      LQ(KQS+L+2) = K
   63 K = L
      L = LQ(KQS+K)
      IF (L.EQ.0)                  GO TO 65
      IF (L.NE.LORG)               GO TO 63
   64 LQ(KQS+K) = LNEW
 
C----              Update k- and up-link in vertically dependent banks
 
   65 K = LNEW - NSC - 1
 
C--                          each link
   66 K = K + 1
      IF (K.GE.LNEW)               GO TO 81
      L = LQ(KQS+K)
      IF (L.EQ.0)                  GO TO 66
      IF (LQ(KQS+L+2).NE.K-NDELTA)    GO TO 66
      LQ(KQS+L+2) = K
 
C--                          and its linear structure
 
      LF = L
   68 LQ(KQS+L+1) = LNEW
      L = LQ(KQS+L)
      IF (L.EQ.LF)                 GO TO 66
      IF (L.NE.0)                  GO TO 68
      GO TO 66
 
C------            Global update of links
 
   71 MQDVGA = 0
      MQDVWI = 0
      JQSTMV = -1
+SELF, IF=QDEBPRI.
      IF (NQLOGL.GE.1)
     + WRITE (IQLOG,9071) JQSTOR,JQDIVI,LORG,NQID
 9071 FORMAT (' MZPUSH-  Store/Div',2I3,' Relocation pass for L/ID ='
     F,I9,1X,A4)
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9871)
 9871 FORMAT (' DEVZE MZPUSH,  Update by relocation pass')
+SELF.
 
      CALL MZTABM
 
      LMT  = LQMTA - 8
   74 LMT  = LMT + 8
      IF (LQ(LMT).NE.JQDIVI)       GO TO 74
      LQ(LMT+1) = 2
 
      CALL MZTABX
      LQMTE = LQMTLU
 
      LQ(LQTA-1) = LORG - NL - NQNIO - 1
      LQ(LQTA)   = LORG - NLC
      LQ(LQTA+1) = LORG + NDC + 9
      LQ(LQTA+2) = NDELTA
      LQ(LQTA+3) = 0
      LQ(LQTA+4) = LORG + ND + 9
 
      LQTE  = LQTA + 4
 
      CALL MZRELX
 
      NQDPSH(KQT+JQDIVI) = NQDPSH(KQT+JQDIVI) + 1
 
C------            Finished, reset LORG, clear new data words
 
   81 LORGP(1) = LNEW
      IF (INCND.GT.0)  CALL VZERO (IQ(KQS+LNEW+ND+1),INCND)
+SEQ, QTRACE99.
      RETURN
 
C----              Error conditions
 
   95 NQCASE = 3
      NQFATA = 1
      IQUEST(19) = K
      GO TO 92
 
   94 NQCASE = 1
      NQFATA = 2
      IQUEST(19) = L - LORG
      IQUEST(20) = LQ(KQS+L)
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 7
      IQUEST(12) = NQID
      IQUEST(13) = NS
      IQUEST(14) = NL
      IQUEST(15) = ND
      IQUEST(16) = NQNIO
      IQUEST(17) = INCNL
      IQUEST(18) = INCND
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 1
      IQUEST(11) = LORG
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK, ZTELL.
*CMZ :          17/10/97  12.42.42  by  Pavel Nevski
*CMZ :  1.30/00 19/03/97  22.28.33  by  Pavel Nevski
*-- Author :
      SUBROUTINE ZTELL (IDP,JFLP)
+CDE,QUEST.
C-    Signal trouble situation,
C-    called from the garbage collector if not enough space
C-    may be user called with IDP > 100
      write (*,101) IDP,JFLP
 101  format(1x,20('*'),' ZEBRA problem, ZTELL called with ',2i6,
     >       1x,20('*'))
      If (IDP.eq.19 .and. JFLP.eq.0) write(*,102)
 102  format(22x,'probably there is no more space on output file')
      END
 
 
 
 
 
+DECK, MZGAR1,IF=test.
*CMZ :  1.30/00 16/03/97  22.41.45  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZGAR1
 
C-    Garbage collect division JQDIVI for not enough space
C-    System called
 
+CDE, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCN, MZCT.
C--------------    End CDE                             --------------
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZGA, 4HR1   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZGAR1 /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZGAR1  ')
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT.
 
 
+SEQ, QTRACE.
+SELF, IF=QDEBUG.
      IQVREM(1,1) = IQVID(1)
      IQVREM(2,1) = IQVID(2)
+SELF.
 
C----              Construct Memory Occupation table
 
      MQDVGA = 0
      MQDVWI = 0
 
      IF (JQDIVI.LT.3)             GO TO 24
      MQDVGA = MSBIT1 (0,JQDIVI)
      JQDVM2 = JQDIVI - JQMODE
      IF (JQDVM2.EQ.JQDVSY-1)  JQDVM2=JQDVLL
      JQDVM1 = 2
      JQSTMV = JQSTOR
      IQTNMV = 0
      IF (JQSHAR.EQ.0)             GO TO 29
      MQDVGA = MSBIT1 (MQDVGA,JQSHAR)
      GO TO 29
 
   24 MQDVGA = 3
      JQSTMV = -1
   29 NQDVMV = 0
      NRESAV = NQRESV
+SELF, IF=QDEBPRI, IF=-QTRHOLL, A6M.
      IF (NQLOGL.GE.1)  WRITE (IQLOG,9028) MQTRAC(NQTRAC-1),
     +                      JQSTOR,JQDIVI,NQRESV
 9028 FORMAT (' MZGAR1-  Auto Garbage Collection called from ',A6,
     F' for Store/Div',2I3,' Free',I7)
+SELF, IF=QDEBPRI, IF=QTRHOLL, IF=-A6M.
      IF (NQLOGL.GE.1)  WRITE (IQLOG,9028) MQTRAC(NQTRAC-3),
     +                      MQTRAC(NQTRAC-2),JQSTOR,JQDIVI,NQRESV
 9028 FORMAT (' MZGAR1-  Auto Garbage Collection called from ',2A4,
     F' for Store/Div',2I3,' Free',I7)
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9829) JQDIVI,JQSHAR,NQRESV
 9829 FORMAT (1X/' DEVZE MZGAR1 entered,  JQDIVI,JQSHAR,NQRESV= ',3I8)
+SELF.
      CALL MZTABM
 
C--                Construct Link Relocation table
 
      CALL MZTABR
      NQRESV = NQRESV + NQFREE
      IF (NQRESV.GE.0)             GO TO 51
      IF (IQPART.NE.0)             GO TO 51
      IF (JQDIVI.LT.3)             GO TO 72
 
C----              Shift division if not enough space
 
      NRESV1 = LQSTA(KQT+2) - LQEND(KQT+1) - NQMINR
      NRESV1 = MIN (NRESV1,LQEND(KQT+2)-LQ2END)
 
C--                Forward division
 
      IF (JQMODE.NE.0)             GO TO 34
      IF (JQSHAR.NE.0)  THEN
          NPOSSH = NQDMAX(KQT+JQDIVI) + NQDMAX(KQT+JQDIVN)
     +             -(LQEND(KQT+JQDIVN) - LQSTA(KQT+JQDIVI))
          GO TO 36
        ELSE
          NPOSSH = LQSTA(KQT+JQDIVI) + NQDMAX(KQT+JQDIVI)
     +             - LQSTA(KQT+JQDIVN)
          GO TO 36
        ENDIF
 
C--                Reverse division
 
   34 IF (JQSHAR.NE.0)  THEN
          NPOSSH = NQDMAX(KQT+JQDIVI) + NQDMAX(KQT+JQDIVN)
     +             -(LQEND(KQT+JQDIVI) - LQSTA(KQT+JQDIVN))
        ELSE
          NPOSSH = LQEND(KQT+JQDIVN)
     +             - (LQEND(KQT+JQDIVI) - NQDMAX(KQT+JQDIVI))
        ENDIF
 
   36 NSH = (LQEND(KQT+JQDIVI)-LQSTA(KQT+JQDIVI)) / 8
      NSH = MAX (NSH,24) - NQRESV
      NSH = MIN (NSH, NPOSSH, NRESV1)
 
      IF (NSH+NQRESV.LT.0)         GO TO 72
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9836) JQDIVI,JQSHAR,NQRESV
     +,           NRESV1,NPOSSH,NSH
     +,           JQGAPM,JQGAPR
 9836 FORMAT (' DEVZE MZGAR1,  JQDIVI,JQSHAR,NQRESV=    ',3I8/
     F16X,'NRESV1,NPOSSH,NSH=',3I8/
     F16X,'JQGAPM,JQGAPR=    ',2I8)
+SELF.
      NQRESV = NQRESV + NSH
      NQDVMV = - NSH
      CALL MZTABS
 
C----              Relocate + memory move
 
   51 NWIN = NQRESV - NRESAV
+SELF, IF=QDEBPRI.
      IF (NQLOGL.GE.1)  WRITE (IQLOG,9051) NWIN,NQDVMV
 9051 FORMAT (10X,'Wins',I7,' words, Shift by',I7)
+SELF.
      CALL MZTABX
      CALL MZTABF
      IF   (NQNOOP)          68, 53, 67
   53 CALL MZGSTA (NQDGAF(KQT+1))
      CALL MZRELX
   67 CALL MZMOVE
   68 IF (NQRESV.LT.0)             GO TO 71
+SEQ, QTRACE99.
      RETURN
 
C--------          Not enough space
 
   71 IF (IQPART.NE.0)             GO TO 29
   72 IQUEST(11) = NQRESV
      IQUEST(12) = JQSTOR
      IQUEST(13) = JQDIVI
 
*     WRITE (IQLOG,9072) NQRESV
 9072 FORMAT (10X,'Not enough space, Free',I7)
 
      IF (NQPERM.NE.0)             GO TO 999
      IF (JQKIND.EQ.1)             CALL ZTELL (99,1)
 
C------            Error conditions
 
      NQCASE = 1
      NQFATA = 1
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK,zfatam.
*CMZ :  1.30/00 19/03/97  21.37.20  by  Pavel Nevski
*-- Author :    Pavel Nevski   16/03/97
      subroutine ZFATAM  (message)
      character  message*(*)
+CDE,MZCA.
+CDE,ZFATALCH.
+CDE,ZFATALRE.
      print *,' ********** ZFATAM message: ',message,' **********'
      end
+DECK,RZREAD
*CMZ :          08/08/97  16.00.05  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZREAD(V,N,IPC,IFORM)
*
************************************************************************
*
*           Read N words from input buffer into V
*
* Called by RZIN,RZINS,RZVIN
*
*  Author  : R.Brun, B.Holl
*  Written : 07.05.86
*  Last mod: 17.05.93 Change test on IFOCON(1) to .LT.0
*        PN: 08.08.97 When exchange format does not conside with native,
*            (-FQXISN selected), if last copied record comes from LROUT,
*            current IRIN value was not saved.
*
************************************************************************
+SEQ,ZUNIT,IF=-FQXISN.
+SEQ,RZCL,RZCLUN,RZCOUT,RZK.
+SEQ,MZIOC.
      DIMENSION V(*)
*
*-----------------------------------------------------------------------
*
*           Find first record
*
      NL1=LREC-IP1+1
      IF(IPC.LE.NL1)THEN
         IRS=IR1
         IS1=IP1+IPC-1
      ELSE
         NBEF=(IPC-NL1-1)/LREC
         IRS=IR2+NBEF
         IS1 =IPC-NL1-NBEF*LREC
      ENDIF
*
      LRIN=LQ(KQSP+LTOP-7)
      IF(LRIN.EQ.0)THEN
         CALL MZBOOK(JQPDVS,LRIN,LTOP,-7,'RZIN',0,0,LREC+1,2,-1)
         IQ(KQSP+LRIN-5)=IQ(KQSP+LTOP-5)
         IQ(KQSP+LTOP+KIRIN)=0
         IRIN=0
      ELSE
         IRIN=IQ(KQSP+LTOP+KIRIN)
      ENDIF
      LROUT=LQ(KQSP+LTOP-6)
      IF(LROUT.EQ.0)THEN
         IROUT=0
      ELSE
         IROUT=IQ(KQSP+LTOP+KIROUT)
      ENDIF
      IF(IRS.NE.IRIN)THEN
         IF(IRS.NE.IROUT)THEN
            CALL RZIODO(LUN,LREC,IRS,IQ(KQSP+LRIN+1),1)
            IF(IQUEST(1).NE.0)GO TO 90
            IRIN=IRS
            IQ(KQSP+LTOP+KIRIN)=IRIN
         ENDIF
      ENDIF
*
*           Read record into array V
*
+SELF,IF=-FQXISN.
      IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
         NWFOTT = N
         NWFODN = 0
         IF(IFORM.GT.0)THEN
            MFO(1) = IFORM
            MFO(2) = -1
            JFOEND = 2
         ENDIF
      ENDIF
+SELF.
      NLEFT=LREC-IS1+1
      IF(N.LE.NLEFT)THEN
         NP1=N
      ELSE
         NP1=NLEFT
      ENDIF
      IF(IRS.NE.IROUT)THEN
+SELF,IF=-FQXISN.
         IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
            NWFOAV=NP1
            CALL FZICV(IQ(KQSP+LRIN+IS1),V)
            IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
            IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LRIN+IS1+NP1-1)
            IQUEST(1)=0
         ELSE
+SELF.
            CALL UCOPY(IQ(KQSP+LRIN+IS1),V,NP1)
+SELF,IF=-FQXISN.
         ENDIF
+SELF.
      ELSE
+SELF,IF=-FQXISN.
         IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
            NWFOAV=NP1
            CALL FZICV(IQ(KQSP+LROUT+IS1),V)
            IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
            IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LROUT+IS1+NP1-1)
            IQUEST(1)=0
         ELSE
+SELF.
            CALL UCOPY(IQ(KQSP+LROUT+IS1),V,NP1)
+SELF,IF=-FQXISN.
         ENDIF
+SELF.
      ENDIF
      IF(NP1.LT.N)THEN
         NR=(N-NP1-1)/LREC+1
         IF(IRS.EQ.IR1)THEN
            IRS=IR2
         ELSE
            IRS=IRS+1
         ENDIF
         DO 60 I=1,NR
            IRin=IRS+I-1
            IF(I.NE.NR)THEN
+SELF,IF=-FQXISN.
               IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
                  CALL RZIODO(LUN,LREC,IRin,IQ(KQSP+LRIN+1),1)
                  IF(IQUEST(1).NE.0)GO TO 90
                  IQ(KQSP+LTOP+KIRIN)=IRIN
                  IF(NWFOAV.LT.0)THEN
                     CALL UCOPY2(IQ(KQSP+LRIN+1),IQ(KQSP+LRIN+2),LREC)
                     IQ(KQSP+LRIN+1)=IDOUB1
                     NWFOAV=LREC
                     CALL FZICV(IQ(KQSP+LRIN+1),V)
                     CALL UCOPY2(IQ(KQSP+LRIN+2),IQ(KQSP+LRIN+1),LREC)
                  ELSE
                     NWFOAV=LREC
                     CALL FZICV(IQ(KQSP+LRIN+1),V)
                  ENDIF
                  IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
                  IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LROUT+LREC)
                  IQUEST(1)=0
               ELSE
+SELF.
                  CALL RZIODO(LUN,LREC,IRin,V(NP1+1),1)
                  IF(IQUEST(1).NE.0)GO TO 90
+SELF,IF=-FQXISN.
               ENDIF
+SELF.
               NP1=NP1+LREC
            ELSE
               NL=N-NP1
               IF(IRIN.NE.IROUT)THEN
                  CALL RZIODO(LUN,LREC,IRIN,IQ(KQSP+LRIN+1),1)
                  IF(IQUEST(1).NE.0)GO TO 90
                  IQ(KQSP+LTOP+KIRIN)=IRIN
+SELF,IF=-FQXISN.
                  IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
                     IF(NWFOAV.LT.0)THEN
                       CALL UCOPY2(IQ(KQSP+LRIN+1),IQ(KQSP+LRIN+2),LREC)
                       IQ(KQSP+LRIN+1)=IDOUB1
                       NWFOAV=NL
                       CALL FZICV(IQ(KQSP+LRIN+1),V)
                       CALL UCOPY2(IQ(KQSP+LRIN+2),IQ(KQSP+LRIN+1),LREC)
                     ELSE
                       NWFOAV=NL
                       CALL FZICV(IQ(KQSP+LRIN+1),V)
                     ENDIF
                     IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
                     IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LRIN+NL)
                     IQUEST(1)=0
                  ELSE
+SELF.
                     CALL UCOPY(IQ(KQSP+LRIN+1),V(NP1+1),NL)
+SELF,IF=-FQXISN.
                  ENDIF
+SELF.
               ELSE
+SELF,IF=-FQXISN.
                 IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
                   IF(NWFOAV.LT.0)THEN
                     CALL UCOPY2(IQ(KQSP+LROUT+1),IQ(KQSP+LROUT+2),LREC)
                     IQ(KQSP+LROUT+1)=IDOUB1
                     NWFOAV=NL
                     CALL FZICV(IQ(KQSP+LROUT+1),V)
                     CALL UCOPY2(IQ(KQSP+LROUT+2),IQ(KQSP+LROUT+1),LREC)
                   ELSE
                     NWFOAV=NL
                     CALL FZICV(IQ(KQSP+LROUT+1),V)
                   ENDIF
                   IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
                   IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LROUT+NL)
                   IQUEST(1)=0
                 ELSE
+SELF.
                     CALL UCOPY(IQ(KQSP+LROUT+1),V(NP1+1),NL)
+SELF,IF=-FQXISN.
                  ENDIF
+SELF.
               ENDIF
            ENDIF
  60     CONTINUE
      ENDIF
  90  CONTINUE
+SELF,IF=QMVAX.
      IF(IRELAT.NE.0)UNLOCK(UNIT=LUN)
+SELF,IF=-FQXISN.
      GO TO 99
  95  IQUEST(1) =4
      IQUEST(11)=NWFOTT
      IQUEST(12)=NWFORE
      IQUEST(13)=NWFOAV
      IQUEST(14)=NWFODN
      IF(JBYT(IQ(KQSP+LTOP),15,3)-3.GE.-2) WRITE(IQLOG,1000)
 1000 FORMAT(' RZREAD. Error during conversion into native format')
+SELF.
  99  RETURN
      END
+DECK, MZLINK.
*CMZ :          20/11/97  23.58.03  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZLINK (IXSTOR,CHNAME,LAREA,LREF,LREFL)
 
C-    Set permanent link area, user called
 
+CDE, ZBCD, ZSTATE, ZUNIT.
+CDE, MQSYS.
C--------------    End CDE                             --------------
      DIMENSION    LAREA(9),LREF(9),LREFL(9),NAME(2)
      CHARACTER    *(*) CHNAME
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZLI, 4HNK   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZLINK /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZLINK  ')
+SELF.
 
+SEQ, Q$JBIT, Q$LOCF.
 
+SEQ, QTRACE.
 
+SEQ, QSTORE.
+SELF, IF=QDEBUG.
      IF (IQVSTA.NE.0)       CALL ZVAUTX
+SELF.
 
C--                Check enough space in system link-area table
 
      LSYS  = LQSYSS(KQT+1)
      NWTAB = IQ(KQS+LSYS+1)
      IF (NWTAB+5.GT.IQ(KQS+LSYS-1))  THEN
          JQDIVI = JQDVSY
          CALL MZPUSH (-7,LSYS,0,100,'I')
          LQSYSS(KQT+1) = LSYS
        ENDIF
 
C--                Construct table entry
 
      LSTO = LSYS + NWTAB
+SELF, MZLINK24.
      LOCAR = LOCF (LAREA(1)) - LQSTOR
      LOCR  = LOCF (LREF(1))  - LQSTOR
      LOCRL = LOCF (LREFL(1)) - LQSTOR
+SELF.
      NS = LOCR    - LOCAR
      NL = LOCRL+1 - LOCAR
      IF (NL.EQ.1)  THEN
          NS = NS + 1
          NL = NS
        ENDIF
 
      LOCARE = LOCAR + NL
      MODAR  = NS
 
      NAME(1) = IQBLAN
      NAME(2) = IQBLAN
      N = MIN (8, LEN(CHNAME))
      IF (N.NE.0)  CALL UCTOH (CHNAME,NAME,4,N)
 
      IQ(KQS+LSTO+1) = LOCAR
      IQ(KQS+LSTO+2) = LOCARE
      IQ(KQS+LSTO+3) = MODAR
      IQ(KQS+LSTO+4) = NAME(1)
      IQ(KQS+LSTO+5) = NAME(2)
 
C--                Range of possible values for an origin-link
 
      IQTABV(KQT+13) = MIN (IQTABV(KQT+13), LOCAR)
      IQTABV(KQT+14) = MAX (IQTABV(KQT+14), LOCARE)
 
+SELF, IF=QPRINT.
      IF (NQLOGL.GE.0)
     +WRITE (IQLOG,9039) NAME,JQSTOR,NL,NS
 9039 FORMAT (1X/' MZLINK.  Initialize Link Area  ',2A4,'  for Store'
     F,I3,' NL/NS=',2I6)
 
+SELF, IF=QDEBUG.
 
C----              Check valid parameters
 
      IF (LOCR .LT.LOCAR)          GO TO 91
      IF (LOCRL.LT.LOCAR)          GO TO 91
      IF (NL.LT.NS)                GO TO 91
 
C------            Check overlap with existing stores
 
      KLA = KQS + LOCAR
      KLE = KQS + LOCARE
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9841) 4*LQSTOR, 4*LQATAB, 4*LQBTIS, 4*KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
 9841 FORMAT (1X/' DEVZE MZLINK.  ',17X,'LQSTOR',17X,'LQATAB',
     F17X,'LQBTIS',20X,'KLA'
+SELF, IF=QDEVZE, IF=-HEX.
     F/10X,'4* OCT',4O23/13X,'OCT',4O23/13X,'DEC',4I23)
+SELF, IF=QDEVZE, IF=HEX.
     F/10X,'4* HEX',4Z23/13X,'HEX',4Z23/13X,'DEC',4I23)
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)  WRITE (IQLOG,9842) KLA,KLE
 9842 FORMAT (16X,' KLA/KLE=',2I10)
+SELF, IF=QDEBUG.
 
      DO 47  JSTO=1,NQSTOR+1
      IF (NQALLO(JSTO).NE.0)       GO TO 47
      JT  = NQOFFT(JSTO)
      JS  = NQOFFS(JSTO)
      JSA = JS  - IQTABV(JT+2) + 1
      JSE = JS  + LQSTA(JT+21) + 1
      JTA = JT  + LQBTIS       + 1
      JTE = JTA + NQTSYS
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9843) JTA,JTE,  JSA,JSE
 9843 FORMAT (16X,' JTA/JTE=',2I10,'  JSA/JSE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JTA .AND. KLA.LT.JTE)    GO TO 92
      IF (KLE.GT.JSA .AND. KLA.LT.JSE)    THEN
         IF (NQLOGL.GE.0) WRITE (IQLOG,9139) CHNAME,JSTO
 9139    FORMAT (' Link area ',a,' overlaps with store #',i3)
      ENDIF
 
C--                Check overlap with existing link areas
 
      L = JS+ LQSYSS(JT+1)
      N = IQ(L+1)
      IF (N.LT.12)                 GO TO 47
 
      DO 44  J=12,N,5
      JLA = JS + IQ(L+J)
      JLE = JS + IQ(L+J+1)
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9844) JLA,JLE
 9844 FORMAT (16X,' JLA/JLE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JLA .AND. KLA.LT.JLE)    GO TO 94
   44 CONTINUE
   47 CONTINUE
+SELF.
 
   61 IQ(KQS+LSYS+1) = NWTAB + 5
      CALL VZERO (LAREA,NL)
+SEQ, QTRACE99.
      RETURN
 
C------            Error conditions
 
   94 NQCASE = 1
      NQFATA = 3
      IQUEST(21) = IQ(L+J+3)
      IQUEST(22) = IQ(L+J+4)
      IQUEST(23) = JLA + LQSTOR
 
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 3
      IQUEST(18) = JSTO - 1
      IQUEST(19) = NQPNAM(JT+1)
      IQUEST(20) = NQPNAM(JT+2)
 
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 7
      IQUEST(11) = NAME(1)
      IQUEST(12) = NAME(2)
      IQUEST(13) = LOCAR + LQSTOR
      IQUEST(14) = LOCR  + LQSTOR
      IQUEST(15) = LOCRL + LQSTOR
      IQUEST(16) = NS
      IQUEST(17) = NL
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZLINT.
*CMZ :          21/11/97  17.09.55  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZLINT (IXSTOR,CHNAME,LAREA,LREF,LREFL)
 
C-    Set permanent link area, user called
 
+CDE, ZBCD, ZSTATE, ZUNIT.
+CDE, MQSYS.
C--------------    End CDE                             --------------
      DIMENSION    LAREA(9),LREF(9),LREFL(9),NAME(2)
      CHARACTER    *(*) CHNAME
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZLI, 4HNT   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZLINT /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZLINT  ')
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT, Q$LOCF.
 
 
+SEQ, QTRACE.
 
+SEQ, QSTORE.
+SELF, IF=QDEBUG.
      IF (IQVSTA.NE.0)       CALL ZVAUTX
+SELF.
 
      LSYS  = LQSYSS(KQT+1)
      NWTAB = IQ(KQS+LSYS+1)
+SELF, MZLINT14.
      LOCAR = LOCF (LAREA(1)) - LQSTOR
+SELF.
      JDES = LAREA(2)
      IF (JDES.LT.11)              GO TO 21
      IF (JDES.GE.NWTAB)           GO TO 21
      LSTO = LSYS + JDES
      IF (IQ(KQS+LSTO+1).NE.LOCAR)    GO TO 21
      NL = IQ(KQS+LSTO+2) - LOCAR
+SELF, IF=QDEBPRI.
      IF (NQLOGL.LT.2)             GO TO 19
      WRITE (IQLOG,9018) IQ(KQS+LSTO+4),IQ(KQS+LSTO+5),JQSTOR
 9018 FORMAT (1X/' MZLINT-  Re-Init of Link Area ',2A4,'  for Store',I3)
+SELF.
 
C--                Set link area active
 
   19 LAREA(1) = 7
      CALL VZERO (LAREA(3),NL-2)
+SEQ, QTRACE99.
      RETURN
 
C------            Initialize for the first time
 
   21 IF (NWTAB+5.GT.IQ(KQS+LSYS-1))  THEN
          JQDIVI = JQDVSY
          CALL MZPUSH (-7,LSYS,0,100,'I')
          LQSYSS(KQT+1) = LSYS
        ENDIF
 
      LSTO = LSYS + NWTAB
+SELF, MZLINT24.
      LOCR  = LOCF (LREF(1))  - LQSTOR
      LOCRL = LOCF (LREFL(1)) - LQSTOR
+SELF.
      NS = LOCR    - LOCAR
      NL = LOCRL+1 - LOCAR
      IF (NL.EQ.1)  THEN
          NS = NS + 1
          NL = NS
        ENDIF
 
      LOCARE = LOCAR + NL
      MODAR  = MSBIT1 (NS,31)
 
      NAME(1) = IQBLAN
      NAME(2) = IQBLAN
      N = MIN (8, LEN(CHNAME))
      IF (N.NE.0)  CALL UCTOH (CHNAME,NAME,4,N)
 
      IQ(KQS+LSTO+1) = LOCAR
      IQ(KQS+LSTO+2) = LOCARE
      IQ(KQS+LSTO+3) = MODAR
      IQ(KQS+LSTO+4) = NAME(1)
      IQ(KQS+LSTO+5) = NAME(2)
 
C--                Range of possible values for an origin-link
 
      IQTABV(KQT+13) = MIN (IQTABV(KQT+13), LOCAR+2)
      IQTABV(KQT+14) = MAX (IQTABV(KQT+14), LOCARE)
 
      NSM2 = NS - 2
      NLM2 = NL - 2
+SELF, IF=QPRINT.
      IF (NQLOGL.GE.1)
     +WRITE (IQLOG,9039) NAME,JQSTOR,NLM2,NSM2
 9039 FORMAT (1X/' MZLINT.  Initialize Link Area  ',2A4,'  for Store'
     F,I3,' NL/NS=',2I6)
 
+SELF, IF=QDEBUG.
 
C----              Check valid parameters
 
      IF (LOCR .LT.LOCAR)          GO TO 91
      IF (LOCRL.LT.LOCAR)          GO TO 91
      IF (NL.LT.NS)                GO TO 91
 
C------            Check overlap with existing stores
 
      KLA = KQS + LOCAR
      KLE = KQS + LOCARE
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9841) 4*LQSTOR, 4*LQATAB, 4*LQBTIS, 4*KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
 9841 FORMAT (1X/' DEVZE MZLINT.  ',17X,'LQSTOR',17X,'LQATAB',
     F17X,'LQBTIS',20X,'KLA'
+SELF, IF=QDEVZE, IF=-HEX.
     F/10X,'4* OCT',4O23/13X,'OCT',4O23/13X,'DEC',4I23)
+SELF, IF=QDEVZE, IF=HEX.
     F/10X,'4* HEX',4Z23/13X,'HEX',4Z23/13X,'DEC',4I23)
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9842) KLA,KLE
 9842 FORMAT (16X,' KLA/KLE=',2I10)
+SELF, IF=QDEBUG.
 
      DO 47  JSTO=1,NQSTOR+1
      IF (NQALLO(JSTO).NE.0)       GO TO 47
      JT  = NQOFFT(JSTO)
      JS  = NQOFFS(JSTO)
      JSA = JS  - IQTABV(JT+2) + 1
      JSE = JS  + LQSTA(JT+21) + 1
      JTA = JT  + LQBTIS       + 1
      JTE = JTA + NQTSYS
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9843) JTA,JTE,  JSA,JSE
 9843 FORMAT (16X,' JTA/JTE=',2I10,'  JSA/JSE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JTA .AND. KLA.LT.JTE)    GO TO 92
      IF (KLE.GT.JSA .AND. KLA.LT.JSE)    THEN
         IF (NQLOGL.GE.0) WRITE (IQLOG,9139) CHNAME,JSTO
 9139    FORMAT (' Link area ',a,' overlaps with store #',i3)
      ENDIF
 
C--                Check overlap with existing link areas
 
      L = JS+ LQSYSS(JT+1)
      N = IQ(L+1)
      IF (N.LT.12)                 GO TO 47
 
      DO 44  J=12,N,5
      JLA = JS + IQ(L+J)
      JLE = JS + IQ(L+J+1)
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9844) JLA,JLE
 9844 FORMAT (16X,' JLA/JLE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JLA .AND. KLA.LT.JLE)    GO TO 94
   44 CONTINUE
   47 CONTINUE
+SELF.
 
C--                Success, register new link area
 
      LAREA(2) = NWTAB
      IQ(KQS+LSYS+1) = NWTAB + 5
      GO TO 19
 
C------            Error conditions
 
   94 NQCASE = 1
      NQFATA = 4
      IQUEST(21) = IQ(L+J+3)
      IQUEST(22) = IQ(L+J+4)
      IQUEST(23) = JLA + LQSTOR
      IQUEST(24) = LAREA(2)
 
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 3
      IQUEST(18) = JSTO - 1
      IQUEST(19) = NQPNAM(JT+1)
      IQUEST(20) = NQPNAM(JT+2)
 
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 7
      IQUEST(11) = NAME(1)
      IQUEST(12) = NAME(2)
      IQUEST(13) = LOCAR + LQSTOR
      IQUEST(14) = LOCR  + LQSTOR
      IQUEST(15) = LOCRL + LQSTOR
      IQUEST(16) = NSM2
      IQUEST(17) = NLM2
+SEQ, QTOFATAL.
*     prevent warning only
      L = MSBIT0 (NS,31)
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZSTOR.
*CMZ :          25/03/98  17.51.27  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZSTOR (IXSTOR,CHNAME,CHOPT
     +,                  IFENCE,LV,LLR,LLD,LIMIT,LAST)
 
C-    Initialize new Zebra store region, user called
 
+CDE, ZBCD, ZMACH, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCWK.
C--------------    End CDE                             --------------
      DIMENSION    IXSTOR(9),IFENCE(9)
      DIMENSION    LV(9),LLR(9),LLD(9),LIMIT(9),LAST(9)
      DIMENSION    MMSYSL(5), NAMELA(2), NAMESY(2)
      CHARACTER    *(*) CHNAME,CHOPT
+SELF, IF=QMVDS.
      SAVE         MMSYSL, NAMELA, NAMESY, NAMWSP, NAMEDV
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZST, 4HOR   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZSTOR /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZSTOR  ')
+SELF, IF=QHOLL.
      DATA  MMSYSL / 4HSYSL,0,0,101,2/
      DATA  NAMELA / 4Hsyst, 4Hem   /
      DATA  NAMESY / 4Hsyst, 4Hem   /
      DATA  NAMWSP / 4Hqwsp /
      DATA  NAMEDV / 4HQDIV /
+SELF, IF=-QHOLL.
      DATA  MMSYSL / 0,0,0,101,2/
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT, Q$SHIFT, Q$LOCF.
 
 
C--                Clear Zebra tables on first entry
 
      IF (NQSTOR.NE.-1)            GO TO 13
      CALL VZERO (NQOFFT,32)
      LQATAB = LOCF (IQTABV(1)) - 1
      LQASTO = LOCF (LQ(1)) - 1
      LQBTIS = LQATAB - LQASTO
      LQWKTB = LOCF(IQWKTB(1)) - LQASTO
      LQWKFZ = LOCF(IQWKFZ(1)) - LQASTO
      NQTSYS = LOCF(IQDN2(20)) - LQATAB
      NQWKTB = NQWKTT
 
C-      KQFT=342 relies on LQFSTA(1) to be LQSTA(1+342) in /MZCC/
      KQFT = 342
+SELF, IF=QPRINT.
      IF (NQLOGD.GE.-1)
     +WRITE (IQLOG,9011) LQATAB,LQATAB
 9011 FORMAT (1X/' MZSTOR.  ZEBRA table base TAB(0) in /MZCC/ at adr'
+SELF, IF=QPRINT, IF=-HEX.
     F,I12,1X,O11,' OCT')
+SELF, IF=QPRINT, IF=HEX, IF=-B64.
     F,I12,1X,Z11,' HEX')
+SELF, IF=QPRINT, IF=HEX, IF=B64.
     F,I12,1X,Z16,' HEX')
+SELF.
   13 CONTINUE
+SELF, IF=-QHOLL.
      CALL UCTOH ('SYSL',    MMSYSL, 4,4)
      CALL UCTOH ('system  ',NAMELA, 4,8)
      CALL UCTOH ('system  ',NAMESY, 4,8)
      CALL UCTOH ('qwsp'    ,NAMWSP, 4,4)
      CALL UCTOH ('QDIV'    ,NAMEDV, 4,4)
+SELF.
 
+SEQ, QTRACE.
 
      CALL UOPTC (CHOPT,'Q:',IQUEST)
      LOGQ   = IQUEST(1)
      IFLSPL = IQUEST(2)
 
      JQSTOR = NQSTOR + 1
      CALL VZERO (KQT,27)
 
C--                Calculate store off-set
 
      LQSTOR = LOCF(LV(1)) - 1
      KQS    = LQSTOR - LQASTO
 
      NFEND  = (LQSTOR+1) - LOCF(IFENCE(1))
      NQFEND = NFEND
 
C--                Printing name of store
 
      NQSNAM(1) = IQBLAN
      NQSNAM(2) = IQBLAN
      N = MIN (8, LEN(CHNAME))
      IF (N.NE.0)  CALL UCTOH (CHNAME,NQSNAM,4,N)
 
C--                Set log level
 
      NQLOGL = NQLOGD
      IF (LOGQ.NE.0)  NQLOGL=-2
 
C--                Permanent links et al.
 
      NQSTRU = LOCF(LLR(1)) - (LQSTOR+1)
      NQREF  = LOCF(LLD(1)) - (LQSTOR+1)
      NQLINK = NQREF
      LQ2END = LOCF(LIMIT(1)) - LQSTOR
      NDATAT = LOCF(LAST(1))  - LQSTOR
 
C--                Calculate table off-set
 
      NDATA = NDATAT
      LOCT  = LQATAB
      IF (JQSTOR.NE.0)  THEN
          NDATA = NDATA  - NQTSYS
          NQSNAM(6) = NDATA
          LOCT  = LQSTOR + NDATA
          KQT   = LOCT   - LQATAB
          NDATA = NDATA - 4
          CALL VFILL (LQ(KQS+NDATA),10,IQNIL)
        ENDIF
 
+SELF, IF=QPRINT.
      IF (NQLOGL.GE.-1)
     +WRITE (IQLOG,9021) JQSTOR,NQSNAM(1),NQSNAM(2)
     +,                  LQSTOR,LOCT,LQSTOR,LOCT,KQS,KQT,KQS,KQT
     +,                  NQSTRU,NQREF,LQ2END,NDATAT,NFEND
 9021 FORMAT (1X/' MZSTOR.  Initialize Store',I3,'  in ',2A4,
     F/10X,'with Store/Table at absolute adrs',2I12
+SELF, IF=QPRINT, IF=-HEX.
     F/40X,'OCT',2(1X,O11)/40X,'OCT',2(1X,O11)
+SELF, IF=QPRINT, IF=HEX, IF=-B64.
     F/40X,'HEX',2(1X,Z11)/40X,'HEX',2(1X,Z11)
+SELF, IF=QPRINT, IF=HEX, IF=B64.
     F/30X,'HEX',2(1X,Z16)/30X,'HEX',2(1X,Z16)
+SELF, IF=QPRINT.
     F/30X,'relative adrs',2I12
     F/10X,'with',I6,' Str. in',I6,' Links in',I7,' Low words in'
     F,I8,' words.'
     F/10X,'This store has a fence of',I5,' words.')
+SELF.
 
C--                Set minimum sizes
 
      NSYS   =  400
      NQMINR =   40
      NWF    = 2000
      IF (JQSTOR.EQ.0)  NQMINR=164
 
C--                Check parameters valid
 
      IF (NQSTRU.LT.0)               GO TO 91
      IF (NQREF .LT.NQSTRU)          GO TO 91
      IF (NDATAT.LT.NQLINK+NWF)      GO TO 91
      IF (LQ2END.LT.NQLINK+NQMINR)   GO TO 91
      IF (NFEND .LT.1)               GO TO 92
      IF (NFEND .GE.1001)            GO TO 92
      IF (IFLSPL.EQ.1)  THEN
          IF (JQSTOR.EQ.0)           GO TO 96
          GO TO 39
        ENDIF
 
+SELF,             IF=-QSINGLST, IF=QDEBUG.
C--                Check overlapping stores
 
      IF (JQSTOR.EQ.0)             GO TO 41
      KSA = KQS - NQFEND
      KSE = KQS + NDATAT
 
      DO 36  JSTO=1,JQSTOR
      JT  = NQOFFT(JSTO)
      JS  = NQOFFS(JSTO)
      JSA = JS  - IQTABV(JT+2)
      JSE = JS  + LQSTA(JT+21)
      JTA = JT  + LQBTIS
      JTE = JTA + NQTSYS
 
      IF (KSE.GT.JTA .AND. KSA.LT.JTE     .or.
     >    KSE.GT.JSA .AND. KSA.LT.JSE)    THEN
         IF (NQLOGL.GE.0) WRITE (IQLOG,9139)
     >                    CHNAME,NQPNAM(JT+1), NQPNAM(JT+2)
 9139    FORMAT (' store ',a,' overlaps with store ',2a4)
      ENDIF
 
   36 CONTINUE
+SELF.
   39 IF (JQSTOR.GE.16)            GO TO 93
 
C----              Initialize divisions 1 + 2 + system
 
   41 NQOFFT(JQSTOR+1) = KQT
      NQOFFS(JQSTOR+1) = KQS
      NQALLO(JQSTOR+1) = IFLSPL
      CALL VZERO (IQTABV(KQT+1),NQTSYS)
      CALL VBLANK (IQDN1(KQT+1), 40)
      NQSTOR = NQSTOR + 1
 
      LQ(KQS+NDATA-1) = IQNIL
      LQ(KQS+NDATA)   = IQNIL
 
      NDATA = NDATA - 2
      LQSTA(KQT+21) = NDATA
 
      JQDVLL = 2
      JQDVSY = 20
      LQSTA(KQT+20)  = NDATA
      LQEND(KQT+20)  = NDATA
      NQDMAX(KQT+20) = NDATA
      IQMODE(KQT+20) = 1
      IQKIND(KQT+20) = ISHFTL (1, 23)
      IQRNO(KQT+20)  = 9437183
      IQDN1(KQT+20)  = NAMESY(1)
      IQDN2(KQT+20)  = NAMESY(2)
 
      LQSTA(KQT+2)  = NDATA - NSYS
      LQEND(KQT+2)  = LQSTA(KQT+2)
      NQDMAX(KQT+2) = NDATA
      IQMODE(KQT+2) = 1
      IQKIND(KQT+2) = MSBIT1 (2, 21)
      IQRCU(KQT+2)  = 3
      IQRTO(KQT+2)  = ISHFTL (3,20)
      IQRNO(KQT+2)  = 9437183
      IQDN1(KQT+2)  = NAMEDV
      IQDN2(KQT+2)  = IQNUM(3)
 
      LQSTA(KQT+1)  = NQLINK + 1
      LQEND(KQT+1)  = LQSTA(KQT+1)
      NQDMAX(KQT+1) = NDATA
      IQKIND(KQT+1) = MSBIT1 (1, 21)
      IQRCU(KQT+1)  = 3
      IQRTO(KQT+1)  = ISHFTL (3,20)
      IQRNO(KQT+1)  = 9437183
      IQDN1(KQT+1)  = NAMEDV
      IQDN2(KQT+1)  = IQNUM(2)
 
      CALL UCOPY (IQCUR,IQTABV(KQT+1),16)
      CALL VFILL (IFENCE,NFEND,IQNIL)
      IF (NQLINK.NE.0)  CALL VZERO (LV,NQLINK)
 
C--                Return IXSTOR
 
      IF (JQSTOR.EQ.0)  THEN
          IF (IXSTOR(1).EQ.0)      GO TO 71
        ENDIF
      IDN = ISHFTL (JQSTOR,26)
      IXSTOR(1) = IDN
 
C----              Create system link table bank
 
   71 JQDIVI = JQDVSY
      CALL MZLIFT (-7,LSYS,0,2,MMSYSL,0)
      LQSYSS(KQT+1) = LSYS
 
      NALL   = LOCF(IQTDUM(1)) - LOCF(LQSYSS(1))
      NSTR   = LOCF(LQSYSR(1)) - LOCF(LQSYSS(1))
 
      LOCAR  = LOCF (LQSYSS(KQT+1)) - LQSTOR
      LOCARE = LOCAR + NALL
 
C--                Working space
 
      IQ(KQS+LSYS+1) = 11
      IQ(KQS+LSYS+2) = 1
      IQ(KQS+LSYS+3) = 1 + NQLINK
      IQ(KQS+LSYS+4) = NQSTRU
      IQ(KQS+LSYS+5) = NAMWSP
      IQ(KQS+LSYS+6) = IQBLAN
 
C--                System link area
 
      IQ(KQS+LSYS+7) = LOCAR
      IQ(KQS+LSYS+8) = LOCARE
      IQ(KQS+LSYS+9) = NSTR
      IQ(KQS+LSYS+10)= NAMELA(1)
      IQ(KQS+LSYS+11)= NAMELA(2)
 
C--                Range of possible values for an origin-link
 
      IQTABV(KQT+13) = MIN (1, LOCAR)
      IQTABV(KQT+14) = MAX (LQSTA(KQT+21), LOCARE)
 
+SEQ, QTRACE99.
      RETURN
C------            Error conditions
 
   96 NQCASE = NQCASE + 3
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 9
      IQUEST(11) = NQSNAM(1)
      IQUEST(12) = NQSNAM(2)
      IQUEST(13) = NFEND
      IQUEST(14) = NQSTRU
      IQUEST(15) = NQLINK
      IQUEST(16) = LQ2END
      IQUEST(17) = NDATAT
      IQUEST(18) = NQMINR
      IQUEST(19) = NWF
+SEQ, QTOFATAL.
+SELF,IF=HPUX.  prevent "never used" warning
      N=NOT(IAND(IBITS(1,1,1),1))
+SELF.
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZRELB.
*CMZ :          25/03/98  17.50.48  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZRELB
 
C-    Relocator for links in banks
 
+CDE, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCN, MZCT.
C--------------    End CDE                             --------------
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZRE, 4HLB   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZRELB /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZRELB  ')
+SELF.
 
+SEQ, Q$JBIT.
 
 
+SEQ, QTRACE.
 
      LFIXLO = LQ(LQTA-1)
      LFIXRE = LQ(LQTA)
      LFIXHI = LQ(LQTE)
      JHIGO  = (LQTE-LQTA) / 4
      NENTR  = JHIGO - 1
 
      IF (NENTR.EQ.0)  THEN
          LADTB1 = LQ(LQTA+1)
          NRLTB2 = LQ(LQTA+2)
          IFLTB3 = LQ(LQTA+3)
        ENDIF
 
      LMRNX  = LQMTA
   12 LMR    = LMRNX
      IF (LMR.GE.LQMTE)            GO TO  999
      LMRNX  = LMRNX + 8
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)
     +WRITE (IQLOG,9813) (LQ(J+LMR-1),J=1,8)
 9813 FORMAT (1X/' DEVZE MZRELB.  DIV, ACT,   NSH, LF, LL, LTA, LTB'
     F,', NFREE'/14X,2I5,6I7)
+SELF.
 
      IACT   = LQ(LMR+1)
      IF (IACT.LE.0)               GO TO 12
      IF (IACT.EQ.4)               GO TO 12
      LSTOP  = LQ(LMR+4)
      IF (IACT.EQ.3)               GO TO 14
      LN     = LQ(LMR+3)
      LDEAD  = LSTOP
      GO TO 19
 
   14 LSEC   = LQRTA + LQ(LMR+5) - 4
 
C------            Next bank,  check if dead group
 
   16 LSEC   = LSEC + 4
      LNX    = LQ(LSEC)
      LDEAD  = LQ(LSEC+1)
 
   17 LN = LNX
      IF (LN.GE.LSTOP)             GO TO 12
      IF (LN.EQ.LDEAD)             GO TO 16
 
C--                Next bank,  alive
 
   19 CONTINUE
 
+SELF, IF=QDEBUG.
      CALL MZCHLN (-7,LN)
      IF (IQFOUL.NE.0)             GO TO 91
      LNX = IQNX
      IF (IQND.LT.0)               GO TO 17
      LS  = IQLS
      LO  = LS + 2
      LX  = LS + 3
      L2  = LS - IQNS
      L1  = LS - IQNL
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9819) LN, IQID,IQNL,IQNS,IQND
 9819 FORMAT (1X/' DEVZE MZRELB.  Do bank at LN =',I7
     F,'  ID,NL,NS,ND= ',A4,3I7)
+SELF, IF=-QDEBUG.
      NST = JBYT (LQ(KQS+LN),1,16) - 11
      IF (NST.LT.0)  THEN
          LNX = LN + NST + 11
          GO TO 17
        ELSE
          LS  = LN + NST
          LO  = LS + 2
          LX  = LS + 3
          L2  = LS - IQ(KQS+LS-2)
          L1  = LS - IQ(KQS+LS-3)
          LNX = LS + IQ(KQS+LS-1) + 9
        ENDIF
+SELF.
      IF   (NENTR)           66, 46, 26
 
C--------------    2 OR MORE RELOCATION INTERVALS       -------------
 
C----              Next link
 
   23 IF (L1.EQ.LO) GO TO 25
   24 LQ(KQS+L1)= 0
 
   25 L1 = L1 + 1
      IF (L1.EQ.LX)                GO TO 17
   26 LFIRST= LQ(KQS+L1)
   27 LINK  = LQ(KQS+L1)
      IF (LINK.EQ.0)               GO TO 25
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9827) LINK,L1
 9827 FORMAT (16X,'Link =',I7,' from L1 =',I7)
+SELF.
      IF (IQFLIO.EQ.0)  THEN
          IF (LINK.LT.LFIXLO)      GO TO 25
          IF (LINK.GE.LFIXHI)      GO TO 25
          IF (LINK.LT.LFIXRE)      GO TO 23
        ELSE
          IF (LINK.LT.LFIXRE)      GO TO 24
          IF (LINK.GE.LFIXHI)      GO TO 24
        ENDIF
 
C--                Binary search in relocator table
 
      JLOW = 0
      JHI  = JHIGO
 
   29 JEX = (JHI+JLOW) / 2
      IF (JEX.EQ.JLOW)             GO TO 31
      IF (LINK.GE.LQ(LQTA+4*JEX))  GO TO 30
      JHI  = JEX
      GO TO 29
 
   30 JLOW = JEX
      GO TO 29
 
C--                Relocate
 
   31 JTB = LQTA + 4*JLOW
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)
     +WRITE (IQLOG,9831) JLOW, (LQ(JTB+J-1),J=1,4)
 9831 FORMAT (50X,'Entry',I5,',',4I7)
+SELF.
      IF (LINK.GE.LQ(JTB+1))             GO TO 33
      LQ(KQS+L1) = LINK + LQ(JTB+2)
      GO TO 25
 
C----              Link into dead area
 
   33 IF   (LQ(JTB+3))       25, 24, 34
 
C--                Bridge structural link
 
   34 IF (L1.LT.L2)                GO TO 24
      IF (LS+1-L1)           36, 24, 35
   35 CONTINUE
 
+SELF, IF=QDEBUG.
      CALL MZCHLS (-7,LINK)
      IF (IQFOUL.NE.0)             GO TO 92
+SELF.
      LINK = LQ(KQS+LINK)
      LQ(KQS+L1) = LINK
      IF (LINK.NE.LFIRST)          GO TO 27
      GO TO 24
 
C--                Reverse bridging of s-link
 
   36 LINK = LQ(KQS+LINK+2)
      LQ(KQS+L1) = LINK
      GO TO 27
 
C--------------    1 RELOCATION INTERVAL ONLY           -------------
 
C----              Next link
 
   43 IF (L1.EQ.LO) GO TO 45
   44 LQ(KQS+L1)= 0
 
   45 L1 = L1 + 1
      IF (L1.EQ.LX)                GO TO 17
   46 LFIRST= LQ(KQS+L1)
   47 LINK  = LQ(KQS+L1)
      IF (LINK.EQ.0)               GO TO 45
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9827) LINK,L1
+SELF.
      IF (IQFLIO.EQ.0)  THEN
          IF (LINK.LT.LFIXLO)      GO TO 45
          IF (LINK.GE.LFIXHI)      GO TO 45
          IF (LINK.LT.LFIXRE)      GO TO 43
          IF (LINK.GE.LADTB1)      GO TO 53
        ELSE
          IF (LINK.LT.LFIXRE)      GO TO 44
          IF (LINK.GE.LADTB1)      GO TO 44
        ENDIF
 
C--                Relocate
 
      LQ(KQS+L1) = LINK + NRLTB2
      GO TO 45
 
C----              Link into dead area
 
   53 IF   (IFLTB3)           45, 44, 54
 
C--                Bridge structural link
 
   54 IF (L1.LT.L2)                GO TO 44
      IF (LS+1-L1)           56, 44, 55
   55 CONTINUE
 
+SELF, IF=QDEBUG.
      CALL MZCHLS (-7,LINK)
      IF (IQFOUL.NE.0)             GO TO 92
+SELF.
      LINK = LQ(KQS+LINK)
      LQ(KQS+L1) = LINK
      IF (LINK.NE.LFIRST)          GO TO 47
      GO TO 44
 
C--                Reverse bridging of s-link
 
   56 LINK = LQ(KQS+LINK+2)
      LQ(KQS+L1) = LINK
      GO TO 47
 
C--------------    NO RELOCATION INTERVAL               -------------
 
C----              Next link
 
   64 LQ(KQS+L1)= 0
 
   65 L1 = L1 + 1
      IF (L1.EQ.LX)                GO TO 17
   66 LINK  = LQ(KQS+L1)
      IF (LINK.EQ.0)               GO TO 65
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9827) LINK,L1
+SELF.
      IF (LINK.LT.LFIXLO)          GO TO 65
      IF (LINK.GE.LFIXHI)          GO TO 65
      GO TO 64
 
C------            Error conditions
+SELF,  IF=QDEBUG.
   92 NQCASE = 1
      NQFATA = 2
      LN     = LS
      IQUEST(12) = L1
      IQUEST(13) = LINK
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 1
      IQUEST(11) = LN
      IF (IQFLIO.NE.0)             GO TO 98
+SEQ, QTOFATAL.
 
   98 IQUEST(9) = NQCASE
      IQUEST(10)= NQFATA
      NQCASE = 0
      NQFATA = 0
      IQFLIO = -7
+SELF.
+SEQ, QTRACE99.
+SELF, IF=HPUX. prevent warning "not used"
      I=IBITS(1,1,1)
+SELF.
      RETURN
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZPAW.
*CMZ :          06/12/97  11.36.55  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZPAW (NWORDS,CHOPT)
 
C-    Initialize the store /PAWC/ of at least 10000 words;
 
      COMMON /PAWC/  NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKU,IFENCE(5)
     +,              LMAIN, IPAW(9989)
C--------------------------------------------------------------------
      CHARACTER*(*) CHOPT
 
      NW   = abs (NWORDS)
      NW   = max (NW,100000)
      I1   = LOCF(IPAW)
      I2   = memget (NW*4+1000)/4
      LL   = max    (I2-I1,0)
      NW   = NW + LL
      KWW  = LL + 100
C
      CALL MZSTOR (IXPAWC,'/PAWC/',' ',IFENCE,LMAIN,IPAW,IPAW,
     +                                 IPAW(KWW+100),IPAW(NW-100))
      CALL MZWORK (IXPAWC,IPAW(9989),IPAW(KWW),5)
      CALL MZWORK (IXPAWC,IPAW(50),IPAW(5000),0)
c
      NWPAW  = NW
      IHBOOK = 0
      IXHIGZ = 0
      IXKU   = 0
      RETURN
      END
+DECK,mzchnb.
*CMZ :          05/12/97  19.43.57  by  Pavel Nevski
*-- Author :    Pavel Nevski   05/12/97
 
      SUBROUTINE MZCHNB (LIX)
      END
+DECK, MZWORK.
*CMZ :          06/12/97  11.43.18  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZWORK (IXSTOR,DFIRST,DLAST,IFLAGP)
 
C-    Allocate working space, user called
 
C-    IFLAG = -1  reset wsp empty
C-             0  new wsp
C-             1  vary both limits, keep common links
C-             2  vary  only DLAST  limit, keep links and common data
C-             3  reset only DFIRST limit, zero all links
C-             4  vary  only DFIRST limit, keep common links
C-            >5  allocate reserve between WS and DIV1
+CDE, ZMACH, ZSTATE, ZUNIT.
+CDE, MQSYS.
      COMMON /MZCDN/ LQRSTA(20),LQREND(20)
C--------------    End CDE                             --------------
      INTEGER      DFIRST(9), DLAST(9), IFLAGP(9)
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZWO, 4HRK   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZWORK /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZWORK  ')
+SELF.
 
+SEQ, Q$JBIT, Q$LOCF.
+SEQ, QTRACE.
+SEQ, QSTORE.
 
      IFLAG = IFLAGP(1)
      JSTO  = JBYT (IXSTOR,27,4)
      IF (JSTO.GT.NQSTOR) GO TO 91
 
C----              Reset empty working space
 
      NEWL  = NQREF
      NEWD  = NQREF
      IF (IFLAG.LT.0)              GO TO 71
      NEWL  = LOCF (DFIRST(1)) - (LQSTOR+1)
      NEWD  = LOCF (DLAST(1))  -  LQSTOR
 
      IF (IFLAG.GE.5)              then
         LQRSTA(JSTO+1)=NEWL
         LQREND(JSTO+1)=NEWD
         GO TO 999
      endif
 
      IF (IFLAG.GE.3)  NEWD = LQSTA(1) - 1
      IF (IFLAG.EQ.2)  NEWL = NQLINK
 
C----              Check valid parameters
 
      IF (NEWL.LT.NQREF)           GO TO 92
      IF (NEWD.LT.NEWL)            GO TO 93
      IF (IFLAG.GE.3)              GO TO 31
      IF (LQRSTA(JSTO+1).EQ.0) then
         IF (NEWD.GE.LQEND(KQT+2)) GO TO 94
      ELSE
         IF (NEWD.GE.LQRSTA(JSTO+1)) GO TO 94
      ENDIF
 
C--                Check garbage collection
 
      NQRESV = LQSTA(KQT+2) - NQMINR - NEWD
      IF (NQRESV.GT.0)             GO TO 31
      print *,' negative NQRESV force garbage collection = ',NQRESV
      LQEND(KQT+1) = LQSTA(KQT+1)
      JQDIVI = 2
      CALL MZRESV
      CALL MZGAR1
      NQRESV = LQSTA(KQT+2) - NQMINR - NEWD
      IF (NQRESV.LE.0)             GO TO 94
 
C--                Clear new links
 
   31 LA = NQREF
      IF (IFLAG.EQ.1)  LA = NQLINK
      IF (IFLAG.EQ.2)  LA = NQLINK
      IF (IFLAG.EQ.4)  LA = NQLINK
      N  = NEWL - LA
      IF (N.GT.0)  CALL VZERO (LQ(KQS+LA+1),N)
 
C----              Set new limits
 
   71 NQLINK  = NEWL
      IQTABV(KQT+5) = NQLINK
      IF (IFLAG.LT.3)  THEN
          IF (NEWD.GE.LQSTA(KQT+1)) Then
             LQSTA(KQT+1) = LQREND(JSTO+1)
             IF (LQSTA(KQT+1).EQ.0)  LQSTA(KQT+1) = NEWD + 1
             LQEND(KQT+1) = LQSTA(KQT+1)
          endif
        ENDIF
 
      IF (NQLOGL.GE.2) WRITE (IQLOG,9071) JQSTOR,IFLAG,NQLINK,NEWD
 9071 FORMAT (' MZWORK-  Store',I3,' Flag=',I2,' Last Link/Data',2I7)
 
+SEQ, QTRACE99.
      RETURN
 
C------            Error conditions
 
   94 NQCASE = 1
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
   91 NQCASE = NQCASE + 1
      NQFATA = 4
      IQUEST(11) = NQREF
      IQUEST(12) = NEWL
      IQUEST(13) = NEWD
      IQUEST(14) = IFLAG
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK,RZMAKE.
*CMZ :          25/03/98  19.29.54  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZMAKE(LUNIN,CHDIR,NWKEY,CHFORM,CHTAG,NRECP,CHOPT)
*
************************************************************************
*
*           Routine to create a new RZ file
*           To use an already existing file CALL RZFILE
* Input:
*   LUNP    Logical unit number associated with  the RZ file.   A FORTRAN
*           OPEN statement must precede the call to RZFILE.
*           Starting address of the memory area which will contain the RZ
*           information ('M' option)
*   CHDIR   Character variable specifying  the name of the  top directory
*           to be associated with unit LUN.
*   NWKEY   Number of words associated to a key (maximum 5)
*   CHFORM  Character variable describing each element  of the key vector
*           'B' Bit string but not zero
*           'H' Hollerith (4 characters)
*           'I' Integer (nonzero)
*           Ex: CHFORM='IIH' for NWKEY=3 and the 2 first keys are integer
*               and the third one is Hollerith
*   CHTAG   Character array defined as CHARACTER*8 CHTAG(NWKEY).
*           Each  element of  the  array allows  the  description of  the
*           corresponding element in the key vector with a tag of up to 8
*           characters.
*   NRECP   Number of physical records for primary allocation
*   CHOPT   Character variable specifying the selected options.
*           medium
*             default
*                   Disk
*             'M'   Memory
*                   In this  case the user  must have allocated  at least
*                   NRECP*LUNP words of memory starting at address LUN.
*           mode
*             default
*                   Native mode
*             'X'   Exchange mode
*           other
*             'F'   Format NRECP records (unless 'M')
*             'C'   C I/O (unless 'M')
*                   LRECL (words) taken from IQUEST(10)
*             'O'   OLD format for Cycle information (default is NEW)
*
* Called by <USER>
*
*  Author  : R.Brun DD/US/PD
*  Written : 01.04.86
*  Last mod: 14.09.93 No longer force exchange mode for LINUX
*          : 09.03.94 S.Banerjee (Change in cycle structure)
*          : 30.01.95 J.Shiers. Permit nrecp>65000 for new format
*          : 10.12.97 P.Nevski  Default is NEW
************************************************************************
*
+SEQ,ZUNIT.
+SEQ,ZSTATE.
+SEQ,RZCL,RZDIR,RZCLUN,RZK,RZCYCLE.
+SELF,IF=QMVAX.
      CHARACTER*16 CHORG
+SELF
      CHARACTER    CHOPT*(*),CHDIR*(*),CHFORM*(*)
      CHARACTER*16 CHTOP
      CHARACTER*(*)  CHTAG(*)
      DIMENSION    IOPTV(6),IHDIR(2)
      EQUIVALENCE (IOPTM,IOPTV(1)), (IOPTX,IOPTV(2))
     +,           (IOPTF,IOPTV(3)), (IOPTC,IOPTV(4))
     +,           (IOPTN,IOPTV(5)), (IOPTO,IOPTV(6))
*
*-----------------------------------------------------------------------
*
+SEQ,Q$JBIT.
      IQUEST(1)=0
      LOGLV = MIN(NQLOGD,4)
      LOGLV = MAX(LOGLV,-3)
      LUNP  = LUNIN
*
      CALL UOPTC(CHOPT,'MXFCNO',IOPTV)
+SELF,IF=-QCFIO.
      IF(IOPTC.NE.0) THEN
         WRITE(IQPRNT,*) 'RZMAKE. option C ignored - valid only ',
     +      'for MSDOS, Unix and VMS systems'
         IOPTC = 0
      ENDIF
+SELF.
      IOPTN =1-IOPTO
      IMODEX=IOPTX
      IMODEC=IOPTC
      IF(IOPTC.NE.0) LUNP = IQUEST(11)
+SELF,IF=FQXISN.
      IMODEX=1
+SELF,IF=QMLNX.
C     RZfile maked always with Exchange mode for LINUX
*     IMODEX=1
+SELF.
      IRELAT=0
*
*                Check NWKEY and NRECP
*
      IF(NWKEY.LE.0.OR.NWKEY.GT.KNMAX)THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9010)
 9010    FORMAT(' RZMAKE. NWKEY input value is invalid')
         IQUEST(1) =1
         IQUEST(11)=NWKEY
         GO TO 99
      ENDIF
      IF(NRECP.LT.2.OR.(NRECP.GT.65000.AND.IOPTN.EQ.0))THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9011)
 9011    FORMAT(' RZMAKE. NRECP input value is invalid')
         IQUEST(1) =1
         IQUEST(11)=NRECP
         GO TO 99
      ENDIF
*
*          Save existing material (if any)
*
      CALL RZSAVE
*
*            Find record length (as specified in the OPEN statement)
*
*          A, Memory option. LUN contains the buffer address
*                            and the value of LUNP is the block length
*
      IF(IOPTM.NE.0)THEN
         LRECP=LUNP
         IF(LRECP.LT.100.OR.LRECP.GT.10000)LRECP=1024
      ELSE
*
*          B, Standard option DISK. Use information as specified
*             in the Fortran OPEN statement
*
          IF(IOPTC.EQ.0) THEN
+SELF,IF=-QMVAX,IF=-QMVDS.
            INQUIRE(UNIT=LUNP,RECL=LRECB)
+SELF,IF=QMVDS.
            LRECB=4096
+SELF,IF=QMVAX.
            INQUIRE(UNIT=LUNP,RECL=LRECB,ORGANIZATION=CHORG)
            IF(CHORG.EQ.'RELATIVE')IRELAT=1
+SELF.
*
+SELF,IF=RZBYTES.
            LRECP=LRECB/4
+SELF,IF=-RZBYTES.
            LRECP=LRECB
+SELF,IF=QMCRY,QMCV64.
            IF(IOPTX.EQ.0) THEN
               LRECP=LRECB/8
            ELSE
               LRECP=LRECB/4
            ENDIF
+SELF.
         ELSE
*
*     Take LRECL from IQUEST(10) in case of C I/O option
*
            LRECP = IQUEST(10)
         ENDIF
      ENDIF
*
      LUN = LUNP
      IZRECL = LRECP
      IF(LUN.LE.0.AND.IOPTM.EQ.0)THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9012)
 9012    FORMAT(' RZMAKE. LUN input value is invalid')
         IQUEST(1) =1
         IQUEST(11)=LUN
         GO TO 99
      ENDIF
      IF(LRECP.LT.50)THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9013)
 9013    FORMAT(' RZMAKE. LRECP input value less than 50')
         IQUEST(1) =1
         IQUEST(11)=LRECP
         GO TO 99
      ENDIF
      IF(LOGLV.GE.0) WRITE(IQLOG,9014) LUNP,LRECP,CHOPT
 9014 FORMAT(' RZMAKE. Unit ',I6,' Initializing with LREC=',I6,
     +', OPT= ',A)
      CALL MZSDIV (0,-7)
*
*           Check if LUN not already defined
*
      LRZ=LQRS
  10  IF(LRZ.NE.0)THEN
         IF(IQ(KQSP+LRZ-5).EQ.LUN)THEN
            IF(LOGLV.GE.-2) WRITE(IQLOG,9015)
 9015       FORMAT(' RZMAKE. Logical unit number already in use')
            IQUEST(1) =1
            IQUEST(11)=LUN
            GO TO 99
         ELSE
            LRZ=LQ(KQSP+LRZ)
            GO TO 10
         ENDIF
      ENDIF
*
*            First call to RZMAKE, create link area
*
      IF(LQRS.EQ.0)THEN
         CALL MZLINK(JQPDVS,'RZCL',LTOP,LTOP,LFROM)
         CALL MZBOOK(JQPDVS,LRZ0,LQRS,1,'RZ0 ',2,2,36,2,0)
         IQ(KQSP+LRZ0-5)=0
         ISAVE = 1
         NHPWD = 0
         CALL VBLANK(IHPWD,2)
      ENDIF
      NCHD  = LEN(CHDIR)
      IF(NCHD.GT.16)NCHD=16
      CHTOP = CHDIR(1:NCHD)
*
*            Create control bank
*
      IDTIME=0
      CALL RZDATE(IDTIME,IDATE,ITIME,2)
      KTAGS = KKDES+(NWKEY-1)/10+1
      NREC  = NRECP
      LREC  = LRECP
      NWREC = (NREC-1)/32 +1
      NW    = 50+NWREC
      NRD   = (NW-1)/LREC +1
      NWL   = NRD*LREC
      LD    = KTAGS+2*NWKEY
      LB    = LD+NRD+1
      LS    = LB+3+NWREC
      LK    = LS
      LF    = LS
*
      CALL MZBOOK (JQPDVS,LTOP,LQRS,1,'RZ  ',10,9,NWL,2,0)
*
*            Disk or memory
*
      IF(IOPTM.EQ.0)THEN
         IQ(KQSP+LTOP-5) = LUN
*
*            C I/O?
         IF(IOPTC.NE.0) CALL SBIT1(IQ(KQSP+LTOP),5)
      ELSE
         NMEM=IQ(KQSP+LRZ0)+1
         IQ(KQSP+LRZ0)=NMEM
         IQ(KQSP+LTOP-5)=-NMEM
         IF(2*NMEM.GT.IQ(KQSP+LRZ0-1))THEN
            CALL MZPUSH(JQPDVS,LRZ0,0,10,'I')
         ENDIF
         IQ(KQSP+LRZ0+2*NMEM-1)=LOCF(LUNP)-LOCF(IQ(1))+1
         IQ(KQSP+LRZ0+2*NMEM  )=LRECP
         LUN=-NMEM
      ENDIF
*
*            Pre-format file
*
      IF((IOPTF.NE.0).AND.(IOPTM.EQ.0))THEN
         DO 100 I=2,NRECP
  100    CALL RZIODO(LUN,LREC,I,IQ(KQSP+LTOP+1),2)
         IF(IQUEST(1).NE.0)THEN
            IF(LOGLV.GE.-1) WRITE(IQLOG,1000) I-1
 1000       FORMAT(' RZMAKE. Could only pre-format',I6,' records')
            IQUEST(1)=0
         ENDIF
      ENDIF
*
*            Write empty record for locks
*
      CALL RZIODO(LUN,LREC,1,IQ(KQSP+LTOP+1),2)
      IF(IQUEST(1).NE.0) GO TO 99
*
*            Build top-directory parameters
*
      CALL SBIT1(IQ(KQSP+LTOP),2)
      CALL VBLANK(IQ(KQSP+LTOP+1),4)
      CALL UCTOH(CHDIR,IQ(KQSP+LTOP+1),4,NCHD)
      CALL ZHTOI(IQ(KQSP+LTOP+1),IQ(KQSP+LTOP+1),4)
+SELF,IF=QMVAX.
*
*             Set ORGANIZATION type
*
      IF(IRELAT.NE.0)CALL SBIT1(IQ(KQSP+LTOP),4)
+SELF.
*
      NHPWD = 0
      CALL VBLANK(IHPWD,2)
      CALL UCOPY(IHPWD,IQ(KQSP+LTOP+KPW1),2)
      IQ(KQSP+LTOP+KPW1+2) = NCHD
      IF(IMODEX.GT.0)THEN
         CALL SBIT1(IQ(KQSP+LTOP+KPW1+2),12)
      ENDIF
      IQ(KQSP+LTOP+KDATEC) = IDTIME
      IQ(KQSP+LTOP+KDATEM) = IDTIME
      IQ(KQSP+LTOP+KQUOTA) = NREC
      IQ(KQSP+LTOP+KRUSED) = NRD
      IQ(KQSP+LTOP+KWUSED) = NWL
      IF (IOPTN.NE.0) THEN
        WRITE(IQLOG,7001) CHDIR
 7001   FORMAT(10x,'RZMAKE. new RZ format selected for ',a)
*     +        10x,'This file will not be readable with versions',
*     +            ' of RZ prior to release 94B')
        IQ(KQSP+LTOP+KRZVER) = 1
      ELSE
        WRITE(IQLOG,7007)
 7007 FORMAT(10x,'RZMAKE. OLD RZ format selected for ',a/,
     +       10x,'This file will have the limit on the number of',
     +           ' blocks < 64 K')
        IQ(KQSP+LTOP+KRZVER) = 0
      ENDIF
      IQ(KQSP+LTOP+KIP1)   = 2
      IQ(KQSP+LTOP+KNFREE) = NWL-LF
      IQ(KQSP+LTOP+KLD)    = LD
      IQ(KQSP+LTOP+KLB)    = LB
      IQ(KQSP+LTOP+KLS)    = LS
      IQ(KQSP+LTOP+KLK)    = LK
      IQ(KQSP+LTOP+KLF)    = LF
      IQ(KQSP+LTOP+KLC)    = NWL+1
      IQ(KQSP+LTOP+KLE)    = NWL
      IQ(KQSP+LTOP+KNWKEY) = NWKEY
      IQ(KQSP+LTOP+LD)     = NRD
      IQ(KQSP+LTOP+LB)     = NWREC
      IQ(KQSP+LTOP+LB+1)   = LREC
      IQ(KQSP+LTOP+LB+2)   = IDTIME
*
      NCHF=LEN(CHFORM)
      NCH =LEN(CHTAG(1))
      IF(NCH.GT.8)NCH=8
      DO 20 I=1,NWKEY
         IF(NCH.LT.8)CALL VBLANK(IHDIR,2)
         CALL UCTOH(CHTAG(I),IHDIR,4,NCH)
         CALL UCOPY(IHDIR,IQ(KQSP+LTOP+KTAGS+2*(I-1)),2)
         IFORM=2
         IF(I.LE.NCHF)THEN
            IF(CHFORM(I:I).EQ.'B')IFORM=1
            IF(CHFORM(I:I).EQ.'H')IFORM=3
            IF(CHFORM(I:I).EQ.'A')IFORM=4
         ENDIF
         IKDES=(I-1)/10
         IKBIT1=3*I-30*IKDES-2
         CALL SBYT(IFORM,IQ(KQSP+LTOP+KKDES+IKDES),IKBIT1,3)
  20  CONTINUE
      CALL ZHTOI(IQ(KQSP+LTOP+KTAGS),IQ(KQSP+LTOP+KTAGS),2*NWKEY)
      DO 30 I=1,NRD
         IQ(KQSP+LTOP+LD+I)=I+1
         CALL SBIT1(IQ(KQSP+LTOP+LB+3),I+1)
  30  CONTINUE
*
*            Store default LOG level
*
      LOGL = LOGLV + 3
      CALL SBYT(LOGL,IQ(KQSP+LTOP),15,3)
      CALL RZVCYC(LTOP)
*
*            Allocate free records
*
      CALL MZBOOK(JQPDVS,LFREE,LTOP,-2,'RZFR',0,0,3,2,0)
      IQ(KQSP+LFREE-5)=LUN
      IQ(KQSP+LFREE+1)=1
      IQ(KQSP+LFREE+2)=NRD+2
      IQ(KQSP+LFREE+3)=NREC
*
*            Allocate space for used records
*
      CALL MZBOOK(JQPDVS,LUSED,LTOP,-3,'RZUS',0,0,21,2,0)
*
      IQ(KQSP+LUSED-5)=LUN
      LRIN  = 0
      LPURG = 0
      LROUT = 0
      LCDIR = LTOP
      NLCDIR= 1
      NLNDIR= 1
      NLPAT = 1
      CHCDIR(1)=CHTOP
      CHNDIR(1)=CHTOP
      IQUEST(1)=0
*
+SELF, IF=HPUX. prevent warning "not used"
      I=IBITS(1,1,1)
+SELF.
  99  RETURN
      END
+DECK,RZFILE
*CMZ :          18/03/98  17.12.00  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZFILE(LUNIN,CHDIR,CHOPT)
*
************************************************************************
*
*           Routine to access an already existing RZ file
*           To create a new RZ file routine RZMAKE should be used
* Input:
*   LUNP    Logical unit number associated with  the RZ file.   A FORTRAN
*           OPEN statement must precede the call to RZFILE.
*           Starting address of the memory area which will contain the RZ
*           information ('M' option)
*   CHDIR   Character variable specifying  the name of the  top directory
*           to be associated with unit LUN.
*   CHOPT   Character variable specifying the selected options.
*           medium
*          default
*                   Disk
*             'M'   Memory mode
*                   In this case space has already been allocated starting
*                   at address LUNP.
*           other
*             'U'   UPDATE mode  default is READ mode only
*             'S'   SHARED mode  default is exclusive access
*             '1'   UPDATE mode  with only one user (no LOCKs required)
*             'L'   Show all locked directories and lock-ids
*             'D'   Reset LOCKing word in first record
*             'C'   C I/O
*             'H'   Hook user routine to RZIODO
*             'X'   Exchange mode file
*
*             'B'   Rebuild bit map of file occupancy from file itself
*
* Called by <USER>
*
*  Author  : R.Brun DD/US/PD
*  Written : 07.04.86
*  Last mod: 22.09.94 JDS - include Z=RZCYCLE and call to RZVCYC
*            18.03.98 PN  - IZRECL assignment moved later to avoid warnings
*
************************************************************************
*
+SEQ,ZUNIT,ZSTATE.
+SEQ,RZCL,RZDIR,RZCLUN,RZK,RZCKEY,RZCYCLE.
+CDE,RZBUFF.
+SELF,IF=QMVAX.
      CHARACTER*16 CHORG
+SELF
      CHARACTER    CHOPT*(*),CHDIR*(*)
      CHARACTER*16 CHTOP
      DIMENSION    IOPTV(10)
      EQUIVALENCE (IOPTM,IOPTV(1)), (IOPTU,IOPTV(2))
      EQUIVALENCE (IOPTS,IOPTV(3)), (IOPTL,IOPTV(4))
      EQUIVALENCE (IOPT1,IOPTV(5)), (IOPTD,IOPTV(6))
      EQUIVALENCE (IOPTC,IOPTV(7)), (IOPTX,IOPTV(8))
      EQUIVALENCE (IOPTB,IOPTV(9)), (IOPTH,IOPTV(10))
*
*-----------------------------------------------------------------------
*
+SEQ,Q$JBIT.
      IQUEST(1)=0
      LOGLV = MIN(NQLOGD,4)
      LOGLV = MAX(LOGLV,-3)
      LUNSA = LUN
      LUNP  = LUNIN
*
*          Save existing material (if any)
*
      CALL RZSAVE
*
      CALL UOPTC (CHOPT,'MUSL1DCXBH',IOPTV)
+SELF,IF=-QCFIO.
*SELF,IF=-QMCRY,IF=-QMVAX,IF=-QMCV64,IF=-QMAPO,IF=-QMAPO9,IF=-QMUIX,IF=-QMDOS.
      IF(IOPTC.NE.0) THEN
         WRITE(IQPRNT,*) 'RZFILE. option C ignored - valid only ',
     +      'for MSDOS, Unix and VMS systems'
         IOPTC = 0
       ENDIF
+SELF.
      IRELAT=0
      IMODEC=IOPTC
      IMODEH=IOPTH
      IMODEX=IOPTX
+SELF,IF=QMLNX.
C     RZfile always with Exchange mode for LINUX
*     IMODEX=1
+SELF.
*
*     Take LRECL and LUNP from IQUEST(10-11) in case of C I/O
*
      IF(IOPTC.NE.0) THEN
         LRECP = IQUEST(10)
         LUNP  = IQUEST(11)
      ENDIF
*
*     Take LRECL and address of user routine from IQUEST(10-11)
*     in case of user I/O routine
*
      IF(IOPTH.NE.0) THEN
         LRECP  = IQUEST(10)
         LUN    = IQUEST(11)
         LUSER  = LUNIN
      ENDIF
*
*            Find record length (as specified in the OPEN statement)
*
*          A, Memory option. LUN contains the buffer address
*                            and the value of LUNP is the block length
*
      IF(IOPTM.NE.0)THEN
         LRECP=1024
         LUN=-99
      ELSEIF(IOPTH.EQ.0) THEN
*
*          B, Standard option DISK. Use information as specified
*             in the Fortran OPEN statement
*
+SELF,IF=QMVAX.
         IF(IOPTC.EQ.0) THEN
            INQUIRE(UNIT=LUNP,ORGANIZATION=CHORG)
            IF(CHORG.EQ.'RELATIVE')IRELAT=1
         ENDIF
+SELF.
*
         IZRECL=LRECP
         CALL RZIODO(LUNP,50,2,ITEST,1)
*
*      If option X not specified, determine mode (eXchange, native)
*      from file
*
         IF(IOPTX.EQ.0) THEN
+SELF,IF=QMVAX,QMVMI,QMDOS,QMLNX.
            CALL VXINVB(ITEST(9),1)
+SELF.
            IF(JBIT(ITEST(9),12).NE.0)THEN
               IMODEX=1
+SELF,IF=QMVAX,QMVMI,QMDOS,QMLNX.
               CALL RZIODO(LUNP,50,2,ITEST,1)
            ELSE
               CALL VXINVB(ITEST(9),1)
+SELF.
            ENDIF
         ENDIF
 
         IF(IQUEST(1).NE.0)GO TO 30
         LB=ITEST(KLB)
         IF(LB.GT.48)CALL RZIODO(LUNP,LB+6,2,ITEST,1)
         IF(LB.GT.100)THEN
            IF(LOGLV.GE.-1) WRITE(IQLOG,10000)
10000       FORMAT(' RZFILE. WARNING!! Top directory is big')
         ENDIF
         LRECP=ITEST(LB+1)
+SELF,IF=QMALT,QMAPO,QMDOS.
         IF(IOPTC.EQ.0.AND.IOPTH.EQ.0) THEN
            INQUIRE(UNIT=LUNP,RECL=LRECL)
+SELF,IF=QF_DEC,IF=QMDOS. DEC Fortran takes "longword" units
            IF(LRECP.NE.LRECL)THEN
+SELF,IF=QMALT,QMAPO,QMDOS,IF=-QF_DEC.
            IF(LRECP.NE.LRECL/4)THEN
+SELF,IF=QMALT,QMAPO,QMDOS.
               IQUEST(1)=1
               IF(LOGLV.GE.-2) WRITE(IQLOG,10100)LUNP,LRECP,LRECL/4
10100          FORMAT(' RZFILE. Unit ',I6,'RECL on file ',I5,
     +                ' incompatible with RECL in OPEN =',I5)
               GO TO 30
            ENDIF
         ENDIF
+SELF.
         LUN=LUNP
         IQUEST(1)=0
      ENDIF
*
      IZRECL=LRECP
      IF(LOGLV.GE.0) WRITE(IQLOG,10200) LUN,LRECP,CHOPT
10200 FORMAT(' RZFILE. UNIT ',I6,' Initializing with LREC=',I6,
     +', OPT= ',A)
      CALL MZSDIV (0,-7)
*
*           Check if LUN not already defined
*
      LRZ=LQRS
   10 IF(LRZ.NE.0)THEN
         IF(IQ(KQSP+LRZ-5).EQ.LUN)THEN
            IQUEST(1)=1
            IF(LOGLV.GE.-2) WRITE(IQLOG,10300)
10300       FORMAT(' RZFILE. Unit is already in use')
            LUN=LUNSA
            GO TO 30
         ELSE
            LRZ=LQ(KQSP+LRZ)
            GO TO 10
         ENDIF
      ENDIF
*
*            First call to RZFILE, create link area
*
      IF(LQRS.EQ.0)THEN
         CALL MZLINK(JQPDVS,'RZCL',LTOP,LTOP,LFROM)
         CALL MZBOOK (JQPDVS,LRZ0,LQRS,1,'RZ0 ',2,2,36,2,0)
         IQ(KQSP+LRZ0-5)=0
         ISAVE = 1
         NHPWD = 0
         CALL VBLANK(IHPWD,2)
      ENDIF
      NCHD  = LEN(CHDIR)
      IF(NCHD.GT.16)NCHD=16
      CHTOP = CHDIR(1:NCHD)
*
*            Create control bank
*
      CALL MZBOOK(JQPDVS,LTOP,LQRS,1,'RZ  ',10,9,LRECP,2,0)
*
*            Disk or memory
*
      IF(IOPTM.EQ.0)THEN
         IQ(KQSP+LTOP-5) = LUN
*
*            C I/O?
*
         IF(IOPTC.NE.0) CALL SBIT1(IQ(KQSP+LTOP),5)
*
*            user I/O?
*
         IF(IOPTH.NE.0) THEN
            CALL SBIT1(IQ(KQSP+LTOP),6)
            CALL SBYT(LUSER,IQ(KQSP+LTOP),7,7)
         ENDIF
      ELSE
         NMEM=IQ(KQSP+LRZ0)+1
         IQ(KQSP+LRZ0)=NMEM
         IQ(KQSP+LTOP-5)=-NMEM
         IF(2*NMEM.GT.IQ(KQSP+LRZ0-1))THEN
            CALL MZPUSH(JQPDVS,LRZ0,0,10,' ')
         ENDIF
         IQ(KQSP+LRZ0+2*NMEM-1)=LOCF(LUNP)-LOCF(IQ(1))+1
         IQ(KQSP+LRZ0+2*NMEM  )=LRECP
         LUN=-NMEM
      ENDIF
*
*            Read 1st record of directory
*
      CALL RZIODO(LUN,LRECP,2,IQ(KQSP+LTOP+1),1)
      IF(IQUEST(1).NE.0)GO TO 30
      LD   = IQ(KQSP+LTOP+KLD)
      LB   = IQ(KQSP+LTOP+KLB)
      LREC = IQ(KQSP+LTOP+LB+1)
      NRD  = IQ(KQSP+LTOP+LD)
+SELF,IF=FQXISN.
*
*     Set exchange mode bit
*
      CALL SBIT1(IQ(KQSP+LTOP+KPW1+2),12)
+SELF.
      IMODEX=JBIT(IQ(KQSP+LTOP+KPW1+2),12)
*
*            Increase size of control bank if required
*            and read all records for top directory
*
      NPUSH=NRD*LREC-LRECP
      IF(NPUSH.NE.0)CALL MZPUSH(JQPDVS,LTOP,0,NPUSH,'I')
      DO 20 I=2,NRD
         CALL RZIODO(LUN,LREC,IQ(KQSP+LTOP+LD+I),
     +               IQ(KQSP+LTOP+(I-1)*LREC+1),1)
         IF(IQUEST(1).NE.0)GO TO 30
   20 CONTINUE
      CALL VBLANK(IQ(KQSP+LTOP+1),4)
      CALL UCTOH(CHDIR,IQ(KQSP+LTOP+1),4,NCHD)
      CALL ZHTOI(IQ(KQSP+LTOP+1),IQ(KQSP+LTOP+1),4)
      CALL SBYT(NCHD,IQ(KQSP+LTOP+KPW1+2),1,5)
      CALL UCOPY(IQ(KQSP+LTOP+KPW1),IHPWD,2)
      NHPWD=JBYT(IQ(KQSP+LTOP+KPW1+2),6,5)
      IQ(KQSP+LTOP+KIRIN)=0
      IQ(KQSP+LTOP+KIROUT)=0
+SELF,IF=NOTNEW.
*
*     Check that the file is not in the NEW format
*
      IF (IQ(KQSP+LTOP+KRZVER).NE.0) THEN
         CALL ZFATAM
     +      (' RZFILE. file cannot be processed by this version of RZ')
      ENDIF
+SELF.
 
      LFREE = 0
      LUSED = 0
      LRIN  = 0
      LPURG = 0
      LROUT = 0
      LCDIR = LTOP
      NLCDIR= 1
      NLNDIR= 1
      NLPAT = 1
      CHCDIR(1)=CHTOP
      CHNDIR(1)=CHTOP
*
*             Reset LOCKing word in record 1
*
      IF(IOPTD.NE.0)THEN
         CALL RZDLOK
      ENDIF
*
*             Show locks
*
      IF(IOPTL.NE.0)THEN
         CALL RZLLOK
      ENDIF
+SELF,IF=QMVAX.
*
*             Set ORGANIZATION type
*
      IF(IRELAT.NE.0)THEN
         UNLOCK(UNIT=LUN)
         CALL SBIT1(IQ(KQSP+LTOP),4)
      ENDIF
+SELF.
*
*            Store default LOG level
*
      LOGL = LOGLV + 3
      CALL SBYT(LOGL,IQ(KQSP+LTOP),15,3)
      CALL RZVCYC(LTOP)
*
*     Rebuild bit map?
*
      IF(IOPTB.NE.0) CALL RZVERI('//'//CHTOP(1:NCHD),'B')
*
*             UPDATE mode only
*
      CALL SBIT1(IQ(KQSP+LTOP),1)
      IF(IOPTU.NE.0.OR.IOPT1.NE.0)THEN
*
*            Allocate free records
*
         CALL SBIT0(IQ(KQSP+LTOP),1)
         CALL MZBOOK(JQPDVS,LFREE,LTOP,-2,'RZFR',0,0,21,2,0)
         IQ(KQSP+LFREE-5)=LUN
*
*        IF(IOPTU.EQ.0.AND.IOPT1.EQ.0)THEN
         IF(IOPTS.EQ.0)THEN
            CALL SBIT1(IQ(KQSP+LTOP),3)
            CALL RZLOCK('RZFILE')
            IF(IQUEST(1).NE.0)THEN
               CALL SBIT1(IQ(KQSP+LTOP),1)
               IQ1=IQUEST(1)
               CALL MZDROP(JQPDVS,LFREE,' ')
               LFREE=0
               IQUEST(1)=2+IQ1
               GO TO 30
            ENDIF
         ELSE
            CALL SBIT0(IQ(KQSP+LTOP),3)
         ENDIF
*
*            Allocate space for used records
*
         CALL MZBOOK(JQPDVS,LUSED,LTOP,-3,'RZUS',0,0,21,2,0)
         IQ(KQSP+LUSED-5)=LUN
      ENDIF
      IQUEST(7)=IQ(KQSP+LCDIR+KNKEYS)
      IQUEST(8)=IQ(KQSP+LCDIR+KNWKEY)
*
   30 RETURN
      END
+DECK,RZLOGL
*CMZ :          18/03/98  17.23.05  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZLOGL(LUN,LOGLEV)
*
************************************************************************
*
*        To set the LOG level
* Input:
*   LUN     Logical unit number for which the logging level has to be set
*   LOGLEV  Logging level
*           -3  Suppress all messages
*           -2  Error messages only
*           -1  Terse logging
*            0  Normal logging: RZFILE, RZEND
*            1  Log to watch rare events
*            2  Log to monitor calls
*            3  Short diagnostics
*               Short dumps to debug user-written output routines
*            4  Full diagnostics
*               Full dumps to debug user-written output routines
*
* Called by <USER>
*
*  Author  : R.Brun DD/US/PD
*  Written : 01.04.86
*  Last mod: 17.11.92 JDS - restrict loglevel to documented range
*                     so that only 3 bits are required to store it (15-17)
*            18.03.98 PN  - NQLOGD is really used in RZ package...
*
************************************************************************
+SEQ,ZUNIT.
+SEQ,ZSTATE.
+SEQ,RZCL.
*-----------------------------------------------------------------------
*
      NQLOGD = LOGLEV
*
      IQUEST(1)=0
      IF(LQRS.EQ.0)GO TO 99
      LRZ=LQRS
  10  IF(LRZ.EQ.0)GO TO 99
      IF(IQ(KQSP+LRZ-5).NE.LUN)THEN
         LRZ=LQ(KQSP+LRZ)
         GO TO 10
      ENDIF
*
      LOGL = MIN(LOGLEV,4)
      LOGL = MAX(LOGL, -3) + 3
      CALL SBYT(LOGL,IQ(KQSP+LRZ),15,3)
      IF(LOGLEV.GE.0)WRITE(IQLOG,9022)LUN,LOGLEV
 9022 FORMAT(' RZLOGL.  File at LUN=',I6,', Diagnostic log level=',I2)
*
  99  RETURN
      END
+PATCH,HADR,if=hadr.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
+KEEP,MXGKGH.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      PARAMETER (MXGKGH=100)
+KEEP,/BLANKP.       *** NVE 09-FEB-1988 ***
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      PARAMETER (MXGKPV=MXGKGH)
      COMMON /VECUTY/ PV(10,MXGKPV)
+KEEP,/CONSTS.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      COMMON/CONSTS/ PI,TWPI,PIBTW,MP,MPI,MMU,MEL,MKCH,MK0,SMP,SMPI,
     $               SMU,CT,CTKCH,CTK0,
     $               ML0,MSP,MS0,MSM,MX0,MXM,CTL0,CTSP,CTSM,CTX0,CTXM,
     $               RMASS(35),RCHARG(35)
C
                     REAL MP,MPI,MMU,MEL,MKCH,MK0,
     *                    ML0,MSP,MS0,MSM,MX0,MXM
C
+KEEP,/EVENT.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      PARAMETER (MXEVEN=12*MXGKGH)
      COMMON/EVENT / NSIZE,NCUR,NEXT,NTOT,EVE(MXEVEN)
C
+KEEP,/PRNTFL.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      COMMON/PRNTFL/INBCD,NEWBCD,INBIN,NEWBIN,NPEVT,NEVTP,LPRT,NPRT(10)
                    LOGICAL LPRT,NPRT
+KEEP,PCODIM.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
C --- DIMENSION STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DIMENSION KIPART(48),IKPART(35)
C
+KEEP,PCODAT.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
C --- DATA STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DATA KIPART/
     $               1,   3,   4,   2,   5,   6,   8,   7,
     $               9,  12,  10,  13,  16,  14,  15,  11,
     $              35,  18,  20,  21,  22,  26,  27,  33,
     $              17,  19,  23,  24,  25,  28,  29,  34,
     $              35,  35,  35,  35,  35,  35,  35,  35,
     $              35,  35,  35,  35,  30,  31,  32,  35/
C
      DATA IKPART/
     $               1,   4,   2,   3,   5,   6,   8,   7,
     $               9,  11,  16,  10,  12,  14,  15,  13,
     $              25,  18,  26,  19,  20,  21,  27,  28,
     $              29,  22,  23,  30,  31,  45,  46,  47,
     $              24,  32,  48/
C
+KEEP, DIMPAR
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*                                                                     *
*=== dimpar ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      DIMPAR: included in any routine                                *
*                                                                     *
*          Mxxrgn = maximum number of regions                         *
*          Mxxmdf = maximum number of media in Fluka                  *
*          Mxxmde = maximum number of media in Emf                    *
*          Mfstck = stack dimension in Fluka                          *
*          Mestck = stack dimension in Emf                            *
*          Nallwp = number of allowed particles                       *
*          Mpdpdx = number of particle types for which EM dE/dx pro-  *
*                   cesses (ion,pair,bremss) have to be computed      *
*          Icomax = maximum number of materials for compounds (equal  *
*                   to the sum of the number of materials for every   *
*                   compound )                                        *
*          Nstbis = number of stable isotopes recorded in common iso- *
*                   top                                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( MXXRGN = 500  )
      PARAMETER ( MXXMDF = 50   )
      PARAMETER ( MXXMDE = 18   )
      PARAMETER ( MFSTCK = 1000 )
      PARAMETER ( MESTCK = 100  )
      PARAMETER ( NALLWP = 39   )
      PARAMETER ( MPDPDX = 8    )
      PARAMETER ( ICOMAX = 120  )
      PARAMETER ( NSTBIS = 304  )
+KEEP, PAPROPT
*CMZ :          16/12/97  14.05.33  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
      DOUBLE PRECISION AM, AMDISC, THALF,BIASDC, BIASIN
 
+KEEP, PAPROP
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== paprop ===========================================================*
*
*----------------------------------------------------------------------*
*     include file: paprop copy                   created 26/11/86 by p*
*     changes: on  16 december 1992 by Alfredo Ferrari                 *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /paprop/ contains particle properties                            *
*        btype  = literal name of the particle                         *
*        am     = particle mass in gev                                 *
*        ichrge = electric charge of the particle                      *
*        iscore = explanations for the scored distribution             *
*        genpar = names of the generalized particles                   *
*        ijdisc = list of the particle types to be discarded           *
*        thalf  = half life of the particle in sec                     *
*        biasdc = decay biasing factors                                *
*        biasin = inelastic interaction biasing factors                *
*        lhadro = flag for hadrons                                     *
*        jspinp = particle spin (in units of 1/2)                      *
*        lbsdcy = logical flag for biased decay: if .true. the biasing *
*                 factor is used as an upper limit to the decay length *
*        lprbsd = logical flag for biased decay: if .true. the biasing *
*                 factor is applied only to primaries                  *
*        lprbsi = logical flag for inelastic interaction biasing: if   *
*                 .true. the biasing factor is applied only to prima-  *
*                 ries                                                 *
*                                                                      *
*----------------------------------------------------------------------*
*
      LOGICAL LHADRO, LBSDCY, LPRBSD, LPRBSI
      CHARACTER*8 BTYPE,GENPAR
      COMMON / FKPAPR / AM  (NALLWP), AMDISC (NALLWP), THALF  (NALLWP),
     &               BIASDC (NALLWP), BIASIN (NALLWP), ICHRGE (NALLWP),
     &               ISCORE     (10), IJDISC (NALLWP), LHADRO (NALLWP),
     &               JSPINP (NALLWP), LBSDCY (NALLWP), LPRBSD, LPRBSI
      COMMON / FKCHPR / BTYPE  (NALLWP), GENPAR (30)
 
 
+KEEP, FINUCT
*CMZ :          16/12/97  14.01.37  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
      DOUBLE PRECISION CXR, CYR, CZR, TKI, PLR, WEI, TV, TVCMS,
     &                 TVRECL, TVHEAV, TVBIND
+KEEP, FINUC
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== finuc ============================================================*
*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990     by Alfredo Ferrari, INFN Milan   *
*     include file: finuc copy                   created 26/11/86 by pa*
*     note: if changed change finuc2 copy also                         *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        np        = number of secondaries                             *
*        kpart(ip) = type of the secondary ip                          *
*        cxr(ip)   = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyr(ip)   = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czr(ip)   = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        tki(ip)   = kinetic energy of secondary ip                    *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXR (MXP), CYR (MXP), CZR (MXP), TKI (MXP),
     &                 PLR (MXP), WEI (MXP), TV, TVCMS, TVRECL, TVHEAV,
     &                 TVBIND, NP0, NP, KPART (MXP)
 
+KEEP, COMCONT
*CMZ :          16/12/97  14.15.27  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
      DOUBLE PRECISION AOCMBC, CONTNT, SUMACN, CABINX, CABELX,
     &                 ANXNOR, ELXNOR, CONA13, SUMZMF
*-- Author :    A. Ferrari
+KEEP, COMCON
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== comcon ===========================================================*
*
*----------------------------------------------------------------------*
*                                                                      *
*     include file: comcon copy                 created 26/11/86 by pa *
*                                                                      *
*     Last change  on  30-oct-92   by   Alfredo Ferrari, INFN - Milan  *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /comcon/ contains information about compounds                    *
*         icompl(imat) = number of materials in a compound             *
*         matnum(i)    = material numbers (compounds consist of the    *
*                        materials)                                    *
*         aocmbc(i)    = atomic densities in barn**-1 cm**-1           *
*                        (Atoms Over Cm times Barn for Compounds)      *
*         cona13(i)    = A^1/3 of the constituents                     *
*         sumzmf(i)    = cumulative z^2 for multiple scattering        *
*         contnt(i)    = partial densities                             *
*         sumacn(i)    = cumulative atom contents of the compounds     *
*         cabinx(i)    = cumulative at.cont.*inelastic cross section   *
*         cabelx(i)    = cumulative at.cont.*  elastic cross section   *
*         anxnor       = total inelastic cross section                 *
*         elxnor       = total   elastic cross section                 *
*----------------------------------------------------------------------*
*
      COMMON /FKCOMC/ AOCMBC (ICOMAX), CONA13 (ICOMAX), SUMZMF (ICOMAX),
     &                CONTNT (ICOMAX), SUMACN (ICOMAX), CABINX (ICOMAX),
     &                CABELX (ICOMAX), ANXNOR, ELXNOR,  ICOMPL (MXXMDF),
     &                MATNUM (ICOMAX)
+KEEP, FHEAVYT
*CMZ :          16/12/97  14.01.37  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
      DOUBLE PRECISION CXHEAV, CYHEAV, CZHEAV, TKHEAV, PHEAVY,
     &                 WHEAVY, AMHEAV
+KEEP, FHEAVY
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== fheavy ===========================================================*
*
*----------------------------------------------------------------------*
*     Last change on 9 March 1993     by Alfredo Ferrari, INFN Milan   *
*     include file: fheavy copy       created 5/4/90 by A. Ferrari     *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /fheavy/ is the storage for heavy secondaries created in the     *
*              nuclear evaporation                                     *
*        npheav     = number of secondaries                            *
*        kheavy(ip) = type of the secondary ip                         *
*                   ( 3 = deuteron, 4 = 3-H, 5 = 3-He, 6 = 4-He,       *
*                     7-12 = "Heavy" fragment specified by Ibheav and  *
*                     Icheav )                                         *
*        cxheav(ip) = direction cosine of the secondary ip             *
*                     with respect to x-axis                           *
*        cyheav(ip) = direction cosine of the secondary ip             *
*                     with respect to y-axis                           *
*        czheav(ip) = direction cosine of the secondary ip             *
*                     with respect to z-axis                           *
*        tkheav(ip) = kinetic energy of secondary ip                   *
*        pheavy(ip) = momentum of the secondary ip                     *
*        wheavy(ip) = weight of the secondary ip                       *
*        amheav(ip) = atomic masses of the six types of evaporated     *
*                     particles                                        *
*        anheav(kp) = name of the kp-type heavy particle               *
*        icheav(kp) = charge of the kp-type heavy particle             *
*        ibheav(kp) = mass number of the kp-type heavy particle        *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*   !!! There is now the possibility to produce up to 6 "heavy" !!!!   *
*   !!! fragments besides the residual nucleus recorded in      !!!!   *
*   !!! Resnuc: they are identified by indeces 7-12, of course  !!!!   *
*   !!! the corresponding physical properties (Z,A,m..) must be !!!!   *
*   !!! updated every time they are produced                    !!!!   *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*----------------------------------------------------------------------*
*
      PARAMETER ( MXHEAV = 100 )
      CHARACTER*8 ANHEAV
      COMMON / FKHEAV / CXHEAV (MXHEAV), CYHEAV (MXHEAV),
     &                  CZHEAV (MXHEAV), TKHEAV (MXHEAV),
     &                  PHEAVY (MXHEAV), WHEAVY (MXHEAV),
     &                  AMHEAV  ( 12 ) ,
     &                  KHEAVY (MXHEAV), ICHEAV  ( 12 ) ,
     &                  IBHEAV  ( 12 ) , NPHEAV
      COMMON / FKHEAC / ANHEAV  ( 12 )
 
+KEEP, PART2T
*CMZ :          16/12/97  14.01.37  by  Pavel Nevski
*-- Author :
      DOUBLE PRECISION AAM, GA, TAU, AAMDSC
+KEEP, PART2
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*-- Author :
*
*=== part2 ============================================================*
*
*----------------------------------------------------------------------*
*     Include file: part2 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part3 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AAM  (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AAMDSC (IDMAX8), IICH   (IDMAX8), IIBAR  (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)
+KEEP,camass.
*CMZ :          16/12/97  13.47.10  by  Pavel Nevski
*-- Author :    Christian Zeitnitz
      REAL*4 XMASS(0:11)
      COMMON/CMASS/XMASS
+KEEP,CERRCM
*CMZ :          16/12/97  13.48.36  by  Pavel Nevski
*-- Author :    Christian Zeitnitz
      LOGICAL CERRF
      COMMON/CERRCM/CERRF,IERRU
+KEEP,CALGEA
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  1.04/02 13/02/95  11.09.49  by  Christian Zeitnitz
*-- Author :   Christian Zeitnitz
C***************************************************************
C
C       CALOR-GEANT Interface common
C
C parameters of incident particle :
C                   IPinc   = particle type a la CALOR
C                   Einc    = kinetic energy
C                   Uinc(3) = direction cosines
C material parameters:
C                   NCEL    = number of elements in mixture (NMTC)
C                             GEANT material no. for MICAP
C                   Amed(I) = mass number
C                   Zmed(I) = charge number
C                   Dmed(I) = Atoms/cm**3 * 1E-24
C                   Hden    = Atoms/cm**3 * 1E-24
C                             of H-Atoms in mixture
C
C particle stack:
C            NPHETC           = number of particles
C            Ekinet(1:NPHETC) = kinetic energy of part.
C            IPCAL(1:NPHETC)  = particle type a la CALOR (extended)
C            UCAL(1:NPHETC,3) = direction cosines
C            CALTIM(1:NPHETC) = age of particle (nsec)
C
C            ATARGT = A no. of target nucleus
C            ZTARGT = Z no. of target nucleus
C
C return of residual nucleus information
C            NRECOL  = no. of heavy recoil products
C            Amed(I) = mass number of residual nucleus
C            Zmed(I) = charge number "          "
C            EXmed   = exitation energy of nucleus
C            ERmed(I)= recoil energy of nucleus
C            IntCal  = type of interaction (GEANT NAMEC index)
C return of cross section of hadronic interaction (CALSIG called)
C            SIG =  x-section
C
C set by CALSIG:
C            ICPROC = -1   undefined
C                   =  0   NMTC called for cross-section
C                   =  1   MICAP called for cross-section
C                   =  2   SKALE(NMTC at 3 GeV) called for cross-section
C                   =  3   FLUKA called for cross-section
C            KCALL : same coding as ICPROC, but is only valid after a
C                    call to GCALOR
C       18/8/92  C.Zeitnitz University of Arizona
C****************************************************************
C
      PARAMETER(EMAXP  = 3.495)
      PARAMETER(EMAXPI = 2.495)
C transition upper limit (GeV) NMTC-FLUKA
      PARAMETER(ESKALE = 10.0)
      PARAMETER(MXCP = 300)
C
      COMMON/ CALGEA / IPINC  , EINC       , UINC(3)   ,NCEL        ,
     +                 HDEN   , AMED(100)  , ZMED(100) ,DMED(100)   ,
     +                 NPHETC ,EKINET(MXCP),IPCAL(MXCP),UCAL(MXCP,3),
     +                 INTCAL , EXMED      , ERMED(100),SIG         ,
     +                 CALTIM(MXCP), ICPROC, NRECOL    ,KCALL       ,
     +                 ATARGT , ZTARGT
C
+DECK,FLUFIN.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 19/05/94  13.35.12  by  S.Ravndal
*-- Author :
      SUBROUTINE FLUFIN
+SEQ,GCBANK.
+SEQ,GCCUTS.
+SEQ,GCJLOC.
+SEQ,GCFLAG.
+SEQ,GCKINE.
+SEQ,GCKING.
+SEQ,GCMATE.
+SEQ,GCPHYS.
+SEQ,GCTRAK.
+SEQ,GSECTI.
+SEQ,GCTMED.
+SEQ,GCUNIT.
+SEQ,DIMPAR.
 
+SEQ,FINUCT,IF=-SINGLE
+SEQ,FINUC.
      REAL RNDM(1)
+SELF, IF=-SINGLE
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
+SELF
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
+SEQ,PART2T,IF=-SINGLE
+SEQ,PART2.
+SEQ,COMCONT,IF=-SINGLE
+SEQ,COMCON.
+SEQ,FHEAVYT,IF=-SINGLE
+SEQ,FHEAVY.
+SEQ,PAPROP.
+SEQ,PAPROPT,IF=-SINGLE
+SEQ,GFKDIS.
+SELF, IF=-SINGLE
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
+SELF
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
      NP = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF ((IGF.EQ.1).OR.
     +      (GEKIN.EQ.0..AND.ITRTYP.EQ.3.AND.IPART.NE.25)) THEN
         CALL GHEISH
         IGF = 0
         GOTO 999
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         LMEC(NMEC)=30
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
      ELSE
         ISTOP=1
         NSTAK1 = MIN(NP,MXGKIN-NGKINE)
         IF(NP.GT.NSTAK1) THEN
            WRITE(CHMAIL,10000) NP-NSTAK1
            CALL GMAIL(0,0)
         ENDIF
         DO 90  K=1,NSTAK1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NSTAK2 = MIN(NPHEAV,MXGKIN-NGKINE)
         IF(NPHEAV.GT.NSTAK2) THEN
            WRITE(CHMAIL,10100) NPHEAV-NSTAK2
            CALL GMAIL(0,0)
         ENDIF
         DO 100 K=1,NSTAK2
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
         KCASE=NAMEC(12)
      END IF
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
10000 FORMAT(' **** FLUFIN: Stack overflow, ',I6,' particles lost')
10100 FORMAT(' **** FLUFIN: Stack overflow, ',I6,
     +' heavy particles lost')
  999 END
+DECK,GHEISH.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.38  by  S.Giani
*-- Author :
      SUBROUTINE GHEISH
C
C *** MAIN STEERING FOR HADRON SHOWER DEVELOPMENT ***
C *** NVE 15-JUN-1988 CERN GENEVA ***
C
C CALLED BY : GUHADR (USER ROUTINE)
C ORIGIN : F.CARMINATI, H.FESEFELDT
C                       ROUTINES : CALIM  16-SEP-1987
C                                  SETRES 19-AUG-1985
C                                  INTACT 06-OCT-1987
C
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCCUTS.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTMED.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCUNIT.
C --- GHEISHA COMMONS ---
+CDE,MXGKGH.
+CDE,/BLANKP.
+CDE,/CONSTS.
+CDE,/EVENT.
+CDE,/PRNTFL.
C
C --- "NEVENT" CHANGED TO "KEVENT" IN COMMON /CURPAR/ DUE TO CLASH ---
C --- WITH VARIABLE "NEVENT" IN GEANT COMMON ---
C
      PARAMETER (MXGKCU=MXGKGH)
      COMMON /CURPAR /WEIGHT(10),DDELTN,IFILE,IRUN,NEVT,KEVENT,SHFLAG,
     $                ITHST,ITTOT,ITLST,IFRND,TOFCUT,CMOM(5),CENG(5),
     $                RS,S,ENP(10),NP,NM,NN,NR,NO,NZ,IPA(MXGKCU),
     $                ATNO2,ZNO2
C
C --- "IPART" CHANGED TO "KPART" IN COMMON /RESULT/ DUE TO CLASH ---
C --- WITH VARIABLE "IPART" IN GEANT COMMON ---
C
      COMMON /RESULT/ XEND,YEND,ZEND,RCA,RCE,AMAS,NCH,TOF,PX,PY,PZ,
     $                USERW,INTCT,P,EN,EK,AMASQ,DELTN,ITK,NTK,KPART,IND,
     $                LCALO,ICEL,SINL,COSL,SINP,COSP,
     $                XOLD,YOLD,ZOLD,POLD,PXOLD,PYOLD,PZOLD,
     $                XSCAT,YSCAT,ZSCAT,PSCAT,PXSCAT,PYSCAT,PZSCAT
                      REAL NCH,INTCT
C
C --- "ABSL(21)" CHANGED TO "ABSLTH(21)" IN COMMON /MAT/ DUE TO CLASH ---
C --- WITH VARIABLE "ABSL" IN GEANT COMMON ---
C
      COMMON /MAT/ LMAT,
     $             DEN(21),RADLTH(21),ATNO(21),ZNO(21),ABSLTH(21),
     $             CDEN(21),MDEN(21),X0DEN(21),X1DEN(21),RION(21),
     $             MATID(21),MATID1(21,24),PARMAT(21,10),
     $             IFRAT,IFRAC(21),FRAC1(21,10),DEN1(21,10),
     $             ATNO1(21,10),ZNO1(21,10)
C
      DIMENSION IPELOS(35)
      SAVE IDEOL
C
C --- TRANSFER GEANT CUT-OFFS INTO GHEISHA VALUES ---
      DIMENSION CUTS(5)
      EQUIVALENCE (CUTS(1),CUTGAM)
      DIMENSION RNDM(1)
C
+CDE,PCODIM.
+CDE,PCODAT.
C
C --- DENOTE STABLE PARTICLES ACCORDING TO GHEISHA CODE ---
C --- STABLE : GAMMA, NEUTRINO, ELECTRON, PROTON AND HEAVY FRAGMENTS ---
C --- WHEN STOPPING THESE PARTICLES ONLY LOOSE THEIR KINETIC ENERGY ---
      DATA IPELOS/
     $             1,   1,   0,   1,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   0,   0,
     $             0,   0,   0,   0,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   1,   1,
     $             0,   0,   1/
C
C --- LOWERBOUND OF KINETIC ENERGY BIN IN N CROSS-SECTION TABLES ---
      DATA TEKLOW /0.0001/
C
C --- KINETIC ENERGY TO SWITCH FROM "CASN" TO "GNSLWD" FOR N CASCADE ---
      DATA SWTEKN /0.05/
C
      DATA IDEOL/0/
C
C --- INITIALIZE RELEVANT GHEISHA VARIABLES IN CASE NOT DONE ALREADY ---
      IF (IFINIT(4) .EQ. 0) CALL GHEINI
C
C --- SET THE INTERACTION MECHANISM TO "HADR" ---
      KCASE=NAMEC(12)
C
C --- SET GHEISHA PRINTING FLAGS ACCORDING TO "DEBUG" STEERING CARD --
      IF (IDEOL .EQ. IDEBUG) GO TO 9000
C
      IF (IDEBUG .NE. 1) GO TO 9001
C
C --- SET SELECTED DEBUGGING FLAGS ---
      DO 9002 LL=1,10
      IF ((ISWIT(LL) .LE. 100) .OR. (ISWIT(LL) .GT. 110)) GO TO 9002
      JJ=ISWIT(LL)-100
      NPRT(JJ)=.TRUE.
 9002 CONTINUE
      GO TO 9000
C
C --- NO DEBUGGING SELECTED ---
 9001 CONTINUE
      DO 9003 LL=1,10
      NPRT(LL)=.FALSE.
 9003 CONTINUE
      IDEOL=IDEBUG
C
 9000 CONTINUE
C
C --- SET THE GHEISHA PARTICLE TYPE TO THE ONE OF GEANT ---
      IF(IPART.GT.48) THEN
         IF(ISTOP.EQ.0) GOTO 9999
         JPA = LQ(JPART-IPART)
         AMAS=Q(JPA+7)
         NCH =Q(JPA+8)
         KPART=-IPART
         GOTO 107
      ENDIF
      NETEST=IKPART(KPART)
      IF ((NETEST .EQ. IPART) .OR. (ISTOP .NE. 0)) GO TO 9004
C
      PRINT 8881,IPART,KPART,ISTOP
 8881 FORMAT(' *GHEISH* IPART,KPART = ',2(I3,1X),' ISTOP = ',I3/
     $ ' *GHEISH* ======> PARTICLE TYPES DO NOT MATCH <=======')
      STOP
C
 9004 CONTINUE
      KPART=KIPART(IPART)
      KKPART=KPART
      AMAS=RMASS(KPART)
      NCH=RCHARG(KPART)
C
C --- TRANSPORT THE TRACK NUMBER TO GHEISHA AND INITIALISE SOME NUMBERS
 107  NTK=ITRA
      INTCT=0.0
      NEXT=1
      NTOT=0
      TOF=0.0
C
C --- FILL RESULT COMMON FOR THIS TRACK WITH GEANT VALUES ---
C --- CALIM CODE ---
      XEND=VECT(1)
      YEND=VECT(2)
      ZEND=VECT(3)
      PX=VECT(4)
      PY=VECT(5)
      PZ=VECT(6)
      USERW=UPWGHT
C --- SETRES CODE ---
      P=VECT(7)
      AMASQ=AMAS*AMAS
      EN=SQRT(AMASQ+P*P)
      EK=ABS(EN-ABS(AMAS))
      ENOLD=EN
C
      SINL=0.0
      COSL=1.0
      SINP=0.0
      COSP=1.0
C
      IF (ABS(P) .LE. 1.0E-10) GO TO 1
      SINL=PZ
      COSL=SQRT(ABS(1.0-SINL**2))
C
 1    CONTINUE
      CALL GRNDM(RNDM,1)
      PHI=RNDM(1)*TWPI
      IF ((PX .EQ. 0.0) .AND. (PY .EQ. 0.0)) GOTO 3
      IF (ABS(PX) .LT. 1.E-10) GOTO 2
      PHI=ATAN2(PY,PX)
      GOTO 3
C
 2    CONTINUE
      IF (PY .GT. 0.0) PHI=PI/2.0
      IF (PY .LE. 0.0) PHI=3.0*PI/2.0
C
 3    CONTINUE
      SINP=SIN(PHI)
      COSP=COS(PHI)
C
C --- SET GHEISHA INDEX FOR THE CURRENT MEDIUM ALWAYS TO 1 ---
      IND=1
C
C --- TRANSFER GLOBAL MATERIAL CONSTANTS FOR CURRENT MEDIUM ---
C --- DETAILED DATA FOR COMPOUNDS IS OBTAINED VIA ROUTINE COMPO ---
      ATNO(IND+1)=A
      ZNO(IND+1)=Z
      DEN(IND+1)=DENS
      RADLTH(IND+1)=RADL
      ABSLTH(IND+1)=ABSL
C
C --- SETUP PARMAT FOR PHYSICS STEERING ---
      PARMAT(IND+1,5)=0.0
      PARMAT(IND+1,8)=IPFIS
      PARMAT(IND+1,9)=0.0
      PARMAT(IND+1,10)=0.0
      JTMN=LQ(JTM)
      IF (JTMN .LE. 0) GO TO 4
      PARMAT(IND+1,5)=Q(JTMN+26)
 4    CONTINUE
C
C --- CHECK WHETHER PARTICLE IS STOPPING OR NOT ---
      IF (ISTOP .EQ. 0) GO TO 5
C
      IF (NPRT(9)) PRINT 1000,KPART
 1000 FORMAT(' *GHEISH* STOPPING GHEISHA PARTICLE ',I3)
      CALL GHSTOP
C --- IN CASE OF DECAY OF PARTICLE OR USER PARTICLE ==> RETURN ---
      IF (LMEC(NMEC) .EQ. 5 .OR. KPART .LT. 0) GO TO 9999
C --- IN CASE OF HAD. INT. WITH GENERATION OF SEC. ==> GO TO 40 ---
      IF (IHADR .NE. 2) GO TO 40
C --- ALSO DEPOSIT REST MASS ENERGY FOR IN-STABLE PARTICLES ---
      IF (IPELOS(KPART) .EQ. 0) DESTEP=DESTEP+ABS(RMASS(KPART))
      GO TO 9999
  5   CONTINUE
C
C --- INDICATE LIGHT (<= PI) AND HEAVY PARTICLES (HISTORICALLY) ---
C --- CALIM CODE ---
      J=2
      TEST=RMASS(7)-0.001
      IF (ABS(AMAS) .LT. TEST) J=1
C
C *** DIVISION INTO VARIOUS INTERACTION CHANNELS DENOTED BY "INT" ***
C THE CONVENTION FOR "INT" IS THE FOLLOWING
C
C INT  = -1 REACTION CROSS SECTIONS NOT YET TABULATED/PROGRAMMED
C      =  0 NO INTERACTION
C      =  1 ELEASTIC SCATTERING
C      =  2 INELASTIC SCATTERING
C      =  3 NUCLEAR FISSION WITH INELEASTIC SCATTERING
C      =  4 NEUTRON CAPTURE
C
C --- INTACT CODE ---
      KK=ABS(Q(JMA+11))
      ALAM1=0.0
      CALL GRNDM(RNDM,1)
      RAT=RNDM(1)*ALAM
      NMEC=NMEC+1
      ATNO2=A
      ZNO2 =Z
C
      DO 6 K=1,KK
      IF (KK .LE. 0) GO TO 6
C
      IF (KK .EQ. 1) GO TO 7
      ATNO2=Q(JMIXT+K)
      ZNO2 =Q(JMIXT+K+KK)
C
 7    CONTINUE
C
C --- TRY FOR ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
      ALAM1=ALAM1+AIEL(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR INELASTIC SCATTERING ---
      INT=2
      LMEC(NMEC)=20
      ALAM1=ALAM1+AIIN(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NUCLEAR FISSION WITH INELASTIC SCATTERING ---
      INT=3
      LMEC(NMEC)=15
      ALAM1=ALAM1+AIFI(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NEUTRON CAPTURE ---
      INT=4
      LMEC(NMEC)=18
      ALAM1=ALAM1+AICA(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
 6    CONTINUE
C --- NO REACTION SELECTED ==> ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
C
C *** TAKE ACTION ACCORDING TO SELECTED REACTION CHANNEL ***
C --- FOLLOWING CODE IS A TRANSLATION OF "CALIM" INTO GEANT JARGON ---
C
 8    CONTINUE
      IF (NPRT(9)) PRINT 1001,INT
 1001 FORMAT(' *GHEISH* INTERACTION TYPE CHOSEN INT = ',I3)
C
C --- IN CASE OF NO INTERACTION OR UNKNOWN CROSS SECTIONS ==> DONE ---
      IF (INT .LE. 0) GO TO 40
C
C --- IN CASE OF NON-ELASTIC SCATTERING AND NO GENERATION OF SEC. ---
C --- PARTICLES DEPOSIT TOTAL PARTICLE ENERGY AND RETURN ---
      IF ((INT .EQ. 1) .OR. (IHADR .NE. 2)) GO TO 9
      ISTOP=2
      DESTEP=DESTEP+EN
      NGKINE=0
      GO TO 9999
C
 9    CONTINUE
      IF (INT .NE. 4) GO TO 10
C
C --- NEUTRON CAPTURE ---
      IF (NPRT(9)) PRINT 2000
 2000 FORMAT(' *GHEISH* ROUTINE CAPTUR WILL BE CALLED')
      ISTOP=1
      CALL CAPTUR(NOPT)
      GO TO 40
C
 10   CONTINUE
      IF (INT .NE. 3) GO TO 11
C --- NUCLEAR FISSION ---
      IF (NPRT(9)) PRINT 2001
 2001 FORMAT(' *GHEISH* ROUTINE FISSIO WILL BE CALLED')
      ISTOP=1
      TKIN=FISSIO(EK)
      GO TO 40
C
 11   CONTINUE
C
C --- ELASTIC AND INELASTIC SCATTERING ---
      PV( 1,MXGKPV)=P*PX
      PV( 2,MXGKPV)=P*PY
      PV( 3,MXGKPV)=P*PZ
      PV( 4,MXGKPV)=EN
      PV( 5,MXGKPV)=AMAS
      PV( 6,MXGKPV)=NCH
      PV( 7,MXGKPV)=TOF
      PV( 8,MXGKPV)=KPART
      PV( 9,MXGKPV)=0.
      PV(10,MXGKPV)=USERW
C
C --- ADDITIONAL PARAMETERS TO SIMULATE FERMI MOTION AND EVAPORATION ---
      DO 111 JENP=1,10
         ENP(JENP)=0.
 111  CONTINUE
      ENP(5)=EK
      ENP(6)=EN
      ENP(7)=P
C
      IF (INT .NE. 1) GO TO 12
C
C *** ELASTIC SCATTERING PROCESSES ***
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C --- NORMAL ELASTIC SCATTERING FOR LIGHT MEDIA ---
      IF (ATNO2 .LT. 1.5) GO TO 35
C
C --- COHERENT ELASTIC SCATTERING FOR HEAVY MEDIA ---
      IF (NPRT(9)) PRINT 2002
 2002 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED')
      CALL COSCAT
      GO TO 40
C
C *** NON-ELASTIC SCATTERING PROCESSES ***
 12   CONTINUE
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C *** USE SOMETIMES NUCLEAR REACTION ROUTINE "NUCREC" FOR LOW ENERGY ***
C *** PROTON AND NEUTRON SCATTERING ***
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=4.5*(EK-0.01)
      IF ((KPART .EQ. 14) .AND. (TEST1 .GT. TEST2)) GO TO 85
      IF ((KPART .EQ. 16) .AND. (TEST1 .GT. TEST2)) GO TO 86
C
C *** FERMI MOTION AND EVAPORATION ***
      TKIN=CINEMA(EK)
      PV( 9,MXGKPV)=TKIN
      ENP(5)=EK+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=FERMI(ENP(5))
      ENP(5)=ENP(5)+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=EXNU(ENP(5))
      ENP(5)=ENP(5)-TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
C
C *** IN CASE OF ENERGY ABOVE CUT-OFF LET THE PARTICLE CASCADE ***
      TEST=ABS(CHARGE)
      IF ((TEST .GT. 1.0E-10) .AND. (ENP(5) .GT. CUTHAD)) GO TO 35
      IF ((TEST .LE. 1.0E-10) .AND. (ENP(5) .GT. CUTNEU)) GO TO 35
C
C --- SECOND CHANCE FOR ANTI-BARYONS DUE TO POSSIBLE ANNIHILATION ---
      IF ((AMAS .GE. 0.0) .OR. (KPART .LE. 14)) GO TO 13
      ANNI=1.3*P
      IF (ANNI .GT. 0.4) ANNI=0.4
      CALL GRNDM(RNDM,1)
      TEST=RNDM(1)
      IF (TEST .GT. ANNI) GO TO 35
C
C *** PARTICLE WITH ENERGY BELOW CUT-OFF ***
C --- ==> ONLY NUCLEAR EVAPORATION AND QUASI-ELASTIC SCATTERING ---
 13   CONTINUE
C
      ISTOP=3
C
      IF (NPRT(9)) PRINT 1002,KPART,EK,EN,P,ENP(5),ENP(6),ENP(7)
 1002 FORMAT(' *GHEISH* ENERGY BELOW CUT-OFF FOR GHEISHA PARTICLE ',I3/
     $ ' EK,EN,P,ENP(5),ENP(6),ENP(7) = ',6(G12.5,1X))
C
      IF ((KPART .NE. 14) .AND. (KPART .NE. 16)) GO TO 14
      IF (KPART .EQ. 16) GO TO 86
C
C --- SLOW PROTON ---
 85   CONTINUE
      IF (NPRT(9)) PRINT 2003,EK,KPART
 2003 FORMAT(' *GHEISH* ROUTINE NUCREC WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL NUCREC(NOPT,2)
C
      IF (NOPT .NE. 0) GO TO 50
C
      IF (NPRT(9)) PRINT 2004,EK,KPART
 2004 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL COSCAT
      GO TO 40
C
C --- SLOW NEUTRON ---
 86   CONTINUE
      IF (NPRT(9)) PRINT 2015
      NUCFLG=0
      CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- OTHER SLOW PARTICLES ---
 14   CONTINUE
      IPA(1)=KPART
C --- DECIDE FOR PROTON OR NEUTRON TARGET ---
      IPA(2)=16
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=ZNO2/ATNO2
      IF (TEST1 .LT. TEST2) IPA(2)=14
      AVERN=0.0
      NFL=1
      IF (IPA(2) .EQ. 16) NFL=2
      IPPP=KPART
      IF (NPRT(9)) PRINT 2005
 2005 FORMAT(' *GHEISH* ROUTINE TWOB WILL BE CALLED')
      CALL TWOB(IPPP,NFL,AVERN)
      GOTO 40
C
C --- INITIALISATION OF CASCADE QUANTITIES ---
 35   CONTINUE
C
C *** CASCADE GENERATION ***
C --- CALCULATE FINAL STATE MULTIPLICITY AND LONGITUDINAL AND ---
C --- TRANSVERSE MOMENTUM DISTRIBUTIONS ---
C
C --- FIXED PARTICLE TYPE TO STEER THE CASCADE ---
      KKPART=KPART
C
C --- NO CASCADE FOR LEPTONS ---
      IF (KKPART .LE. 6) GO TO 9999
C
C *** WHAT TO DO WITH "NEW PARTICLES" FOR GHEISHA ?????? ***
C --- RETURN FOR THE TIME BEING ---
      IF (KKPART .GE. 35) GO TO 9999
C
C --- CASCADE OF HEAVY FRAGMENTS
      IF ((KKPART .GE. 30) .AND. (KKPART .LE. 32)) GO TO 390
C
C --- INITIALIZE THE IPA ARRAY ---
      CALL VZERO(IPA(1),MXGKCU)
C
C --- CASCADE OF OMEGA - AND OMEGA - BAR ---
      IF (KKPART .EQ. 33) GO TO 330
      IF (KKPART .EQ. 34) GO TO 331
C
      NVEPAR=KKPART-17
      IF (NVEPAR .LE. 0) GO TO 15
      GO TO (318,319,320,321,322,323,324,325,326,327,328,329),NVEPAR
C
 15   CONTINUE
      NVEPAR=KKPART-6
      GO TO (307,308,309,310,311,312,313,314,315,316,317,318),NVEPAR
C
C --- PI+ CASCADE ---
 307  CONTINUE
      IF (NPRT(9)) PRINT 2006
 2006 FORMAT(' *GHEISH* ROUTINE CASPIP WILL BE CALLED')
      CALL CASPIP(J,INT,NFL)
      GO TO 40
C
C --- PI0 ==> NO CASCADE ---
 308  CONTINUE
      GO TO 40
C
C --- PI- CASCADE ---
 309  CONTINUE
      IF (NPRT(9)) PRINT 2007
 2007 FORMAT(' *GHEISH* ROUTINE CASPIM WILL BE CALLED')
      CALL CASPIM(J,INT,NFL)
      GO TO 40
C
C --- K+ CASCADE ---
 310  CONTINUE
      IF (NPRT(9)) PRINT 2008
 2008 FORMAT(' *GHEISH* ROUTINE CASKP WILL BE CALLED')
      CALL CASKP(J,INT,NFL)
      GO TO 40
C
C --- K0 CASCADE ---
 311  CONTINUE
      IF (NPRT(9)) PRINT 2009
 2009 FORMAT(' *GHEISH* ROUTINE CASK0 WILL BE CALLED')
      CALL CASK0(J,INT,NFL)
      GO TO 40
C
C --- K0 BAR CASCADE ---
 312  CONTINUE
      IF (NPRT(9)) PRINT 2010
 2010 FORMAT(' *GHEISH* ROUTINE CASK0B WILL BE CALLED')
      CALL CASK0B(J,INT,NFL)
      GO TO 40
C
C --- K- CASCADE ---
 313  CONTINUE
      IF (NPRT(9)) PRINT 2011
 2011 FORMAT(' *GHEISH* ROUTINE CASKM WILL BE CALLED')
      CALL CASKM(J,INT,NFL)
      GO TO 40
C
C --- PROTON CASCADE ---
 314  CONTINUE
      IF (NPRT(9)) PRINT 2012
 2012 FORMAT(' *GHEISH* ROUTINE CASP WILL BE CALLED')
      CALL CASP(J,INT,NFL)
      GO TO 40
C
C --- PROTON BAR CASCADE ---
 315  CONTINUE
      IF (NPRT(9)) PRINT 2013
 2013 FORMAT(' *GHEISH* ROUTINE CASPB WILL BE CALLED')
      CALL CASPB(J,INT,NFL)
      GO TO 40
C
C --- NEUTRON CASCADE ---
 316  CONTINUE
      NUCFLG=0
      IF (EK .GT. SWTEKN) THEN
         CALL CASN(J,INT,NFL)
         IF (NPRT(9)) PRINT 2014
 2014 FORMAT(' *GHEISH* ROUTINE CASN WILL BE CALLED')
      ELSE
         CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
         IF (NPRT(9)) PRINT 2015
 2015 FORMAT(' *GHEISH* ROUTINE GNSLWD WILL BE CALLED')
      ENDIF
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- NEUTRON BAR CASCADE ---
 317  CONTINUE
      IF (NPRT(9)) PRINT 2016
 2016 FORMAT(' *GHEISH* ROUTINE CASNB WILL BE CALLED')
      CALL CASNB(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA CASCADE ---
 318  CONTINUE
      IF (NPRT(9)) PRINT 2017
 2017 FORMAT(' *GHEISH* ROUTINE CASL0 WILL BE CALLED')
      CALL CASL0(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA BAR CASCADE ---
 319  CONTINUE
      IF (NPRT(9)) PRINT 2018
 2018 FORMAT(' *GHEISH* ROUTINE CASAL0 WILL BE CALLED')
      CALL CASAL0(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + CASCADE ---
 320  CONTINUE
      IF (NPRT(9)) PRINT 2019
 2019 FORMAT(' *GHEISH* ROUTINE CASSP WILL BE CALLED')
      CALL CASSP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 ==> NO CASCADE ---
 321  CONTINUE
      GO TO 40
C
C --- SIGMA - CASCADE ---
 322  CONTINUE
      IF (NPRT(9)) PRINT 2020
 2020 FORMAT(' *GHEISH* ROUTINE CASSM WILL BE CALLED')
      CALL CASSM(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + BAR CASCADE ---
 323  CONTINUE
      IF (NPRT(9)) PRINT 2021
 2021 FORMAT(' *GHEISH* ROUTINE CASASP WILL BE CALLED')
      CALL CASASP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 BAR ==> NO CASCADE ---
 324  CONTINUE
      GO TO 40
C
C --- SIGMA - BAR CASCADE ---
 325  CONTINUE
      IF (NPRT(9)) PRINT 2022
 2022 FORMAT(' *GHEISH* ROUTINE CASASM WILL BE CALLED')
      CALL CASASM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 CASCADE ---
 326  CONTINUE
      IF (NPRT(9)) PRINT 2023
 2023 FORMAT(' *GHEISH* ROUTINE CASX0 WILL BE CALLED')
      CALL CASX0(J,INT,NFL)
      GO TO 40
C
C --- XI - CASCADE ---
 327  CONTINUE
      IF (NPRT(9)) PRINT 2024
 2024 FORMAT(' *GHEISH* ROUTINE CASXM WILL BE CALLED')
      CALL CASXM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 BAR CASCADE ---
 328  CONTINUE
      IF (NPRT(9)) PRINT 2025
 2025 FORMAT(' *GHEISH* ROUTINE CASAX0 WILL BE CALLED')
      CALL CASAX0(J,INT,NFL)
      GO TO 40
C
C --- XI - BAR CASCADE ---
 329  CONTINUE
      IF (NPRT(9)) PRINT 2026
 2026 FORMAT(' *GHEISH* ROUTINE CASAXM WILL BE CALLED')
      CALL CASAXM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - CASCADE ---
 330  CONTINUE
      IF (NPRT(9)) PRINT 2027
 2027 FORMAT(' *GHEISH* ROUTINE CASOM WILL BE CALLED')
      CALL CASOM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - BAR CASCADE ---
 331  CONTINUE
      IF (NPRT(9)) PRINT 2028
 2028 FORMAT(' *GHEISH* ROUTINE CASAOM WILL BE CALLED')
      CALL CASAOM(J,INT,NFL)
      GO TO 40
C
C --- HEAVY FRAGMENT CASCADE ---
 390  CONTINUE
      IF (NPRT(9)) PRINT 2090
 2090 FORMAT(' *GHEISH* ROUTINE CASFRG WILL BE CALLED')
      NUCFLG=0
      CALL CASFRG(NUCFLG,INT,NFL)
      IF (NUCFLG .NE. 0) GO TO 50
C
C *** CHECK WHETHER THERE ARE NEW PARTICLES GENERATED ***
 40   CONTINUE
      IF ((NTOT .NE. 0) .OR. (KKPART .NE. KPART)) GO TO 50
C
C --- NO SECONDARIES GENERATED AND PARTICLE IS STILL THE SAME ---
C --- ==> COPY EVERYTHING BACK IN THE CURRENT GEANT STACK ---
      NGKINE=0
      TOFG=TOFG+TOF*0.5E-10
C --- In case of crazy momentum value ==> no change to GEANT stack ---
      IF (P .LT. 0.) GO TO 41
      VECT(4)=PX
      VECT(5)=PY
      VECT(6)=PZ
      VECT(7)=P
      GETOT=EN
      GEKIN=EK
C --- CHECK KINETIC ENERGY ---
      CALL GEKBIN
      EDEP=ABS(ENOLD-EN)
      RMASSI=EN-EK
      IF (NPRT(9) .AND. (EN .GT. ENOLD))
     $ PRINT 8888,EDEP,ENOLD,EN,EK,RMASSI
 8888 FORMAT(' *GHEISH* EDEP,ENOLD,EN,EK,M = ',5(G12.5,1X)/
     $ ' *GHEISH* =======> EDEP WOULD BE NEGATIVE <========')
      IF (ISTOP .EQ. 0) DESTEP=DESTEP+EDEP
C
C --- RE-INITIALIZE THE PROBABILITY FOR HADRONIC INTERACTION ---
 41   CONTINUE
      CALL GRNDM(RNDM,1)
      IF ((RNDM(1) .LE. 0.) .OR. (RNDM(1) .GE. 1.)) GO TO 41
      ZINTHA=-LOG(RNDM(1))
      SLHADR=SLENG
      STEPHA=1.0E10
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1003,NTOT,IPART,KPART,KKPART,NVEDUM
 1003 FORMAT(' *GHEISH* NO SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X)/
     $ ' CURRENT PARTICLE ON THE STACK AGAIN')
      GO TO 9999
C
C *** CURRENT PARTICLE IS NOT THE SAME AS IN THE BEGINNING OR/AND ***
C *** ONE OR MORE SECONDARIES HAVE BEEN GENERATED ***
 50   CONTINUE
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1004,NTOT,IPART,KPART,KKPART,NVEDUM
 1004 FORMAT(' *GHEISH* SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X))
C
C --- INITIAL PARTICLE TYPE HAS BEEN CHANGED ==> PUT NEW TYPE ON ---
C --- THE GEANT TEMPORARY STACK ---
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((KPART .NE. 11) .AND. (KPART .NE. 12)) GO TO 52
      CALL GRNDM(RNDM,1)
      KPART=11.5+RNDM(1)
C
 52   CONTINUE
      ITY=IKPART(KPART)
      LNVE=LQ(JPART-ITY)
      IF (LNVE .LE. 0) PRINT 1234,NTOT,ITY,LNVE
 1234 FORMAT('0*GHEISH* 1234 NTOT,ITY,LNVE = ',3(I10,1X))
      IF (LNVE .LE. 0) STOP
      IF (ISTOP .EQ. 0) ISTOP=1
C
C --- IN CASE THE NEW PARTICLE IS A NEUTRINO ==> FORGET IT ---
      IF (KPART .EQ. 2) GO TO 60
C
C --- PUT PARTICLE ON THE STACK ---
      GKIN(1,1)=PX*P
      GKIN(2,1)=PY*P
      GKIN(3,1)=PZ*P
      GKIN(4,1)=SQRT(P*P+RMASS(KPART)**2)
      GKIN(5,1)=ITY
      TOFD(1)=TOF*0.5E-10
      NGKINE = 1
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
      IF (NPRT(9)) PRINT 1005,ITY,NGKINE
 1005 FORMAT(' *GHEISH* GEANT PART. ',I3,' PUT ONTO STACK AT POS. ',I3)
C
C *** CHECK WHETHER SECONDARIES HAVE BEEN GENERATED AND COPY THEM ***
C *** ALSO ON THE GEANT STACK ***
 60   CONTINUE
C
C --- ALL QUANTITIES ARE TAKEN FROM THE GHEISHA STACK WHERE THE ---
C --- CONVENTION IS THE FOLLOWING ---
C
C EVE(INDEX+ 1)= X
C EVE(INDEX+ 2)= Y
C EVE(INDEX+ 3)= Z
C EVE(INDEX+ 4)= NCAL
C EVE(INDEX+ 5)= NCELL
C EVE(INDEX+ 6)= MASS
C EVE(INDEX+ 7)= CHARGE
C EVE(INDEX+ 8)= TOF
C EVE(INDEX+ 9)= PX
C EVE(INDEX+10)= PY
C EVE(INDEX+11)= PZ
C EVE(INDEX+12)= TYPE
C
      IF (NTOT .LE. 0) GO TO 9999
C
C --- ONE OR MORE SECONDARIES HAVE BEEN GENERATED ---
      DO 61 L=1,NTOT
      INDEX=(L-1)*12
      JND=EVE(INDEX+12)
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((JND .NE. 11) .AND. (JND .NE. 12)) GO TO 63
      CALL GRNDM(RNDM,1)
      JND=11.5+RNDM(1)
C
C --- FORGET ABOUT NEUTRINOS ---
 63   CONTINUE
      IF (JND .EQ. 2) GO TO 61
C
C --- SWITH TO GEANT QUANTITIES ---
      ITY=IKPART(JND)
      JTY=LQ(JPART-ITY)
      IF (JTY .LE. 0) PRINT 1235,NTOT,ITY,JTY
 1235 FORMAT('0*GHEISH* 1235 NTOT,ITY,JTY = ',3(I10,1X))
      IF (JTY .LE. 0) STOP
*     ITRT=Q(JTY+6)
      PLX=EVE(INDEX+9)
      PLY=EVE(INDEX+10)
      PLZ=EVE(INDEX+11)
      ELT=SQRT(PLX*PLX+PLY*PLY+PLZ*PLZ+Q(JTY+7)**2)
C
C --- ADD PARTICLE TO THE STACK IF STACK NOT YET FULL ---
      IF (NGKINE .GE. MXGKIN) THEN
          WRITE(CHMAIL,1236) NTOT, L
 1236     FORMAT(' *** GHEISH: ',I9,' particle produced but only ',
     +           I9,' put on the GEANT stack!')
          CALL GMAIL(1,1)
          GO TO 9999
      ENDIF
      NGKINE=NGKINE+1
      GKIN(1,NGKINE)=PLX
      GKIN(2,NGKINE)=PLY
      GKIN(3,NGKINE)=PLZ
      GKIN(4,NGKINE)=ELT
      GKIN(5,NGKINE)=ITY
      TOFD(NGKINE)=EVE(INDEX+8)*0.5E-10
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
      IF (NPRT(9)) PRINT 1006,ITY,NGKINE,L,(EVE(INDEX+J),J=1,12)
 1006 FORMAT(' *GHEISH* GEANT PART. ',I3,' ALSO PUT ONTO STACK AT',
     $ ' POS. ',I3/
     $ ' EVE(',I2,') = '/12(1H ,12X,G12.5/))
C
 61   CONTINUE
C
 9999 CONTINUE
C --- LIMIT THE VALUE OF NGKINE IN CASE OF OVERFLOW ---
      NGKINE=MIN(NGKINE,MXGKIN)
      END
+DECK,GCALOR.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  1.04/08 31/08/95  12.01.02  by  Christian Zeitnitz
*-- Author : Christian Zeitnitz
      SUBROUTINE GCALOR
********************************************************************
*                                                                  *
* PURPOSE: GEANT interface to CALOR                                *
*                                                                  *
* CALLED BY : GUHADR                                               *
*                                                                  *
* INPUT :  particle, material, and probabilities via GEANT common  *
*                                                                  *
* OUTPUT : COMMON GCKING, DESTEP                                   *
*          KCALL  = -1  : Nothing done                             *
*                 =  0  : NMTC has been called                     *
*                 =  1  : MICAP has been called                    *
*                 =  2  : HETC/SKALE has been called               *
*                 =  3  : FLUKA has been called                    *
*                                                                  *
* AUTHOR : C.Zeitnitz (University of Arizona)                      *
*                                                                  *
********************************************************************
C.
C. --- GEANT Commons
+SEQ,GCBANK
+SEQ,GCJLOC
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCMATE
+SEQ,GCPHYS
+SEQ,GCTRAK
+SEQ,GSECTI
+SEQ,GCONST
+SEQ,GCCUTS
+SEQ,GCFLAG
C --- CALOR - GEANT Interface common
+SEQ,CALGEA
+SEQ,CERRCM
+SEQ,CAMASS
C
C  Avogadro number multiplied by 1.E-24
      PARAMETER(XNAVO = 0.60221367)
C
      DIMENSION NNPART(12)
      LOGICAL INIT,GOFLUK,DOSKAL,FMICAP,SKALEF,NABSOR,FSTOP
      DOUBLE PRECISION DECIN,DMASS
C
      DATA INIT /.TRUE./
      SAVE INIT
C
      IF ( INIT ) THEN
C
C     initialize CALOR
         CALL CALINI
C
         INIT = .FALSE.
C
      ENDIF
      KCALL = -1
C
C get CALOR particle type
      IPINC = -1
      IF(IPART .LE. 48 )  IPINC = IGECAL(IPART)
+SELF,IF=CDEBUG1
C
      PRINT *,' GCALOR: Call CALOR - IPART=',IPART,' GEKIN=',GEKIN
+SELF.
C
C energy in MeV
 
      EINC   =GEKIN * 1000.0
      UINC(1)=VECT(4)
      UINC(2)=VECT(5)
      UINC(3)=VECT(6)
      KCASE=NAMEC(12)
      NGKINE = 0
      NABSOR = .FALSE.
      FSTOP = .FALSE.
C ----- particle has to be stopped ? -------
      IF(GEKIN.LT.CUTHAD.AND.ITRTYP.EQ.4) THEN
+SELF,IF=CDEBUG
C          particle = Pi- => Pi- capture marked by energy of 1 MeV
         IF(IPART.EQ.9) PRINT *,' GCALOR: PI- capture selected '
+SELF.
         FSTOP = .TRUE.
         ISTOP = 2
         IF(IPART .EQ. 9) THEN
            NABSOR = .TRUE.
            ISTOP = 1
            EINC = 1.0
            IF(GEKIN.GT.EINC/1000.) DESTEP = DESTEP + GEKIN - EINC/
     +      1000.0
            GEKIN = 0.0
            VECT(7) = 0.0
            KCASE = NAMEC(18)
            NMEC = NMEC + 1
            LMEC(NMEC) = 18
         ELSE
            DESTEP = DESTEP + GEKIN
            GEKIN = 0.0
            VECT(7) = 0.0
            IF(IPART.EQ.8.OR.IPART.EQ.11.OR.IPART.EQ.12) THEN
              CALL GDECAY
              KCASE = NAMEC(5)
              NMEC = NMEC + 1
              LMEC(NMEC) = 5
            ENDIF
            RETURN
         ENDIF
      ELSE IF(GEKIN.LT.CUTNEU.AND.IPART.EQ.13) THEN
         IF(GEKIN.LT.1.E-14) EINC=1.E-11
         ISTOP = 1
         NABSOR = .TRUE.
      ENDIF
      IF(ISTOP.EQ.2.OR.GEKIN.EQ.0.0) RETURN
C
C ------------- check if FLUKA has to be called ---------
C ------------------------------------------------- Goto FLUKA ?
C
      DOSKAL = (IPINC.EQ.0 .OR. IPINC.EQ.1) .AND. GEKIN.GT.EMAXP
      DOSKAL = DOSKAL .OR. (GEKIN .GT. EMAXPI .AND. (IPINC .GT. 1))
      IF(ICPROC.GE.0) THEN
         GOFLUK = ICPROC.EQ.3 .OR. IPINC.EQ.-1
         DOSKAL = DOSKAL .AND. ICPROC.EQ.2
      ELSE
         GOFLUK = IPINC .EQ. -1 .OR. GEKIN .GE. ESKALE
         DOSKAL = DOSKAL .AND. .NOT.GOFLUK
         GOFLUK = GOFLUK .OR. (DOSKAL.AND.SKALEF(IPINC,GEKIN,ESKALE))
         GOFLUK = GOFLUK .AND. .NOT.FSTOP .AND. .NOT.NABSOR
      ENDIF
      ICPROC = -1
C ------------------------------------------- call FLUKA
      IF(GOFLUK) THEN
+SELF,IF=CDEBUG1
         PRINT *,' CALL FLUKA '
+SELF.
         CALL FLUFIN
         KCALL = 3
         RETURN
      ENDIF
      CERRF = .FALSE.
      IF(IPINC .EQ. 1 .AND. EINC .LE. 20.0) THEN
C MICAP needs only GEANT material number
         NCEL = NMAT
C --- low energetic neutron -> call micap
+SELF,IF=MDEBUG
         PRINT *,' CALL MICAP '
+SELF.
         CALL MICAP
         KCALL = 1
      ELSE
         NCEL = 1
         AMED(1) = A
         ZMED(1) = Z
         DMED(1) = DENS/A*XNAVO
         IF(INT(A) .EQ. 1) THEN
            HDEN = DMED(1)
         ELSE
            HDEN = 0.0
         ENDIF
C ------- get material parameter for a mixture---------------------
         KK=MIN1(ABS(Q(JMA+11)),100.)
         NCEL = 1
         IF(KK.GT.1) THEN
            HDEN = 0.0
            NCEL = 0
            AMOL = Q(LQ(JMIXT-1) + 2)
            DO 10 K=1,KK
               IF(NINT(Q(JMIXT+K)).EQ.1) THEN
C                           hydrogen density
                  XMOLCM = DENS/AMOL*XNAVO
                  WI = Q(JMIXT+K+2*KK)*AMOL/Q(JMIXT+K)
                  HDEN = HDEN + XMOLCM * WI
               ELSE
                  NCEL = NCEL + 1
                  AMED(NCEL) = Q(JMIXT+K)
                  ZMED(NCEL) = Q(JMIXT+K+KK)
C                                        molekuls/cm^3
                  XMOLCM = DENS/AMOL*XNAVO
C                                     number of atoms per molecule
                  WI = Q(JMIXT+K+2*KK)*AMOL/AMED(NCEL)
C                                        atoms/cm^3
                  DMED(NCEL) = XMOLCM * WI
               ENDIF
+SELF,IF=CDEBUG
               PRINT '('' GCALOR: A('',I5,'')='',F7.2,'' Z='',F7.2,    '
     +         //'                '' WI='',F7.3,'' DEN='',F7.3,'' Hden='
     +         //''',F7.3)', K,AMED(K),ZMED(K),WI,DMED(K),HDEN
+SELF.
   10       CONTINUE
         ENDIF
+SELF,IF=CDEBUG1
C --- call hetc -----
         PRINT *,' CALL HETC '
+SELF
         CALL CHETC(DOSKAL)
         KCALL = 0
         IF(DOSKAL) KCALL = 2
      ENDIF
C error ocurred in CALOR ?
      IF(CERRF) THEN
         WRITE(IERRU,'('' NEVT,IPART,Ek,NMED,ISTOP,NABSOR,FSTOP :'',   '
     +   //'          I10,I5,G15.6,2I6,2L6)') IEVENT,IPART,GEKIN,NMAT,
     +   ISTOP,NABSOR,FSTOP
      ENDIF
+SELF,IF=CDEBUG1
C
C ---------------- store secondaries ---------------
C
      PRINT *,' AFTER CALOR NPART=',NPHETC
+SELF.
      ESUM =0.
      EKSUM = 0.
      PX = 0.
      PY = 0.
      PZ = 0.
      NGKINE = 0
      PSUM = 0.
C
      ZINTHA=GARNDM(6)
      SLHADR=SLENG
      STEPHA=BIG
C
      IF(NPHETC.EQ.0.AND.NABSOR) ISTOP = 2
C neutron has been absorbed -> INTCAL=18
      IF(INTCAL.EQ.18) ISTOP = 1
      IF(NPHETC.LE.0) GOTO 160
C
C too many particles in the CALOR array for GEANT
C happens sometimes with deexitation gammas and evaporation neutrons
C simple approach to combine particles and sum up their energies, but
C forget about momentum conservation
C
      IF(NPHETC.GT.MXGKIN) THEN
   20    CONTINUE
         DO 30 I=1,12
            NNPART(I)=0
   30    CONTINUE
         NNTOT = 0
         DO 40 I=1,NPHETC
            IF(IPCAL(I).NE.-1) THEN
               NNPART(IPCAL(I)+1)=NNPART(IPCAL(I)+1)+1
               NNTOT = NNTOT + 1
            ENDIF
   40    CONTINUE
         IF(NNTOT.LE.MXGKIN) GOTO 100
         JMAX=0
         IMAX=0
         DO 50 I=1,12
            IF(JMAX.LT.NNPART(I)) THEN
               JMAX=NNPART(I)
               IPI=I-1
            ENDIF
   50    CONTINUE
         DO 60 I=1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 70
   60    CONTINUE
   70    I1=I
         DO 80 I=I1+1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 90
   80    CONTINUE
   90    I2=I
         ECINI = EKINET(I1)
         DMASS = DBLE(XMASS(IPI))*1.D3
         DECIN = DBLE(ECINI)
         PPI = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         IPJ = IPCAL(I2)
         ECINJ = EKINET(I2)
         DECIN = DBLE(ECINJ)
         PPJ = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         ECIN = SNGL(DBLE(ECINI)+DBLE(ECINJ)+DMASS)
         EKINET(I1) = ECIN
         PP = SNGL(DSQRT(DBLE(ECIN*ECIN) + 2.D0*DBLE(ECIN)*DMASS))
C determine new direction cosines
         UCAL(I1,1) = (PPI*UCAL(I1,1)+PPJ*UCAL(I2,1))/PP
         UCAL(I1,2) = (PPI*UCAL(I1,2)+PPJ*UCAL(I2,2))/PP
         UCAL(I1,3) = (PPI*UCAL(I1,3)+PPJ*UCAL(I2,3))/PP
         USUM = SQRT(UCAL(I1,1)**2+UCAL(I1,2)**2+UCAL(I1,3)**2)
C normalize direction cosines
         IF(USUM.LT.0.0001) THEN
C direction is isotropic distributed
            CALL AZIRN(SINA,COSA)
            COSP = SFLRAF(DUM)
            SINP = SQRT(1.0-COSP*COSP)
            UCAL(I1,1) = SINP * COSA
            UCAL(I1,2) = SINP * SINA
            UCAL(I1,3) = COSP
         ELSE
            UCAL(I1,1) = UCAL(I1,1)/USUM
            UCAL(I1,2) = UCAL(I1,2)/USUM
            UCAL(I1,3) = UCAL(I1,3)/USUM
         ENDIF
C particle I2 vanished
         IPCAL(I2)=-1
         GOTO 20
C end of particle combination
  100    CONTINUE
C sort particles
         I2=NPHETC
         DO 120 I = 1,NPHETC
            IF(I.GE.I2) GOTO 130
            IF(IPCAL(I).EQ.-1) THEN
               DO 110 J = I2,I,-1
                  IF(IPCAL(J).NE.-1) THEN
                     IPCAL(I) = IPCAL(J)
                     EKINET(I) = EKINET(J)
                     UCAL(I,1) = UCAL(J,1)
                     UCAL(I,2) = UCAL(J,2)
                     UCAL(I,3) = UCAL(J,3)
                     I2 = J-1
                     GOTO 120
                  ENDIF
  110          CONTINUE
            ENDIF
  120    CONTINUE
  130    CONTINUE
         NPHETC=MXGKIN
      ENDIF
C
      IF(INTCAL.LT.1.OR.INTCAL.GT.30) INTCAL=12
      KCASE = NAMEC(INTCAL)
      IF(INTCAL.NE.12) THEN
        NMEC = NMEC + 1
        LMEC(NMEC) = INTCAL
      ENDIF
      DO 140 I=1,NPHETC
         IP=IPCAL(I)
         IGPART=ICALGE(IP)
         IF ( IGPART.EQ.0 ) THEN
            PRINT*,'>>> ERROR GCALOR: Particle type ',IP, ' not '
     +      //'implemented in GEANT'
            GOTO 140
         ENDIF
+SELF,IF=CDEBUG1
         PRINT *,' GCALOR after CALOR: IP=',IGPART,' Ekin=',EKINET(I)
+SELF.
C
C store particle
         ECIN = EKINET(I)/1000.0
         IF(ECIN.LT.1.E-15) GOTO 140
         DECIN = DBLE(ECIN)
         DMASS = DBLE(XMASS(IP))
         PP = SNGL(DSQRT(DECIN*DECIN + 2.0D0*DECIN*DMASS))
+SELF,IF=CDEBUG,MDEBUG
         IF(IP.GE.2.AND.IP.LE.4) THEN
           ESUM = ESUM + ECIN + XMASS(IP)
         ELSE
           ESUM = ESUM + ECIN
         ENDIF
         EKSUM = EKSUM + ECIN
+SELF.
         PX = PX + PP*UCAL(I,1)
         PY = PY + PP*UCAL(I,2)
         PZ = PZ + PP*UCAL(I,3)
+SELF,IF=CDEBUG,MDEBUG
         PRINT '('' IP,Ek,Px,Py,Pz ='',I4,4(1X,E15.7))',
     +          IGPART,ECIN,PX,PY,PZ
+SELF.
C generated particle eq incoming
         IF(NPHETC.EQ.1 .AND. IGPART.EQ.IPART) THEN
            VECT(4) = UCAL(I,1)
            VECT(5) = UCAL(I,2)
            VECT(6) = UCAL(I,3)
            VECT(7) = PP
            GEKIN = ECIN
            GETOT = SNGL(DECIN + DMASS)
            TOFG = TOFG + CALTIM(I)
            ISTOP = 0
            IF(NABSOR) ISTOP = 2
            GOTO 160
         ENDIF
C
         NGKINE=NGKINE+1
         GKIN(1,NGKINE) = PP*UCAL(I,1)
         GKIN(2,NGKINE) = PP*UCAL(I,2)
         GKIN(3,NGKINE) = PP*UCAL(I,3)
C the total energy is critical for ECIN below 1.E-8 GeV because of
C single precision of GKIN (normalization when mass is added)!!
C luckely GEANT does use only the momentum components when storing the
C particle on the stack.
         GKIN(4,NGKINE) = SNGL(DECIN+DMASS)
         GKIN(5,NGKINE) = FLOAT(IGPART)
         TOFD(NGKINE)   = CALTIM(I)
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(NGKINE.GE.MXGKIN) GOTO 150
C
  140 CONTINUE
  150 CONTINUE
C particle lost its identity
      ISTOP=1
  160 CONTINUE
+SELF,IF=CDEBUG,MDEBUG
      EPREC = AMED(1)*0.93149432
      PIX = VECT(4)*VECT(7)
      PIY = VECT(5)*VECT(7)
      PIZ = VECT(6)*VECT(7)
      ESUM = ESUM + ERMED(1)/1000. + AMASS
      PSUM = SQRT((PX-PIX)**2 + (PY-PIY)**2 + (PZ-PIZ)**2)-
     +       SQRT((EPREC+ERMED(1)/1000.)**2 -EPREC**2)
      PRINT '('' AFTER INTERACTION: Einc,Pinc = '',2F7.3,
     + '' Ediff,Pdiff='',2F7.3)',GETOT,VECT(7),
     + GETOT-ESUM,  PSUM
+SELF.
C
C
      NGKINE = MIN(NGKINE,MXGKIN)
C
C score kinetic energy of recoil nucleus (given in MeV)
CZ      DESTEP = DESTEP + ERMED * 1.E-3
  170 RETURN
      END
+DECK,GFMFIN.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.47  by  S.Giani
*-- Author :
      SUBROUTINE GFMFIN
+SEQ,GCBANK.
+SEQ,GCCUTS.
+SEQ,GCJLOC.
+SEQ,GCFLAG.
+SEQ,GCKINE.
+SEQ,GCKING.
+SEQ,GCMATE.
+SEQ,GCPHYS.
+SEQ,GCTRAK.
+SEQ,GSECTI.
+SEQ,GCTMED.
+SEQ,GCUNIT.
+SEQ,DIMPAR.
 
+SEQ,FINUCT,IF=-SINGLE
+SEQ,FINUC.
      REAL RNDM(1)
+SELF, IF=-SINGLE
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
+SELF
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
+SEQ,PART2T,IF=-SINGLE
+SEQ,PART2.
+SEQ,COMCONT,IF=-SINGLE
+SEQ,COMCON.
+SEQ,FHEAVYT,IF=-SINGLE
+SEQ,FHEAVY.
+SEQ,PAPROP.
+SEQ,PAPROPT,IF=-SINGLE
+SEQ,GFKDIS.
+SELF, IF=-SINGLE
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
+SELF
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
      NP = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF (IGF.EQ.2.OR.(GEKIN.EQ.0.0.AND.IPART.EQ.13)) THEN
         IF (GEKIN.LT.CUTNEU) THEN
            GEKIN = MAX(GEKIN,1E-14)
* should kinetic energy be deposited?
            ISTOP = 2
            IGF = 0
            GOTO 110
         ENDIF
         CALL GMICAP
         IGF = 0
         GOTO 110
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
      ELSE
         ISTOP=1
         NSTAK1 = MIN(NP,MXGKIN-NGKINE)
         IF(NP.GT.NSTAK1) THEN
            WRITE(CHMAIL,10000) NP-NSTAK1
            CALL GMAIL(0,0)
         ENDIF
         DO 90  K=1,NSTAK1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NSTAK2 = MIN(NPHEAV,MXGKIN-NGKINE)
         IF(NPHEAV.GT.NSTAK2) THEN
            WRITE(CHMAIL,10100) NPHEAV-NSTAK2
            CALL GMAIL(0,0)
         ENDIF
         DO 100 K=1,NSTAK2
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
         KCASE=NAMEC(12)
      END IF
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
10000 FORMAT(' **** FLUFIN: Stack overflow, ',I6,' particles lost')
10100 FORMAT(' **** FLUFIN: Stack overflow, ',I6,
     +' heavy particles lost')
  999 END
