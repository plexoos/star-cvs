+TITLE.
Advanced Geant Inteface
+PATCH,ATGEANT. ================================================================
*CMZ :  1.00/00 19/12/95  09.59.57  by  G. Poulard
+DECK,AxCOMPONENT,T=geant. ====================================================
*CMZ :  1.30/00 16/07/96  23.30.40  by  Pavel Nevski
*CMZ :  1.00/00 12/04/95  19.53.08  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x C o m p o n e n t
*                                                                    *
*  Description:  introduce a componenet of a new mixture             *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCUNIT.
 Integer LENOCC
 " check %W>0; "
 If (%z>0) %Za=%z;
 IF %NLmat>=10 { error('NO more place to store a component of the mixture') }
 %NLmat+=1; %AA(%NLmat)=%A; %ZZ(%NLmat)=%Za; %WW(%NLmat)=%W;
   END
 
+DECK,AxMIXTURE,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 21/07/96  15.36.42  by  Pavel Nevski
*CMZ :  1.00/00 05/05/95  20.15.51  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x M i x t u r e
*                                                                    *
*  Description:  introduce a new mixture, reset medium number   	     *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
  Integer      AgSMATE,LENOCC,Imixt,N,i,jma;
  Real         SW,a(20),z(20),w(20),Par(10);
  Character*4  Cmate,Cmodu;
 
  Call Vzero(Par,10);
  %Material=%Title;  Imixt=AgSMATE(%Material,JMATE,Par);
  Cmate=%Material;   Cmodu=%Module;
 
  N=0;  do i=1,%Nlmat  { if (%WW(i)>0) N+=1; };   Par={0,0,%Dens,0,0,N};
  if Imixt<0 & Cmate#Cmodu & Cmodu#' '
  {  %Material=Cmodu//'_'//%Title; Imixt=AgSMATE(%Material,JMATE,Par); }
 
  %Medium=%Material;   %Imed=-1;   %Imat=abs(Imixt);
  If Imixt<0
  {  SW=0; N=0;  do i=1,%Nlmat
     {check %WW(i)>0; N+=1; SW+=%WW(i); a(N)=%aa(i); z(N)=%ZZ(i); W(N)=%WW(i)}
     If SW<=0 {error('Mixture undefined')};   if (SW>1.5)  N=-N;
     prin1  %L(%Material),%Imat,%Dens,N,(%aa(i),%zz(i),%ww(i),i=1,%NLmat);
     (' GSMIXT   for mixture ',A,' used Imat=',I3,
      ' Density=',F5.2,' NLmat=',i2/(10x,'A,Z,W =',3F10.3));
     Call GSMIXT (%Imat, %Material, A, Z, %Dens, N, W);
  }
  Jma=LQ(JMATE-%Imat);  %A   = Q(Jma+6);     %Z  = Q(Jma+7);
                       %RadL = Q(Jma+9);    %AbsL = Q(Jma+10);
                       %NLMAT= 0;
   END
 
+DECK,AxMATERIAL,T=geant. ------------------------------------------------------
*CMZ :  1.00/00 23/02/95  01.10.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x M a t e r i a l
*                                                                    *
*  Description:  introduce a new material, reset medium number       *
*  New material in a module is always prefixed by the module name    *
*  A request without parameters does not introduce new material      *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
    Integer     AgSMATE,LENOCC,Im;
    Character   Cmate*4,Cmodu*4,Material*20;
    Real        PAR(10);
 
 If(%z>0) %Za=%z;     Call Vzero(Par,10);
 %Material=%Title;    Cmate=%Material;   Cmodu=%Module;
 If %ParList#'NONE'  { PAR={%A,%Za,%Dens,%Radl,%ABSL}; }
 
 Im=AgSMATE (%Material,JMATE,Par);           " first check for a global "
 if Im<0 & Cmate#Cmodu & Cmodu#' '           " then for a local material"
 {  %Material=Cmodu//'_'//%Title;  Im=AgSMATE(%Material,JMATE,Par); }
 
 %Medium=%Material;   %Imed=-1;   %Imat=abs(Im);
 if Im<0
 { If %Parlist='NONE'  {error('Undefined material requested',%Title)}
   prin1  %L(%Material),%Imat,%A,%Za,%Dens,%RADL,%ABSL;
   (' GSMATE   called with for material ',A,' produces Imat =',I3/,
      10x, 'A,Z,D,x0,l0 =',5E11.4);
    Call GSMATE(%Imat,%Material,%A,%Za,%Dens,%RADL,%ABSL,%UBUF,%NWBUF);
 }
 Else If %Parlist='NONE'
 {  Call GFMATE(%Imat, Material,%A,%Za,%Dens,%RADL,%ABSL,%UBUF,%NWBUF); }
  END
 
+DECK,AxMEDIUM,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 02/04/97  15.00.54  by  Pavel Nevski
*CMZ :  1.00/00 27/02/95  15.31.04  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x M e d i u m
*                                                                    *
*  Description:  introduce parameters of a new GEANT tracking medium *
*  Direct call always sets the medium name and fetchs its parameters *
*  In the STANDARD module it can introduce a new media in the table  *
*  The real medium is introduced at the SHAPE operator only,         *
*  otherwise initial medium inherits a wrong material (tested!)      *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
    Integer      AgSMATE,LENOCC,Im,Imed,Imat,Ifield
    Character    Medium*20,Cmedi*4,Cmodu*4
    Real         Par(10)
*
 %Medium=%Title;     Cmedi=%Medium;   Cmodu=%Module;  Ifield=%Ifield*%Imfld
 PAR={0,%IsVol, Ifield,%Fieldm,%TmaxFD, %SteMax,%DeeMax,%Epsil,%Stmin, 0};
 
 Im=AgSMATE (%Medium,JTMED,Par);              " first check for a global "
 If Im<=0 & Cmedi#Cmodu & Cmodu#' '           " then for a local medium  "
 {  %Medium=Cmodu//'_'//%Title;  Im=AgSMATE(%Medium,JTMED,Par);  }
 
 Imed=abs(Im); %Imed=-1;
 If Im<0
 {  %Imed = Imed
    " If %Parlist='NONE' {error('Undefined medium requested',%Title)} "
    prin1       %L(%MEDIUM), %Imed, %Imat, %ISVOL,   IFIELD, %FIELDM, %TMAXFD,
                                           %STEMAX, %DEEMAX, %EPSIL,  %STMIN
                (' AGSTMED  for medium ',A,' med,mat,sen,fld =',2i4,2i2/,
                               10x ,'Field = ',2F5.1,'  steps = ',4F8.5)
    Call GSTMED (%Imed, %MEDIUM, %IMAT,   %ISVOL,  IFIELD, %FIELDM, %TMAXFD,
                        %STEMAX, %DEEMAX, %EPSIL, %STMIN,  %UBUF,   %NWBUF)
 }
 else if %Parlist='NONE'
 {  Call GFTMED ( Imed,  Medium,  Imat,   %Isvol, %IFIELD, %FIELDM, %TMAXFD,
                        %STEMAX, %DEEMAX, %EPSIL, %STMIN,  %UBUF,   %NWBUF)
 }
  END
 
+DECK,AxSHAPE,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 06/01/95  22.24.20  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x S H A P E
*                                                                    *
*  Description:  a dispatch routine to do GSDIV, GSVOLU              *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM.
 
    %Shape=%Title;  %Ishape=0;
    if %Imed<=0        {   Call AgSMedi;   check %Imed    >0; }
    If %Shape = 'DIVI' {   Call AgSDIVI;   Check %Ivolume >0; }
    else               {   Call AgSHAPE;   Check %Ishape  >0;
                           Call AgSVOLU;   Check %Ivolume >0; }
    %Istatus=1;            Call AxATTRIBUTE;
   END
 
+DECK,AxATTRIBUTE,T=geant. -----------------------------------------------------
*CMZ :  1.30/00 28/04/96  20.12.52  by  Pavel Nevski
*CMZ :  1.00/00 21/03/95  22.40.41  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x A T T R I B U T E
*                                                                    *
*  Description:  set volume attributes for GEANT                     *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCFLAG.
 character*4 ATTname(6) /'WORK','SEEN','LSTY','LWID','COLO','FILL'/; Integer i;
 Integer     is,ig;
 Check  %Istatus>0;
 Do i=1,6
 {  if (%attribute(i)#%MAGIC) Call GSATT (%Cnick,ATTname(i),%attribute(i)); }
 If %IGRAP>1
 {  is=1;  Ig=%IGRAP-%LEVEL;
    if(Ig<0) is=-1; if(Ig>2) is=0; Call GSATT(%Cnick,'SEEN',is);
 }
 END
 
+DECK,AxPOSITION,T=geant. ------------------------------------------------------
*CMZ :  1.30/00 21/11/96  19.48.44  by  Pavel Nevski
*CMZ :  1.00/00 06/08/95  14.04.27  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x P O S I T I O N
*                                                                    *
*  Description:  make GSPOS or GSPOSP                                *
*  Modifications:                                     28.07.95 - PLN *
*  - Start with the mother volume checking to allow fake positioning *
*    divisions.   No checks are done yet for an errenious            *
*    normal volume positioning at the same level as divisions ...    *
*  - 14.11.96 PN+SB: Ncopy can be passed throu AGECOM in both ways   *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM.
  Character*4 Daughter,Daught;            Real Vdist,D,V
  Integer  LENOCC,Idaught,Ivd,Jvd,Ivo,Jvo,Ign,Ir,Jvm,Ivm,
           Npo,Npa,Jmo,in,nin,Ncopy,Id,Jd,Jg,IDH,IDM
 
* search for the mother, if it is explicitely defined, and check it.
  If %Ivolume<=0 | %Mother!=%Volume
  {  %Cnick=%Mother;  Call GLOOK(%Mother,IQ(JVOLUM+1),Nvolum,%Ivolume);
     If %Ivolume<=0
     {  If %Level>0  {error('mother volume does not exist')};
        <w> %Mother; (' Warning: Volume ',a4,' does not exist'); Return;
     }
     Jvm=LQ(JVOLUM-%Ivolume); Ivm=IQ(Jvm-5); IDM=IQ(Jvm-4);
     IF IDM==IQ(JVOLUM+%Ivolume) & 1<=Ivm&Ivm<=Nvolum
     { %Ivolume=Ivm; call UHTOC(IQ(JVOLUM+Ivm),4,%Cnick,4); }
  }  Jmo=LQ(JVOLUM-%Ivolume); nin=Q(Jmo+3);
  Check "that it has no divisions " nin>=0
 
* get Active volume number from the generic bank IDN word;
  Daughter=%Title;  Call GLOOK (Daughter,IQ(JVOLUM+1),Nvolum,Ivd);
  If Ivd<=0   {error('daughter ',Daughter,' does not exist ')};
  " generic daughter "  IDH=IQ(JVOLUM+Ivd); Jvd=LQ(JVOLUM-Ivd);
  Ivo=IQ(Jvd-5);  If Ivo<=0 {error('Actual daughter does not exist ')};
  " its nickname "  Idaught=IQ(JVOLUM+Ivo); Jvo=LQ(JVOLUM-Ivo);
  " and number   "  Ign=0;    If (Ivd#Ivo)  Ign=IQ(Jvo-5);
 
* get actual rotation and may be shape parameters
  %Ishape=Q(Jvo+2);  Npo=Q(Jvo+5);  Npa=0;
  Call AgSROTM " - it may cause bank relocation, links should be reaccessed !"
  If Npo=0
  {  Call AgSHAPE;      Npa=%Npar;
     If %Npar=0  {error('Can not position undefined Volume ',Daughter)}
  }
 
* set copy number(generic) and avoid content (actual name!) dublication
  Ncopy=1;  Jmo=LQ(JVOLUM-%Ivolume);
  do in=1,abs(nin)
  {  Jd=LQ(Jmo-in); "its content"Id=Q(Jd+2); "and address"Jg=LQ(JVOLUM-Id);
     "count copies of generic name"    Check IDH=IQ(Jg-4); Ncopy+=1;
     " dont position same volumes "    Check Idaught=IQ(JVOLUM+Id);
     " at the same place and angle"    Ir=Q(jd+4); d=Vdist(%x,Q(Jd+5),3); v=0;
                                       if (Npo=0) V=Vdist(%Par,Q(jd+10),Npa);
                                       if (d=0 & V=0 & Ir=%Irot)  Return;
  }
  If (%Ncopy>0) Ncopy=%Ncopy;  %Ncopy=Ncopy;
  Call UHTOC(Idaught,4,Daught,4);   Call CLTOU (%KONLY);
  If Npo>0 { Call GSPOS (Daught,Ncopy,%CNick,%X,%Y,%Z,%Irot,%KONLY); }
  else     { Call GSPOSP(Daught,Ncopy,%CNick,%X,%Y,%Z,%Irot,%KONLY,
                                                         %PAR, %NPAR);  }
  prin1 Daught,Daughter,%CNick,%Volume,%x,%y,%z,
        %Level,Ncopy,Npa,%IROT,Ivd,Ivo,nin;
  (' POSITION',2(1x,A4),'  into',2(1x,A4),' at x,y,z=',3f9.3/_
  10x,'level',i3,'  Ncopy',i4,' with Npar,Irot=',2i4,' Ivdau,Ivact=',3I5);
   END
 
 
+DECK,AgSVOLU,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 02/04/97  15.21.45  by  Pavel Nevski
*CMZU:  1.00/01 30/11/95  19.31.02  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S V O L U
*                                                                    *
*  Description: On SHAPE returns Ivolume, actual Npar and Npo of the *
*  existing GEANT volume or creates and returns the new volume number*
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM,GCONST.
Integer     Name,LENOCC,Ivo,Jvo,IDH,Npo,Npa,i,JATTF,Jj,Jat
real        eps/1.e-6/,P(50),Tth,Phi,Ph
JATTF(Jj) = Jj+int(Q(Jj+5))+6
*
* Toggle the actual Npa = 0 | NPar
  Npa=0;  Do I=1,%Npar { if (%Par(i)#0) Npa=%Npar; }
  Call UCTOH(%Volume,Name,4,4);  %Ignum=-1;
  If %IMED<=0 {error(' Medium  in  ',%Volume,' not defined')};
 
* if the top level volume has a hole, its inner radius(radii) is reset to 0:
   if Nvolum==0
   {  If %Ishape==5 | %Ishape==6 | %Ishape==9 { %Par(1)=0 " - TUBE,TUBS,SPHE"}
      If %Ishape==7 | %Ishape==8   { %Par(2)=0; %Par(4)=0 " - CONE,CONS     "}
      If %Ishape==11  {  do i=1,nint(%PAR(4)) { %Par(3*i+3)=0 }  " - PGON   "}
      If %Ishape==12  {  do i=1,nint(%PAR(3)) { %Par(3*i+2)=0 }  " - PCON   "}
   }
* If the volume has been defined with the same dimensions, return %Ivolume;
  :volume: Do %Ivolume=1,NVOLUM
  { "take next volum's IDs "       Jvo=LQ(JVOLUM-%Ivolume);   IDH=IQ(Jvo-4);
    "Select same generic names"  check IDH==Name;   "and count them" %Ignum+=1;
    "Now check that parameters are the same, otherwise search for another copy"
    "Undefined volumes with Npa=0  will fit any other volume "
     Npo=Q(Jvo+5);     Jat=JATTF(Jvo);
     If %Ishape=4 | %Ishape=10      "      special cases in Geant 3.21     "
     {  Call Ucopy(%Par,P,min(%Npar,30));
        IF %ISHAPE=4                "        Trapezoid    "
        {  TTH =TAN(P(2)*DEGRAD);   PHI  =P(3)*DEGRAD;
           P(2)=TTH*COS(PHI);       P(3) =TTH*SIN(PHI)
           P(7)=TAN(P(7)*DEGRAD);   P(11)=TAN(P(11)*DEGRAD)
        }
        ELSE IF %ISHAPE=10   " Parallelepiped - change angles to tangents. "
        {  P(4)=TAN(P(4)*DEGRAD);   TTH=TAN(P(5)*DEGRAD);  PH=P(6)*DEGRAD;
           P(5)=TTH*COS(PH);        P(6)=TTH*SIN(PH)
        }
        Do I=1,min(Npo,Npa)
        {  If (abs(P(i)-Q(Jvo+6+i))>eps*abs(P(i)+Q(Jvo+6+i))) Next :volume:; }
     }  Else
     {  Do I=1,min(Npo,Npa)        { If (%Par(i)#Q(Jvo+6+i))  Next :volume:; }
     }
    "Do I=1,6             { If(%Attribute(i)#nint(Q(Jat+i)))  Next :volume:; }"
    "This is an existing volume, use it! If Npo==0, we will need to GSPOSP it"
     if (%Serial=nint(Q(Jat+10)) & %Imed=nint(Q(Jvo+4)))      goto :done:
  }
 
* make a new volume always at the end of the volume list
   %Ignum+=1;  Call AgSNAME(%Volume,%Ignum,%Cnick)
   Call GSVOLU(%Cnick, %Shape, %Imed, %Par, Npa, %Ivolume)
   prin1 %Volume,%Cnick,%Shape,%Imed,%Ivolume,Npa,(%Par(i),i=1,Npa)
  (' AGSVOLU: Name/shape ',3(A4,2x),' Imed,Iv,Np=',3I5/(10x,'Par=',10F8.2))
   If %Ivolume<NVOLUM {error(' error defining GEANT volume ',%Volume)}
*
  "set also volume generic name and number in IDH & IDN , Idtype "
   Jvo=LQ(JVOLUM-%Ivolume); IQ(Jvo-4)=Name; IQ(Jvo-5)=%Ignum;
   Jat=JATTF(Jvo);  Q(Jat+9)=%IdType;  Q(Jat+10)=%Serial;
:done:
* save Active volume number in the generic bank status word;
  Call GLOOK (%Volume,IQ(JVOLUM+1),Nvolum,Ivo);  Jvo=LQ(JVOLUM-Ivo);
  IQ(Jvo-5)=%Ivolume;  Call UHTOC(IQ(JVOLUM+%Ivolume),4,%CNICK,4);
   END
 
+DECK,AgSDIVI,T=geant. ---------------------------------------------------------
*CMZU:  1.00/01 30/11/95  23.54.58  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S D I V I
*                                                                    *
*  Description: make volume division according to actual parameters  *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM.
 Character   Fun*6,Mother*4
 Integer     LENOCC,Name,Nick,Nin,Jmo,Jvd,Ndm,JATTF,Jj,Jat
 JATTF(Jj) = Jj+int(Q(Jj+5))+6
*
 Call UCTOH(%Volume,Name,4,4)
 Call UHTOC(IQ(JVOLUM+%Imother),4,Mother,4)
 Jmo=LQ(JVOLUM-%Imother);  nin=Q(Jmo+3);
 If nin>0  { error('Volume has daughters, division impossible')}
 If nin<0  { %Ivolume=Q(LQ(Jmo-1)+2);       Jvd=LQ(JVOLUM-%Ivolume);
             If IQ(Jvd-4)#NAME  { error('bad name of an existing division')}
             Call UHTOC(IQ(JVOLUM+%Ivolume),4,%CNICK,4)
             %Ignum=IQ(Jvd-5);              Return;
           }
 %Ignum=0;
 Do %Ivolume=1,NVOLUM { If(IQ(LQ(JVOLUM-%Ivolume)-4)=Name) %Ignum+=1; }
 Call AgSNAME (%Volume,%Ignum,%CNick)
*
  Ndm=%NdvMax;
  If      %C0=0 & %Ndiv#0
  { Fun='GSDVN';  Call GSDVN (%Cnick,Mother,%Ndiv,%Iaxis )}
  else If %C0=0 & %Step#0
  { Fun='GSDVT';  Call GSDVT (%Cnick,Mother,%Step,%Iaxis,%Imed,Ndm)}
  else If %C0#0 & %Ndiv#0 & %Step#0
  { Fun='GSDVX';  Call GSDVX (%Cnick,Mother,%Ndiv,%Iaxis,%Step,%C0,%Imed,Ndm)}
  else If %C0#0 & %Ndiv#0
  { Fun='GSDVN2'; Call GSDVN2(%Cnick,Mother,%Ndiv,%Iaxis,%C0,%Imed)}
  else If %C0#0 & %Step#0
  { Fun='GSDVT2'; Call GSDVT2(%Cnick,Mother,%Step,%Iaxis,%C0,%Imed,Ndm)}
  else { error('missing parameters to make a division ')}
*
  Call UCTOH(%Cnick,Nick,4,4)
  If IQ(JVOLUM+Nvolum)#Nick {error('can not find newly created division ')}
  "set also volume generic name and number in IDH & IDN, and IdType "
  %Ivolume=NVOLUM; Jvd=LQ(JVOLUM-%Ivolume)
  IQ(Jvd-4)=NAME;  IQ(Jvd-5)=%Ignum;
  Jat=JATTF(Jvd);  Q(jat+9)=%IdType;  Q(jat+10)=%Serial;
  prin1 Mother,%Cnick,%L(%Volume),%Ignum,Fun
  (' AGSDIVI: mother ',A4,' divided into ',A4,2x,A4,'(',i3,') using ',A6)
  END
 
 
+DECK,AgSHAPE,T=geant. ---------------------------------------------------------
*CMZ :          02/12/97  18.46.06  by  Pavel Nevski
*CMZ :  1.00/00 12/12/94  22.30.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S H A P E
*                                                                    *
*  Description: given SHAPE or ISHAPE  returns its code/name and     *
*               parameters                                           *
*  Modifications:                                                    *
*  A.Dellacqua 27.02.97: CTUB parameters introduced                  *
**********************************************************************
+CDE,TYPING,AGECOM,GCUNIT.
Replace[;#?#;]    with  [[SETR a=0];    IF %Shape=='#1' {;#2=>Par;};          ]
Replace[;#,#=>#;] with  [{IF} [EXIST 1] {[INCR a]; %#3([COPY a])=%#1; #2,=>#3;}
                         {ELSE} {; %Npar=[COPY a]; }            ]
 
 Integer  LENOCC,Is,I,K; Character*4  ShapS(30);
 Data ShapS /'BOX ','TRD1','TRD2','TRAP','TUBE','TUBS','CONE','CONS','SPHE',
      'PARA','PGON','PCON','ELTU','HYPE',  13 * '    ','GTRA','CTUB','    '/;
 
 If %Ishape<=0  { Do Is=1,30 { IF %SHAPE==ShapS(Is)  { %Ishape=Is; Break;} } }
 If %Ishape<=0  { error(' Undefined shape ',%SHAPE)}   %Shape=ShapS(%Ishape);
 
 Box  ?  dx,dy,dz;
 Trd1 ?  dx1,dx2, dy,dz;
 Trd2 ?  dx1,dx2, dy1,dy2, dz;
 Trap ?  dz,thet,phi, h1,bl1,tl1,alp1, h2,bl2,tl2,alp2;
 Tube ?  Rmin,Rmax,Dz;
 Tubs ?  Rmin,Rmax,Dz, Phi1,Phi2;
 Cone ?  Dz, Rmn1,Rmx1, Rmn2,Rmx2;
 Cons ?  Dz, Rmn1,Rmx1, Rmn2,Rmx2, phi1,phi2;
 Sphe ?  Rmin,Rmax, The1,The2, Phi1,Phi2;
 Para ?  Dx,Dy,Dz,  Alph,Thet,Phi;
 Pgon ?  Phi1,Dphi,Npdiv,Nz;
 Pcon ?  Phi1,Dphi,      Nz;
 Eltu ?  P1, P2, Dz;
 Hype ?  Rmin,Rmax,Dz,Thet;
 Gtra ?  Dz,Thet,Phi,Twis, h1,bl1,tl1,alp1, h2,bl2,tl2,alp2;
 Ctub ?  Rmin,Rmax,Dz, Phi1,Phi2, Lx,Ly,Lz,Hx,Hy,Hz;
 
 If %Shape=='PGON' | %Shape=='PCON'
 { k=%Npar; %Npar+=3*%Nz;  do i=1,%Nz
   { %Par(3*i+k-2)=%zi(i); %Par(3*i+k-1)=%rmn(i); %Par(3*i+k)=%rmx(i);}
 }
   END
 
+DECK,AgSROTM,T=geant. ---------------------------------------------------------
*CMZ :          05/06/97  12.19.59  by  Pavel Nevski
*CMZ :  1.30/00 13/03/96  21.37.15  by  Pavel Nevski
*CMZ :  1.00/00 12/12/94  22.30.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
************************************************************************
*                                                                      *
                    Subroutine   A g S R O T M
*                                                                      *
* Description:  Given the rotation parameters returns matrix number    *
  Replace [;#,#=>#;] with [;rot(#3)=%#1; IF(abs(rot(#3)-#2)>eps) k+=1; ]
************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
  Real Rrot,Rot(6),Rota(6),eps/1.e-5/
  Integer k,Im,i,Nlink,JTM,ii
  rrot(ii)=rot(mod(2*%OrtI+ii-1,6)+1)
*
  k=0;  %Irot=0;
  Thetax+%Alfay,90 => 1;   Thetay+%Alfax,90 => 3;   Thetaz+%Alfax+%Alfay,0 => 5;
  Phix + %Alfaz, 0 => 2;   Phiy + %Alfaz,90 => 4;   Phiz                ,0 => 6;
        " correct for phi uncertainty "  If  %Alfax#0  { %Phiz=90; rot(6)=90; }
  check  k>0 | %Orti>0
  %Irot=1;   Do i=1,6 { Rota(i)=RRot(i) }
  IF JROTM>0    " find an old matrix or the first free slot (or the end) "
  {  Nlink=IQ(JROTM-2);  :matrix: DO  Im=1,Nlink+1
     {  %Irot=Im;  JTM=LQ(JROTM-Im);   IF (JTM<=0 | Im>Nlink)  Break
        Do i=1,6 { If (Rota(i)#Q(JTM+10+i)) Next :Matrix:; };  Return
  }  }
        " Free slot for a new rotation matrix"
  Call GSROTM(%IRot,Rota(1),Rota(2),Rota(3),Rota(4),Rota(5),Rota(6))
  prin1 (Rota(i),i=1,6); (' NEW ROTM theta,phi=',3(F8.1,F6.1))
  END
 
 
 
+DECK,AgSMATE,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 03/02/95  14.29.31  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
              Function     A g S M A T E (CNAME,LINK,Par)
*                                                                    *
*  Description: find the media or the first free slot (or the  end)  *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
     Integer       AgSMATE,NAME(5),LINK,Nlink,Im,JTM,i,Np;
     Character*20  CNAME;
     Real          Par(10);
 
 IF LINK<=0  { AgSMATE =-1;  Return "book first medium at slot 1"; }
;
 Call UCTOH(CNAME,NAME,4,20);  Nlink=IQ(LINK-2);
 NP=6; If (LINK=JTMED) NP=5;
 :Media: DO  Im=1,Nlink+1
 {  JTM=LQ(LINK-Im);    IF (JTM<=0 | Im>Nlink)  Break;
    Do i=1,5  { If ( NAME(i) # IQ(JTM+i) )      Next :Media:; };
    Do i=1,Np { If (0#PAR(i)&Par(i)#Q(JTM+5+i)) Next :Media:; };
    AgSMATE=+Im; " <W> IM; (10x,'ITMED of existing medium ', I3);" return;
 }  AgSMATE=-Im; " <W> IM; (10x,'Free slot for a new medium',I3);" return;
   END
 
+DECK,AgSNAME,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.30.12  by  Pavel Nevski
*CMZU:  1.00/01 30/11/95  19.17.48  by  Pavel Nevski
*CMZ :  1.00/00 24/12/94  15.06.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
          Subroutine   A g S N A M E   (Volume,Ign,CNick)
*                                                                    *
*  Description:  generate a NickName for (Volume,Ign) instance       *
**********************************************************************
+CDE,TYPING,GCUNIT.
  Character*1 Symb
  Character*4 Volume,Cnick
  Integer     Ign,ii,i,j,k
 
 Cnick=Volume;  Unless 0<=Ign & Ign <=1368
{<W> Ign,Volume;(' AgSNAME: Bad volume number ',I5,' for Volume ',A); Return;}
  ii=Ign; do k=4,3,-1
  {  i=mod(ii,37);   ii=ii/37;   check i>0
     j=i+48;   If(i==10) j=48;   If(i>10) j=96+(i-10)
*     Cnick(k:k)=char(j)
     Call ITOCH(j,Symb,*:err:);   Cnick(k:k)=Symb
  }  :err:
   END
 
+DECK,AgSMEDI,T=geant. --------------------------------------------------------
*CMZ :  1.00/00 07/03/95  21.07.41  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A g S M e d i
*                                                                    *
*  Description:  introduce parameters of a new GEANT tracking medium *
*  Called from   AxSHAPE on a new material or medium parameters      *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
    Integer      AgSMATE,LENOCC,Imede,Ifield;
    Character    Cmedi*4,Cmodu*4;
    Real         Par(10);
 
 Cmedi=%Medium;   Cmodu=%Module;  Ifield=%Ifield * %IMFLD;
 if (Cmedi#Cmodu & Cmodu#' ')  %Medium=Cmodu//'_'//%Medium;
 PAR={%Imat,%IsVol,Ifield,%Fieldm,%TmaxFD,%SteMax,%DeeMax,%Epsil,%Stmin,0};
 
 Imede=AgSMATE(%Medium,JTMED,Par);  %IMED=abs(Imede);
 If Imede<0
 {  prin1       %L(%MEDIUM), %IMED, %Imat, %ISVOL,   IFIELD, %FIELDM, %TMAXFD,
                                           %STEMAX, %DEEMAX, %EPSIL,  %STMIN;
                (' AGSTMED  for medium ',A,' med,mat,sen,fld =',2i4,2i2/,
                               10x ,'Field = ',2F5.1,'  steps = ',4F8.5);
    Call GSTMED (%IMED, %MEDIUM, %IMAT,   %ISVOL,  IFIELD, %FIELDM, %TMAXFD,
                        %STEMAX, %DEEMAX, %EPSIL, %STMIN,  %UBUF,   %NWBUF);
 }
  END
 
+DECK,AgSDETV,T=geant. ---------------------------------------------------------
*CMZ :          07/01/98  15.04.19  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  15.03.50  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                Subroutine   A g S D E T V (title)
*                                                                    *
*  Description: for a given (SET,DET) create GEANT sensetive         *
*  detector with corresponding DETU user structure filled later.     *
* In a Geometry module global %iset,%idet are set only for the call  *
* when this set is created to allow next routine (Agsdetu) to store  *
* hit or digi definitions in DETU bank, otherwise they are set to 0. *
* Local Iset,Idet are save in attributes of each calling Nick volume.*
*    In a Digitisation module global %iset,%idet are set always,     *
*    to allow not only set creation, but a modification as well.     *
***GsDETv definition for DIGI erases Iset,Idet,Idtype in the volume. *
*  this is corrected by saving them in sdt and then restoring attrib.*
***If %Type is changed, a new copy of DETU bank is created and       *
* %iset/%idet are set to allow DETU filling in AgsDETH/AgSDETU       *
*                                                                    *
*  Called from users code at the beginning of the hit definition     *
* 16/05/96 PN: bug corrected in %JDU selection for USER bank change  *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM.
   Character title*(*),Cdet*4,Cset*4,Cbank*4,T*1
   Integer   LENOCC,JATTF,JV,J,Iset,Idet,Jdet,Iv,Js,Jd,JDN,JDU,
             NWHI/1000/,NWDI/1000/,Lcumu/15/
   Real      Sdt(3),Upar(%LDETU)" up to 15 levels of volumes and hits "
   JATTF(JV) = JV+int(Q(JV+5))+6
                            * * *
 " Set is always the same as 3 letters of the module name plus H or D "
 T=%EXNAME;  Cset=%Module(1:3)//T;  Cdet=Title;
 { %iset,%idet,Iset,Idet,Jdet,Iv }=0;
 If (Jset > 0)  Call GLOOK(Cset,IQ(JSET+1),IQ(JSET-1),Iset)
 If (Iset > 0)  JDET =LQ(JSET-ISET)
 If (Jdet > 0)  Call GLOOK(Cdet,IQ(JDET+1),IQ(JDET-1),Idet)
                            * * *
 If Iset<=0 | Idet<=0
 {  "              for digi, save previous volume set/det reference       "
    If (T='D') Call GLOOK (Cdet,IQ(JVOLUM+1), Nvolum, Iv)
    If (iv>0)  Call UCopy (Q(JATTF(LQ(JVOLUM-Iv))+7),sdt,3)
    Call GsDETv (Cset,Cdet,%Idtype,NWHI,NWDI,Iset,Idet)
    If Idet<=0|Iset<=0 {error(' can not define sensitive detector ',Title)}
    "              set empty hit or digi bank with maximum size           "
    Call Vzero (Upar,%LDETU)
    If (T='H') Call GsDETH (Cset,Cdet,Lcumu,Upar,Upar,Upar,Upar)
    If (T='D') Call GsDETD (Cset,Cdet,Lcumu,Upar,Upar)
    "              now set users bank - also with max.size                "
    Upar(1)=10;  Upar(8)=%Type;   Upar(9)=%Idtype;  Upar(10)=-1;
    Call GsDETU (Cset,Cdet,%LDETU,Upar); %Iset=Iset; %Idet=Idet;
*pn: 16/03/96 - to get nice bank NID reset it for the first bank
    JDU=LQ(LQ(LQ(Jset-Iset)-Idet)-3); Cbank=' ';
    If (JDU>0) Call UHTOC(IQ(JDU-4),4,Cbank,4)
    If Cbank!='SJDU' {error('can not create User Hit/Digi bank for',Cset,Cdet)}
    IQ(JDU-5)=1
 }
                            * * *
 If      %Module(5:5)='G' & T='H' " mark each volume with its HIT set/detector"
 {  j=JATTF(LQ(JVOLUM-%Ivolume)); Q(j+7)=Iset; Q(j+8)=Idet; Q(j+9)=%IdType; }
 else If %Module(5:5)='D' & T='D' " only digitisation re-definition accepted "
 { if(Iv>0) Call UCopy(sdt,Q(JATTF(LQ(JVOLUM-Iv))+7),3);%iset=Iset;%idet=Idet;}
 else       {error('HITS or DIGI can not be redefined for ',Cset,Cdet)}
 
                            * * *
 " find DETU bank with corresponding serial number and keep its link in %JDU "
 JS=LQ(JSET-Iset);  JD=LQ(JS-Idet);  JDU=LQ(JD-3);  %JDU=JDU;
 While Q(JDU+8)!=%Type & LQ(JDU)>0 { JDU=LQ(JDU);   %JDU=JDU; }
 If %Type!=Q(JDU+8)       " make a new user bank "
 {  Call MZBOOK(IxCons,JDN,JDU,0,'SJDU',0,0,%LDETU,3,0)
    If JDN<=0  {error(' cant create new copy of DETU bank ',%Type)}
    Call Ucopy (Q(JDU+1),Q(JDN+1),%LDETU);    Q(JDN+8)=%Type;
    %iset=Iset;  %idet=Idet;  %JDU=JDN;
 }
   END
 
 
+DECK,AgSDETH,T=geant. ---------------------------------------------------------
*CMZ :          15/02/98  12.51.45  by  Pavel Nevski
*CMZ :  1.30/00 16/04/96  19.12.28  by  Pavel Nevski
*CMZ :  1.00/00 02/06/95  02.20.02  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
***************************************************************************
*                                                                         *
                  Subroutine   A g S D E T H (IEXT)
*                                                                         *
*  Description:  fill the description of a new hit element in DETU.       *
*  In a digitization module a modification mode is also possible.         *
*  Final analyse is done by AggDETV and AggDETU called from AggCLOS.      *
*  This is done on the exit from a geometry module, when all volume       *
*  positionning is finished, or at the end of the DIGI operator           *
*  in a digitization module where positionning is already done.           *
*                Called from users code on each hit element               *
*  Possible hit options are:  C,H,X,R,S - see comments in the code        *
*  If hit code is undefined, an attempt is made to find 'codehit' routine *
*  It is supposed to have same arguments as any user step routine-(j,hit) *
*  Modifications:                                                         *
*  15feb97, PN: Allow less then 4 letters for a 'chit'HIT  routine        *
*                                                                         *
***************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCONST.
 Integer     CSADDR,LENOCC,IEXT,Ltab,Ioption,Jdu,Ia,N,Ja,i1,i2,Ifun,k,i,new
 Real        ARFROMC
 Parameter   (Ltab=27)
 Character   T*1, Hit*4, Ctab(Ltab)*4 _
            /'X','Y','Z','R','RR','PHI','THE','ETA','TDR','CT',
             'CX','CY','CZ','ETOT','ELOS','BIRK','STEP','LGAM',
             'TOF','USER','XX','YY','ZZ','PX','PY','PZ','SLEN'/
 
  Check %Idet>0 & %Iset>0 & %Jdu>0;
  " save next hit in DETU bank for a new structure marked by negative U(10) "
  JDU=%Jdu;  Ia=Q(Jdu+1);    N=Q(jdu+2);      Ja=Jdu+Ia+%NwuHit*N;
             Hit=%Parlist;   new=Q(Jdu+10);   T=%EXNAME;
                               * * *
  If new<0                                            " a new hit element "
  {  Ia=Q(Jdu+1);   N=Q(jdu+2);    Ja=Jdu+Ia+%NwuHit*N;
     If (N>=14)    {error('Can not store more hit elements ',N)};
     N+=1;          Q(jdu+2)=N;    Q(jdu+3)=Ia+%NwuHit*N;
     Call  Vzero(Q(Ja+1),10);
     Q(Ja+1)=ARFROMC(%ParList);    Q(Ja+2)=ARFROMC(%Option);
     Q(Ja+3)=%Nbits;   Q(Ja+4)=%FhMin;   Q(Ja+5)=%FhMax;
     If (%bin>0)       Q(Ja+7)=1/%bin;
     If (HIT='USER')   IQ(Ja+9)=IEXT;                " not exportable...   "
     Ifun=0;      k=Lenocc(Hit)                      " hit function code   "
     do i=1,Ltab  { Check Hit(1:k)==Ctab(i)(1:k);    Ifun=i;   break;      }
     If Ifun==0   { IQ(Ja+9)=CSADDR(HIT(1:k)//'HIT') }
*
     Q(Ja+10)=Ifun;  Ioption=Q(Jdu+7);               " global option setup "
     "option H used in AggDETU to mark the start of 'hit' field a la GEANT "
     "option R                 to require bin rounding up to 2 digits      "
     if (Index(%Option,'S')>0) Call SBIT1(Ioption,1) " single step option  "
     if (1 <=Ifun & Ifun<= 10) Call SBIT1(Ioption,2) " local coordinate rq "
     if (Index(%Option,'X')>0) Call SBIT1(Ioption,2) " same explicitly     "
     if (11<=Ifun & Ifun<= 13) Call SBIT1(Ioption,3) " local direction rq  "
     if (Index(%Option,'X')>0) Call SBIT1(Ioption,3) " same explicitly     "
     if (Index(%Option,'C')>0) Call SBIT1(Ioption,4) " Calorimeter option  "
     Q(Jdu+7)=Ioption
  }
  else                               " update an existing hit/digi element "
  {  i1=Q(Jdu+1); i2=Q(Jdu+3);
     do ia=i1,i2-1,%NwuHit
     {  Ja=Jdu+ia;   check Q(Ja+1)=ARFROMC(%ParList)
        If (%Option # '*') Q(Ja+2)=ARFROMC(%Option)
        If (%Nbits#%Magic) Q(ja+3)=%Nbits;  Q(Ja+4)=%FhMin;  Q(Ja+5)=%FhMax;
        If (%bin>0)      { Q(Ja+7)=1/%bin;  Q(Ja+3)=%Magic; }
  }  }
  END
 
 
 
+DECK,AgSDETU,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 01/06/95  18.40.03  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                  Subroutine   A g S D E T U (Title)
*                                                                    *
*  Description: in a digitisation module make changes in SET param-s *
*  called from users code at the end of a digi structure description *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
  Character Title*(*),Cdet*4;   Integer Js,Jd,Jdu,new;
 
  Check  %Idet>0 & %Iset>0 & %Jdu>0;      Cdet=Title;
  Jdu=%Jdu;  new=Q(Jdu+10);  Q(Jdu+10)=max(0,%Iprin);
  If (%Module(5:5)='D')
  {  Js=LQ(JSET-%Iset);  Jd=LQ(Js-%Idet);
     if (IQ(JD+9)<0)     IQ(Jd+9)=0;
     if (new<0)   call AgGDETV(Cdet,Jdu);
     call AgGDETU(%Iset,%Idet,JDU,%Iprin);
  }
  { %Iset,%Idet }=0;
  END
 
 
+DECK,AgSRESET,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 14/11/96  17.24.24  by  Pavel Nevski
*CMZ :  1.00/00 06/08/95  14.00.59  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S R E S E T
*                                                                    *
*  Description: Before each processor call reset WORK2 area to allow *
*               recognition of actual parameters
*               and set some (KONLY,ROTM) defaults                   *
**********************************************************************
+CDE,TYPING,AGECOM.
  Integer LOCF
  Call VZERO(%Reset1,LOCF(%Reset2)-LOCF(%Reset1)+1)
  %Mother=%Volume; %Konly='ONLY'
  {%Thetax,%Thetay,%Phiy}=90
   END
 
+DECK,AgSPUSH,T=geant. ---------------------------------------------------------
*CMZ :          30/05/97  15.31.01  by  Pavel Nevski
*CMZ :  1.30/00 07/08/96  15.08.41  by  Pavel Nevski
*CMZU:  1.00/01 01/12/95  02.07.10  by  Pavel Nevski
*CMZ :  1.00/00 01/06/95  13.09.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                     Subroutine   A g S P U S H
*                                                                    *
*  Description:  Push the stack at the start-of-block                *
*                redefine parents and set default attributes etc     *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,SCLINK.
 Integer       LOCF,LENOCC,L,Iv,IL,NUM/0/
 Real          Volume
 Equivalence   (%Volume,Volume)
 
 If %Mark!='V00'
 { print *,'     ***********************************************************'
   print *,'     ***           FATAL ERROR in ',%Module,'       ***'
   print *,'     *** geant3.def file was changed, delete your *.sl files ***'
           STOP '***********************************************************'
 }
 If (%Level=0) NUM=0
 If %Level>=15 {error('Number of nesting levels is more than 15')}; %Level+=1;
 L=LOCF(%EndSave)-LOCF(%BegCom)
 if (L>%LSTACK) stop 'AgsPUSH Fatal error: lack of stack dimension'
 Call UCOPY (%BegCom, %Stack(1,%Level), L)
 CALL VZERO (%BegScr, LOCF(%EndScr)-LOCF(%BegScr))
 
 %Mother=%Volume;  %Imother=%Ivolume;  %Volume=%Title;
 {%Ivolume,%Istatus,%NLmat,%Isvol}=0;
 Iv=LOCF(Volume)-LOCF(%Begcom)+1;
 Do IL=1,%Level-1
 { IF %Stack(iv,il)=VOLUME {error('Recursive block call not accepted')} }
 Iprin=max(%Iprin-%Level-1,0);   Num+=1;  Prin1 NUM,%level,%L(%Title)
       (/' **',i5,' ** we are at level ',i3,' in block ',A/)
   END
 
+DECK,AgSPOPB,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 05/08/96  13.22.16  by  Pavel Nevski
*CMZ :  1.00/00 26/12/94  01.37.43  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                     Subroutine   A g S P O P B
*                                                                    *
*  Description:  pop stack at the end-of-block                       *
*                at upper level close hit structure                  *
**********************************************************************
+CDE,TYPING,AGECOM,GCUNIT.
 Integer LOCF,LENOCC;
 
 If %Istatus==0 {error('block is empty')};
 If %Level<=0   {error('Stack underflow: nesting level is wrong')};
 Call UCOPY (%Stack(1,%Level), %BegCom, LOCF(%EndSave)-LOCF(%BegCom));
 %Level-=1;  Iprin=max(%Iprin-%Level-1,0);  if (%level>0) return;
   END
 
+DECK,AgSBEGM,T=geant. ---------------------------------------------------------
*CMZ :          13/01/98  01.32.23  by  Pavel Nevski
*CMZ :  1.30/00 13/05/97  14.31.40  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
************************************************************************
*                                                                      *
            Subroutine   A g S B E G M (Module,IPR)
*                                                                      *
*  Description: open a module execution part and control execution     *
*  Print flag is set to the production of both module and stage print  *
*  In a standalone mode all geomtry structures are dropped             *
*  Modifications:                                                      *
*  13/05/97 PN: default FILL (att6) is 0 to cope with 97a black edges  *
*  10.01.98 PN: detm.rz has to be made 'old format' for built in dzdoc *
************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCFLAG,SCLINK,QUEST.
   Integer           AgPFLAG,LENOCC,n,m;   parameter   (n=100)
   Character         Module*(*),Stage*4,Cmother*4,Cs*1,Chdir0*6/' '/
   Integer           IPR,i,Idet,Lrecl,Istat,Itry,Lun/61/
   Character*8       CHTAG(2)/'Bank-ID','Bank-ID'/,CHDIR(n)
   Real              Xtime,XXtime
   Common /AgCMTIME/ Xtime,XXtime
   Logical           EXST,Opnd,First/.true./
+CDE,STAFUNC.
                            * * *
   Check %Module != Module;
   %Module=Module; Cs=Module(5:5);
   If Cs='G' {Stage='GEOM'} else if Cs='D' {Stage='DIGI'} else {Stage='RECO'}
   Cmother=' ';    If (JVOLUM>0) CALL UHTOC(IQ(JVOLUM+1),4,CMother,4);
   If Cs='G' { do i=1,5 { %attribute(i)=1; };  %attribute(6)=0 }
                               * * *
   Call AsbDETE (Module,Idet)
   %IdType=Idet;         %Iprin=AgPFLAG(Module,Stage);
   %IMFLd=LVMFLD(Idet);  %Ihist=LVHIST(Idet);  %IGrap=LVGRAP(idet);
   %Igeom=LVGEOM(Idet);  IF (Stage=='RECO')    %Igeom=LVRECO(Idet);
   IPR=%Iprin; Iprin=%Iprin;
*
   "Make a standalone clean up"
   If Cs='G' & Cmother=%Module(1:4) & %Standalone>0
   {  Call AGDROP('*'); If (Idebug>0) Iprin+=1; }
*
   "Make sure minimal GEANT structures are present for G stage "
   If (Cs=='G' ) Call Agstand
*
   prin1 %Module,%Igeom,%Iprin;
   (' Module ',a8,'  running for geometry',i5,'  print level=',i3);
  " try to reduce the amount of prints:" if (Iprin>0) Iprin=Iprin-1;
   if (%Iprin>1)  Call TIMEX(Xtime);
   If %IHIST>0
   {  CALL HCDIR('//PAWC',' ');   CALL HRDIR(n,CHDIR,m)
      Do I=1,m  { Check CHDIR(i)==Module(1:LENOCC(CHDIR(i)))
                  CALL HCDIR(CHDIR(i),' ');  Break;
   }            }
                              * * *
   INQUIRE(FILE='detm.rz',OPENED=opnd)
   If .not.opnd
   {  Lrecl=256;   INQUIRE(FILE='detm.rz',EXIST=EXST);  %ChDir='RZDOC'
      If !EXST { Call RZOPEN (Lun,%CHdir,'detm.rz','NWX', Lrecl,Istat)
                 Call RZMAKE (Lun,%CHdir,2,'HH',CHTAG,5000,'XO')
                 call RZCLOS (%Chdir,' ')
               }
      Call RZOPEN (Lun,%ChDir, 'detm.rz','UWXD',Lrecl,Istat);
*
* from pawrop:
*--- bug in RZOPEN with C I/O, TOPDIR is not returned correctly ---
*     IF (IOPTC!=0 & LUN <10) WRITE(TOPDIR,'(3HLUN,i1)') LUN
*     IF (IOPTC!=0 & LUN>=10) WRITE(TOPDIR,'(3HLUN,i2)') LUN
*
      Call RZLOGL (Lun,-3);    "  Call RZCDIR (ChDir0,'P') "
      Do Itry=1,2
      {  Call RZFILE(Lun,%ChDir,'UDX'); if (Iquest(1)==0) Break
         Call Rzfree('RZFILE');         Call RZEND(%Chdir)
      }
      If Istat!=0     { <w>; (' detm.rz absent - no documentation available');}
      If Iquest(1)!=0 { <w>Iquest(1);(' problem opening detm.rz, IQUEST=',i6);}
*     Chdir0=%Chdir
   }
   END
 
 
+DECK,AgSENDM,T=geant. ---------------------------------------------------------
*CMZ :          04/03/98  23.44.07  by  Pavel Nevski
*CMZ :  1.30/00 17/04/97  17.59.21  by  Pavel Nevski
*CMZ :  1.00/00 29/11/95  08.55.19  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                   Subroutine   A g S E N D M
*                                                                    *
*  Description: close the module. In the interactive debug mode      *
*               show documentation banks and draw the detector       *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCFLAG,SCLINK.
   Integer      LZFID,L1,Iv,I,Npar,Key(2)
   Character*4  Cmother
   Real         c,d, Xtime,XXtime,XXi
   Common /AgCMTIME/ Xtime,XXtime
+CDE,STAFUNC.
 
   Check %Module#' '; Call TIMEX(XXi)
   If %Module(5:5)=='G'                                " geometry module "
   {  Call AgGCLOS;
      Cmother=%Module; If (JVOLUM>0) Call UHTOC(IQ(JVOLUM+1),4,Cmother,4);
      If Cmother=%Module(1:4) & %STANDALONE>0 "Cmother!='ATLS'&Cmother!='CAVE'"
      {  Call GGCLOS;
         If Idebug>1                             " show documentation banks "
         {  Call UCTOH  ('DETMNONE',Key,4,8);
            L1=LZFID (IxCONS,Key(1),Key(2),0); If (L1>0) _
            call DZSURV ('Detector Master Banks',IxCONS,L1)
         }
         If JVOLUM>0 & LKDETM>0 & %IGRAP>=1 & Idebug>0  " draw the detector "
         {  Iv=1;    Npar=Q(LQ(JVOLUM-Iv)+5);
            d=1;     do I=1,min(Npar,3) { d=max(d,Q(LQ(JVOLUM-Iv)+6+i)); }
            c=10/d;  Call GDRAW (Cmother,120.,120.,0.,10.,10.,c,c);
      }  }
   }
*  if %Chdir!=' ' { call RZCLOS (%Chdir,' ');  %Chdir=' ' }
   if (%Chdir!=' ') call RZSAVE
   If %Iprin>1
   { Call TIMEX(XXtime); <W> %module,XXtime-Xtime,XXi-Xtime
     (' Module ',a,' done',11x,'Time=',F8.3,' (proper time=',F8.3,')')
   } %Module=' '
   END
 
 
+DECK,AgGCLOS,T=geant. ========================================================
*CMZ :          09/01/98  03.41.25  by  Pavel Nevski
*CMZ :  1.30/00 02/04/96  20.16.48  by  Pavel Nevski
*CMZ :  1.00/00 29/05/95  16.26.52  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g G C L O S
*                                                                    *
*  Description:  Fill hit structures for all sensitive detectors     *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
  Character*4 Cset,Cdet
  Integer     IPRIN,Iset,Idet,JS,JD,Jdu
 
  Check Jset>0
  :set: DO Iset=1,IQ(Jset-1)                                 " Over Nset "
  {  JS=LQ(Jset-Iset);   Check JS>0;  Call UHTOC (IQ(Jset+Iset),4,Cset,4)
     :det: DO Idet=1,IQ(LQ(Jset-Iset)-1)                     " Over Ndet "
     {  JD=LQ(JS-Idet);  Check JD>0;  Call UHTOC (IQ(JS + Idet),4,Cdet,4)
        "Find unprocessed banks "     Check IQ(JD+9)=-1;       IQ(JD+9)=0
*      02/04/96: it is possible also to create GEANT multipath by keeping -1.
*      commented out 09.01.98
*      CALL GGDETV(Iset,Idet);
       JS=LQ(Jset-Iset);    JD=LQ(JS-Idet)
*
        JDU=LQ(JD-3);    While JDU>0
        {  Iprin=Q(JDU+10);
           " get  path  "   Call AgGDETV (Cdet,JDU);
           " fill banks "   Call AgGDETU (Iset,Idet,JDU,IPRIN);
           " take next  "   JDU=LQ(JDU);
        }
  }  }
  END
 
+DECK,AgGDETV,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.30.48  by  Pavel Nevski
*CMZ :  1.00/00 01/01/95  16.58.06  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A g G D E T V (Cdet,JDU)
*                                                                    *
*  Description: given a sensitive detector make a description of     *
*               path (NAMESV,NBITSV) for the hit definition          *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCNUM.
  Character*4 Cdet
  Integer   Nchild,Ifamily(1000),Level,Idet,Ivol1,Iv,Jv,nin,in,Jd,Id,ip,N1,N2,
            Iprin/9/,Nhisch,Ncopy,Nr,Jp,L,m,Jdu,Ia,N,Ja,Name(20),GName(20),
            NumV(20),Numb(20),Mask(20),NumP(20),NumH(20),Ivol(20)
 
call UCTOH(Cdet,Idet,4,4); call UCTOH('VOL1',Ivol1,4,4);
Level=1;                 {Name(1),Gname(1)}=Idet;
{N1,N2,Mask(1),NumV(1),NumP(1),NumH(1),Nchild}=0;
if (JVOLUM<0) Return;
Do Iv=1,Nvolum
{  Jv=LQ(JVOLUM-Iv);  Check JV>0;  Check IQ(JV-4)=Idet;
   Nchild+=1; Ifamily(Nchild)=Iv;  If (IQ(JVOLUM+Iv)=Idet) Ivol(1)=Iv;
}
If Nchild=0 { <w> Cdet; (' AgGDETV: detector ',a,' not found'); return; }
"<w> cdet,Nvolum,Nchild; (' *** in aggdetv: cdet,nvol,nchild = ',a4,2i6);"
 
Until "Ifamily(Nchild)==0 \" N1>N2  \ Level==20
{  " previous level children are in (N1,N2) range on family "
   N1=N2+1;  N2=Nchild;  Level+=1;  L=Level;
   {Name(L),Gname(L),NumV(L),Numb(L),NumH(L),Mask(L),NumP(L),Ivol(L)}=0;
 
  " select family parents: Iv is parent of Id, Nr is copy number or Ndiv  "
  " Nhisch is the number if his direct counted children (previous level !)"
  " Ncopy is the higher copy number, used for NVL if more than one copy ! "
  " NumP contains total number of found new parents at that level         "
 
   Do Iv=1,NVOLUM                                      " Iv is a parent "
   {  Jv=LQ(JVOLUM-Iv);  nin=Q(Jv+3); Check nin#0;     " He has a child "
      Nhisch=0; Ncopy=0;
      do in=1,max(nin,1)
      {  Jd=LQ(Jv-in); Id=Q(Jd+2); Nr=Q(Jd+3);         " - is his child "
         do ip=N1,N2                                   " in the family? "
         {  Check Id==Ifamily(ip);                     "   Yes !        "
            Nhisch+=1; Ncopy=max(Ncopy,Nr);
            "mark this parent as a next level child (If not marked yet) "
            Do jp=n2+1,Nchild { If (Ifamily(jp)==Iv) go to :known:; }
            if Nchild<1000    { Nchild+=1;  Ifamily(Nchild)=Iv; }
            else {<W> Cdet;(' AgGDETV error: too many parents of ',a);Return;}
            :known:        " -  find its generic name ";
            If IQ(Jv-4)#Ivol1 { Gname(Level)=IQ(Jv-4); }
            else              { Gname(Level)=IQ(JVOLUM+iv); };
            " make XOR name and mask - and select NameSV name "
            Name(Level)=IOR(Name(Level),IQ(JVOLUM+Iv));
            Mask(Level)=IOR(Mask(Level),IEOR(Name(Level),IQ(JVOLUM+Iv)));
            If (Name(level)==Gname(Level)) Ivol(Level)=Iv;
            If  (Iv=1)  NumV(Level)=1;
      }  }  L=Level-1;
 
      " skip counting if one child only is positioned "
      Unless (Nin>0 & Nhisch<=1) NumH(L)=max(NumH(L),Ncopy)
      NumV(L)=max(NumV(L),Ncopy) " but remember anyway its copy number "
      NumP(Level)=Nchild-N2      " and count how many branches we have "
   }
   If Ivol(Level)==0 " active daughters are positioned NOT in the first copy "
   { Do Iv=1,Nvolum  { If (Gname(Level)==IQ(JVOLUM+iv)) Ivol(Level)=Iv;  } };
   Numb(L)=0; If (NumH(L)>0) { m=NumV(L)-1; while m>0 { m/=2; Numb(L)+=1; }};
   If (Jdu>0) Iprin=Q(Jdu+10);
   Prin5  L,NumP(L),Name(L),Gname(L),NumH(L),NumV(L),Numb(L),Mask(L),Ivol(L);
         (2i6,2(2x,A4),3i6,1x,Z8,i8);
}  Level=Level-2;
   If Jdu>0
   {  Do L=Level,1,-1
      {  Ia=Q(Jdu+3);      N=Q(jdu+4);       Ja=Jdu+Ia+N*3;   "<<start<<"
         Q(Ja+1)=Ivol(L);  Q(Ja+2)=NumV(L);  Q(Ja+3)=Numb(L); " 3 words "
         N+=1;             Q(jdu+4)=N;       Q(jdu+5)=Ia+N*3; "<< stop<<"
   }  }
   END
 
+DECK,AgGDETU,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 09/09/96  16.45.51  by  Pavel Nevski
*CMZ :  1.00/00 06/06/95  00.08.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
              Subroutine   A g G D E T U (Iset,Idet,Jdu,IPRIN)
*                                                                    *
*  Description: calculate Nbit,Origin and Factors for hit/digi sets  *
*               and fill DET,DETH/DETD banks starting from DETU bank *
*  ->           Parameters NwuHit,NwuVol,Magic are hardwired here    *
*  ->31.8.96:   Nbit option use full 2**Nbit range,                  *
*               Bin option has its range symmetrise around the center*
**********************************************************************
Replace[ERR(#)] with _
       [<W> Cset,Cdet; (' AgGDETU error for set,det=',2(1x,a));
         Write (Lout,*) ' ******> ',#1; RETURN;              ];
+CDE,TYPING,GCBANK,GCUNIT,GCONST.
 
 Character*4 ACFROMR,Cset,Cdet,Chit,Copt
 Integer     INDEX,IPRIN,Iset,Idet,Js,Jd,Jdu,Jx,i,i1,i2,J,K,L,M,N,X,Mode,Node,
             Nbit,Nbin,Nb,Nam,iv,Kv,Nv,Nn,Nh,Nw,Nwo,Lf,Ifun,Ld,Lx,Ldu,Jds,Lex,
             JL,NameV(20),NbitV(20),LL(2)/10,3/,Magic/-696969/
 Real        Lfact,Fmin,Fmax,Orig,Fact,Range,ofs,
             Log2/.30103/,safety/0.02/
 
  Check  Jset>0 & Idet>0 & Iset>0;
  JS=LQ(Jset-Iset);  Check JS>0;  Call UHTOC (IQ(Jset+Iset),4,Cset,4);
  JD=LQ(JS - Idet);  Check JD>0;  Call UHTOC (IQ(JS + Idet),4,Cdet,4);
  If Cset(4:4)='H'  {X=1}  else  If Cset(4:4)='D'  {X=2}
  else              {err('can not decode set type ')};       Ld =IQ(JD-1);
  JX =LQ(JD-X); If JX <=0 {err('hit/digi bank not found ')}; Lx =IQ(JX-1);
 "Jdu=LQ(JD-3)" If Jdu<=0 {err('No  user bank  defined  ')}; Ldu=IQ(Jdu-1);
  Prin2  Cset,Cdet; (/' *** ',2(1x,A4),' *** ');
 
  "reset volumes and hit counters " {Nn,Nv,Nw,K,Kv,Nh,Nwo,Mode,Node} =0;
  Do M=2,0,-2
  {  i1=Q(Jdu+M+1); i2=Q(Jdu+M+3); N=Q(Jdu+M+2); Check N>0; L=(i2-i1)/N;
     If L#LL(1+M/2) | 1>N|N>15 | i2>Ldu | i1<10
        {err('Bad format of DETU bank, M,i1/2,N=',M,I1,I2,N)}
     do i=i1,i2-1,L
     {  j=Jdu+i; If M==2   " - - - - - - - volumes - - - - - - - - "
        {  iv=Q(j+1); Nam=IQ(JVOLUM+iv); {Nbit,Nb}=Q(j+3); Check Nb>0; Kv+=1; }
        else               " - - - - - - - - hits  - - - - - - - - "
        {  Chit=ACFROMR(Q(j+1)); Copt=ACFROMR(Q(j+2)); Call UCTOH(Chit,nam,4,4)
          " Limits will be re-calculated If Q(4)>=Q(5), ifun is not redefined "
           Ifun=Q(j+10); Call AgGFLIM(Chit,Cdet,Q(j+4),Q(j+5),Ifun);
                                  * * *
          " mode=1 means commulative part, node=1 - users request for hit part"
           Nbit=Q(j+3);  Fmin=Q(j+4);   Fmax=Q(J+5);   Fact=Q(J+7);
           If Index(Copt,'H')>0             { K=0;    Node=1;  }
           If -32<=Nbit&Nbit<=0 & Mode=0    { K=0;    Mode=1;  }
           If Fmin==Magic & Fmax==Magic & Nbit>0
           {  ofs=0;  if (i==i1 & Q(LQ(JD-3)+8)>Magic) ofs=Q(LQ(JD-3)+8)
              Fmin=ofs-0.5; if (Index(Copt,'F')>0) Fmin=ofs; Fmax=Fmin+2**Nbit;
           }
           "   Define Range (for a cumulative mode Origin is always 0)    "
           Orig=0;  If (mode=0) Orig =-Fmin;  Range=Orig+Fmax;
           If (Range<=0) <w> Cset,Cdet,Chit,Fmin,Fmax; (' Error in',2(1x,a4),
             ': HITS/DIGI element ',a4,' has invalid range',2E12.3/,
             ' *** Probably this shape is still absent in GFLCAR/RAD/etc ***'/,
             ' *** You should set limits for this element explicitely !! ***')
                                  * * *
           If Nbit>=-32                                        " Nbit option "
           {  "             Nb is always from 1 to 32                   "
              Nb=min(32,abs(Nbit));  If (Nb=0) Nb=32;
              " 31.08.96:  use all bit combination without last spare   "
              Fact=1;  If (Range>0)  Fact=2.**min(31,Nb)/Range;
              "     if rounding option, factors mantissa is 2 digits    "
              If Index(Copt,'R')>0 & Range>0
              {  Lfact=Log2*min(Nb,31)-log10(Range)-safety;
                 Lf=nint(Lfact-1.5); Fact=nint(10.**(Lfact-Lf))*10.**Lf;
           }  }
           else                                              " fix bin option "
           {  Nbin=Range*Fact+0.99; Range=Nbin/Fact;         " ? to continue? "
              Nb=0;  while Nbin>0 { Nbin/=2; Nb+=1; };
              Nb=min(max(1,Nb),32);
           }
           if (Mode=0) Orig=-(Fmax+Fmin-Range)/2         "  - symmetrise  "
           Q(J+5)=Fmax;  Q(J+6)=Orig;  Q(J+7)=Fact;  Q(J+8)=Nb;
           Prin3 Chit,Ifun,Nb,Fmin,Fmax,Orig,Fact;
           (' hit = ',A4,' cod,nb=',2i3,' min/max,orig,fact=',3F10.3,G12.3);
        }
        " count packed words and the remaining bits "
        If  Nb>K   { Nw+=1; K=32; };    K-=Nb;
        Nn=min(Nn+1,20); NameV(Nn)=Nam; NbitV(Nn)=Nb*(1-2*mode);
                                  * * *
        If Mode=0 & Node=0            " overwrite SEJD detector bank in SETS "
        {  if 2*(nv+1)+10>Ld | Nv>=20
              {err('unsufficient length of the detector bank in SETS',ld,nv)};
           Nv+=1;  IQ(Jd+2*nv+9)=Nam;   nwo=nw;
                   IQ(Jd+2*nv+10)=max(IQ(Jd+2*nv+10),Nb);
        }  else                       " overwrite SJDH or SJDD hit/digi bank "
        {  if (Nh+1)*(4/X)>Lx | Nh>=20
              {err('unsufficient length of DETH or DETD bank in SETS',lx,nh)};
           Nh+=1;  Jx=Jx+1; IQ(Jx)=Nam; Jx=Jx+1; IQ(Jx)=max(IQ(Jx),Nb);
           if X=1 {Jx=Jx+1; Q(Jx)=Orig; Jx=Jx+1;  Q(Jx)=Fact; }
        }
  }  }
  Prin2 (NameV(i),i=1,Nn); (/' NameV : ',20(2x,A4));
  Prin2 (NbitV(i),i=1,Nn); ( ' NbitV : ',20(i4,2x));
  Prin3   Cset,Cdet;       (' *** ',2(1x,A4),' *** '/);
 *                                          this is maximum number of:
 J=JD+2*X;   if  Jdu=LQ(JD-3)   {{IQ(JD+1),IQ(JD+2),IQ(J+1),IQ(J+2)}=0;}
 IQ(JD+1) = max(IQ(JD+1),Nwo)   " words to store packed volume numbers";
 IQ(JD+2) = max(IQ(JD+2),Nv)    " volume descriptors in detector bank ";
 IQ(J+1)  = max(IQ(J+1),Nw-Nwo) " words to store packed hits or digi  ";
 IQ(J+2)  = max(IQ(J+2),Nh)     " hit/digi descriptors in DETH/D bank ";
 Q(Jdu+6) = Kv      " number of geometry branchings - really volumes  ";
 *
 *                                          trim hit/digi/user banks
      Lex=IQ(Jdu-1)-nint(max(Q(Jdu+3),Q(Jdu+5)));
          If (Lex>0) Call MZPUSH(IxCons,Jdu,0,-Lex,'I')
      Lex=IQ(JD-1)-10-2*IQ(JD+2);
 *     original SEJD bank was 100, but GGDETV may change it - then leave it
          If (Lex>0 & IQ(JD-1)==100) Call MZPUSH(IxCons,JD, 0,-Lex,'I')
      JL=JX; JX =LQ(JD-X);  Lex=IQ(JX-1)-(JL-JX);
          If (Lex>0) Call MZPUSH(IxCons,JX, 0,-Lex,'I')
 
 Nv=IQ(JD+2); Do i=kv+1,nv
 { jds=LQ(JD-3); while Jds>0 { Q(Jds+10*(i-kv)+8)=IQ(JD+10+2*i); jds=LQ(jds)} }
 *
  END
 
+DECK,AGGFlIM,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.31.31  by  Pavel Nevski
*CMZ :  1.00/00 22/09/95  18.08.16  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
      Subroutine   A g G F L I M (CHit,Cdet,CLo,CHi,Ifun)
*                                                                    *
*  Description: set limits for a hit using GEANT volume dimensions   *
*  Modifications:                                                    *
*  12/11/96 - only if both limits are not defined explicitly.        *
**********************************************************************
+CDE,TYPING,GCUNIT,AGECOM,GCCUTS.
 
  Integer      Ifun,iax,Magic/-696969/
  Real         Clo,Chi,CL,CH,dens,Step2,Step3
  Character*4  Cdet,Chit
 
  Check (Clo==%Magic | Chi==%Magic)
If 1<=Ifun & Ifun<=9    "x,y,z,r,rr,phi,the,eta,tdr"
{  iax=Ifun; If (Ifun=8) iax=7; If (Ifun=9) iax=4;
   Call AgGFDIM (iax,Cdet,CL,CH,dens);
   If Ifun=8 { " instead of Rap(CL,CH)" CL=-5; CH=+5; }
}
If 15<=Ifun & Ifun<=17  "step and energy losses"
{  Step2=0; Step3=1; do iax=1,3
   { Call AgGFDIM (iax,Cdet,CL,CH,dens);
     Step2=Step2+(CH-CL)**2;  Step3=Step3*abs(CH-CL);
   } Step2=Sqrt(Step2);   If (Step3>0) Step3=Step3**0.333333;
}
*                               set measurement default limits
 If Ifun=10               "Cp"     { CL=-1;     CH=+1;      }
 If 11<=Ifun&Ifun<=13  "cx,cy,cz"  { CL=-1;     CH=+1;      }
 If Ifun=14              "ETOT"    { CL=0;      CH=1000;    }
 If Ifun=15 | Ifun=16    "ELOS"    { CL=0;      CH=.01*dens*step3; }
 If Ifun=17              "STEP"    { CL=0;      CH=Step2;   }
 If Ifun=18              "Lgam"    { CL=0;      CH=10;      }
 If Ifun=19              "TOF "    { CL=0;      CH=TOFMAX;  }
 If Ifun=20              "USER"    { CL=%Magic; CH=%Magic   }
 If 21<=Ifun&Ifun<=23  "XX,YY,ZZ"  { CL=-1000;  CH=1000;    }
 If 24<=Ifun&Ifun<=26  "PX,PY,PZ"  { CL=-1000;  CH=1000;    }
 If Ifun=27              "SLEN"    { CL=0;      CH=10000;   }
 If Ifun=28              "SHTN"    { CL=%Magic; CH=%Magic   }
 If Ifun>0  { If (Clo=%Magic) Clo=CL; If (Chi=%Magic) Chi=CH; }
   END
 
 
 
 
+DECK,AgGFDIM,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.32.11  by  Pavel Nevski
*CMZU:  1.00/01 27/01/96  22.06.24  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
          Subroutine   A g G F D I M (Iax,Cdet,Cl0,Ch0,dens)
*                                                                    *
*  Description: given a sensetive volume and axis, find its dimension*
*             Just a continuation of AgGFLIM splitted for convenience*
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCONST.
 
 Integer     Idet,Iax,Nvol,Iv,Jv,Ish,Imo,Jmo,Nin,In,Ida,NR,
             IDH,Jda,Npar,Natt,Ier,Numed,Nmat
 Real        CL0,CH0,CL,CH,dens,xyz(3),Par(100),Att(20)
 Character*4 Cdet
 Data        xyz/3*0/
 
 CL0=+1.e10; CH0=-1.e10;            Check 1<=Iax & Iax<=8;
 Check JVOLUM>0; NVOL=IQ(JVOLUM-1); Call UCTOH(Cdet,Idet,4,4);
Do Iv=1,Nvol
{  Jv=LQ(JVOLUM-Iv);               Check JV>0;
   Ish=Q(Jv+2);  IDH=IQ(Jv-4);     Check Idet==IDH;
   numed=Q(Jv+4);  if (numed>0 & JTMED>0) Nmat=Q(LQ(JTMED-numed)+6);
                   If (Nmat>0  & JMATE>0) dens=Q(LQ(JMATE-Nmat)+8);
   Do Imo=1,Nvol
   {  Jmo=LQ(JVOLUM-Imo); Check Jmo>0;  Nin=Q(Jmo+3);
      do In=1,Abs(Nin)
      {  Jda=LQ(Jmo-In);  Check Jda>0;  Ida=Q(Jda+2);
         NR=Q(Jda+3);     Check Ida=Iv; Npar=Q(Jv+5);
         Call GFIPAR(Jv,Jmo,In, Npar,Natt,Par,Att)
         IF Npar<=0 | Npar>50
         { <W> Cdet; (' AgGFDIM: still error in GFIPAR for volume ',a4/,
                      ' ***** PLEASE USE EXPLICIT HIT LIMITS *****')
           next
         }
         if      Iax<=3  {  call GFLCAR (Iax,Ish,0,    Par,CL,CH,ier);  }
         else if Iax<=5  {  call GFLRAD (Iax,Ish,0,xyz,Par,CL,CH,Ier);  }
         else if iax==6  {  call GFLPHI (    Ish,0,xyz,Par,CL,CH,Ier);
                            if (CL>CH) CL-=360; CL*=DegRad; CH*=DegRad; }
         else if iax==7  {  call GFLTHE (    Ish,0,xyz,Par,CL,CH,Ier);
                                                CL*=DegRad; CH*=DegRad; }
 
         CL0=min(CL0,CL);   CH0=max(CH0,CH);
}  }  }
   END
 
+DECK,AgGSTEP,T=geant. =========================================================
*CMZ :          11/01/98  19.20.57  by  Pavel Nevski
*CMZ :  1.30/00 16/03/97  14.27.55  by  Pavel Nevski
*CMZU:  1.00/01 29/01/96  13.26.30  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                  Subroutine   A g G S T E P (Iret)
*                                                                    *
*    Description: general gustep for any detector with auto-hits     *
*    Scan and fill the hit structure for all sensitive detectors     *
**********************************************************************
+CDE,TYPING,GCBANK,GCFLAG,GCONST,GCUNIT,GCVOLU,GCTMED,GCSETS.
+CDE,GCKINE,GCKING,GCTRAK,AGCSTEP,SCLINK,QUEST.
 Real      Org,Fct,Fmx,Hit,AgGHIT,Serial,xx,h1,Gold
 Integer   JBIT,JATTF,LWSTEP,LDETE,Jj,JS,JD,i,j,k,i1,i2,Nb,Ih,Jh,Jv,Idevt0,
           iv,iw,Nlev,Jat,Ihit,Ic,Iad,Id,Iopt,Iret,Itr,JDH,Jds,mode,mec,itry,
           Iprin,Isimu,bin,Nbr,Jdu/0/,Id0/-1/,NwuVol/3/,NwuHit/10/,Inpu/-1/
 Save      Jdu,iv,iw,Iprin,Isimu,Iopt,Id0,Serial,Gold,Idevt0
+CDE,STAFUNC.
 LWSTEP(IIIII) = IQ(LQ(LKDETM-IIIII)+13)
 LDETE (IIIII) = IQ(LQ(LKDETM-IIIII)-1)
 JATTF(Jj)     = Jj+int(Q(Jj+5))+6
 bin(xx)       = Ifix((xx+org)*fct)
*
* - - - - - - - - - - - - - print control - - - - - - - - - - - -
 If (Idevt!=Idevt0&LkDETM>0) Call GLOOK('TRAC',IQ(LKdetm+1),IQ(LKdetm-1),Id0);
 Idevt0=Idevt;  Jat=JATTF(LQ(JVOLUM-LVOLUM(Nlevel)));  Id=Q(Jat+9);  Iprin=0;
 If Idebug>0 & LkDETM>0
 {  If (Id>0)  Iprin = LVPRIN(Id)
    If (Id0>0) Iprin*= LVPRIN(Id0)
    Iprin = max(Iprin,Idebug)
    If (iw!=IQ(JVOLUM+LVOLUM(Nlevel))&Iprin>0 | Nlevel+Iprin>15) Call Gdebug
        iw= IQ(JVOLUM+LVOLUM(Nlevel))
 }
* - - - - - - - - - - - - - energy correction - - - - - - - - - -
 If LKDETM>0 & Id0>0
 {  if (sleng==0)  Gold=GeKin
    If Istop>0 & 2<=Ipart & Ipart<=3 & NGKINE<2 & LVSIMU(id0)>0
    {  Mec=0;  Do i=1,Nmec { If (Lmec(i)==30 | Lmec(i)==11) Mec=Lmec(i) }
       If (Ipart==3 & NGKINE==0 & Mec==30) dEstep=Gold
       If (Ipart==2 & NGKINE<=1 & Mec==11)
       {   dEstep=Gold+2*emass;  If (NGKINE==1) dEstep-=GKIN(4,1);    }
    }  Gold=Gekin
 }
* - - - - - - - - - - - - - - - - user - - - - - - - - - - - - - -
 AdEstep+=DeStep;     Astep+=Step;      Iret=Id;
 If LKDETM>0 & Id>0          " permanent user tracing routine needed "
 { Iad=0; If (LdetE(id)>12) Iad=LWSTEP(Id); If (Iad!=0) Call JUMPT0(Iad); }
 If (isvol<=0)  Go To :done:;           Iret=0;
* - - - - - - - - - - - - - - - - sensitive - - - - - - - - - - -
 If  InwVOL==1
 { " If sensitive detector, find it's description banks a la GFINDS "
   Do Nlev=Nlevel,1,-1
   { Jat=JATTF(LQ(JVOLUM-LVOLUM(Nlev))); If (Q(Jat+8)>0) goto :sens:; };
   { IHset,IHdet,Iset,Idet,IDtype,NVname,Jdu }=0;        goto :done:;
   :sens:                               " now fill GCSETS "
   Iset=Q(Jat+7);    Js=LQ(Jset-Iset);  IHset=IQ(Jset+Iset);
   Idet=Q(Jat+8);    Jd=LQ(Js - Idet);  IHdet=IQ(Js  +Idet);
   IdType=Q(Jat+9);  Serial=Q(Jat+10);  NVname=IQ(Jd+2);
   Jdu=LQ(Jd-3);     Iret=Jdu;
   If jdu>0
   { i1=Q(Jdu+3);  i2=Q(Jdu+5);  {jv,iv}=0;
     do i=i1,i2-1,NwuVol         " - - - - - - - volumes - - - - - - - - "
     {  jv+=1; Nb=Q(jdu+i+3); Check Nb>0; iv+=1; NUMBV(iv)=NUMBER(jv)-1;
        If (NUMBV(iv)<0) <w> IHset,IHdet,iv,NUMBER(jv)
        (' AgGSTEP error in ',2(1x,a4),' at level',i5,' NUMBER=',i6)
     }
     Isimu=1;  If (IdType>0 & LKDETM>0) Isimu=LVSIMU(IdType)
     Iopt=Q(Jdu+7);               {Astep,AdEstep}=0;
     Call UCOPY(vect,vect0,7);     Vloc0(7)=Vect(7)
     If (Jbit(Iopt,2)>0) Call GMTOD(vect,vloc0,1)
     If (Jbit(Iopt,3)>0) Call GMTOD(vect(4),vloc0(4),2)
 } }
* - - - - - - - - - - - - - -
 If STEP>0 & Jdu>0 & Isimu>0
 {  If (Charge=0 & AdEstep=0)                go to :done:;
    "  Single hit option - only entry and exit are registered by user  "
    If (Istop=0 & InwVol<2 & Jbit(Iopt,1)>0 & aStep<SteMax) go to :done:
    If (Isimu>1 & Istak>0)                   Call AgSKING
*
    If Jbit(Iopt,2)>0                     " calculate the middle position "
    { Call GMTOD(vect,vloc,1);       do i=1,3 { xloc(i)=(vloc(i)+vloc0(i))/2.}}
    If Jbit(Iopt,3)>0                     " calculate the middle cosines  "
    { Call GMTOD(vect(4),vloc(4),2); do i=4,6 { xloc(i)=(vloc(i)+vloc0(i))/2.}}
    Vloc(7)=Vect(7);                            xloc(7)=(vloc(7)+vloc0(7))/2.
*
    Itr=ITRA;  If (Jbit(Iopt,4)>0) Itr=1;  IhaveMore=0;
    Loop
    {"  reaccess Jdu, it might move since we entered the volume "
     Js=LQ(Jset-Iset);  Jd=LQ(Js-Idet);  JDU=LQ(Jd-3);  Iret=Jdu;
     i1=Q(Jdu+1);  i2=Q(Jdu+3);  jv=iv;  ih=0;  jh=0;  JDH=Jd+10+2*iv;
     K=0;
     do i=i1,i2-1,NwuHit        " - - - - - - - - hits  - - - - - - - - "
     {  j=jdu+i;  Fmx=Q(j+5); Org=Q(j+6); Fct=Q(j+7); Iad=IQ(j+9); ic=Q(j+10);
        hit=serial;
        If   Iad==0   { hit=AgGHIT(ic)           }
        else If ic>0  { Call JumpT2(Iad,j,hit)   }
        else          { Call CSJCAL(Iad,2,j,hit) }
 
        " special case for phi(0,2pi) and rapidity(0,max) -> Org=-Fmin "
        If "phi"  ic==6  { If (Org<=0 & Fmx>6.28 & hit<0) hit+=TwoPi;  }
        If "eta"  ic==8  { If (Org<=0 &            hit<0) hit=-hit;    }
        K+=1; Hits(k)=hit;
     }
     K=0;  Jds=Jdu;  h1=hits(1);  Mode=0
     do i=i1,i2-1,NwuHit        " - - - - - now make binning  - - - - - "
     {  j=jds+i;  Fmx=Q(j+5); Org=Q(j+6); Fct=Q(j+7); Nb=Q(j+8); Nbr=Q(j+3)
        " NB: Nb is always positive, only Nbr keeps track of REQUESTED Nb "
 
        K+=1;      hit=max(-Org,HITS(k))
        If jv<NVname        "  pseudo-volumes - may change SJDH content   "
        { jv+=1; NumBV(jv)=bin(min(hit,Fmx-.1/fct));
                 JDH+=2;IQ(JDH)=mod(Nb,32);              }
        else                " hit part - may be only partially comulative "
        { ih+=1; Hits(ih)=min(Hit,Fmx-1.1/fct);
                 if (-32<=Nbr&Nbr<=0) Mode=1; jh+=Mode;  }
 
        " select the appropriate hit descriptor using the first hit element "
        If K==1
        { while LQ(Jds)>0 & bin(Q(LQ(Jds)+8))<=NumBv(jv) {Jds=LQ(Jds)} }
     }
    " all non-comulative AGI hits before opt=H are stored in the volume part "
     If IEOTRI==0
     { do itry=1,2
       { Call GSCHIT(Iset,Idet,Itr,NumBV,Hits,jh,Ihit);    if (ihit>0) break
         If itry==1 { call mzgarb(2,0); call mzgarb(20,0); call mzdred(20);}
         else       { IEOTRI=1; IQUEST(1)=0;  Call GPCXYZ;
                      <w> IHset,IHdet;(' AGGSTEP cant store hits in',
                          2(1x,a4)/' **** event simulation abandoned ****');
     } }            }
    } while IhaveMore>0
    Call UCOPY(vect,vect0,7); call Ucopy(vloc,vloc0,7); {Astep,AdEstep}=0;
 }
 :done:; " If  NGKINE>0 { Call GSKinG (0); NGKINE=0; } - now in gustep "
   END
 
 
+DECK,AgGHIT,T=geant. ----------------------------------------------------------
*CMZ :          08/08/97  11.42.02  by  Pavel Nevski
*CMZ :  1.30/00 02/04/96  14.53.21  by  Pavel Nevski
*CMZ :  1.00/00 31/05/95  23.17.43  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Function     A g G H I T (ic)
*                                                                    *
*  Description:  general hit coding for any standard detector        *
*                                                                    *
**********************************************************************
+CDE,TYPING,GCUNIT,GCONST,GCVOLU,GCKINE,GCKING,GCTMED,GCTRAK,AGCSTEP.
 REAL             AgGHIT,VDOTN,VDOT,Hit,V(3),R,THE,VMOD,
                  a(2),c(2),dk,da,Vec(2)
 Integer          IC,JMP,i,IcMax/27/
 
 AgGHIT=-9999;    If (0>Ic | Ic>IcMax) Return;      hit=0;
 
 Case  IC of ( X  Y  Z   R    RR   PHI  THET ETA  TDR CP    _
               U  V  W   ETOT ELOS BIRK STEP LGAM TOF USER  _
               XX YY ZZ  PX   PY   PZ   SLEN                )
 {
  :X:;:Y:;:Z: hit=Xloc(ic);                                              Break;
  :R:         hit=VMOD(Xloc,2);                                          Break;
  :RR:        hit=VMOD(Xloc,3);                                          Break;
  :PHI:       If (xloc(1)#0|xloc(2)#0) hit=ATAN2(xloc(2),xloc(1));       Break;
  :THET:      R=VMOD(xloc,3); if (R>0) hit=ACOS(xloc(3)/R);              Break;
  :ETA:       Do i=1,3 { V(i)=(Vect(i)+Vect0(i))/2 }
              R=VMOD(V,3); if (R>0) THE=ACOS(V(3)/R)
              hit=-ALOG(TAN(min(max(1.e-6,THE),pi)/2));                  Break;
  :TDR:       " vector a=vloc-vloc0"   Call vsub(vloc,vloc0,a,2);
              da=vdot(a,a,2);  dk=-1;  if (da>0) dk=-vdot(a,vloc0,2)/da;
              If 0<= dk&dk <=1 "point is insided, vec=vloc+a*dk "
                   { Call Vlinco(vloc0,1.,a,dk,Vec,2); hit=VMOD(Vec,2);}
              Else { hit=min(VMOD(vloc0,2),VMOD(vloc,2)) };              Break;
  :CP:        " vector a=vloc-vloc0"   Call vsub(vloc,vloc0,a,2);
              Call Vlinco(vloc0,-1.,a,-0.5,c,2); hit=vdotn(a,c,2);       Break;
  :u:;:v:;:w: i=ic-10+3;   hit=Xloc(i);                                  Break;
  :ETOT:      hit=GETOT;                                                 Break;
  :ELOS:      hit=aDeStep;                                               Break;
  :BIRK:      hit=aDeStep; Call GBIRK(hit);                              Break;
  :STEP:      hit=aStep;                                                 Break;
  :LGAM: hit=-999; IF(AMass>0&GEKin>0&Charge#0) Hit=ALOG10(GEKin/AMass); Break;
  :TOF:       hit=TOFG;                                                  Break;
  :USER:      hit=aDeStep;                                               Break;
  :XX:;:YY:;:ZZ:  i=ic-20; Hit=(Vect(i)+Vect0(i))/2;                     Break;
  :PX:;:PY:;:PZ:  i=ic-20; Hit=(Vect(i)*Vect(7)+Vect0(i)*Vect0(7))/2;    Break;
  :SLEN:      hit= Sleng;                                                Break;
 }
2 AgGHIT=hit;
   END
 
+DECK,AgFHIT0,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 03/07/96  18.18.58  by  Pavel Nevski
*CMZ :  1.00/00 05/06/95  16.16.44  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
             Function     A g F H I T 0 (Cset,Cdet)
*                                                                    *
*  Description: only general digitization control here               *
**********************************************************************
+CDE,TYPING,GCUNIT,AGCRDIG,AGCBUFF.
Character*(*)  Cdet,Cset
Integer        AgFHIT0,AgFDIG0,AgsDIG0,AgPFLAG,I,J,L,ok/0/
*
   AgFHIT0=-1;   Cs=Cset(1:3)//'H';   Cd=Cdet
   IPRIN = AgPFLAG (Cset,'DIGI');     Check Iprin>=0
   If (IPRIN>=5) CALL AGPDIGI (Cs,Cdet)
*
   AgfHIT0  = AgFDIG0 (Cs,Cdet)
   if AgFHIT0==ok { I = AgSDIG0 (Cset(1:3)//'D',Cdet) }
   else           { prin4 AgfHIT0,cs;(' AgFHIT0=',i3,': no hits found in ',a)}
   If Iprin>=15
   {  <w>;  (' *** AGFHIT buffer  ***');  j=1;  while Ibuf(j)>0
      {  L=IBUF(j); if (L<=0) Break; <w> j,L,(Ibuf(j+i),i=1,L);
         (' adr=',i6,' L=',i4,2x,20i5/(20x,20i5));      j+=L+1;
   }  }
   END
 
 
+DECK,AgFHIT1,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 25/06/96  13.21.46  by  Pavel Nevski
*CMZ :  1.00/00 05/06/95  12.50.41  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
     Function     A g F H I T 1 (NHit,LTRA,ISC,HITS)
*                                                                    *
* Description:  only general digitization print control here         *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,AGCRDIG,AGCBUFF.
Integer      AgFHIT1,AgFDIG1,Nhit,LTRA,ISC(*),ok/0/
Real         HITS(*)
*
   AgFHIT1=AGFDIG1(NHit,LTRA,ISC,HITS); If (AgFHIT1==ok) Return;
*
   Prin2 Cs,Cd,nc1,nc2,iws(1)
   (' AGFHIT1: set/det=',2(1x,a),' hits analysed=',2i8,' digits done=',i8)
   if (Iprin>=4)  Call AGPDIGI(cs(1:3)//'D','*')
   END
 
 
+DECK,AgSDIG0,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 12/07/96  09.34.13  by  Pavel Nevski
*CMZ :  1.00/00 01/05/95  14.09.00  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
************************************************************************
*                                                                      *
                 Function  A G S D I G 0 (CSET,CDET)
*                                                                      *
*  Description:   store GEANT digits in the new dense format           *
*  Compared to the original GEANT routine a new SET/DET can be added   *
************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,AGCDIG,QUEST.
   Character*4    Cset,Cdet,cs
   Integer        AgSDIG0,NSET,NDET,NEED,ier
 
   AgSDIG0=-1;  Cs=Cset(1:3)//'D';
   "            Find if selected set, detector exists       "
   JDU=0;                                                   Check JSET> 0;
   NSET = IQ(Jset-1);                                       Check Nset> 0;
   Call GLOOK(Cs,IQ(Jset+1),Nset,Iset);                     Check Iset> 0;
   JS   = LQ(Jset-Iset);                                    Check Js  > 0;
   NDET = IQ(Js-1);                                         Check Ndet> 0;
   Call GLOOK(Cdet,IQ(JS+1),Ndet,Idet);                     Check Idet> 0;
   JD   = LQ(JS-Idet);                                      Check JD  > 0;
   JDX  = LQ(JD-2);                                         Check JDX > 0;
   NW   = IQ(JD+1)+IQ(JD+5)+1;                              Check Nw  > 0;
   JDU  = LQ(JD-3);                                         Check JDU > 0;
   NV   = IQ(JD+2);   ND   = IQ(JD+6);
   NVU  = Q(JDU+6);   NDU  = Q(JDU+2);
   IF (NV+ND # NVU+NDU)  { Print *,' AgSDIG0 error'; Return; }
 
   Ier=iquest(1); Iquest(1)=0;
   IF JDIGI==0                       "    Create DIGItisation master bank    "
   {  Call MZBOOK(IXDIV,JDIGI,JDIGI,1,'DIGI',NSET,NSET,0,2,0); IQ(JDIGI-5)=1;}
   else IF IQ(JDIGI-2)<NSET
   {  NEED=NSET-IQ(JDIGI-2);  Call MZPUSH(IXDIV,JDIGI,NEED,0,'I');   }
*
   JX=LQ(JDIGI-ISET);                "    Create DIGItiastion set bank       "
   IF  JX==0
   {   Call MZBOOK(IXDIV,JX,JDIGI,-ISET,'DIGI',NDET,NDET,NDET,2,0);  }
   else IF min(IQ(JX-1),IQ(JX-2))<Ndet
   {   NEED=NDET-min(IQ(JX-1),IQ(JX-2)); Call MZPUSH(IXDIV,JX,NEED,NEED,'I');}
*
   JXD=LQ(JX-IDET);                  "    Create DIGItisation bank           "
   IF (JXD==0) Call MZBOOK(IXDIV,JXD,JX,-IDET,'SJDX',0,0,IQ(JD+8),1,0);
*
   If IQUEST(1)!=0 {<W> Ier,IQuest(1);(' AgSDIG0 Memory problem ',2i6); Return}
   AgSDIG0 = 0;  IQ(JX+IDET)=0;
 
  END
+DECK,AgSDIG1,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 01/12/96  23.50.41  by  Pavel Nevski
*CMZ :  1.00/00 03/10/95  23.10.08  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
**********************************************************************
*                                                                    *
                 FUNCTION A G S D I G 1 (LTRA,NUMBV,DIGI)
*                                                                    *
*  Description:   store GEANT digits in the new dense format         *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT,AGCDIG,QUEST.
  Integer   AgSDIG1,Last,Kdigi,Nk,Nb,I,J,K,N,i1,i2,i3,Ltra,j1,num,bin,jds,
            NUMBV(*),NwuHit/10/
  REAL      DIGI(*),Org,fct,fmx,xx
  bin(xx) = (xx+org)*fct
 
  AgSDIG1=-1;  Check Jdu>0;  Jds=Jdu;
  LAST=IQ(JX+IDET)     "  Check if enough space. If not increase bank size  "
  If IQ(JXD-1)<=LAST+Nw             "    one attempt should be enouph       "
  {  N=MAX(100,NW,IQ(JD+8)/2);   CALL MZPUSH(IXDIV,JXD,0,N,'I');
     If IQUEST(1)#0 { <W>; (' Lack of Memory in AgSDIG1');  Return; } }
 
  " ========>    Store tracks numbers, volumes numbers and digits  <========"
  " Nbit is taken from the SEJD/SJDD banks not to dublicate option analysis "
  " Org&Fct are taken from SJDU - the only place containing all variables   "
  j=JXD+LAST+1; IQ(j)=max(0,LTRA);  NK=1; K=1; i3=0;
 
  DO I=1,NVU           "           Store packed volume numbers              "
  {  Nb=IQ(JD+2*I+10);     num=max(0,NUMBV(i)-1);
     IF Nb>0  { K+Nb>33 ?; CALL MVBITS(NUM,0,Nb,IQ(j+NK),K-1);   K+=Nb; }
     else     { K>1     ?; IQ(j+Nk)=NUM;                         Nk+=1; }
  }
  Do I=1,NDU           "               Store packed digits                  "
  {  i1=JDS+i*10;   org=Q(i1+6);  fmx=Q(i1+5);  fct=Q(i1+7);
     KDIGI=(org+min(DIGI(i),fmx))*fct;   KDIGI=max(0,KDIGI);
     i2=I+Nvu;  i3=i2-Nv;  i3==1 & K>1 ?;
     If i3<=0 { Nb=IQ(Jd+2*i2+10) } else { Nb=IQ(Jdx+2*i3) };
     IF Nb>0  { K+Nb>33 ?; CALL MVBITS(KDIGI,0,Nb,IQ(j+Nk),K-1); K+=Nb; }
     else     { K>1     ?; IQ(j+Nk)=KDIGI;                       Nk+=1; }
     "   select the appropriate hit descriptor using first hit element  "
     If I==1  { while LQ(Jds)>0 & bin(Q(LQ(Jds)+8))<=KDIGI {Jds=LQ(Jds)}}
  }
  K=1+IQ(JD+1); N=Nw;
  If   i3>0            "               cumulative digits                    "
  {:D: Do j1=JXD+Last,JXD+1,-Nw
       {                  if (IQ(j1)  !=IQ(j)  ) Break :D:;
          do i=1,K-1    { if (IQ(j1+i)!=IQ(j+i)) Next  :D:; }
          do i=K,Nw-1   {     IQ(j1+i)+=IQ(j+i); }
          N=0; Break :D:;
  }    }
  " if (N=0) <W> (DIGI(i),i=1,NDU); ( ' AGSDIG1 digi added: ',10F10.3);     "
  Last+=N;   IQ(JX+IDET)=Last;  IWS(1)=Last/Nw;
  AgSDIG1=0;
   END
 
 
 
+DECK,AgDOCUM,T=geant. =========================================================
*CMZ :          16/03/98  12.34.47  by  Pavel Nevski
*CMZ :  1.30/00 17/11/96  22.43.56  by  Pavel Nevski
*CMZU:  1.00/01 21/12/95  22.19.56  by  Pavel Nevski
*CMZ :  1.00/00 14/11/95  02.46.06  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A g D O C U M  _
     (Module,MTitle,Author,Created,Btit,Bank,Bpath,num,Lb,
                   Map,Names,Comment,Par,LL,LL1,Link,Flag)
*                                                                    *
*  Description: store a bank in DETM or RECB structure with          *
*               corresponding documentation bank for DZDOC           *
* - AgDOCU is the FILL processor. It may be called in MODULEs only.  *
* - There may be 3 forms of Bpath: short relative (one word),        *
*   long relative (words separated by /), absolute (starts with /).  *
* - If the first call in a MODULE has a short Bpath, the latest is   *
*   kept as a CTOP bank, attached to //DETM/MODULE.                  *
* - If the first call in a MODULE has a long Bpath, the latest is    *
*   attached to //RECB.                                              *
*   CTOP bank or any absolutely addressed bank remain a DEFAULT bank *
* - All documetation banks are created lineary in DOCU/MODULE bank   *
* - Flag controls the I/O format, Link - access methode              *
* Modifications:                                                     *
* 16/04/96 PN: flag list changed as in AsFLAGS                       *
**********************************************************************
REPLACE [ERR#{#}] with _
        [; IF (#1) {<W>%L(Module),Bank; (' AgDOCUM error for module ',A,
                    ' for bank ',A/ 10x,'*** #2 ***');    Istat=-100;
                     "no doc mode" {L1Doc,L2Doc,Ldoc}=0;  Return   }; ]
REPLACE [SWAP(#,#)] with [;iw=#1;#1=#2;#2=iw;]
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+CDE,TYPING,GCBANK,GCUNIT,SCLINK,AGCDOCL,QUEST,RBBANK.
Integer       LENOCC,OK,Lb,LL,LL1,LvL,ns1,ns2,Need,Ndm,i,j,k,l,M/1000000/,
              Idat,Itim,Link,Ia,Lk,L1,L2,Flag,IDYN,INEW,JOX,iw,idd/0/,X,IC,
              map(2,LL1),num(Lb),key(3),ID/0/,Iform/0/,Jform/0/,Istat/0/
Character*(*) Module,MTitle,Author,Created,Bank,Bpath,Btit,
              Names(LL1),Comment(LL1)
Character*12  Ddoc
Character*4   Ctop,Cbank,C1,C2
Character*8   Flags(15),Dmodule,Dmodu,Dbank,Dbanu,Dup,Ddef,Bname,nam,dash/'-'/
Character*24  Descr(15),Tshort
Character     Cform*80,Cforn*80,C*1
Parameter     (OK=0)
Save          Id,Dmodule,Dbank,Dup,Ddef,Ctop
Logical       First/.true./,start
Real          Par(LL)
Integer iprin/1/
* - - - - - - - - - - - - - - - dete bank - - - - - - - - - - - - - - - - - - -
Data Flags  /'PNOW', 'PRIN', 'DEBU', 'GEOM', 'HIST', 'GRAP', 'SIMU', 'DIGI',
             'RECO', 'MFLD', 'ANAL', 'BACK', 'resa', 'resb', 'resc'/
Data Descr  _
      /'current print level  ','system print level   ','GEANT debug level    ',
       'geometry version     ','system histogram flag','system graphics level',
       'store GEANT hits flag','digitisation flag    ','reconstruction flag  ',
       'magnetic field flag  ','user analysis level  ','pile-up bunch select.',
       'reserve              ','reserve              ','reserve              '/
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
 
If First
{  First=.false.;   Istat=0;
   Call MZFORM('DETP',  '-F'  ,Iform);   Call MZFORM('DDOC','1H 19I -S',Jform);
  "this part may be re-executed only after recompilation(standalone debugging)"
  "-in this case make sure that link areas are not initialized twice (commons)"
  " If (L1Doc>0)     call MZDROP(IxCONS,L1Doc,' ')  Standalone debugging mode "
*
*  it was a structural link area, now it becomes a reference one
*  If (LdArea(1)=0) call MZLINT(IxCONS,'AGCDOCL',LDarea,Lpar,LDarea)
   If (LdArea(1)=0) call MZLINT(IxCONS,'AGCDOCL',LDarea,L1Doc,Lpar)
   L1Doc=0;
}
If L1Doc<=0
{  Call AsbDETE('DOCU',I);  L=0;  If (LKDETM>0 & I>0)  L=LQ(LQ(LKDETM-I)-1);
   If L>0 { CALL UHTOC(IQ(L-5),4,bname,8); if (bname=='NONEDETM') L1doc=L; }
}
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* - - - - - -          create the information bank itself           - - - - - *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
 
" trace module changes - a module may have only ONE default Ctop bank "
IOX=Flag; If IOX==0
{ call AgDForm(Names,map,LL1,LL,Cform,Cforn);  Call MZFORM(Cbank,CForm,IOX) }
*
Cbank=Bank;  Dmodu=Module;  start=.false.
If Dmodu != Dmodule { Dmodule=Dmodu; Ctop=Cbank; Ddef=' '; start=.true.}
*
If Lb==1                              "  default directories in the DETM bank "
{  If Cbank==Ctop
   { Call AsBDETE(Dmodu,ID); Err Id<=0 {detector not found in DETM bank}
     IrBDIV=IxCONS;  LkArP2=LQ(LkDETM-Id);  LvL=3;  Dup=Dmodu(1:4)//'DETM'}
   else                                   { LvL=4;  Dup=Ddef }
   Call ReBANK (Cbank,Num,LL,LK,Ia)
}
else                                 "     explicit directory setting if /    "
{  J=1;  While Bpath(j:j)=='/' {J=J+1};
   If  J>1                            { Lvl=3;  C2='NONE'}
   else
   {  If Cbank==Ctop
      {  If (LKAR P1==0) Call MZBOOK(IxDIV,LKAR P2,LKAR P1,1,'RECB',2,2,10,2,0)
         IrBDIV=IxDIV;  LkArP2=LkArP1;  Lvl=3;  C2='RECB'}
      else                            { Lvl=4;  C2= Ddef }
   }
   J=J+5*(lb-2)-1; C1=Bpath(J+1:J+4); If (lb>2) C2=Bpath(J-4:J-1); Dup=C1//C2;
   Call ReBANK (Bpath,num,LL,LK,Ia)
}
   JOX=IOX;
   Call UCOPY (PAR,Q(LK+1+Ia),LL);    Call SBIT0(IQ(Lk),1)
   LkArP3=Lk  "temporary save bank address"
   If Lvl==3  { "RbCDir"  LkArP2=Lk;  Ddef=Cbank//Dup }
*
IDYN=0; INEW=LL;             " dependant dynamic banks now - if any required "
DO i=1,LL1
{  if (map(1,i)>0 & map(2,i)>0)       { INEW-=map(1,i)*map(2,i); Next; }
   INEW-=1;                               " dynamic array found here "
   If (Link==0) Link=-1                   " force link to be secured "
   L1=map(1,i); If L1<0
   { L1=-L1;    if L1<M { Call Ucopy(Par(L1),L1,1)} else { L1=nint(Par(L1-M))}}
   L2=map(2,i); If L2<0
   { L2=-L2;    if L2<M { Call Ucopy(Par(L2),L2,1)} else { L2=nint(Par(L2-M))}}
   L=Lenocc(Names(i));  Nam=Names(i)(3:L)//'xxxx';  Nam(5:5)='*';
   C=Names(i)(1:1); If C=='I' {IOX=2} else If C=='H' {IOX=5} else {IOX=3}
   swap(LkArP2,LkArP3)
   CALL ReBANK (Nam,1,2+L1*L2+3,Lk,Ia)
   swap(LkArP2,LkArP3)
}
* LkArP3 keeps the current bank adress now
Dmodule=Module;  Call AGDLINK(Module,Bank,Link,LkArP3)
Check Flag==0;   Flag=JOX;
 
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* - - - - -   new bank: make sure that detector documentation exists  - - - - *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
 
If Start
{ "-------------------       level 1  -  DETM bank       -------------------"
  Call AsBDETE(Dmodu,ID);     Err Id<=0 {detector does not exist in DETM bank}
  Dbanu='DETMNONE';  Call UCTOH(Dbanu,Key,4,8);  IQUEST(1)=0;
  If Istat=0 & L1Doc<=0
  { Call AsBDETE('DOCU',idd)
    Call RZIN (IxCONS,LQ(LKDETM-idd),-1,Key,0,' ')
    If (Iquest(1)==0) L1Doc=LQ(LQ(LkDETM-idd)-1)
    If L1Doc<=0               " main documentation bank does not exist "
    { IQuest(1)=0
      Call MZBOOK(IxCONS,L1Doc,LQ(LkDETM-idd),-1,'DETM',2,2,300,Jform,0)
*      if (idebug>0) print *,'DETM/DOCU/DETM done '
      Err L1Doc<=0 | Iquest(1)#0 { Cant create main documentation bank }
      IQ(L1Doc-5)=key(2)
      Call AgDOCBA(L1Doc,Dbanu,'Detector main bank', Author,Created,'-H',
                         0, 1, 'detector','subsystem or faculty name ',X)
      Err L1Doc<=0 | Iquest(1)#0 { Cant write main documentation bank }
  } }
  "-------------------       level 2  -  DETE bank      -------------------"
  If Istat==0 & L1Doc>0
  { "        first add link description in DETM bank                       "
    Call AgDTIT (MTitle,Tshort)
    Call AgDOCBA (L1Doc,Dbanu,'*','*','*','*',1,0,Module(1:4),Tshort,X)
    " insure that links in doc DETM coincides with the main DETM "
    Ns1=IQ(LkDETM-2);  Ns2=IQ(L1Doc-2);  Need=ns1-ns2
    If (Need>0) Call MZPUSH (IxCONS,L1Doc,Need,0,' ')
    L2Doc=LQ(L1Doc-Id)
    If L1Doc>0 & L2Doc<=0
    { Dbank=DModu(1:4)//'DETM';   Call UCTOH(Dbank,Key,4,8);
      Call RZIN (IxCONS,L1Doc,-ID,Key,0,' ');  L2Doc=LQ(L1Doc-Id);
      If Iquest(1)#0|L2Doc<=0 "Documentation does not exist for THIS detector"
      { IQuest(1)=0; Call MZBOOK(IxCONS,L2Doc,L1Doc,-ID,Dbank,2,2,300,Jform,0)
        Err L2Doc<=0 | Iquest(1)#0  { Can not create DETE documentation bank }
        IQ(L2DOC-5)=key(2)
        Call AgDOCBA(L2Doc,Dbank,Tshort,Author,Created,'-I',0,15,Flags,Descr,X)
        Err L2Doc<=0 | Iquest(1)#0  { Can not write DETE documentation bank  }
  } } }
  Err IQuest(1)#0|L2Doc<=0|L1Doc<0{cannot find top level documentation banks}
}
"---   level 3/4  -  the bank itself: all documentation is lenear in DETE  ---"
Ldoc=0; Lkdoc=0;
If L2Doc>0
{  * first, update links in upper level bank
   Ddoc=Cbank//Dup; Call UCTOH(Ddoc,Key,4,12);
   Ndm=60+LL*16;    Ns1=IQ(L2doc-2)
   if IQ(L2doc-4)==Key(2) & IQ(L2doc-5)==Key(3)  " - for level 3 doc "
   {  "link" Call AgDOCBA (L2doc,Dup,'*','*','*','*',1,0,Cbank,Btit,X) }
   do i=1,Ns1
   {  Ldoc=LQ(L2Doc-i);   If (Ldoc<=0) go to :f:
      * if this is a previus description of the same bank - drop it
      if IQ(Ldoc-4)==Key(1) & IQ(Ldoc-5)==Key(2)
      {  Call MZDROP (IxCons,Ldoc,' ');   goto :f:;  }
      * if this is a description of the parent bank - insert links
      if IQ(Ldoc-4)==Key(2) & IQ(Ldoc-5)==Key(3)   " - for level 4 doc "
      { Lkdoc=Ldoc; Call AgDOCBA (Ldoc,Dup,'*','*','*','*',1,0,Cbank,Btit,X) }
   }  i=Ns1+1;  Call MZPUSH(IxCONS,L2DOC,5,0,' ')
 
   :f: Ldoc=LQ(L2Doc-i)
   If (Ldoc==0)  Call MZBOOK (IxCONS,Ldoc,L2doc,-i,Cbank,2,2,Ndm,Jform,0)
   Call AGDTIT (Btit,Tshort)
   If (INEW>1)
   {  Call AgDOCBA(Ldoc,Ddoc,Tshort,Author,Created,cform,0,1,dash,
                                                   'usage counter',X)
      Call AgDOCBA(Ldoc,Ddoc, '*' , '*' , '*' , '*' ,0,1,dash,
                                                   'system version',X)
   }
   Err LDoc<=0 | Iquest(1)#0 { Can not create documentation bank }
   DO i=1,LL1
   {  k=1; if (map(1,i)>0 & map(2,i)>0) k=map(1,i)*map(2,i)
      L=Lenocc(Names(i));   Nam=Names(i)(3:L)
      Call AgDOCBA(Ldoc,Ddoc,Tshort,Author,Created,cform,0,-k,Nam,Comment(i),X)
   }
   If X==0 & Ldoc>0
   { CALL RZCDIR('//LUN61',' ')
     CALL aRZOUT (IXCONS,L1doc,Dbanu,IC,'SN')
     CALL aRZOUT (IXCONS,L2doc,Dbank,IC,'SN')
     CALL aRZOUT (IXCONS,Lkdoc,Dup , IC,'SN')
     CALL aRZOUT (IXCONS,Ldoc, Ddoc, IC,'SN')
     call RZPURG (1)
}  }
if INEW>1
{  Call DATIME (Idat,Itim);  Par(1)=Idat+Itim/2401.;  Q(LkArP3+1+Ia)=Par(1)
                             Par(2)=IC;               Q(LkArP3+2+Ia)=Par(2)
}
END
 
 
****************************************************************************
          subroutine  ARZOUT(Idiv,Lo,CKey,IC,opt)
*                                                                          *
* Description: same functionality as RZOUT is supposed with few additions: *
*            - consistence between Bank at Lo and Ckey is checked          *
*            - previous bank with simular Ckey is read and compaired,      *
*              new bank is writtent only if it differs from the old one.   *
*            - very crude version , to be developed later (?). Therefore   *
*              intermediate input bank is kept on a free Link=1 of L1Doc   *
****************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,QUEST,AgCDOCL.
 Integer        Ie,Iprin,Idiv,Lo,Li,Key(2),Nc,IC,i,k,New,Old,Mn,Mo;
 Character*(*)  Ckey,Opt,status*10,Copt*4
*
 New(k)=IQ(Lo+k)
 Old(k)=IQ(Li+k)
*
*
 check Lo>0;  Nc=0;  Iprin=Idebug-1; Ie=0; Li=0;
 
* read the highest cycle, return data + cycle info
  Call UCTOH(Ckey,key,4,8); if (key(1)!=IQ(Lo-4) | key(2)!=IQ(Lo-5))
  {  prin2 key,IQ(Lo-4),IQ(Lo-5); (' ARZOUT error: key=',2a4,' bank=',2a4)
     IC=0; Return;
  }
 
* drop previous input - should later be done at the end
  if (L1DOC>0 & LQ(L1DOC-1)>0) Call MZDROP(IxSTOR,LQ(L1DOC-1),' ')
  CALL RZIN (IxCons,L1DOC,-1,Key,999999,'CD');   Li=LQ(L1DOC-1);
* CALL RZIN (IxDIV,Li,2,Key,999999,'CD')
 
  IC=0; Nc=IQUEST(50); if (IQUEST(1)==0 & 0<Nc&Nc<20) Ic=IQUEST(50+Nc)
 
  ie=1; status='written';  if (Li<=0)
  { prin2 key; (' ARZOUT error: key=',2a4,' not found '); go to :w: }
 
  ie=2; "data"   if (New(15)!=Old(15)) goto :w:
  mn=new(3)+new(11)+new(12);  mo=old(3)+old(11)+old(12);
  do i=1,New(15) { If (New(mn+i)!=Old(mo+i)) go to :w: }
 
  ie=3; "links"  if (New(12)> Old(12)) goto :w:
 
  ie=4; "header" if (New(11)> Old(11)) goto :w:;
  mn=new(3);  mo=old(3);
* do i=1,New(11) { If (New(mn+i)!=Old(mo+i)) go to :w: }
 
  ie=9; status='found'
 
  :w: Copt='SN'; " If (ie>2) Copt='SNR' "
  if (status!='found') CALL RZOUT(Idiv,Lo,Key,IC,Copt)
  prin2  status,key,ie,nc,ic; (' aRZOUT status - ',a,' - ',2a4,' cycles ',3i6)
 
* if (Li>0) Call MZDROP(IxSTOR,Li,' ')
 
 end
 
 
+DECK,AgDOCBA,T=geant. ---------------------------------------------------------
*CMZ :          16/03/98  03.34.50  by  Pavel Nevski
*CMZ :  1.30/00 26/04/96  19.30.43  by  Pavel Nevski
*CMZU:  1.00/01 16/01/96  00.31.26  by  Pavel Nevski
*CMZ :  1.00/00 25/08/95  23.30.46  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/95
**********************************************************************
*                                                                    *
                 subroutine       A g D O C B A _
            (Link,Bank,Tit,au,ve,io,NL,ND,Cvar,Comment,i)
*                                                                    *
*  Description:  fill a documentation bank                           *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
Character*(*) Bank,Tit,au,ve,io,Cvar(*),Comment(*),NN*4,Cbuf*80;
Integer       AgDocRd,AgDocWr,Lenocc,Link,NL,ND,Lb,key(2),
              i,j,k,L,Lk,N,N0,ioff,M,ok;
Parameter      (ok=0);
 
I=-1;  Check Link>0;  Lb=IQ(Link-1)
If Bank(1:1)#'*'
{  Call UCTOH(Bank,key,4,8); If IQ(Link-4)#key(1)
   { <w> Bank,IQ(LINK-4); (' AgDOCBA wrong bank: request ',a8,' found ',a4/,
    ' *********************************************************************'/,
    ' * Probably this means that the documentation RZ file is currupted.  *'/,
    ' * This is often fatal and program may crash imediately afterword !  *'/,
    ' * To solve the problem simply remove detm.rz, it will be re-created *'/,
    ' *********************************************************************')
     Link=0;  stop ' too dangerous to continue, re-make detm.rz ! ';
   }
   If IQ(Link+1)=0               " create new bank "
   {  Call Vzero(IQ(Link+1),Lb);  IQ(Link-5)=key(2);
      IQ(Link+1)=key(1);  IQ(Link+2)=20;  IQ(Link+3)=20;
      Cbuf = Bank(1:4)//Tit(1:LENOCC(Tit))
      i    = AgDocWr(Link,'..',0,0,Cbuf)
      i    = AgDocWr(Link,'up',0,0,Bank(5:8))
 
      if (au(1:1)#'*') i=AgDocWr(Link,'au', 0,0,au );
      if (ve(1:1)#'*') i=AgDocWr(Link,'ve', 0,0,ve );
                       i=AgDocWr(Link,'nl', 0,0,' ');
                       i=AgDocWr(Link,'ns', 0,0,' ');
                       i=AgDocWr(Link,'nd', 0,0,' ');
      if (io(1:1)#'*') i=AgDocWr(Link,'io', 0,0,io );
}  }
do k=1,NL                               " links can not be doubled "
{  Lk=Lenocc(Comment(k));
   if AgDocRd(Link,'Link',Cvar(k)(1:4), N,ioff,L) > Ok
   {  if (AgDocRd(Link,'nl',' ', M,Ioff,L)=Ok) IQ(Link+Ioff+3)=N+1;
      if (AgDocRd(Link,'ns',' ', M,Ioff,L)=Ok) IQ(Link+Ioff+3)=N+1;
      Cbuf = Cvar(k)(1:4)//'    - '//Comment(k)(1:Lk)
      i    = AgDocWr(Link,'Link',N+1,0,Cbuf)
}  }
N0=1;
do k=NL+1,NL+abs(ND)                    "    data can be doubled   "
{  j=k; if (ND<0) j=NL+1;  Lk=max(Lenocc(Comment(j)),1);  if (k>j) Lk=0;
   if    AgDocRd(Link,'Data','. . . next free place . . . ',N,ioff,L)>Ok
   { If  Lk=0  { N0+=1; write(NN,'(i3)') N0; }  else  { N0=1; NN=' '; }
     if (AgDocRd(Link,'nd',' ', M,Ioff,L)=Ok)    IQ(Link+Ioff+3)=N+1;
     Cbuf = Cvar(j)(1:8)//'- '//Comment(j)(1:Lk)//NN
     i    = AgDocWr(Link,'Data',N+1,0,Cbuf)
}  }
END
 
 
+DECK,AgDOCRD,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 06/01/95  01.38.29  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/95
**********************************************************************
*                                                                    *
          Function   A g D O C R D (Link,Cf,Ckey, N,ioff,L)
*                                                                    *
* Description: get a record with the Ckey content in the Ctype field *
*              Ckey may be a record type or a content of a DD record *
* Output: N - record number if found, else number of scanned records *
*        id - offset of the record in bank, IQ(link+id+1) first word *
*             of  [3*16+2,'cf',i1,i2,L*16+5,'text data (1-L)']       *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
   character      Cf*(*),Ckey*(*), C*5/'GLSUD'/;
   Integer        AgDOCRD,LENOCC,Link,ioff,N,L,id,if,
                  key(10),Lk,Lt,id1,id2,NW,I,J,IW;
   Integer        mask(9)/1,1024,16384,8192,9216,10240,15361,19456,17410/;
   Character*2    ask (9)/'..','au','ve','nd','nl','ns','up','io','dd'/;
 
   {N,ioff,L,Lk}=-1;                       " check bank format "  AgDocRd =-1;
   Lt=20; do i=1,5 { Lt+=IQ(Link+10+i); };
   Unless (IQ(Link+3)==20 & IQ(Link+2)==Lt & IQ(Link-1)>=Lt)      go to :E:;
 
   Id1=20; if=1;                           " decode request Cf "  AgDocRd =-2;
   do id=1,8 { If (Cf(1:2)=ask(id)) goto :F:; };
   Lk=LENOCC(Ckey); Call UCTOH(Ckey,key,4,min(Lk,40)); Lk=(Lk+3)/4;
   do if=1,5 { if (Cf(1:1)=C(if:if)) goto :F:; Id1+=IQ(Link+10+if); }
                                                                  goto :E:;
   :F: Ioff=id1; id2=0; N=0; Nw=IQ(Link+10+if);
   :N: while id2<NW
   {  Ioff=Id1+Id2; J=Link+Ioff; N+=1;   " check record format"   AgDocRd =-3;
      If (IQ(J+1)#50) Break;            L=0;     Id2+=4;
      Iw=IQ(J+5); IF (Mod(Iw,16)=5)   { L=Iw/16; Id2+=1+L; }
      IF (IQ(J+2)#Mask(Id) | Lk>L)      Next :N:;
      Do i=1,Lk { If (IQ(J+i+5)#Key(i)) Next :N:; }               AgDocRd = 0;
                                                                  goto :E:;
:L:}                                                              AgDocRd = 1;
:E:"<w>AgDOCRD,Cf,Ckey,N,ioff,L;(' AgDocRd=',i2,' at ',a,1x,a,' N,of,L=',3i6)";
END;
 
+DECK,AgDOCWR,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 06/01/95  01.39.27  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/95
**********************************************************************
*                                                                    *
            Function   A g D O C W R (Link,Cf, I1,I2, TEXT)
*                                                                    *
* Description:  Insert a new record at the end(!) of the Cf field    *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
   character    Cf*(*),TEXT*(*), C*5/'GLSUD'/;
   Integer      AgDOCWR,LENOCC,Link,I1,I2,If,Id,Lk,Need,Lt,Li,L,iof,I,N;
   Integer      mask(9)/1,1024,16384,8192,9216,10240,15361,19456,17410/;
   Character*2  ask (9)/'..','au','ve','nd','nl','ns','up','io','dd'/;
 
                                           " check bank format "  AgDocWr =-1;
   Lt=20; do i=1,5 { Lt+=IQ(Link+10+i); };
   Unless (IQ(Link+3)==20 & IQ(Link+2)==Lt & IQ(Link-1)>=Lt)      goto :E:;
 
   Iof=20+IQ(Link+11);  If=1;             " decode request "      AgDocWr =-2;
   do id=1,8 { If (Cf(1:2)=ask(id)) goto :N:; };  Id=9;
   do if=2,5 { Iof+=IQ(Link+10+if); if (Cf(1:1)=C(if:if)) goto:N:; }
                                                                  goto :E:;
   :N: Lk=LENOCC(Text);  Li=4; N=0;   If (Lk>1) { N=(Lk+3)/4; Li=5+N;}
   Need=Lt+Li-IQ(Link-1);  If (need>0) Call MZPUSH(IxCons,Link,0,Need+10,' ');
   L=Link+Iof;     Call UCOPY2(IQ(L+1),IQ(L+Li+1),Lt-Iof);
   IQ(L+1)=16*3+2; IQ(L+2)=Mask(Id); IQ(L+3)=i1; IQ(L+4)=i2;
   If  Li>4  { IQ(L+5)=16*N+5; Call UCTOH (Text,IQ(L+6),4,Lk); }
   " increase length "  IQ(Link+2)+=Li;  IQ(Link+10+If)+=Li;      AgDocWr = 0;
:E:"<w> AgDOCWR,Cf,I1,I2,TEXT;(' AgDocWr=',i2,' at ',a,' i1,i2,T=',2i5,2x,a)";
END;
 
+DECK,AgDGETP,T=geant. ---------------------------------------------------------
*CMZ :          13/03/98  22.56.27  by  Pavel Nevski
*CMZ :  1.30/00 09/02/97  21.15.43  by  Pavel Nevski
*CMZU:  1.00/01 22/12/95  21.50.31  by  Pavel Nevski
*CMZ :  1.00/00 15/11/95  01.03.24  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                     Subroutine   A g D G E T P  _
          (Module,Oper,istat,Bank,Name,Value,Bpath,Num,Lb,
                             Map,Names,Par,LL,LL1,Link,Flag)
*               - - -    USE processor    - - -                      *
* Description: Given the module and the bank name returns the        *
*    instance of the bank containing a selected parameter value      *
*    If the Name is blank, select the first (default) bank           *
*    Flag is 0 only at the first call, allowing more checks on it    *
* Modifications:                                                     *
*  PN, 03/06/96:                                                     *
*  default module/bank is saved in stack as suggested by Ulrik Egede *
*  selected DETM branch becomes Unique only in GEO or by Oper=UNIQ   *
**********************************************************************
+CDE,TYPING,QUEST,GCBANK,GCUNIT,SCLINK,AGCLINK,RBBANK.
     INTEGER          Nbp,IP1STACK,    IP2STACK,    IEND,IDSTACK
     COMMON /RBSTACK/ Nbp,IP1STACK(20),IP2STACK(20),IEND,IDSTACK(20)
REPLACE [ERR#{#}] with [;    IF (#1) {  IQUEST(1)=0;
    IF (istat!=-999) { Istat=Jstat; Return; }
    <W> %L(Module),Ctop,%L(Bank),LL,%L(Name),Value,%L(Bpath),(num(i),i=1,lb)
    (' error in USE operator called from ',A,' for bank ',A,'/',A,' L =',i3/ _
         10x,'Looking for variable ',A8,' =',F10.3/10x, '***** #2 *****'  / _
         10x,'The path is ',A,' with IDN =',10i5 );  Return; }
  ]
   Integer       LENOCC,LOCF,JBIT,Iname,Ns,LL,IL,Ia,Ib,Id,LP,JP,i,J,L,jstat,
                 Lb,Lvl,LL1,Link,Lk,Flag,Num(Lb),Map(2,LL1),Nch,IDYN,istat
   Character*(*) Module,Bank,Bpath,Name,Names(LL1),Oper
   Character*4   Ctop,Cbank,C1,C2
   Character*8   Dmodu,Dmodule,Dup,Ddef
   Character*80  Cform,Cforn,Bform
   Real          Value,Val,Par(LL)
   Save          Ctop,Dmodule,Ddef,Dup,ID
 
" trace module changes - a module may have only ONE default Ctop bank "
Cbank=Bank;  Jstat=-1;
if Oper(1:1)=='N' & (Istat==0 | Istat=-999) " this is a NEXT request "
{ Err LINK<0 { Bank was not selected };       Lk=%LINK(LINK);
  Err Lk<=0  { Previous bank desappeared };   Lk=LQ(Lk);
}
else
{ If Nbp==0  { Dmodu=Module; If Dmodu!=Dmodule
               { Dmodule=Dmodu; Ctop=Cbank; Ddef=' '; ID=0;
             } }
*
 If Lb==1                             "  default directories in the DETM bank "
 { :M: If Cbank==Ctop
   { Call ASLDETN(Dmodu,ID);    Err Id<=0 {detector not found in DETM bank}
     IrBDIV=IxCONS;  LkArP2=LQ(LkDETM-Id);  LvL=3;  Dup=Dmodu(1:4)//'DETM'}
   else                                   { LvL=4;  Dup=Ddef }
   If Name!=' '                    " - we need IL. Num(1) is not used at all "
   {  Lk=0;  Err LKARP2<=0 {default bank undefined}
      Call UCTOH (Cbank,Iname,4,4);    NS=IQ(LKARP2-2)
      Do IL=1,NS { Lk=LQ(LKARP2-IL); If(Lk>0&IQ(Lk-4)==Iname) Break; Lk=0}
   }
   else  { Call ReBANK (Cbank,Num,-LL,Lk,Ia) }
   " this may not be a good solution, try it however "
   If  Lk<=0 & LvL==4  { Ctop=Cbank; Go to :M:; }
 }
 else                               "     explicit directory setting if /    "
 { J=1;  While Bpath(j:j)=='/' {J=J+1};
   If J==1   " - relative address "
   {  If Cbank==Ctop
      {  IrBDIV=IxDIV;  LkArP2=LkArP1;  Lvl=3;  C2='RECB'; ID=0}
      else                            { Lvl=4;  C2= Ctop       }
   }
   else      " - absolute address "   { Lvl=3;  C2='NONE'; ID=0}
   IF (LvL==3 & Bpath(J:J+3)=='DETM') Call AsBDETE(Bpath(J+5:J+8),ID)
   J=J+5*(lb-2)-1; C1=Bpath(J+1:J+4); If (lb>2) C2=Bpath(J-4:J-1); Dup=C1//C2;
   Call ReBANK (Bpath,num,-LL,Lk,Ia)
}}
*
 Err Lk<=0 {No bank exists for this path}
*                                            explicit parameter request
 If Name!=' '
 { Ib=LOCF(Value)-LOCf(Par)+1;    Err 1>Ib|Ib>LL {variable is not in the bank}
   Ia=0;  Until Q(Lk+Ib+Ia)==Value
   { * scan a chain or block of banks
     if  IQ(Lk-5)=>0  { Lk=LQ(Lk) } else { Ia=Ia+LL }
     Err Lk<=0 | Ia>=IQ(Lk-1)  {No bank exists with this value}
   }
   " for top level make this bank default and shunt it at 1st position "
   If Cbank==Ctop & ID>0 & IrBDIV==IxCONS & (Module(5:7)='GEO'|OPER(1:1)='U')
   {  Call ZSHUNT(IxCONS,Lk,LkArP2,-IL,0)
      If (LQ(Lk)>0) Call MZDROP(IxSTOR,LQ(Lk),'L')
 } }
" CHECK LL>0   finish processing for dummy calls "
*
*                                        bank Validation
*                       If user requires the status, dont check length here
 IF istat=-999
 { Err mod(IQ(Lk-1),LL)>0 {Bank length does not correspond to the structure} }
 If Flag==0
 { LkArP3=Lk  "temporary save bank address"
   call AgDForm(Names,map,LL1,LL,Cform,Cforn);  Call MZFORM(Cbank,CForm,Flag)
    " If (LkArP3!=Lk)  print *,' popalsia gad ',LkArP3,Lk; "
   Lk=LkArP3;  Call MZIOTC (IxStor,Lk,Nch,Bform);
   If Cform!=Bform & Cform!=Bform(2:) & Cforn!=Bform
   {    print *,' wrong bank ',Cbank,' : '
        print *,' required format is = ',cform(1:Lenocc(cform)),'***'
        print *,' found bank format  = ',bform(1:Nch),          '***'
        Err Nch>=0 {Bank formats are not the same}
   }
   "    force link to be secured for banks with dymanic arrays  "
   IDYN=0; Do I=1,LL1 { If (map(1,i)<0 | MAP(2,I)<0) IDYN=1; }
   IF (IDYN>0 & LINK==0) LINK=-1
 }
*  Update once DETM family banks with datacards stored in DETP
*  Bit one of the banks status is SET after update is done
If IrBDIV==IxCONS & ID>0 & JBIT(IQ(Lk),1)==0
{
   LP=LQ(LKDETM-ID); Ns=IQ(LP-2); Call UCTOH('DETP',Iname,4,4);
   Do IL=1,Ns
   {  JP=LQ(LP-IL);  Check JP>0;  Check IQ(JP-4)=Iname;  L=IQ(JP-1);
      "   <w> bank; (' detp bank found for bank ',a4)         "
      "  if bank was selected with ISEQ, transmit it as value "
      Val=Value;   If (Name==' ') Val=IQ(Lk-5);   Call SBIT1(IQ(Lk),1)
      Call AgDatCar (Bank,Name,Val,Names,map,LL1,Q(Lk+1),IQ(Lk-1),Q(JP+1),L)
}  }
*
 Call Ucopy (Q(Lk+1+ia),Par,min(LL,IQ(Lk-1)))
 if (Oper(1:1)=='Z') call VZERO(IQ(Lk+1),IQ(Lk-1))
 if (Oper(1:1)=='D') call MZDROP(IxSTOR,Lk,' ')
 Call AGDLINK (Module,Bank,Link,Lk)
 If  LVL == 3    { " print *,' default bank set ' "; LkArP2=Lk; }
*                                      check length once more
 If  istat!=-999 { Istat=0;  Jstat=min(LL,IQ(Lk-1)); }
 Err mod(IQ(Lk-1),LL)>0 {Bank length does not correspond to the structure}
 IQUEST(1)=0
END
 
 
+DECK,AgDATCAR,T=geant. --------------------------------------------------------
*CMZ :          23/07/97  01.10.41  by  Pavel Nevski
*CMZ :  1.30/00 15/04/97  17.02.23  by  Pavel Nevski
*CMZ :  1.00/00 07/10/95  19.31.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/01/95
****************************************************************************
*                                                                          *
                 Subroutine   A g D A T C A R _
          (Bank,Name,Value,names,map,LL1,vars,LL,Buf,Lbuf)
*                                                                          *
*  Description: datacard input, stored in BUF by FFREAD, is assumed to be  *
*        a sequence of text addresses 'bank(sel).variable(ind)=' and some  *
*        amount of real numbers. All parts of the address are optional.    *
*        Type of the selector Value corresponds to the first letter of Name*
****************************************************************************
+CDE,TYPING,GCUNIT,GCFLAG.
Integer       ND,NE,NF,NG,NUM,   Dummy;     Real Anum(2);
Common/slate/ ND,NE,NF,NG,NUM(2),Dummy(34);
Equivalence              (num,                   anum);
Integer       LL,LL1,LBUF,LENOCC,ICLOCU,ICFIND,Isel,i,j,N,ia,ib,map(2,LL1),
              ie,iv,ii,i0,i1,i2,Lt,Lb,Lv,jv,kv,ind,jb,kb,ia1
Character     Bank*4,Name*(*),Names(LL1)*(*),Line*80,C*1,EQ*1/'='/
Real          Value,Rind,vars(LL),Buf(Lbuf),Blank/-989898.e-17/
Replace[ERR(#)]  with [;<W>;(' AgDatCar error : ','#1'); Isel=0; Ia=0; NEXT;]
Replace[DEBUG#;] with [;IF (IDEBUG>=7) print *,#1;]
 
{i1,i2,Ia,Isel}=0
While i2<Lbuf
{  " get new field " i0=i2;  Call AgDatAdr(Buf,i1,i2,Lbuf);
   if Isel>0 & Ia>0      " fill the previous address field with data "
   {  do i=i0+1,i1
      {  j=ia+i-i0-1;  if 1<=j&j<=LL
         {  if Names(N)(1:1)=='I'
            {  Call Ucopy(Nint(Buf(i)),Vars(j),1)
               <w> Names(N),j-ia1+1,Nint(Buf(i)),Bank,Value
               (' ===> Datacard assign ',a,'(',i2,') =',i10,' in ',a,
               ' bank selected with ',F10.3)
            }
            else
            {  Call Ucopy(Buf(i),Vars(j),1)
               <w> Names(N),j-ia1+1,Buf(i),Bank,Value
               (' ===> Datacard assign ',a,'(',i2,') =',F10.4,' in ',a,
               ' bank selected with ',F10.3)
   }  }  }  }
*                          transform the next address field into characters
   Lt=4*(i2-i1);     If Lt>80   {err(address field is too long)}
   Lt=min(lt,80);    Line=' ';   Call UHTOC(Buf(i1+1),4,line,Lt)
   Lb=Lenocc(Bank);  Lt=Lenocc(Line(1:Lt));   Iv=0 "- already used characters "
*
   Jb=ICLOCU(Bank,Lb,Line,1,LT);               " look for this bank reference "
   debug ' looking for ',bank,' in ',line(1:lt),' LT,JB=',lt,jb
   if jb>0
   {  ib=jb+lb; C=Line(ib:ib);  Rind=blank;   Iv=ib;  Isel=1; Ia=0;
      if C='('                                 " check for index in brackets  "
      {  kb=ICFIND(')',Line,ib,Lt); if kb<=0 {err(no closing bracket)};
         call CKRACK(Line,ib+1,kb-1,-1);      Iv=kb+1;
         if Nf=2 {Rind=NUM(1)} else if Nf>2 {Rind=Anum(1)}
         else    {err(index is not a number)}
      }
      if C=EQ                                  " or direct select assignement "
      {  if ib#Lt {err(equal sign is not the last one)}
         Rind=Buf(i2+1);  Iv=Lt+1;
      }                                        " there was a selection done   "
      If (Rind!=blank & Rind!=value)  Isel=0
   }  If (Isel=0 | Iv>Lt) Next
*
   Ia=3; jv=0; do N=1,LL1                      " now check variable reference "
   {  Lv=Lenocc(Names(N));       Jv=ICLOCU(Names(N)(3:Lv),Lv-2,Line,Iv+1,LT)
                                 C=line(jv+Lv-2:jv+Lv-2)
      debug ' ...now for ',names(n)(3:lv),' in ',line(Iv+1:LT),' iv,lt,jv,C=',
      iv,lt,jv,C
      Ia1=Ia;   If (jv>0 & (C=='('|C==EQ)) break;
      Ia=Ia1+1; If (Map(1,N)>0&Map(2,N)>0) Ia=Ia1+Map(1,N)*Map(2,N)
   }
* variable name should imediatly follow - otherwise it may be another bank name
   If jv!=Iv+1 { Isel=0; Next; }
*
   ii=jv+(lv-2);  C=Line(ii:ii);  Ind=1;  Ie=ii;
   If C='('
   {  kv=ICFIND(')',Line,ii,Lt);      if kv<=0 {err(closing bracket lost)}
      call CKRACK(Line,ii+1,kv-1,-1); Ie=kv+1;
      If Nf=2 {Ind=Num(1)} else {err(Index must be integer)}
   }
   debug ' ........ isel,ia,ind=',isel,ia,ind
   Ia+=Ind-1;  If Line(Ie:Ie)#EQ {err(bad assignement termination)}
}
   END
 
+DECK,AgDATADR,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 26/04/96  17.32.50  by  Pavel Nevski
*CMZ :  1.00/00 07/10/95  18.49.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/01/95
**********************************************************************
*                                                                    *
          Subroutine  A g D A T A D R (Itemp,I1,I2,L)
*                                                                    *
*  Description: compensate the lack of info provided by FFREAD(!)    *
*  Find an address field starting with a letter and ending with a =  *
*  Accept everything in (). All other combinations are data fields.  *
*  ICtype is 0-unseen, 1-anything, 2-numeric, 3-low/4-up characters. *
*  PN,26/04/96 change L0 to 2(!) - will see if it is ambigious       *
**********************************************************************
+CDE,TYPING,GCUNIT.
    Integer       L,Itemp(L),I1,I2,i,j,M,N,jx,nb,mb,ICTYPE,Lid,L0/2/
    character     Ctemp*4,c*1,eq*1/'='/
;
  { Lid,Nb,Mb,M }=0;
  do I=I2+1,L
  {  Call UHTOC(Itemp(i),4,Ctemp,4)
     Do j=1,4
     { C=Ctemp(j:j); jx=ICTYPE(C);
       If jx=0                        { Nb=1;         Lid =0;  Break;}
       If Lid=0 & j=1 & jx<=2         { Nb=1;         Lid =0;  Break;}
       If Lid<L0 & jx>=3              { Nb=2;         Lid+=1;  Next; }
       If Lid>=L0	
       {  If jx>=2|C='/'|C='.'|C=' '  { Nb=2;         Lid+=1;  Next; }
          If Mb=0  & C='('            { Nb=2; Mb+=1;  Lid+=1;  Next; }
          If Mb>0  & C=')'            { Nb=2; Mb-=1;  Lid+=1;  Next; }
          If Mb>0  & jx>0             { Nb=2;         Lid+=1;  Next; }
          If C=EQ                     { Nb=3;                  Break;}
       }                                Nb=9;         Lid =0;  Break;
     }   "  print *,' I,Ctemp,nb,lid=',I,Ctemp,nb,lid  "
          If Nb=3                   { N=Lid/4+1; I1=I-N; I2=I; Return; }
  }       I1=L; I2=L;
  End
 
 
+DECK,ASBDETE,T=geant. ---------------------------------------------------------
*CMZ :          08/12/97  13.55.36  by  Pavel Nevski
*CMZ :  1.30/00 23/05/96  14.03.56  by  Pavel Nevski
*CMZ :  1.00/00 22/08/95  04.05.46  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A S B D E T E (Cdet,ID)
*                                                                    *
*  Description:  Book a new subdetector into DETM system description *
*                (SBDETE analog)                                     *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,SCLINK,ASFLAGS.
CHARACTER   Cdet*(*)
INTEGER     I,ID,LDETE,NEED,IUCOMP,Iprin,ND/10/,NL/10/,
            FLAGS(NFLAGS)/3*0, 8*1, 4*0/
 
Iprin=Idebug
If Cdet(1:4)=='flag' " really OO action - only ASBDETE has access to defaults "
{ Do i=1,NFLAGS
  {  check Cdet(5:8)==CFLAG(i); FLAGS(i)=ID;
     Prin2 i,CFLAG(i),ID; (' ASBDETE: change default flag',i3,1x,a,' to',i4)
  }; Return;
}
 
" Check if top level bank exists at all. If not book it:  "
" Occupy first link for the documentation tree            "
 IF LKDETM<=0
 { Call MZBOOK (IxCONS,LKDETM,LKDETM, 1,'DETM',ND,ND,ND, 5,0)
   Call MZBOOK (IxCONS,LDETE, LKDETM,-1,'DOCU',NL,NL,NFLAGS,2,0)
   Call UCTOH  ('DOCU',IQ(LKDETM+1),4,4)
 }
" now check if the detector already exists, If not - find free place "
 ND=IQ(LKDETM-1);   Call GLOOK (Cdet,IQ(LKDETM+1),ND,ID);  If (Id>0) Return;
 ID=IUCOMP (0,IQ(LKDETM+1),ND)
 If ID==0 { ID=ND+1; NEED=10; Call MZPUSH (IxCONS,LKDETM,NEED,NEED,' ') }
 
" Hang the DETector Data bank "
 Call MZBOOK (IxCONS,LDETE,LKDETM,-ID,Cdet,NL,NL,NFLAGS,2,0)
 Call UCTOH  (Cdet,IQ(LKDETM+ID),4,4);      IQ(LDETE-5)=1
 Call Ucopy  (Flags,IQ(LDETE+1), Nflags)
   END
 
 
+DECK,AgSTAND,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 20/11/96  13.38.13  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/01/95
******************************************************************************
*                                                                            *
                          SUBROUTINE   A G S T A N D
*                                                                            *
*  Description: tables of the obvious standard materials and media           *
******************************************************************************
+CDE,TYPING,AGECOM,GCBANK.
  Character*20 Modulo
*
* make sure that minimal GEANT structures exist
  If (Jpart==0) Call GPART
  IF (Jmate==0) Call GMATE
  Check JTMED==0
  call UCTOH('no  ',IQ(LQ(JPART-48)+3),4,4)
  call UCTOH('otti',IQ(LQ(JPART-48)+2),4,4)
  call UCTOH('gian',IQ(LQ(JPART-48)+1),4,4)
  Modulo = %Module;  %Module = ' '
*
*    More simple materials from PDG (july 1994)
  Material  Silicon       z=14  A=28.09  Dens=2.33 RadL=9.36 AbsL=106.0/2.33
  Material  Liquid_argon  z=18  A=39.95  Dens=1.40 RadL=14.0 AbsL=117.2/1.40
  Material  Argon_gas     z=18  A=39.95  Dens=1.78e-3,
                                         RadL=14.*1.4/%Dens  AbsL=117.2/%Dens
  Material  Nitrogen_gas  z=7   A=14.01  Dens=1.25e-3,
                                         RadL=37.99/%Dens    AbsL=87.8/%Dens
  Material  Oxigen_gas    z=8   A=16     Dens=1.43e-3,
                                         RadL=23944          AbsL=90./%Dens "?"
*
*    Some organic composites from PDG (july 1994)
  Component C             Z=6   A=12  w=1
  Component H             Z=1   A=1   w=1
  Component O             Z=8   A=16  w=1
  Mixture   Polystyren    NlMat=2  ww={1,1}   Dens=1.032    "scintillator"
  Mixture   Polyethylene  NlMat=2  ww={1,2}   Dens=0.93
  Mixture   Mylar         NlMat=3  ww={5,4,2} Dens=1.39
*
*    now standard tracking medium (filled here with air)
  Material Air
  Medium   Standard  Ifield=1 FieldM=20 TmaxFd=20 Epsil=0.01,
                     SteMax=10.0   DeeMax=-0.02   StMin=-0.01
  Medium   Atlas     Ifield=1 FieldM=20 TmaxFd=20 Epsil=0.01,
                     SteMax=10.0   DeeMax=-0.02   StMin=-0.01
  %Module = Modulo
  End
 
 
 
 
+DECK,AgPFLAG,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 26/11/96  23.11.18  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
             Function     A G P F L A G (Cdet,Stage)
*                                                                    *
*  Description:  get a standard SLUG-like control Print Flag         *
**********************************************************************
+CDE,TYPING,GCBANK,GCFLAG,SCLINK,AGECOM.
  Integer        AGPFLAG,Idet/0/,Ista/0/
  Character      Cdet*4,Stage*4,Cdeto*4/'.'/,Stageo*4/'.'/
+CDE,STAFUNC.
*                                     requested detector does not exist
      AgPFLAG=-1;
      If (Cdet!=Cdeto) CALL GLOOK(Cdet, IQ(LKDETM+1),IQ(LKDETM-1),Idet)
      Cdeto=Cdet;  Check Idet>0
*                                     attempt to reconsile with DICE
      If      Stage='RECO'  { Check LVRECO(Idet)>0; }
      Else If Stage='ANAL'  { Check LVANAL(Idet)>0; }
      Else                  { Check LVGEOM(Idet)>0; }
*
      AgPFLAG = max(LVPRIN(Idet),LWPRIN(Idet),IDEBUG)
      If (stage!=stageo) CALL GLOOK(Stage,IQ(LKDETM+1),IQ(LKDETM-1),Ista)
      If (Ista>0) AgPFLAG*=max(LVPRIN(Ista),LWPRIN(Ista),IDEBUG)
*     print *,' AFPFLAG: module,stage,flag=',cdet,stage,agpflag
      stageo=stage
   END
 
 
+DECK,AgDROP,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 17/04/97  16.06.21  by  Pavel Nevski
*CMZ :  1.00/00 09/08/95  15.18.33  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
****************************************************************************
*                                                                          *
                 subroutine   A g D R O P (Title)
*                                                                          *
****************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,SCLINK,AGCDOCL,GCNUM,GCVOLU.
 character*(*) Title;  Character*1 Com;
 com=title;  If (Title=='ALL') Com='*';
 if (com='G'|com='G') & JRUNG >0  { Call MZDROP(IxStor,JRUNG ,'L');           }
 if (com='A'|com='-') & JMATE >0  { Call MZDROP(IxStor,JMATE ,'L');  NMATE=0; }
 if (com='M'|com='-') & JTMED >0  { Call MZDROP(IxStor,JTMED ,'L');  NTMED=0; }
 if (com='P'|com='-') & JPART >0  { Call MZDROP(IxStor,JPART ,'L');  NPART=0; }
 if (com='V'|com='*') & JROTM >0  { Call MZDROP(IxStor,JROTM ,'L');  NROTM=0; }
 if (com='V'|com='*') & JVOLUM>0  { Call MZDROP(IxStor,JVOLUM,'L');  NVOLUM=0;}
*if (com='V'|com='*') & JGPAR >0  { Call MZDROP(IxStor,JGPAR, 'L');  JGPAR=0; }
*if (com='V'|com='*') & JGPAR2>0  { Call MZDROP(IxStor,JGPAR2,'L');  JGPAR2=0;}
 if (com='S'|com='*') & JSET  >0  { Call MZDROP(IxStor,JSET  ,'L');           }
 if (com='S'|com='*') & JHITS >0  { Call MZDROP(IxStor,JHITS ,'L');           }
 if (com='S'|com='*') & JDIGI >0  { Call MZDROP(IxStor,JDIGI ,'L');           }
 if (com='D'|com='*') & LKDETM>0  { Call MZDROP(IxStor,LKDETM,'L');           }
 if (com='D'|com='*') & L1Doc >0  { Call MZDROP(IxStor,L1Doc, 'L');           }
 if (com='R'|com='*') & LKRUNT>0  { Call MZDROP(IxStor,LKRUNT,'L');           }
 if (com='R'|com='*') & LKEVNT>0  { Call MZDROP(IxDiv, LKEVNT,'L');           }
 if (com='R'|com='*') & LKARAW>0  { Call MZDROP(IxDiv, LKARAW,'L');           }
 if (com='R'|com='*') & LKARP1>0  { Call MZDROP(IxDiv, LKARP1,'L');           }
 if (com='E'|com='*')             { Call MZWIPE(IxDiv); NTRACK=0; NVERTX=0;   }
 if  com='*'        { call MZGARB(20,0); <w>;(' *** all banks DROPPED *** '); }
 NLEVEL = 0
    END
 
+DECK,ARFROMC,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 03/08/96  17.13.04  by  Pavel Nevski
*CMZ :  1.00/00 04/12/94  14.38.39  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Function     A R F R O M C (Cvar)
*                                                                    *
*  Description:  4-character  to a real number conversion            *
**********************************************************************
Real ARFROMC;  Character Cvar*(*),C*4,S*64;  Integer I,K;
Data S/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz '/;
     C=Cvar;  k=0;
     Do i=1,4 { k=ISHFT(k,6); k+=Index(s(2:64),c(i:i)); }
     ARFROMC=k;
   END
 
+DECK,ACFROMR,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 03/08/96  16.52.41  by  Pavel Nevski
*CMZ :  1.00/00 04/12/94  14.38.39  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Function     A C F R O M R (R)
*                                                                    *
*  Description: real to 4-character conversion                       *
**********************************************************************
Real R;   Character ACFROMR*4,C*4,S*64;  Integer I,J,K;
Data S/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ '/;
     C=' ';   k=R;
     Do i=4,1,-1  { j=IAND(k,63)+1; k=ISHFT(k,-6); C(i:i)=S(j:j); }
     ACFROMR=C;
   END
 
 
+DECK,agphits,T=geant.
*CMZ :  1.00/00 03/02/95  01.15.24  by  Pavel Nevski
*-- Author :    Pavel Nevski   22/01/95
**********************************************************************
*                                                                    *
              SUBROUTINE A G P H I T S (CSET,CDET)
*                                                                    *
*  Description:   print GEANT hits summary in the ATLAS dense format *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT.
      INTEGER       IBITS,JS,JD,JDX,JX,JXD,JDU,Nw,Nd,Nv,Nk,Nb,ii,I,J,K,
                    Nset,Ndet,Last,Kdigi,Iset,Idet,Ltra,i1,Nvu,Ndu,IHIT,
                    ITRA,Nhits,Ind,Mind,NUMBV(15),NHIT(100);
      REAL          Sumt,DIGI(20),SUM(100);
      CHARACTER*4   CSET,CDET,CS,CD;
 
   Check JhitS>0;  NSET=IQ(JSET-1);   " first make selection using SETS "
   DO ISET=1,Nset     "             Loop on all selected sets        "
   {  CALL UHTOC(IQ(JSET+ISET),4,CS,4);  Check CSET(1:1)='*' | CSET=CS;
      JS = LQ(JSET-ISET);   Check Js>0;  Ndet=IQ(JS-1);
      Do IDET=1,NDET  "         Loop on selected detectors for this set "
      {  CALL UHTOC(IQ(JS+IDET),4,CD,4); Check CDET(1:1)='*' | CDET=CD;
 
                                      " now check the HITS structure "
         JX   = LQ(JhitS-ISET);        Check JX>0;
         JXD  = LQ(JX-IDET);           Check JXD>0;
         LAST = IQ(JX+IDET);           Check LAST>0;
         JD   = LQ(JS-IDET);           Check Jd>0;
         JDX  = LQ(JD-1);              Check JDX>0;
         NW   = IQ(JD+1)+IQ(JD+3)+1;   Check Nw>0;
         NV   = IQ(JD+2);              ND  = IQ(JD+4);
         JDU  = LQ(JD-3); If JDU>0   { NVU = Q(JDU+6);  NDU = Q(JDU+2); }
 
         { Mind,Sumt,Nhits,ITRA,NUMBV(1),DIGI(1) } = 0;
         Call Vzero(Sum,100);  Call Vzero(Nhit,100);
         " loop on all hits to get track numbers, volume numbers and info "
         Do ii=1,LAST,NW
         {  j=JXD+ii;  LTRA=IQ(j);   NK=1; K=1;
            DO I=1,min(1,NV)  "      get unpacked volume numbers              "
            {  Nb=IQ(JD+2*I+10);
               IF Nb>0  { K+Nb>33 ?; NUMBV(i)=IBITS(IQ(j+Nk),K-1,Nb); K+=Nb; }
               else     { K>1     ?; NUMBV(i)=IQ(j+Nk);               Nk+=1; }
            }
                                     Nk=1+IQ(JD+1); K=1;
            Do I=1,min(1,ND)  "      get unpacked cumulative hits             "
            {  i1=Jdx+4*(I-1); Nb=IQ(i1+2);  Ihit=IQ(i1+1);
               IF Nb>0  { K+Nb>33 ?; KDIGI=IBITS(IQ(j+Nk),K-1,Nb); K+=Nb; }
               else     { K>1     ?; KDIGI=IQ(j+Nk);               Nk+=1; }
               DIGI(i)=KDIGI/Q(i1+4)-Q(i1+3);
            }
            Ind=min(max(1,NUMBV(1)+1),100);  Nhit(Ind)+=1;  Sum(Ind)+=Digi(1);
            Nhits+=1; Sumt+=Digi(1);  Mind=Max(Mind,Ind); ITRA=max(ITRA,LTRA);
         }
         <W> Cd,Cs,ITRA;
         (/' HITS summary in detector ',A4,' of SET ',A4,' on',i6,' tracks');
         <w> Nhits,    (Nhit(i),i=1,Mind); ('  Hits: ',11I10  /(18x,10i10));
         <w> Ihit,Sumt,(Sum(i) ,i=1,Mind); (2x,a4,': ',11G10.3/(18x,10G10.3));
   }  }
   END
 
 
+DECK,agsflag,T=geant.
*CMZ :  1.30/00 28/04/96  19.59.55  by  Pavel Nevski
*CMZ :  1.00/00 21/03/95  15.01.57  by  Pavel Nevski
*-- Author :    Pavel Nevski   21/03/95
****************************************************************************
*                                                                          *
                SUBROUTINE   A G S F L A G (CflagI,Iflag)
*                                                                          *
****************************************************************************
+CDE,TYPING,AGECOM.
     character*4 CflagI,Cflag
     Integer     Iflag
     Cflag=CflagI;       Call CLTOU(Cflag)
     If (Cflag='PRIN')   %Iprin=Iflag
     If (Cflag='GRAP')   %Igrap=Iflag
     If (Cflag='HIST')   %Ihist=Iflag
     If (Cflag='GEOM')   %Igeom=Iflag
     If (Cflag='MFLD')   %Imfld=Iflag
     If (Cflag='DEBU')   %Idebu=Iflag
     If (Cflag='SIMU')   %Isimu=Iflag
     CALL AsbDETE('flag'//CFLAG,Iflag)
END
 
 
+DECK,AGFPATH,T=geant. ---------------------------------------------------------
*CMZ :          27/08/97  14.26.21  by  Pavel Nevski
*CMZ :  1.00/00 06/06/95  15.09.02  by  Pavel Nevski
*-- Author :    Pavel Nevski   07/02/95
**********************************************************************
*                                                                    *
         subroutine     A g F P A T H (ISC)
*                                                                    *
* Description:  build geant path to a sensitive element ISC          *
*              Set/det should be already selected - only JDU is used *
* Modifications:                                                     *
* 27.08.97,  PN: zero in an ISC means the last possible copy number  *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,AGCRDIG.
  Integer  ISC(*),nam,nom,nick,Ier,I,J,K,L,N,Nb,i1,i2,Jm,Imo,Ivo,nin,
           in,jn,Nr,NwuVol/3/
  Integer  Lnam(20),Lnom(20),Lnum(20),Ivol(20)
  Save     Lnam,Lnom,Lnum,Ivol
*
  Check Jdu>0;
  i1=Q(Jdu+3);  i2=Q(Jdu+5);  N=Q(Jdu+4);  {L,K,Imo}=0;
  :L: Do i=i1,i2-1,NwuVol
  {  j=Jdu+i;         Nb=Q(j+3);    IF (Nb>0) K+=1;    L+=1;
     Ivo=Q(j+1);      nam=IQ(Jvolum+Ivo);    {Lnam(L),Lnom(L)}=nam;
     Lnum(L)=Q(j+2);  IF (Nb>0) Lnum(L)=ISC(K);
     If  L=1          { Ivol(1)=Ivo;  Next :L:; }
     Imo=Ivol(L-1);   Jm=LQ(JVOLUM-Imo);
     nin=Q(jm+3);     If L<N & nin=0
     { <w> nam,L,N; (' AGFPATH: empty ',a4,' at level',2i5);    Break; }
*
     " find copy with the same generic name as NameSH element "
     do in=1,max(nin,1)   " over number of contents "
     {  jn=LQ(Jm-in); Ivo=Q(jn+2); Nr=Q(jn+3);
        Nom=IQ(LQ(JVOLUM-Ivo)-4);  Nick=IQ(JVOLUM+Ivo);
        Check nam=nom | nam=Nick;
        " special request - last copy "
        If k>0 & ISC(k)==0 & Nr>Lnum(L)
        { Lnum(L)=Nr; Lnam(L)=IQ(JVOLUM+Ivo); IVOL(L)=Ivo; Next; }
        " normal request - selected copy "
        Check nin>0 & Lnum(L)=Nr | nin<0 & 0<Lnum(L)&Lnum(L)<=Nr
        Lnam(L)=IQ(JVOLUM+Ivo);    IVOL(L)=Ivo;        Next :L:;
     }
     if k>0 & ISC(k)==0  { ISC(k)=Lnum(L); Next :L:; }
 
     if (Idebug>0) <w> nam,L
     (' AGFPATH: can not find ',a4,' at level',i5); L-=1; Break;
  }  CALL GLVOLU (L,Lnam,Lnum,IER);
*
  END
 
 
+Deck,agsstep,T=geant.
*CMZ :  1.30/00 18/04/96  17.09.45  by  Pavel Nevski
*CMZ :  1.00/00 07/05/95  00.09.13  by  Pavel Nevski
*-- Author :    Pavel Nevski
*************************************************************************
      subroutine     A G S S T E P (ext)
*************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,SCLINK.
   external ext;   Integer JUMPAD,Ldete,L,Id;
   call AsbDETE(%Module,Id);
   If (Id != %IdType) print *,'Id inconsistent - ',Id,%Idtype
   Ldete=LQ(LKDETM-Id);   L=IQ(Ldete-1);
   If L>12 {  IQ(Ldete+13)=JUMPAD(ext) }   else    {  <W>;
   (' AgSSTEP warning: you need a modified DETM format to run this option')}
      end
 
+DECK,aggetdig,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 02/04/97  18.53.55  by  Pavel Nevski
*CMZ :  1.00/00 04/06/95  23.36.31  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
**********************************************************************
*                                                                    *
                SUBROUTINE A g G E T D I G  (JD,JJ,NBV,DIGI)
*                                                                    *
*  Description: Common hit/digi unpacking for any AGI routine        *
*          JD is the link to SEJD bank, JJ is link to a hit/digi     *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK.
   integer            idigi
   Common   /AgCdigi/ idigi(15)
*
   INTEGER     JD,JJ,JDS,Nv,Nk,No,Nb,I,J,K,L,j1,j2,Idig,Ihitf,bin,mode,
               JBYT,NBV(15),NwuVol/3/,NwuHit/10/
   REAL        Org,Fct,Fmx,xx,D,DIGI(15)
   bin(xx)  =  IFIX((xx+org)*fct)
*
*                            get SJDU link and set common counters
     NK=jj+1;  K=1;  D=0.5;  Jds=LQ(JD-3);  Nv=IQ(JD+2);
*                            get unpacked branching volume numbers
     j1=Q(Jds+3);  j2=Q(Jds+5)-1;  i=0;
     Do j=j1,j2,NwuVol
     {  L=Jds+j;  Nb=Q(L+3);  Check Nb>0;
        I+=1;  K+Nb>33?;  NBV(i)=JBYT(IQ(Nk),K,Nb)+1; K+=Nb;
     }
     Ihitf=Nv-I;  mode=0;  I=0;    " Ihitf - start of geant HIT field        "
     j1=Q(Jds+1);  j2=Q(Jds+3)-1;
     Do j=j1,j2,NwuHit             "         unpacked digits                 "
     {" No - requested Nbit (if not MAGIC), Nb - allocated (always positive) "
        L=Jds+j;  No=Q(L+3); Org=Q(L+6); Fct=Q(L+7); Fmx=Q(L+5); Nb=Q(L+8);
        If I==Ihitf               {" geant HIT field "  K>1 ?;  D=0;    }
        If -32<=No&No<=0 & mode=0 {" comulative part "  K>1 ?;  Mode=1; }
        IF 0<Nb&Nb<32  { K+Nb>33 ?;  IDIG=JBYT(IQ(Nk),K,Nb);  K+=Nb; }
        else           { K>1     ?;  IDIG=IQ(Nk);             Nk+=1; }
        I+=1;      DIGI(i)=min((IDIG+D)/fct-Org,fmx);  idigi(i)=IDIG
        If I==1
        { while LQ(Jds)>0 & bin(Q(LQ(Jds)+8))<=IDIG { Jds=LQ(Jds) }}
     }
   END
 
 
+DECK,agfdigi,T=geant. ---------------------------------------------------------
*CMZU:  1.00/01 15/11/95  02.08.58  by  Pavel Nevski
*CMZ :  1.00/00 05/10/95  02.29.43  by  Pavel Nevski
*-- Author :    Pavel Nevski   17/01/95
**********************************************************************
*                                                                    *
   subroutine   A G F D I G I (Cset,Cdet,NVS,LTRA,NBV,DIGI,Iw,Iad)
*                                                                    *
* Returns the next digitisation for the physical volume, specified   *
* by NVS list with generic volume/set name Cdet/Cset,packed form     *
* INPUT:                                                             *
* Cset,Cdet - user set/detector identifiers (CHAR*4)                 *
* NVS - list of volumes identifying the path, ignored if nvs(1)<0    *
* OUTPUT:                                                            *
* LTRA the number of the track which has produced this digitisation  *
* NBV  the list of volume numbers which identify the physical volume *
* KDIGI       array that get the digitalisation elements             *
* ====>  User should take care of NVB and KDIGI real dimesions !     *
* Iw - Hit sequential number. It is negative, if SET/DET does not    *
*      exist at all, and 0 when hits are absent or all hits are done *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,AGCRDIG.
  CHARACTER*4 Cset,Cdet,Cset0/'****'/,Cdet0/'****'/
  Integer     Nvs(*),NBV(*),LTRA,NTRA,Iw,Iad,JH,Iset,Idet,I,J,ii,X
  Real        DIGI(*)
* - - - - - - - - - - - - - - - - - - - - - - - - -
IF Iw<=0 | Cset!=Cset0 | Cdet!=Cdet0
{  Check Jset>0;   {Jdu,Last}=0;   Iw=-1;
   Call  MZLINT(IxSTOR,'AGCRDIG',IWA,JS,Jdu);
   "  Find if digi in selected set & detector exist  "
   Call GLOOK(Cset,IQ(Jset+1),IQ(Jset-1),Iset);             Check Iset> 0;
   JS  = LQ(Jset-Iset);                                     Check Js  > 0;
   Call GLOOK(Cdet,IQ(JS + 1),IQ(JS - 1),Idet);             Check Idet> 0;
   JD  = LQ(JS-Idet);                                       Check JD  > 0;
   JDU = LQ(JD-3);    Cset0=Cset;    Cdet0=Cdet;     Iw=0;
   if Cset(4:4)=='H' {X=1; JH=JHITS} else {X=2; JH=JDIGI};  Check JH  > 0;
   Jx  = LQ(JH-Iset);                                       Check Jx  > 0;
   JXD = LQ(JX-Idet);                                       Check JXD > 0;
   Last= IQ(JX+Idet);                                       Check Last> 0;
   NW  = IQ(JD+1)+IQ(JD+2*X+1)+1
   Nvb = Q(JDU+6)
   if (IW<0) IW  = 0
}
If jdu<=0  { call GFDIG1(Cset,Cdet,1,NVS,LTRA,NTRA,NBV,DIGI,Iw,Ia); Return; }
*
:D: DO ii=Iw*Nw+1,Last,Nw
 {  j=JXD+ii;   LTRA=IQ(j);   Call AgGETDIG(Jd,J,NBV,DIGI)
    do i=1,Nvb  { If (NVS(i)>0 & NVS(i)!=NBV(i)) Next :D:; }
    iw=ii/Nw+1; Iad=J;                           Return;
 }
   {iw,iad,IWA(1)}=0;
   END
 
 
+DECK,agfdig0,T=geant. -------------------------------------------------------
*CMZ :          27/11/97  16.29.36  by  Pavel Nevski
*CMZ :  1.30/00 13/05/97  14.48.21  by  Pavel Nevski
*CMZ :  1.00/00 01/09/95  22.54.27  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
             Function     A g F D I G 0 (Cset,Cdet)
*                                                                    *
*  Prepare hits for digitization making chains in each element       *
*  modifications: 1.09.95 - protect agains 0 path     - PN           *
*  25.01.96 - invert hits order as suggested by Fred                 *
*  01.05.97 - check consistency between sets and hits/digi structure *
*  13.05.97 - on error keep Iv=-1 to stop AgFDIG1                    *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT,GCNUM,GCFLAG,AGCBUFF,AGCRDIG.
Character*(*)    Cdet,Cset;   Integer Lp,Lt;  Parameter (Lp=20,Lt=100);
Integer          AgFDIG0,LgKINE,JBYT,MSBYT,LENOCC,ICDECI,NVL(Lp),ISC(Lp),Itr,
                 Iset,Idet,X,Nv,Nr,Nb,Ja,i,j,k,L,Na,Ma,Jv,Jk,Nk,Ih,JH,Mbm,Ier
*
   Cs=Cset;  Cd=Cdet;  {AgFDIG0,Iv,Ia}=-1;  {Iset,Idet,Jdu}=0;
   CALL MZLINT (IXSTOR,'AGCRDIG',IWA,JS,JDU);
*
   "  Find if hits in selected set & detector exist  "
   Call GLOOK(Cs,IQ(Jset+1),IQ(Jset-1),Iset);               Check Iset> 0;
   JS  = LQ(Jset-Iset);                                     Check Js  > 0;
   Call GLOOK(Cd,IQ(JS + 1),IQ(JS - 1),Idet);               Check Idet> 0;
   JD  = LQ(JS-Idet);                                       Check JD  > 0;
   JDU = LQ(JD-3);                                          Check Jdu > 0;
   if Cset(4:4)=='H' {X=1; JH=JHITS} else {X=2; JH=JDIGI};  Check JH  > 0;
   Ier = 1;          If (Iset>IQ(JH-2))                     goto :e:
   Jx  = LQ(JH-Iset);                                       Check Jx  > 0;
   Ier = 2;          If (Idet>IQ(Jx-2)|Idet>IQ(Jx-1))       goto :e:
   JXD = LQ(JX-Idet);                                       Check JXD > 0;
   Last= IQ(JX+Idet);                                       Check Last> 0;
*
   Nw=IQ(JD+1)+IQ(JD+2*X+1)+1;  Nvb=Q(Jdu+6);  Nv=IQ(JD+2); Nc1=Last/Nw;
   Ier = 3;          If (mod(last,nw)!=0)                   go to :e:
   Nr=0;  if (LENOCC(Cdet)>=6)  Nr=ICDECI(Cdet,5,6);   Nvb=min(Nvb+Nr,Nv);
   Call VZERO(NVL,Lp);          Mb=0; i=Nc1; while i>0 {i/=2; Mb+=1;};
   If Mb>1  { Mbm=2**(32-Mb) } else { Mbm=2 000 000 000 "big positive" }
   Do Ih=1,Nc1 { If (IQ(JXD+(Ih-1)*Nw+1)>=Mbm) Break; Last=Ih }
*
   "       ----------      associate hits in chains     ---------    "
   call VZERO(Ibuf,Lbuf); Na=1; Ma=0; ISC(1)=1; ier=0;
   Do Jv=1,max(1,Nvb)                      " for all higher levels   "
   {  Do Ih=Nc1,1,-1                       " rescan all hits to find "
      {  Nk=1; K=1; J=JXD+(Ih-1)*NW+1;     " the actual maximum of   "
         do Iv=1,min(Jv+1,Nvb)             " the volume number used  "
         { Nb=IQ(JD+2*Iv+10); K+Nb>33?; ISC(iv)=JBYT(IQ(j+Nk),K,Nb)+1; K+=Nb;}
         *                                   now get buffer address
         Ia=1; do i=1,Jv { Ja=Ia+ISC(i); Ia=IBuf(Ja);}  Ma=max(Ma,Ja);
         If Jv<Nvb { IBuf(Ja)=max(Ia,ISC(Jv+1)); }
         else
         { " chitting:  replace track numbers by vertex numbers "
             Itr=IQ(J);
             If itr>Ntrack & ier<=Idebug
             { ier+=1; <w> Cset,Cdet,itr;
               (' AgFDIG0 error for',2(1x,a4),': bad ITRA=',i12)
             }
             If (itr>0&ih>Last) Itr=Q(LgKINE(JK,Itr)+6)
             If Itr>=Mbm & ier<=Idebug
             { ier+=1; <w> Cset,Cdet;
               (' AgFDIG0 for',2(1x,a4),': sometime chitting does not help')
             }
             IQ(J)=MSBYT(Ia,Itr,33-Mb,Mb); IBuf(Ja)=Ih
             }
      }  If (Jv=1) Ibuf(1)=Ma-1;
      *
      Ja=Ma+1;  "expand array"  While Ibuf(Na)>0 & Na<Ma & Jv<Nvb
      {  Do Ia=1,Ibuf(Na)
         {  L=Ibuf(Na+Ia); Check L>0; Ibuf(Na+Ia)=Ja; Ibuf(Ja)=L; Ja+=1+L;
            Check Ja>Lbuf; Ibuf(Na+Ia)=0;  <W> Cset,Cdet;
            (' AgFDIG0: NOT ENOUPH MEMORY FOR',2(1x,A),', HITS WILL BE LOST');
         }  Na+=1+Ibuf(Na);
   }  }
   {AgFDIG0,Iv,Ia,nc2}=0
   If (Last<Nc1)  <W> Cset,Cdet,Mbm,int(Q(LQ(Jkine-Mbm)+6))
   (' AgFDIG0 WARNING FOR',2(1x,a),': TRACKS ABOVE',2i12,' WILL BE chitted')
   return
   :e: <w> ier,Cset,Cdet
   (' AgFDIG0 FATAL ERROR:',i3,' Probably inconsistent geometry ',2(1x,a4))
   {AgFDIG0,Iv,Ia,nc2}=-1
   END
 
 
 
 
 
+DECK,agfdig1,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 13/05/97  14.48.21  by  Pavel Nevski
*CMZ :  1.00/00 01/09/95  22.55.18  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
     Function     A g F D I G 1 (NHit,LTRA,ISC,HITS)
*                                                                    *
* Description:  make a loop over detector elements and give to user  *
*               all hits in the selected element sequentially        *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT,GCVOLU,GCNUM,AGCBUFF,AGCRDIG.
                 Integer Lp; Parameter (Lp=20);
Integer          AgFDIG1,ISC(*),NVL(Lp),JBYT,Nhit,LTRA,ja,Itr,Lev
Real             HITS(*);
Save             NVL;
*
   Lev=0     " will be set to the lowest Iv of the volume index been changed "
If Iv>=0     " Iv - the last changed level is saved in the AGCHIT common     "
{  If Ia==0
   {  Lev=LP; Nhit=0;
      :a:;If (Iv>0) NVL(Iv)+=1;  call UZERO(NVL,Iv+1,Lp);
          Lev=min(max(1,Iv),Lev);
          Ia=1; Iv=0; While Iv<max(1,Nvb)       " bootstrap index "
          {  IF NVL(Iv+1)>=Ibuf(Ia) { If (Iv==0) goto :e:; goto :a:; }
             Iv+=1;  Ia=IBuf(Ia+NVL(Iv)+1);   If (Ia=0) goto :a:;
   }      }
                               * * *
   "   getting a hit in the selected element and the address of the next "
   Ja=JXD+Nw*(Ia-1)+1;   call  AgGETDIG (JD,Ja,ISC,HITS);
   "   get track number, check for the track overlap, clear track number "
   Itr=JBYT(IQ(ja),1,32-Mb);  If (Itr>0 & Ia>Last) Itr=Q(LQ(Jvertx-Itr)+8)
   If (Nhit=0) LTRA=ITR;      If (LTRA#ITR) LTRA=-ITR
   Ia=JBYT(IQ(ja),33-Mb,Mb);  IQ(Ja)=Itr
                              * * *
   " Count hits in the same element, the last one get Nhit negative "
   Nhit+=1; If (Ia=0) Nhit=-Nhit; Nc2+=1;  AgFDIG1=0; "intermediate" Return;
}
   :e:   IWA(1)=0;                         AgFDIG1=-1; "  final  "   Return;
   END
 
 
+DECK,agfdpar,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 06/05/97  15.20.30  by  Pavel Nevski
*CMZU:  1.00/01 13/12/95  16.02.30  by  Pavel Nevski
*CMZ :  1.00/00 07/10/95  23.14.29  by  Pavel Nevski
*-- Author :    Pavel Nevski   03/06/95
************************************************************************
*                                                                      *
         SUBROUTINE A G F D P A R (hits,Chit,FHmin,FHmax,FHbin)
*                                                                      *
*  Description: provides user description of the hit/digi format       *
*               Set/det should be already defined - only JDU is used   *
*               First free element of CHIT is set to blank.            *
*               If No description is available at all, CHIT(1)=blank   *
*               For vectorised hits ONLY: CHIT(1) is also blank        *
*               if HITS(1) is outside any of the defined regions       *
************************************************************************
+CDE,TYPING,GCBANK,AGCRDIG.
     Real         HITS(*),FHmin(*),FHmax(*),FHbin(*),Org,fct,fmx,xx
     Integer      j1,j2,I,J,K,K2,L,Ju,Jn,bin,NwuHit/10/,%Magic/-696969/
     character*4  Chit(*),ACFROMR
     bin(xx)=IFIX((xx+org)*fct)
*
     Chit(1)=' ';  Check Jdu>0;  Ju=Jdu;  j1=Q(Ju+1);  j2=Q(Ju+3)-1;  i=0;
     Do j=j1,j2,NwuHit       "         unpacked digits                   "
     {  L=Ju+j;  Fmx=Q(L+5);  Org=Q(L+6);  fct=Q(L+7);
        If i==0 &  Q(Ju+8)>%Magic
        {  * only for vectorised hit definition
           if (Org>hits(1) | hits(1)>Fmx)   "outside all(a,b)"  Return
           K=bin(hits(1));  K2=bin(Q(ju+8));  If (K<K2) "below" Return
           While K>K2                       "find a valid region"
           { Jn=LQ(Ju); If (Jn<=0) Return; K2=bin(Q(Jn+8)); If (K>=K2) Ju=Jn }
        }
        I+=1; Chit(i)=ACFROMR(Q(L+1)); Fhmin(i)=-Org;  Fhmax(i)=Fmx;
        if (fct!=0) FHbin(i)=1.0/fct
     }  Chit(i+1)=' '
    END
 
 
+DECK,agpdigi,T=geant. ---------------------------------------------------------
*CMZ :          23/10/97  22.22.23  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  18.53.55  by  Pavel Nevski
*CMZ :  1.00/00 03/06/95  12.02.49  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
**********************************************************************
*                                                                    *
                SUBROUTINE A G P D I G I (CSET,CDET)
*                                                                    *
*  Description: print GEANT hits or digits                           *
*  If USER bank is there this is the AGI dense format                *
*  FOR OTHER APPLICATION PLEASE TAKE CARE OF THE NAMING CONVENTION:  *
*  Nv,Nx(=h/d) for original geant counters, Nha,Nvb for AGI counters *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT.
     INTEGER       JS,JD,JH,JX,JXD,JDU,Ip0,Ip1,Nw,NVb,Nha,Mv,Md,
                   Nset,Ndet,Last,Iset,Idet,Ltra,Idig,ii,jj,X,i,
                   JBYT,NBV(15)
     REAL          DIGI(20)
     CHARACTER     CBUF*400,T*6
     CHARACTER*4   ACFROMR,CSET,CDET,CS,CD,CDID
*
 NSET=IQ(JSET-1)    "           first make selection using SETS    "
 DO ISET=1,Nset     "             Loop on all selected sets        "
 { CALL UHTOC(IQ(JSET+ISET),4,CS,4);  Check CSET(1:1)='*' | CSET=CS;
   JS = LQ(JSET-ISET);   Check Js>0;  Ndet=IQ(JS-1);
   Do IDET=1,NDET  "         Loop on selected detectors for this set "
   { CALL UHTOC(IQ(JS+IDET),4,CD,4);  Check CDET(1:1)='*' | CDET=CD;
*
                                     " now check the DIGI structure "
     JD  = LQ(JS-IDET);           Check Jd>0;
     If LQ(JD-2)>0                { T='DIGITS'; JH=JDIGI; X=2;  }
     If LQ(JD-1)>0                { T=' HITS '; JH=JHITS; X=1;  }
                                  CHECK JH>0;
     JX   = LQ(JH-ISET);          Check JX>0;
     JXD  = LQ(JX-IDET);          Check JXD>0;
     LAST = IQ(JX+IDET);          Check LAST>0;
     JDU  = LQ(JD-3);
     IF JDU<=0
     {  CALL UHTOC(IQ(JXD-4),4,CDID,4);
        IF CDID=='DIGI' { CALL GPDIGI(CS,CD) } else { Call GPHITS(CS,CD) }
        Next;
     }
     " otherwise this are hits(SJHD) or new digits(SJDX) "
     NW = IQ(JD+1)+IQ(JD+2*X+1)+1;   Check Nw>0;
     " volumes "  Nvb = Q(JDU+6);  Mv = Min(Nvb,15);  Ip0 = 12+5*Mv;
     " all hits " Nha = Q(JDU+2);  Md = Min(Nha,20);  Ip1 = Ip0+10*Md+2;
*
     <W> T,Cd,Cs;
     (/' ====>',A6,' IN DETECTOR ** ',A4,' ** OF SET ** ',A4,' ** <===='/);
     Cbuf=' '                                   "  print header line ";
     WRITE(CBUF,'(1x,A5,6H TRACK,15(1x,A4))')  T,(IQ(JD+2*I+9),i=1,Mv);
     WRITE(CBUF(Ip0+1:),'(20(6x,A4))') (ACFROMR(Q(JDU+10*I+1)),i=1,Md);
     <W>  (CBUF(i:i),i=1,Ip1);     (122A1/(12x,110A1));
     IDIG=0;
     Do ii=1,LAST,NW
     {  jj=JXD+ii; IDIG+=1; LTRA=JBYT(IQ(jj),1,16);
        Call  AGGETDIG (Jd,jj,NBV,DIGI);
        WRITE(CBUF,        '(2i6,15i5)')     IDIG,LTRA,(NBV(i),i=1,Mv)
        WRITE(CBUF(IP0+1:),'(2x,1P,20G10.3)')         (DIGI(i),i=1,Md)
        <W>  (CBUF(i:i),i=1,Ip1);  (122A1/(12x,110A1));
     }
 } }
   END
 
 
+DECK,agdlink,T=geant.
*CMZ :  1.30/00 18/11/96  12.59.52  by  Pavel Nevski
*CMZU:  1.00/01 22/12/95  21.09.57  by  Pavel Nevski
*CMZ :  1.00/00 08/11/95  00.05.48  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/08/95
**********************************************************************
            subroutine  A G D L I N K (Module,Bank,Link,LK)
*            Register a new link for dynamic bank access             *
*  keep them names now in a common, but can be an internal array too *
**********************************************************************
+CDE,TYPING,GCBANK,GCFLAG,AGCLINK.
Character         Module*(*),Bank*(*),Cbank*8
Integer           NumLin,LinkName,Link,Lk,Key(2),LENOCC
Common /AGCDLINK/ NumLin,LinkName(2,NaLinkMax)
 
If Link<0  " allocate a new secured link "
{  Cbank=Bank(1:lenocc(Bank))//module;  Call UCTOH(CBank,Key,4,8)
   If (%Nlink==0) call MZLINK(IxCONS,'AGCLINK',%Link,%Link,%Link(NaLinkMax))
   Do Link=1,NumLin
   {  If (Key(1)==LinkName(1,link) & Key(2)==LinkName(2,link)) goto :fnd:; }
 
   If NumLin>=NaLinkMax
   {  Print *,'AGDLINK fatal error: NO more free links left for bank ',Bank;
      Link=NaLinkMax; Return
   }
   NumLin+=1; %NLink=NumLin; Link=NumLin; Call Ucopy(Key,LinkName(1,link),2)
   If (IDEBUG>0) Print *,'AGDLINK: new link for bank ',bank,' is ',link
}
:fnd: If (Link>=0)  %LINK(link)=Lk
End
 
 
+DECK,agdform,T=geant.
*CMZ :          13/03/98  22.56.27  by  Pavel Nevski
*CMZ :  1.30/00 01/07/96  15.35.02  by  Pavel Nevski
*CMZ :  1.00/00 07/09/95  13.27.40  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/08/95
*************************************************************************
        Subroutine   A g D F O R M (Names,map,LL1,LL,Cformo,Cforma)
*                    encode bank format for zebra                       *
*   Both new (with 2 system words) and old (only users words) formats   *
*   PN,29-06-96: Make Cform different from Cformo due to AIX problem    *
*************************************************************************
Implicit      NONE
Integer       LL1,LL,map(2,LL1),i,j,k,L,N,NN,Ls
Character     Names(LL1)*(*),Cformo*80,Cforma*80,Cform*80,cf*8,T*1,S*1
Logical       NoTail/.true./
*
*                   count the total mapped bank length
Cformo='-F'; n=0; do i=1,LL1
{  k=1;  if (map(1,i)>0 & map(2,i)>0) k=map(1,i)*map(2,i);  n+=k; }
 
*          for 'old' format n should be the same as LL, the rest is a header
if  n==LL { T=' '; nn=0; }   else if  n+2=LL   { T='F'; nn=2; }
else      { print *,' AgDFORM error detected: N,L=',n,LL,LL1;
            do i=1,LL1 { print *,' i,map =',i,map(1,i),map(2,i),' ',names(i) }
            Return
          }
*
Cform='/';  L=1;
do i=1,LL1+1
{  If i<=LL1
   {  k=1;  if (map(1,i)>0 & map(2,i)>0) k=map(1,i)*map(2,i);
      S=Names(i); If (S!='I' & S!='H') S='F';  If S==T { nn+=k; Next; }
   }
   if T!=' '                   " write previous format element "
   {  L+=1;  write(cf,'(i8)') nn;  Ls=L+1;
      If L>70 { print *,' AgDFORM error: format too long for ',names; break;}
      do j=1,8 { if Cf(j:j)!=' ' { L+=1; Cform(L:L)=Cf(j:j) } }
                                   L+=1; Cform(L:L)=T;
   }  nn=k; T=S;
}
*
   if NoTail & Ls>3 { cformo=cform; cform(Ls:)='-'//T; cforma=cform(3:Ls+1) }
   else             { cforma=cform; cform(Ls:)='-'//T; cformo=cform(3:Ls+1) }
   " print *,' cformo,Ls = ',cformo(1:20),Ls "
*
end
 
 
+DECK,agdtit,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 14/08/95  03.36.26  by  Pavel Nevski
*-- Author :    Pavel Nevski   14/08/95
************************************************************************
                Subroutine    A g D T I T (MTitle,Tshort)
*      make reasonable title cut by rejecting some trivial words       *
************************************************************************
  Implicit      none
  Character*(*) MTitle,Tshort
  Integer       Lenocc,Ntriv,i,j,k,is
  Parameter     (Ntriv=11)
  Character*12  word,trivial(Ntriv)
  Data          Trivial/' ','THIS','IS','THE','DESCRIPTION','OF','A',
                        'GEOMETRY','DIGITISATION','DIGITIZATION','ROUTINE'/
*
    k=1; :syntax: Do i=1,Lenocc(MTitle)                  " skip trivial words "
    {  is=k;  If MTitle(i:i)==' '
       {  word=Mtitle(k:i);  k=i+1
          do j=1,Ntriv { If (word=trivial(j)) next :syntax:; };  Break
    }  }
    Tshort=MTitle(is:)
end
 
 
+DECK,agauto,T=geant.
*CMZ :  1.00/00 27/08/95  20.18.55  by  Pavel Nevski
*-- Author :    Pavel Nevski   27/08/95
***************************************************************************
                SUBROUTINE    A G A U T O  (IAUTO)
* Description - Interactive GEANT fails to do it now, temporary fix       *
***************************************************************************
+cde,typing,gctrak.
     Integer  Iauto
     print *,' igauto was=',igauto,',  set to ',Iauto
     Igauto=Iauto
end
 
+DECK,agdump,T=geant.
*CMZ :  1.30/00 24/03/96  21.59.47  by  Pavel Nevski
*CMZU:  1.00/01 21/01/96  20.18.19  by  Sasha Vanyashin
*CMZ :  1.00/00 24/11/95  00.28.56  by  Pavel Nevski
*-- Author :    Pavel Nevski   20/11/95
***************************************************************************
*                                                                         *
            Subroutine   A G D U M P (CpathI,NUM,Chopt)
*                                                                         *
* Description: Given a path, dump the whole structure below it with DZDOC *
*      NUM   :  If NUM(1) is zero, array of 1s is assumed                 *
*      Chopt : F - write output in a file with the name of the bank(.sgml)*
*            : C - dump values only (to be read by another program)       *
*            : U - dump also undocumented banks, otherwise they are skept *
*            : 1 - skip banks longer then 1000 words                      *
*            : S - SGML format                                            *
*            : H - HGML format                                            *
***************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,QUEST,RbBank.
  INTEGER    LENOCC,INDEX,IL(15),LK(15),Num(15),Nun(15)/15*1/,
             L,I,J,K/0/,Luu/6/,MOQUEQ/11/,Ierr/0/
  Character  CpathI*(*),Cpath*80,Chopt*(*),Chtop*8,Cbank*4,
             Ctop*4,Bank*8,Cold*8,Chop*4,Cfile*4
  Logical    Opnd
*
  INQUIRE (FILE='detm.rz',opened=opnd)
  If .not.opnd
  {  CALL RZOPEN(61,CHTOP,'detm.rz','UWX',256,Ierr)
     CALL RZFILE(61,CHTOP,' ')
  }
*                  convert to capitals
L=Lenocc(CpathI);  Cpath=CpathI(1:L);  Call CLTOU(CPATH(1:L))
*
If Num(1)>0 { Call ReBANK(Cpath,Num,0,L,J) }
else        { Call ReBANK(Cpath,Nun,0,L,J) }
Check L>0;  J=1;  Cold=' ';  Luu=Lout;
If Index(Chopt,'F')!=0
{  Luu=62;  Call UHTOC(IQ(L-4),4,Cfile,4)
   Open(Luu,File=Cfile//'.sgml',STATUS= 'UNKNOWN')
}
*
Loop
{   If L>0
    {  If LQ(L+1)<=0  { Ctop='NONE' }
       else           { Call UHTOC(IQ(LQ(L+1)-4),4,CTOP,4) }
       Call UHTOC(IQ(L-4),4,CBank,4);   Bank=Cbank//Ctop;
      *                                    print bank header
       Chop='PRZ'
       If (Index(Chopt,'H')!=0) Chop='PRZH'
       If (Index(Chopt,'S')!=0) Chop='PRZS'
       If Cold != bank                   " dump new bank header "
       {  IQUEST(MOQUEQ)=1; Call DzDOCO(Luu,Bank,Chop); IERR=IQUEST(MOQUEQ) }
      *                                    print the bank itself
       If (Index(Chopt,'C')==0) { Chop=' ' } else { Chop='C' }
       If ((Ierr==0|Index(Chopt,'U')>0) & (Index(Chopt,'1')==0|IQ(L-1)<1000))_
          Call DzDDOC(IrbDiv,L,Bank,Chop,1,IQ(L-1),Luu,'    ',K)
       Lk(j)=L;  IL(j)=0;  Cold=Bank;
    }
*    now navigate in the structure - first through links, then to next bank
    If IL(j)<IQ(LK(j)-2)  { IL(j)+=1; L=LQ(LK(j)-IL(j));  If (L >0) j+=1; }
    else   " brothers "   { If (j==1) Break; L=LQ(LK(j)); If (L<=0) j-=1; }
}
If Index(Chopt,'F')!=0
{ Close (Luu);  If (Index(Chopt,'H')!=0)
  {  L=Lenocc(CPath);  J=0;  Ctop='NONE'
     do i=1,L-14  { If (CPath(i:i)='/') J=i }
     If (J>0) Ctop=CPath(J+1:J+4)
     Open (Luu,  File=Cfile//'.sgml', STATUS= 'UNKNOWN')
     Call DZE2HT(Luu,Luu+1,3,Ctop)
     close (Luu)
} }
END
 
 
+DECK,agexist,T=geant. --------------------------------------------------
*CMZ :  1.30/00 12/02/96  15.17.30  by  Pavel Nevski
*-- Author :    Sasha Rozanov  06/02/96
**********************************************************************
*                                                                    *
                    Function   A g E X I S T (Ctest)
*                                                                    *
* Description: check if a GEANT volume exist                         *
**********************************************************************
+CDE,TYPING,GCBANK,GCNUM.
  Integer      AgEXIST
  Character*4  Ctest
*
  Call GLOOK  (Ctest,IQ(JVOLUM+1),IQ(JVOLUM-1),AgEXIST)
*
  END
 
 
+deck,AGPMATER,T=geant.
*CMZ :          13/07/97  23.26.30  by  Pavel Nevski
*CMZ :  1.30/00 05/08/96  11.35.22  by  Pavel Nevski
*-- Author :     Pavel Nevski
******************************************************************************
                 subroutine   A g P M A T E R (a,b)
******************************************************************************
   Implicit  none
   Real      ARGUM,HI,HIJ,a,b,x,y,s0,s1,s2,ax,bx,ay,by,aa,bb
   integer   id,jd,kind,ix,iy,nx,ny,nwt,loc/0/
   character tit*100
*
aa=ARGUM(a);  bb=ARGUM(b)
do Id=3000,4000,1000
{  Do Jd=1,7,2
   {  Call  HKIND (ID+jd,KIND,' ')
      If (Kind==1)  Call HOPERA(ID+jd,'/',ID,ID+2,1.,1.)
      If  Kind==2
      {  Call  Hgive (ID+jd,  tit,nx,ax,bx,ny,ay,by,nwt,loc)
         Call  Hbook1(ID+jd+1,tit,nx,ax,bx,0)
         do ix=1,nx
         {  x=ax+(ix-0.5)*(bx-ax)/nx;    {s0,s1,s2}=0;   s0+=HI(ID,ix)
            do iy=0,ny+1
            { y=ay+(iy-0.5)*(by-ay)/ny;
              check aa<=y&y<=bb; s1+=HIJ(ID+jd,ix,iy);
            }
            if (s0>0) call Hfill (ID+jd+1,x,y,s1/s0)
      }  }
      if (1<=Kind&Kind<=2) call HPLOT(ID+jd+1,' ',0,0)
}  }
*
   end
+DECK,agsmater,T=geant. -------------------------------------------------------
*CMZ :          29/07/97  16.38.30  by  Pavel Nevski
*CMZ :  1.30/00 10/02/97  15.01.26  by  Unknown
*-- Author :    Alexandre Rozanov 02.04.95
******************************************************************************
*                                                                            *
                      SUBROUTINE   A g S M A T E R
*                                                                            *
*  Description:  store material distribution while processing geant step     *
*                again a temporary solution before something more general    *
******************************************************************************
+CDE,TYPING,GCONST,GCUNIT,GCFLAG,GCKING,GCKINE,GCTRAK,GCMATE,GCNUM
    REAL               ALRADL,ALABSL
    COMMON /AMATERIAL/ ALRADL,ALABSL
*
      REAL      ptot,eta,x0,R,Za,phi,Vmod,AL
      Real      ax,bx,ay,by
      integer   nx,ny,nwt,loc/0/
      character tit*100
      logical   First/.true./
      save      tit,nx,ax,bx,ny,ay,by,nwt,loc,eta,phi
*
*    should be called for geantino run
      if (First) Call Hgive(3000,tit,nx,ax,bx,ny,ay,by,nwt,loc)
      First=.false.
      If (loc>0) Then
         If Nstep==0
         {  ptot = vmod(pvert,3);    phi  = atan2(pvert(2),pvert(1));
            eta  = -10;  If (ptot>0) eta  = -log(tan(acos(pvert(3)/ptot)/2))
            if (ax>=0) eta=abs(eta); ALRADL=0; ALABSL=0;
            call hfill(3000,eta,1,1.); call hfill(4000,phi,1,1.)
            call hfill(5000,eta,phi,1.)
         }
         R  = vmod(Vect,2);     Za = abs(vect(3))
         x0 = step/radl;        AL = step/AbsL
*
         if Ntmult==1 & NMAT!=15
         {  ALRADL+= x0; ALABSL+= AL;
            call hfill(3001,eta,R,x0);   call hfill(3003,eta,R,AL);
            call hfill(4001,phi,R,x0);   call hfill(4003,phi,R,AL)
* slices in z possible - never used until now.
            call hfill(3005,eta,Za,x0);  call hfill(4005,phi,Za,x0)
            call hfill(3007,eta,Za,AL);  call hfill(4007,phi,Za,AL)
* I dont remember what this was useful for - keep it as spare for a while
            call hfill(5001,eta,phi,x0); call hfill(5003,eta,phi,AL);
         }
      endif
 END
 
 
+DECK,agcheck,T=geant.
*CMZ :  1.30/00 17/04/97  17.28.45  by  Pavel Nevski
*-- Author :    Pavel Nevski   16/04/96
***************************************************************************
*                                                                         *
      SUBROUTINE   A G C H E C K
*
* description: closing of the geometry sometime is not done properly      *
*              due to users faults - try to fix it if posssible           *
***************************************************************************
+CDE,GCBANK,GCUNIT,GCFLAG.
      Integer      Iflag/0/,JNAME/0/
*
      Iflag=0;   If (JNAME==0) CALL UCTOH('GPAR',JNAME,4,4)
      If   JGPAR<=0 | JGPAR>=NZEBRA    {  Iflag=1  }
      else IF IQ(JGPAR-1)<=0           {  Iflag=2  }
      else If IQ(JGPAR-3)!=IQ(JGPAR-1) {  Iflag=3  }
      else If IQ(JGPAR-4)!=JNAME       {  Iflag=4  }
*
      If Iflag>=1
      {   <W> Iflag,Jgpar;  (' AGCHECK: GPAR error',i3,i9,', doing GGCLOS')
         CALL GGCLOS
      }
     END
 
 
+DECK,AgZINI,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 17/04/97  16.14.18  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
***************************************************************************
*                                                                         *
                Subroutine   A g Z I N I
*                                                                         *
***************************************************************************
+CDE,TYPING,GCBANK,SCLINK.
   Integer NLM/20/
*
   Call MZLINK (IxSTOR,'/SCLINK/',LKSLUG,LKSLUG(NSLINK),LKSLUG)
   CALL MZBOOK (IxCONS, JGPAR, JGPAR, 1,'GPAR', NLM,0,NLM, 2,0)
   CALL MZBOOK (IxCONS, JGPAR2,JGPAR2,1,'GPA2', NLM,0,NLM, 2,0)
*
   END
 
+DECK,gfdig1,T=geant.
*CMZ :  1.00/00 21/02/95  01.18.39  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/01/95
**********************************************************************
*                                                                    *
                     subroutine   G F D I G 1                        _
         (IUSET,IUDET,NTDIM,NVS, LTRA,NTRA,NBV,KDIGI,Iw,Iacce)
*                                                                    *
*      Returns the next digitisation for the physical volume, spe-   *
*      cified by NVS list with generic volume/set name IUDET/IUSET   *
* INPUT:                                                             *
* IUSET,IUDET - user set/detector identifiers (CHAR*4)               *
* NTDIM       Max. number of associated tracks to return             *
* NVS         array that contains the path to the detector volume    *
* OUTPUT:                                                            *
* LTRA        array that get the list of tracks                      *
*             which have produced this digitalisation                *
* NTRA        total number of contributed tracks                     *
* NBV         the list of volume numbers which identify              *
*             the physical volume                                    *
* KDIGI       array that get the digitalisation elements             *
* ====>  User should take care of NVS,NVB,KDIGI real dimesions !     *
**********************************************************************
Replace[;#?;] With [; IF #1 {" Take next word " K=1; Nk+=1; } ]   ;
+CDE,GCBANK.
  CHARACTER*4 IUSET,IUDET;
  Integer   NVS(1),NBV(1),KDIGI(1),LTRA(NTDIM),NTDIM,JBYT,
            Iset,Idet,Js,Jd,Jdi,Jddi,Jdid,ILAST,Nv,Nd,Kd,
            I,Iw,Io,Iv,Id,NWDI,NTRA,K,Nk,Nb,Jv,It,Iacce;
  COMMON    /GFDIGLI/  JS,JD,JDI,JDDI,JDID;
  Save      ISET,IDET,ILAST,NV,ND,IO;
  LOGICAL   First/.TRUE./;
                           * * *
IF First { First=.FALSE.; Call MZLINK(IXSTOR,'GFDIGLI',JS,JS,JDID); }
IF Iw<=0
{  "      Find if selected set and detector exist    "      Check JDIGI>0;
   Call GLOOK(IUSET,IQ(JSET+1),IQ(JSET-1),ISET);            Check Iset>0;
   JS   = LQ(JSET-ISET);                                    Check Js>0;
   JDI  = LQ(JDIGI-ISET);                                   Check JDI>0;
   Call GLOOK(IUDET,IQ(JS + 1),IQ(JS - 1),IDET);            Check Idet>0;
   JDID = LQ(JDI-IDET);                                     Check JDID>0;
   ILAST= IQ(JDI+IDET);                                     Check ILAST>0;
   JD=LQ(JS-IDET);  JDDI=LQ(JD-2);  NV=IQ(JD+2);  ND=IQ(JD+6);
   Iw=1; Io=0;
}
"                 Loop Over remaining digits                         "
NWDI=0;
for I=Iw  to  ILAST  by  NWDI
{  NWDI=IQ(JDID+I);  If (NWDI<=0 | I>=ILAST) Break;
   If (I=Io & Iacce=Jdid+Io) Next;
   NTRA=JBYT(IQ(JDID+I+1),1,16)+1;  Nk=2+NTRA/2; K=1; Nb=0;
   "   Select volume (tracks are not selected)   "
   Do Iv=1,NV
   {  Nb=IQ(JD+2*Iv+10);
      IF Nb>0  { K+Nb>33 ?; Jv=JBYT(IQ(JDID+I+Nk),K,Nb); K+=Nb;}
      ELSE     { K>1     ?; Jv=IQ(JDID+I+Nk);            Nk+=1;}
      IF (0<NVS(Iv)&NVS(Iv)#JV) GOTO :E:;           NBV(iv)=JV;
   }  Nb>0 ?;
   "      Now fetch unpacked digits and track numbers   "
   Do Id=1,ND
   {  Nb=IQ(JDDI+2*Id);
      IF Nb>0  { K+Nb>33 ?; Kd=JBYT(IQ(JDID+I+Nk),K,Nb); K+=Nb;}
      ELSE     { K>1     ?; Kd=IQ(JDID+I+Nk);            Nk+=1;}
                                                  Kdigi(Id)=Kd;
   }
   "             Get track numbers                    "
   Nk=1;  K=17;  Nb=16;
   do It=1,min (NTRA,NTdim)
   {   K+Nb>33 ?;  LTRA(It)=JBYT(IQ(JDID+I+Nk),K,Nb); K+=Nb;}
   {Iw,Io}=I;      Iacce=JDID+I;  Return;      :E:
}   Iw=0;
END;
 
 
+DECK,agsking,T=geant.
*CMZ :  1.30/00 03/05/97  16.11.50  by  Pavel Nevski
*-- Author :    Pavel Nevski  01/02/97
****************************************************************************
*                                                                          *
                subroutine   A g S K I N G
*                                                                          *
* Description: Save a stack track in KINE bank, before it produces a hit   *
* Too late to get anything from stack, all should be extracted in GLTRAC   *
*                                                                          *
****************************************************************************
+CDE,typing,GCBANK,GCFLAG,GCSTAK,GCUNIT,GCKINE,GCNUM,GCTMED.
Integer  i,L,Ivn,Itn,IPRIN,MECATO,ITRO
Real     TOFO,Ubuf
COMMON   /GCKINE_CONT/ ITRO,TOFO,MECATO
*
Check Istak>0 & Isvol=1; Iprin=Idebug
 
* first hit by this particle, save it
   Do IVN=NVERTX,1,-1
   { L=LQ(JVERTX-IVN);     IF "generator vertices" (Q(5+L)<=0) Break;
     check Q(4+L)==TOFO    & Q(5+L)==ITRA    & Q(6+L)==Mecato
     check Q(1+L)==Vert(1) & Q(2+L)==Vert(2) & Q(3+L)==Vert(3)
     go to :track:
   }
   Call GsVERT (Vert,ITRA,0,Ubuf,0,IVN)
   If IVN<=0
   { <w> ITRA,MECATO; (' AgGSKING cannot set Vertex for ',2i8/,
         ' ****** event simulation abandoned ******');  IEOTRI=1; RETURN
   }
   * Correct TOF (GsVERT takes it from TOFG of /GCTRAK/), save History
   L=LQ(JVERTX-IVN);  Q(4+L)=TOFO;  Q(6+L)=Mecato
*
   :track: Call GsKINE (Pvert, Ipart, IVN, Ubuf, 0, ITN)
   prin4 ITRA,Ivert,(vert(i),i=1,3),Itn,Ivn,Mecato
   (' AgSKING:  T/V=',2i4,'  v=',3f9.3,'  t/v=',2i4,' Mecato=',i8)
   * Ivert is set in GLTRAC only for KINE entries, not for any Jstak
   * Ivert should still remains primary numbering and cant be used
   Istak=0;  ITRA=Itn;  " Bad: Ivert=Ivn "
 
end
 
 
+DECK,AgSsecond,T=geant.
*CMZ :  1.30/00 05/05/97  01.05.56  by  Pavel Nevski
*-- Author :    Pavel Nevski   02/04/97
****************************************************************************
       Subroutine    A g S S E C O N D
*                                                                          *
* Description:  default solution is to put secondaries onto JSTAK only     *
*   NA49:  descendents of tracks from stack go into stack                  *
*          in DENSE MEDIA:  write all vertices of showers in NEW media,    *
*          ie check medium at point origin of parent track and             *
*          if the same as current medium, do not write out vertex          *
****************************************************************************
+CDE,typing,GCBANK,GCTMED,GCVOLU,GCTRAK,GCKINE,GCKING,AGCKINE.
       CHARACTER    Cmedium*20
       EQUIVALENCE (Cmedium,NATMED)
       Integer      LgKINE, i, j, IV, IB, IT
*                   Med_Vertex, Med_Current
*
       If ( flag_secondaries  .lt.  2 )    Return
       If ( Ngkine.le.0.or.Istak.gt.0 )    Return
       IV = Q(6+LgKINE(J,ITRA))            ! production vertex
       IB = Q(5+LQ(JVERTX-IV))             ! beam   - geant parent
       IT = Q(6+LQ(JVERTX-IV))             ! target - medium & process
*      If (IB!=0)                          Return
       If ( Cmedium(6:10) .ne. 'DENSE')    Return
*      call GTMEDI( vert, Med_Vertex  )
*      call GTMEDI( vect, Med_Current )
*      If ( Med_Vertex.eq.Med_Current )    Return
       If (abs(IT)/100==LVOLUM(NLEVEL))    Return
*
***      put secondaries into both JSTAK and JVERTX/JKINE structures
*
       do I=1,NGKINE
          IFLGK(I) = 1
       enddo
 
       END
 
+DECK,agusecond,T=geant.
*CMZ :          16/07/97  22.01.24  by  Pavel Nevski
*CMZ :  1.30/00 03/05/97  16.15.42  by  Pavel Nevski
*-- Author :    Pavel Nevski
************************************************************************
*                                                                      *
                SUBROUTINE   A g U S E C O N D
*                                                                      *
* Description :                                                        *
*     Set users conditions for products saving into the KINE bank      *
*     It gets arguments from DETP  TRAC  datacard:                     *
*          Mechanism, Rmax, Zmax, Eparent, Esecondary                  *
************************************************************************
+CDE,TYPING,GCUNIT,GCKINE,GCKING,GCTRAK,GCFLAG.
*
      INTEGER      AGPFLAG,N,I,J,IPRIN/0/,NPAR/0/,ISEL/0/,IdEvt0/-1/,IPAR(21)
      LOGICAL      FIRST/.true./
      Real         VMOD,PAR(21)
      Save         PAR
      Character*4  Cproc
      Equivalence  (PAR,IPAR)
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF (IdEvt0 != IdEvt)  THEN
          Idevt0  = Idevt
          IPRIN=AGPFLAG('TRAC','SIMU')
          CALL ASLGETBA('TRAC','DETP',21,NPAR,PAR)
          If (Iprin>=Idevt & Idebug>0)  <w> (PAR(i),i=2,NPAR)
             (' SECONDARY SAVING : process   Rmax   Zmax    Eparent    Eprod',
                                   /(20x,a4,f10.1,f7.1,2f10.3))
          NPAR=((NPAR-1)/5)*5;  Isel=0
          Do N=1,NPAR,5
             Call UHTOC(PAR(N+1),4,CPROC,4)
             If (Cproc=='*' | Cproc=='ALL') Isel=1
          enddo
      ENDIF
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CHECK ISTAK==0
* Check Mechanism, R,Z,E0 and Ei
:Mech: DO N=1,NPAR,5
          Check GETOT>=PAR(N+4)
          Check ABS(VECT(3))<PAR(N+3)
          Check VMOD(VECT,2)<PAR(N+2)
          DO I=1,NGKINE
             IF (GKIN(4,I)<PAR(N+5)) Next :mech:
          enddo
 
          DO I=max(1,NMEC-1),NMEC
             Check (NAMEC(LMEC(I))==IPAR(N+1) | Isel>0)
             Prin5   NGKINE,(VECT(J),J=1,3),GETOT,(NAMEC(LMEC(J)),J=1,NMEC)
             (' AgUSECOND: SAVED',I3,' products at',4F10.3,' of',20(1X,A4))
             DO J = 1,NGKINE
                IFLGK(J) = 1
             ENDDO
             break :Mech:
          enddo
       enddo
*
      END
 
 
+DECK,agfhita,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.32.49  by  Pavel Nevski
*-- Author : Pavel Nevski
*************************************************************************
*                                                                       *
             Function     A g F H I T a (Cset,Cdet)
*                                                                       *
*  Description: this routine does not set DIGI - this allows add digits *
*************************************************************************
+CDE,TYPING,GCUNIT,AGCRDIG,AGCBUFF.
 Character*(*)  Cdet,Cset
 Integer        AgFHITa,AgFDIG0,AgPFLAG,I,J,L,ok/0/
*
   AgFHITa =-1;  Cs=Cset(1:3)//'H';  Cd=Cdet
   IPRIN = AgPFLAG (Cset,'DIGI');    Check Iprin>=0
   If (IPRIN>=5) CALL AGPDIGI (Cs,Cdet)
   AgfHITa = AgFDIG0 (Cs,Cdet)
*
****** if (AgFHIT0==ok)   I = AgSDIG0 (Cset(1:3)//'D',Cdet) **********
   If Iprin>=15
   {  <w>; (' *** AGFHITa buffer  ***');  j=1; while Ibuf(j)>0
      {  L=IBUF(j); if (L<=0) Break; <w> j,L,(Ibuf(j+i),i=1,L);
         (' adr=',i6,' L=',i4,2x,20i5/(20x,20i5));      j+=L+1;
   }  }
   END
 
 
+DECK,agkeeps,T=geant.
*CMZ :          16/03/98  15.21.26  by  Pavel Nevski
*-- Author :    Pavel Nevski   25/11/97
*************************************************************************
*                                                                       *
                subroutine  A G K E E P S (Request,Cdest)
*                                                                       *
* Description:                                                          *
* produce include files and update the documentation database           *
* IWr=0 - global include file, 1 - subsystem files, 2 - separate structs*
* Kw=0  - no prefix in keep name, not used                              *
*************************************************************************
+include,TYPING,GCBANK,SCLINK,GCUNIT,GCFLAG,AGCDOCL.
     integer     Iprin,i,i1,i2,il,id,ic,jl,L,L1,L2,Iwr,Kw/1/,Lu,Idl,Key(2)
     Integer     LENOCC,INDEX,STafTab
     Character*8 Sname, Bname, Ckey
     Character*4 Csys, Cban
     Character   Request*(*),Cdest*(*), Table*10
 
     character      ccc*12000
     common /agcstaftab/ ccc
 
     Call Agsbegm('DOCUM',Iprin); Call AsbDETE('DOCU',Id); Iprin=Idebug
 
     Idl = 0
     if (Index(Cdest,'idl')>0) Idl=1
     if (Index(Cdest,'dui')>0) Idl=2
 
*  request a la UNIX: sys/bank
     Iwr = 0
     i2=lenocc(request);    i1=index(request,'/');  if (i1<=0) i1=i2+1
     Csys='*'; if (i1>2)    Csys=request(1:i1-1);   if (i2>0)  Iwr=1
     Cban='*'; if (i1<i2) { Cban=request(i1+1:i2);             Iwr=2 }
     prin2 csys,cban,i1,i2,iwr,idl;(' in agkeep csys=',a,' cban=',a,' iwr=',4i2)
 
     i1=Lenocc(Csys);       Call CUTOL(Csys);
     i2=Lenocc(Cban);       Call CUTOL(Cban);
*
     If (LdArea(1)=0) call MZLINT(IxCONS,'AGCDOCL',LDarea,L1Doc,Lpar)
     Check LKDETM>0 & Id>0;  L=LQ(LQ(LKDETM-Id)-1); Check L>0;
     CALL UHTOC(IQ(L-5),4,Sname,8);
     if (Sname=='NONEDETM' | Sname=='ENONDETM')  L1doc=L;
     prin4 L1Doc;  (' ==> got L1Doc  ',i10);     Check L1Doc>0;
 
     Lu  = 0
     call agdprina(Iprin,Lu,L1doc,0,Iwr,Kw,Idl)
 
     do il=1,IQ(L1doc-2)
        L1=LQ(L1doc-il); check L1>0;
        CALL UHTOC(IQ(L1-5),4,Sname,8); Call CUTOL(Sname)
        Check csys='*' | Sname(5:4+i1)==csys(1:i1)
 
        call agdprina(Iprin,Lu,L1,1,Iwr,Kw,Idl)
 
        do jl=1,IQ(L1-2)
           L2=LQ(L1-jl); check L2>0; ccc=' '
           CALL UHTOC(IQ(L2-5),4,Bname,8); Call CUTOL(Bname)
           Check cban='*' | Bname(5:4+i2)==cban(1:i2)
           call agdprina(Iprin,Lu,L2,2,Iwr,Kw,Idl)
 
           Table=Sname(5:8)//'_'//Bname(5:8); Call CUTOL(Table)
           if (idl==2) i=StafTab(%L(Cdest),%L(Table),%L(ccc),0,0)
 
           Key(1)=IQ(L2-4);  Key(2)=IQ(L2-5);  Call UHTOC(Key,4,Ckey,8)
           CALL aRZOUT(IXCONS,L2,CKey,IC,'SN')
        enddo
     enddo
     If (Lu>6) close (Lu)
     Call Agsendm
     end
 
 
*************************************************************************
*                                                                       *
              subroutine agdprina(Iprin,Lu,L,Lev,Iwr,Kw,Idl)
*                                                                       *
* Description: Produce a copiler readable include files for structures  *
* Decoding part is tough, for format details see 2.16 MZFORM, page 44:  *
* a Bank consists of 3 types of blocks (P=1-3 -> tit)                   *
* each of blocks contains sectors (crec<=ask(1-9))                      *
* A useful dd sector contains type.variable + comments                  *
* Routine produce or a def file, or an idl file, or struct in memory    *
*************************************************************************
+include,TYPING,GCBANK,SCLINK,GCUNIT,AGCDOCL,QUEST.
   Integer      INDEX,LENOCC,NwDESC,Nwhead,NwGEN,Nwlink,Nwdata,Idl,lu,nc,MM
   Integer      Lev,Iwr,Kw,Iprin,i,j,k,l,m,n,is,nd,Nw,iw,iv,i1,j1,P,nn(3)
   Integer      mask(9)/1,1024,16384,8192,9216,10240,15361,19456,17410/
   Character*2  ask (9)/'ba','au','ve','nd','nl','ns','up','io','dd'/
   character*1  Let,T,Sec(0:8)/'*','B','I','F','D','H','*','S','*'/
   character*6  tit (3)/'header','links','data'/
   character*80 Text,texto,Format,Header,Author,Create
   character*8  var,varo,dname,cn,type,typo
   character    crec*2,kname*16,blan*12/' '/
   character*4  Upper,Bname,Csys/' '/
   Equivalence  (text,var),(texto,varo)
 
   integer        nc
   character      ccc*24
   common /agcstaftab/ ccc(500)
 
   nc=0; check L>0;
   prin3 (IQ(L-i),i=1,5);(' ***** doc bank =',3i10,2x,2a5,' *****')
   call UHTOC(IQ(L-5),4,dname,8); prin5 dname;  (' dname  = ',a)
   call UHTOC(IQ(L+1),4,bname,4); prin5 bname;  (' bname  = ',a)
   NwDesc = IQ(L+2);              prin5 NwDesc; (' Nwdesc = ',i4)
   NwHead = IQ(L+3);              prin5 Nwhead; (' Nwhead = ',i4)
   NwGen  = IQ(L+11);             prin5 NwGen;  (' Nwgen  = ',i4)
   NwLink = IQ(L+12);             prin5 NwLink; (' Nwlink = ',i4)
   NwData = IQ(L+15);             prin5 NwData; (' Nwdata = ',i4)
   i=Nwhead+1;  Call Vzero(NN,3); P=1; Format='-F'; MM=0;
 
   while i<=Nwdesc+1
   {  if i>=Nwhead+Nwgen+Nwlink+1 {P=3} else if i>=Nwhead+Nwgen+1 {P=2}
      Let='H'; Text=' '; if i<NwDesc
      {  i1=i; Is=IQ(L+i1); Nw=is/16; i=i+Nw;
         Let=Sec(min(mod(Is,16),8));
      }  i=i+1;
 
      If let=='I' & Nw==3
      {  iw=IQ(L+i1+1);  Iv=IQ(L+i1+2);
         crec='un';   do k=1,9 { If (iw==mask(k)) crec=ask(k); }
         if (crec(1:1)=='n') { prin5 crec,iv; (' sector ',a4,i5);}
      }
      else If let='H' & i<=NwDesc+1
      {  j1=1; if (crec=='ba') j1=2;
         Call UHTOC(IQ(L+i1+j1),4,text,4*(Nw-j1+1));
         If  NN(P)==0  { Nd=0; Texto=' '; Prin3 tit(p); (' ---  ',a,'  ---') }
         if (P==3 & nn(p)>=mm)  call agreforma(format,mm,type,idl)
         NN(P)+=1;  Prin6 crec,p,NN(p),Nd,type,text(1:Lenocc(text));
         (' sector ',A4,':  NN(',i1,')=',i4,'  ND=',i3,' t=',a,' : ',a)
      }
      else  { prin6 i,let,Nw; (' unknown sector at ',i6,2x,a1,i8); crec='dd';}
 
      If (crec=='ba' & Let='H')  Header = text
      If (crec=='au' & Let='H')  Author = text
      If (crec=='ve' & Let='H')  Create = text
      If (crec=='up' & Let='H')  Upper  = text
      If (crec=='io' & Let='H')  Format = text
      check P==3 & Let='H' & crec='dd'
*
* ----------------  unpacking done, now output stuff --------------
*
      If NN(P)==1
      {  prin4 lev,bname; ('===>  starting lev,bname=',i3,2x,a,' <===');
*         if (Lev<=1) Csys='sys'
         kname=%L(csys)//'_'//%L(bname)
         if (Lev<=1) kname=%L(bname)//'sys'
         if (Idl==0) kname=%L(kname)//'.def'
         if (Idl>0 ) kname=%L(kname)//'.idl'
         call CUTOL (kname); J=index(kname,'.')
         if (Lev==1) Csys=bname
 
         if Lev==Iwr
         {
            If (Lu>6) CLose(lu);  Lu=1 " pseudo-output - in memory only"
            if (idl<=1)
            { lu=62;  prin2 kname; (' AgDocPrin: open file ',a)
              Open (Lu, file=%L(kname), STATUS= 'UNKNOWN')
         }  }
 
         if (Lu>0 & Idl==0)
         { if (Lev=0) output kname(:j),%L(create)
              ('+PATCH,',a/'*Created: ',a/,
               '*This file is automatically generated by AGI'/,
               '*--------- DO NOT EDIT THIS FILE -----------'/'*')
           if (Lev=1) output kname(:j),%L(header),%L(author),%L(create)
              ('+DECK,',a,' describes the ',a/'*Author : ',a/'*Created: ',a/'*')
           if (Lev=2) output kname(:j),%L(header),%L(author),%L(create),
                                                                  bname,header
              ('+KEEP,',a,' - ',a/'*Author : ',a/'*Created: ',a/'*'/,
               '  structure  ',A4,'    { " ',a42, ' " _ ')
         }
         if (Lu>0 & Idl==1)
         {  if (Lev==Iwr) output %L(kname),%L(header),%L(author),%L(create)
            ('/* File ',a,/'** '/'** Description: ',a/,
             '** Author     : ',a/'** Created    : ',a/,
             '** This file is automatically generated by AGI'/,
             '** --------- DO NOT EDIT THIS FILE -----------'/'*/')
            if (Lev==2) output kname(:j-1);  ('  struct  ',a,'   { ')
         }
         if (Lu>0 & Idl==2 & Lev==2)
         {  nc+=1; CCC(nc)=' struct '//kname(:j-1)//' { '; }
      }
*
      nd+=1; check Lev==2 & var!=varo & lu>0
*
      If varo!='  '
      {  if (varo=='- ') varo='system'
*        fit rigid stic format - no extra spaces allowed
         call CUTOL(varo);     N=Lenocc(varo)
         if (idl>0 & typo=='char') ND=4*ND
         write(CN,'(i6)') ND;  M=Lenocc(CN)
         do K=1,M { if (CN(K:K)!=' ') Break; }
 
         if Idl==0
         {  T=','; if (text==' ') T='}'
            if (ND==1) output typo,%L(varo),blan(N:),texto(9:),T
                    (4x,a4,1x,2a,' " ',a42,' " ',a)
            if (ND >1) output typo,%L(varo),CN(K:M),blan(M-K+N+3:),texto(9:),T
                    (4x,a4,1x,a,'(',a,')',a,' " ',a42,' " ',a)
            if (text==' ') output; ('*');
         }
         If Idl==1
         {  if (ND==1) output typo,%L(varo),blan(N:),texto(9:)
                    (4x,a5,1x,a,       ';',a,'/* ',a42,' */')
            if (ND >1) output typo,%L(varo),CN(K:M),blan(M-K+N+3:),texto(9:)
                    (4x,a5,1x,a,'[',a,'];',a,'/* ',a42,' */')
            if (text==' ') output; ('};');
         }
         If Idl==2
         {  NC+=1;
            if (ND==1) CCC(NC)='  '//typo//%L(varo)//'; '
            if (ND >1) CCC(NC)='  '//typo//%L(varo)//'['//CN(K:M)//']; '
            if (text==' ')  { NC+=1; CCC(NC)='}' }
         }
      }
      nd=0; Texto=Text; typo=type
   }
  end
 
 
****************************************************************************
  subroutine  agreforma (format,num,type,idl)
*                                                                          *
* Description: decode ZEBRA 'format' descriptor into a sequence of 'type's *
*              for format details see: 2.16 MZFORM, page 44                *
*              - num is the number of items already taken, should be saved *
*              - idl is an agi/c switch                                    *
****************************************************************************
 
  character   format*(*),type*8,List*14/'0123456789-IFH'/
  integer     Lenocc,idl,L,i,k,n,num,big/9999999/
 
     L=Lenocc(format);  if (num==0) i=0;  N=0;
     Do i=i+1,L
     { k=index(list,format(i:i))-1;  check k>=0
       if  k<=9  "digit"  { N=N*10+k; Next; }
       if  k=10  "tail"   { N=big;    Next; }
       num=num+max(1,N);  Break;
     }
     if (idl==0) { type ='real';  if (format(i:i)=='I') type='int';  }
     else        { type ='float'; if (format(i:i)=='I') type='long'; }
     if (format(i:i)=='H') type='char'
     end
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
+DECK,agphysi,T=geant.
*CMZ :          06/03/98  12.45.01  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/03/98
************************************************************************
*                                                                      *
                subroutine    A g P H Y S I
*                                                                      *
*  Description: make Cross-section calculations re-executable          *
*  Modified algorithm from GXPHYS. CKOV banks are not dropped          *
*                                                                      *
************************************************************************
+CDE,TYPING,GCBANK,GCCUTS,GCPHYS.
*    provide index access to geant mechanism
     Integer       MECA(5,13)
     EQUIVALENCE  (MECA,IPAIR)
 
     Integer i,j,jtm,jma
 
         IF JTMED>0               " Extracted From GXPHYS "
         {  DO I=1,IQ(JTMED-2)
            {  JTM=LQ(JTMED-I);  Check JTM>0
               IF IQ(JTM-2)==0 { CALL MZPUSH(IXCONS,JTM,10,0,'I');     Next;}
               * drop only MUEL and MUMU banks
               DO J=1,2 { IF(LQ(JTM-J)>0) CALL MZDROP(IXCONS,LQ(JTM-J),' ');}
            }
            " copy tracking cuts from standard to special media "
            CALL UCOPY(CUTGAM,Q(JTMED+1),10)
            " copy mecanism flags (pair..rayl) to special media "
            DO I=1,13 { Q(JTMED+10+I)=MECA(1,I) }
         }
         IF JMATE>0               " Extracted From GXPHYS "
         {  DO I=1,IQ(JMATE-2)
            {  JMA=LQ(JMATE-I); Check JMA>0
               DO J=1,IQ(JMA-2)
               {  IF (J==4 | J==5) Break " strange !"
                  IF (LQ(JMA-J)>0) CALL MZDROP(IXCONS,LQ(JMA-J),'L')
         }  }  }
         Call GPHYSI
     end
 
+DECK,agstrut,T=geant.
*CMZ :          16/03/98  15.02.52  by  Pavel Nevski
*-- Author :    Pavel Nevski   25/11/97
***************************************************************************
*                                                                         *
            Subroutine   A G S T R U T (Source,Destin)
*                                                                         *
* Description: Given a path, dump the whole structure below into STAF     *
*     request a la UNIX: sys/bank - very combersome for the moment :      *
*     'standard' path form is [/DETM/]sys..., * at the end means 'all'    *
*     RECB alternative form is /RECB/....bank*sys
*                                                                         *
***************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,AgCDOCL,RbBank,QUEST.
  INTEGER       LENOCC,StafTab,Iprin,Nun(15)/15*1/,
                I,J,L,K,M,N,Ia,Lc,Lp,Mj,LK(15),IL(15)
  Character     Cpath*80,Cdest*80,Csys*80,Table*10,Cbank*4
  Character*(*) Source,Destin
  EQUIVALENCE   (L,Lpar)
*
* reduce to the standard path and dest:
  Iprin=Idebug;         Cpath=Source;
  if (Cpath(1:1)!='/')  Cpath='/DETM/'//Source;
  Call CLTOU(Cpath);
 
  Cdest='/dui/Run'; if (Cpath(2:5)!='DETM') Cdest='/dui/Event';
  if (Lenocc(Destin)>0) Cdest='/dui/'//Destin;
 
* Csys - prefix for AgKeeps
  Lc=Lenocc(Cpath); n=Index(Cpath,'@');  Csys=' ';
  if (Cpath(1:6)=='/DETM/' & Lc>=10) Csys=Cpath(7:Lc)
  if (0<n&n<Lc)  { Csys=Cpath(n+1:Lc); Lc=n-1 }
  Mj=2; if (Lenocc(Csys)>0) { Call Agkeeps(Csys,Cdest); Mj=0; }
*
* Rebank path does not accept / or /* at the end, truncate:
  m=Index(Cpath(1:Lc),'*'); Lp=Lc;
  if (m>0) Lp=min(Lp,m-1);  if (Cpath(Lp:Lp)='/') { Lp-=1; m=-1 }
  Call ReBANK(Cpath(:Lp),Nun,0,L,Ia)
  Call UHTOC(IQ(L-4),4,CBank,4)
 
  prin2  %L(Csys),Cpath(:lp),Cbank,lc,n,m,mj,lp
  (' AGSTRUT decoded Csys,Cpath,Cbank=',3(1x,a),' lc,n,m,mj,lp=',6i5)
 
  if L<=0 { <w> %L(Cpath); (' AGSTRU: Data source ',a,' not found '); Return; }
*
*
J=1; Loop
{  If L>0
   {  Call UHTOC(IQ(L-4),4,CBank,4);
      if     J==MJ
      { Csys=Cbank; If (Csys!='DOCU') Call AGKEEPs(%L(Csys),%L(Cdest)) }
      elseif J> MJ & Csys!='DOCU'
      { Table=Csys(1:4)//'_'//Cbank;  Call CUTOL(Table);
        K=1; if (IQ(L-5)<0) K=-IQ(L-5)
        i=StafTab(%L(Cdest),%L(Table),'\000',K,IQ(L+1))
        prin2 %L(Cdest),%L(Table),i,k,(Q(L+i),i=1,3)
              (' StafTab:',2(1x,a),2i5,3F8.1)
        " specific bank requested " if (m==0 & Mj==0) Break;
      } Lk(j)=L;  IL(j)=0;
   }
*    now navigate in the structure - first through links, then to next bank
   If IL(j)<IQ(LK(j)-2)  { IL(j)+=1; L=LQ(LK(j)-IL(j));  If (L >0) j+=1; }
   else   " brothers "   { If (j==1) Break; L=LQ(LK(j)); If (L<=0) j-=1; }
}
END
 
+PATCH,ATCDES. ================================================================
*CMZ :  1.00/00 19/12/95  09.59.59  by  G. Poulard
+KEEP,agchadr.
*CMZ :          15/12/97  23.04.02  by  Pavel Nevski
*-- Author :    Pavel Nevski   15/12/97
* sequence to let hadronic package produce more then MXGKIN secondaries
*     geant  message - NDONE positive
*     guhadr message - NREST positive
*
      INTEGER          NDONE,NREST
      COMMON /AGCHADR/ NDONE,NREST
 
+KEEP,agcvers.
*CMZ :          05/11/97  17.07.44  by  Pavel Nevski
*-- Author :    Pavel Nevski   04/11/97
      COMMON /AGCVERS/IDATQQ,ITIMQQ,IVERSQ,VERSQQ,QFTITLCH
      INTEGER         IDATQQ,ITIMQQ,IVERSQ
      CHARACTER       VERSQQ*8,QFTITLCH*60
*     - - - - - - - - - - - - - - - - - - - -
+KEEP,agstcom,T=TEXT,If=INFO.
*CMZ :  1.30/00 28/04/97  14.31.37  by  Pavel Nevski
*-- Author :    Pavel Nevski   02/04/97
************************************************************************
gstar_event_input.inc		
gstar_evthead_ubuf.inc
gstar_vertex_ubuf.inc
gstar_track_ubuf.inc		
 
gstar_cfio.inc			
gstar_user_cards.inc		
gstar_geant_prim_vert.inc	
gstar_udecay.inc
gstar_decay_modes.inc
gstar_shower_tracks.inc
gstar_pid.inc			
 
==========================
>  gst/inc/eg_event_str_def.inc  is OBSOLETE
==========================
      STRUCTURE /eg_run_t/   !  Event generator run structure - OBSOLETE
        INTEGER*4   eg_number              ! event generator identification
        REAL*4      eg_version             ! version of event generator
        REAL*4      sqrts                  ! center of mass energy
        REAL*4      b_max                  ! maximal impact parameter
        INTEGER*4   proj_a                 ! projectile mass number
        INTEGER*4   proj_z                 ! projectile charge
        INTEGER*4   targ_a                 ! target mass number
        INTEGER*4   targ_z                 ! target charge
      END STRUCTURE
*
      STRUCTURE /eg_event_t/   !  Event generator event structure - OBSOLETE
        INTEGER*4   i_event                ! event number
        INTEGER*4   n_part_prot            ! participant protons
        INTEGER*4   n_part_neut            ! participant neutrons
        REAL*4      b_impact               ! impact parameter
        INTEGER*4   n_track                ! # tracks
        INTEGER*4   n_track                ! # tracks
        INTEGER*4   n_vertex               ! # vertices
        INTEGER*4   n_fs_track             ! # final state tracks
        INTEGER*4   n_not_fs_track         ! # non-final state tracks
        INTEGER*4   n_primary_vertex       ! # primary vertices
        INTEGER*4   n_fs_vertex            ! # non-final state vertices
        INTEGER*4   p_first_primary_vertex ! pointer to ll of primary vertices
        INTEGER*4   p_first_fs_vertex      ! pointer to ll of final state vert.
      END STRUCTURE
==========================
>  g2t/inc/eg_event_str_def.inc  <
==========================
     STRUCTURE /eg_run_t/ !  Event generator run structure
        INTEGER*4      generator              ! event generator identification
        CHARACTER*32   eg_name                ! event generator name
        REAL*4         eg_version             ! version of event generator
        INTEGER*4      eg_run                 ! generator run number
        INTEGER*4      eg_rndm(2)             ! generator random numbers
        REAL*4         sqrts                  ! center of mass energy
        INTEGER*4      is_minbias             ! minimum bias flag
        REAL*4         b_min                  ! minimum impact parameter
        REAL*4         b_max                  ! maximum impact parameter
        INTEGER*4      east_a                 ! projectile 1 mass number
        INTEGER*4      east_z                 ! projectile 1 charge
        INTEGER*4      west_a                 ! projectile 2 mass number
        INTEGER*4      west_z                 ! projectile 2 charge
        INTEGER*4      polarization_run(10)   ! to be defined
      END STRUCTURE
*
     STRUCTURE /eg_event_t/ !  Event generator event structure
        INTEGER*4   n_event                  ! eg event number
        REAL*4      b_impact                 ! actual impact parameter
        REAL*4      phi_impact               ! reaction plane
        INTEGER*4   event_type               ! trigger, minbias bkgd, cosmic, etc.
        INTEGER*4   polarization_evt(10)     ! to be defined
        INTEGER*4   n_part_prot_east         ! number of participant protons
        INTEGER*4   n_part_neut_east         ! number of participant neutrons
        INTEGER*4   n_part_prot_west         ! number of participant protons
        INTEGER*4   n_part_neut_west         ! number of participant neutrons
        INTEGER*4   n_track                  ! # tracks
        INTEGER*4   n_vertex                 ! # vertices
        INTEGER*4   n_fs_track               ! # final state tracks
        INTEGER*4   n_not_fs_track           ! # non-final state tracks
        INTEGER*4   n_primary_vertex         ! # primary vertices
        INTEGER*4   n_fs_vertex              ! # non-final state vertices
        INTEGER*4   p_first_primary_vertex   ! pointer to ll of primary vertices
        INTEGER*4   p_first_fs_vertex        ! pointer to ll of final state vert.
      END STRUCTURE
*
      STRUCTURE /eg_track_t/            !  Event generator track structure
        INTEGER*4   label                  ! event generator label
        INTEGER*4   eg_pid                 ! event generator id
        INTEGER*4   ge_pid                 ! GEANT id
        REAL*4      p(3)                   ! momentum
        INTEGER*4   p_start_vertex         ! pointer to start vertex
        INTEGER*4   p_stop_vertex          ! pointer to stop vertex
        INTEGER*4   p_parent_track         ! pointer to parent track
        INTEGER*4   p_next_fs_track        ! pointer to next final state track
        INTEGER*4   p_prev_fs_track        ! pointer to previous final state track
        INTEGER*4   p_next_not_fs_track    ! pointer to next non-fs track
        INTEGER*4   p_prev_not_fs_track    ! pointer to previous non-fs track
      END STRUCTURE
*
      STRUCTURE /eg_vertex_t/           !  Event generator vertex structure
        INTEGER*4   label                  ! event generator label
        INTEGER*4   i_eg_process           ! event generator production process
        REAL*4      x(3)                   ! space point
        REAL*4      t                      ! time coordinate
        INTEGER*4   n_fs_track             ! # final state daughter tracks
        INTEGER*4   n_not_fs_track         ! # non-final state daughter tracks
        INTEGER*4   p_parent_track         ! pointer to parent track
        INTEGER*4   p_first_fs_track       ! pointer to ll of final state tracks
        INTEGER*4   p_first_not_fs_track   ! pointer to ll of non-fs tracks
        INTEGER*4   p_next_primary_vertex  ! pointer to next primary vertex
        INTEGER*4   p_prev_primary_vertex  ! pointer to previous primary vertex
        INTEGER*4   p_next_fs_vertex       ! pointer to next final state vertex
        INTEGER*4   p_prev_fs_vertex       ! pointer to prev. final state vertex
      END STRUCTURE
*
===========================
>  gstar_event_input.inc  <
===========================
c
c*** Contains structures for event generator events
c
#include "eg_event_str_def.inc"
c
	record  /eg_run_t/ eg_run
	pointer (p_eg_run, eg_run)
	record  /eg_event_t/ eg_event
	pointer (p_eg_event, eg_event)
	record  /eg_track_t/ eg_track (1)
	pointer (p_eg_track, eg_track)
	record  /eg_vertex_t/ eg_vertex (1)
	pointer (p_eg_vertex, eg_vertex)
		
	logical start_new_event
	integer i_subevent
 
	common/event_input/
     &           p_eg_run
     &          ,p_eg_event
     &          ,p_eg_vertex
     &          ,p_eg_track
     &          ,start_new_event
     *          ,i_subevent
#ifdef AIX
      integer p_eg_run, p_eg_event, p_eg_vertex, p_eg_track
#endif
c-------------------------------------------------------------
c*** objects for controlling event input
 
	integer       input_format
     *               ,input_flag
     *               ,alt_input_flag
     *               ,p_mm_struct
	logical       input_file_ok
	logical       read_from_file
	character*256 input_filename
	character*256 alt_input_filename
 
	common /input_control/
     *          input_format
     *          ,input_flag
     *          ,alt_input_flag
     *          ,input_filename
     *          ,alt_input_filename
     *          ,input_file_ok
     *          ,read_from_file
     *          ,p_mm_struct
c
c*** flat phase space       structure/ phase_space_t/     ...
c*** momentum bin           structure/ momentum_bin_t/    ...
c
c*** controlling event output
 
        logical output_file_open
        common/output_control/  output_file_open
 
 
 
 
============================
>  gstar_evthead_ubuf.inc  <
============================
c
c*** contains defintions for run header user buffer
c
      structure /ubuf_event_t/
         character*80 author            ! run-related
         character*80 machine
         integer      date
         integer      time
         real         geant_version
         integer      ge_run
         integer      ge_rndm_run(2)
         integer      events_ordered
         integer      ge_rndm_evt(2)    ! event-related
         integer      n_event           !
         integer      cav(12)           ! geometry information
         integer      n_shtk_evt        ! event information
         integer      mx_shtk_itra      !
         integer      nw_shtk           !
         integer      p_first_eg_vertex ! pointers for event chunking
         integer      p_first_eg_track  !
         integer      equals_99999      ! test of length of structure
      end structure
      record /ubuf_event_t/   ubuf_event
      common /com_ubuf_event/ ubuf_event
      integer    nubuf_event
      parameter( nubuf_event = 68 )
 
 
 
> gstar_vertex_ubuf.inc
=======================
c
c*** contains vertex user buffer structure
c
      structure /vertex_ubuf/
         integer geant_mechanism
         integer geant_medium
         real    geant_volume
         real    geant_tof
         real    evgen_x(3)
         real    evgen_tof
         integer evgen_label
         integer evgen_process
         integer evgen_n_parent
         integer evgen_p_first_parent
         integer evgen_n_fs_track
         integer evgen_p_first_fs_track
         integer evgen_n_not_fs_track
         integer evgen_p_first_not_fs_track
         integer intermediate_vertex
         integer equals_99999
      end structure
      record /vertex_ubuf/ v_ubuf
      integer    n_v_ubuf
      parameter (n_v_ubuf = 18 )
 
 
> gstar_track_ubuf.inc
=======================
c
c*** contains track user buffer structure
c*** NB keep stop vertex as 4th element: used in guskip
c
      structure /track_ubuf/
         integer evgen_label
         integer evgen_pid
         integer evgen_p_start_vertex
         integer evgen_p_stop_vertex
         integer evgen_p_first_intermed_vertex
         integer evgen_p_next_parent
         integer equals_99999
      end structure
      record /track_ubuf/ t_ubuf
      integer    n_t_ubuf
      parameter (n_t_ubuf = 7 )
 
=============================================================================
 
gstar_user_cards.inc
====================
c
c*** common block containing values extracted from user-defined cards
c
c*** number of event generator events to skip before start of processing
      integer n_skip_events
     *    ,n_skip_subevents
     *    ,n_skip_subran1
     *    ,n_skip_subran2
 
c*** smear vertex position over thickness of target? (0=no (def), 1=yes)
      integer i_smear_target
 
c*** set cuts high in dense materials
      integer make_shadow
 
c*** location of primary vertex prim_vert
      real prim_vert(3)
 
c*** number of tracks per subevent
      integer n_track_per_subevt
 
c*** flag for treating secondary tracks
      integer i_flag_secondaries
 
c*** flag for treating secondary tracks
      integer i_flag_prim_vert
 
c*** sigmas for gaussian dithering of primary geant vertex
      real sigma_prim_vert_z
      real sigma_prim_vert_xy
 
c*** flag for debug output of geometry (prints out all materials, media and volumes)
      integer i_flag_geo_debug
 
c*** value of electron tracking cut in gases
      real cutele_gas
 
c---------------------------------------------------------------------
      common/c_user_cards/n_skip_events
     *    ,n_skip_subevents
     *    ,n_skip_subran1
     *    ,n_skip_subran2
     &    ,i_smear_target
     &    ,make_shadow
     &    ,prim_vert
     &    ,n_track_per_subevt
     &    ,i_flag_secondaries
     &    ,i_flag_prim_vert
     &    ,sigma_prim_vert_xy
     &    ,sigma_prim_vert_z
     &    ,i_flag_geo_debug
     *    ,cutele_gas
 
 
 
gstar_geant_prim_vert.inc
=========================
c*** This is the global Geant offset to the primary vertex for this
c*** event-generator event (i.e. must be same for all sub-events)
 
      real prim_vert_this_event(3)
 
      common/event_vertex/prim_vert_this_event
 
 
 
gstar_cfio.inc
==============
c
c*** contains i/o pointers for cfio (needed for running on shift)
c
      integer         lunptr_input, lunptr_output
      common/ c_cfio /lunptr_input, lunptr_output
 
c*** lun for text file read
 
      integer lun_tx_in
      data    lun_tx_in/71/
 
 
 
gstar_pid.inc	
=============
c
c*** file of parameters and other definitions for symbolic reference
c*** to particle IDs specific to STAR Geant
c
      parameter( pid_omega = 150 )
      parameter( pid_phi = 151 )
      parameter( pid_rho0 = 152 )
      parameter( pid_rho_plus = 153 )
      parameter( pid_rho_minus = 154 )
      parameter( pid_D_plus = 155 )
      parameter( pid_D0 = 156 )
      parameter( pid_dq = 157 )
      parameter( pid_dqb = 158 )
      parameter( pid_uq = 159 )
      parameter( pid_uqb = 160 )
      parameter( pid_sq = 161 )
      parameter( pid_sqb = 162 )
      parameter( pid_cq = 163 )
      parameter( pid_cqb = 164 )
      parameter( pid_bq = 165 )
      parameter( pid_bqb = 166 )
      parameter( pid_tq = 167 )
      parameter( pid_tqb = 168 )
      parameter( pid_g = 169 )
      parameter( pid_laserino = 170 )
 
 
 
gstar_decay_modes.inc
======================
c
c*** for storing decay modes of geant-defined particles
c
*include "g2t_decay_mode.inc" - PN: do it manually
 
	STRUCTURE /DECAY_MODE_ST/
	CHARACTER*80 mode           ! character string describing mode !
	INTEGER*4 daughter_p        ! Id of first daughter !
	INTEGER*4 id                ! primary key !
	INTEGER*4 mode_label        ! integer labelling mode !
	INTEGER*4 n_daughter        ! number of daughters of decay !
	INTEGER*4 next_decay_p      ! pointer to next decay mode !
	REAL*4    b_ratio           ! branching ratio for this mode !
	END STRUCTURE               ! G2T_DECAY_MODE_ST !
 
      record /decay_mode_st/ decay_mode
 
*include "g2t_decay_daughter.inc" - PN: do it manually
 
	STRUCTURE /DECAY_DAUGHTER_ST/
	INTEGER*4 eg_pid            ! event generator pid !
	INTEGER*4 ge_pid            ! geant pid !
	INTEGER*4 id                ! primary key !
	INTEGER*4 next_daughter_p   ! next daughter of same decay mode !
	END STRUCTURE               ! G2T_DECAY_DAUGHTER_ST !
 
      record /decay_daughter_st/ daughter
 
      integer  p_mode, p_daughter
      pointer( p_mode, decay_mode )
      pointer( p_daughter, daughter )
 
 
 
gstar_udecay.inc
=================
c
c*** defines structures, common block, etc. for defining uniform
c*** decay of specified particles
c
      integer udecay_count
     *        ,udecay_count_max
     *        ,udecay_nstep
     *        ,udecay_nstep_max
     *        ,i_udecay
     *        ,udecay_nstep_last
 
      logical udecay_track,udecay_in_region_last_step
 
      real udecay_pathlength_entrance
 
      parameter (udecay_count_max=10)
      parameter (udecay_nstep_max=5000)
 
      structure /udecay_t/
         integer parent
         integer new_parent
         real r_in
         real r_out
         integer daughter_1
         integer daughter_2
         integer daughter_3
         real mass_p
         real mass_1
         real mass_2
         real mass_3
         integer nbody
      end structure
 
      record /udecay_t/ udecay(udecay_count_max)
 
      structure /udecay_step_t/
         real x
         real y
         real z
         real px
         real py
         real pz
         real pathlength
      end structure
 
      record /udecay_step_t/ udecay_step(udecay_nstep_max)
 
      common/c_udecay/
     *        udecay_count
     *        ,udecay
     *        ,udecay_nstep
     *        ,udecay_step
     *        ,i_udecay
     *        ,udecay_track
     *        ,udecay_in_region_last_step
     *        ,udecay_nstep_last
     *        ,udecay_pathlength_entrance
 
 
 
 
gstar_shower_tracks.inc
=======================
c
c*** Contains counter to ennumerate shower tracks in each subevent that
c*** produce hits in the sensitive detectors
c
      integer n_shower_track_evt
     &        ,max_shower_track_itra
     &        ,n_shower_track_itra
 
      common/com_shower_tracks/n_shower_track_evt
     &        ,max_shower_track_itra
     &        ,n_shower_track_itra
c
c
c*** define user buffer here
 
      structure /shower_t/
         integer n_shower_track
         integer pid
         real    px
         real    py
         real    pz
         integer equals_88888
      end structure
 
      record /shower_t/        ubuf_shower_track
      common /com_ubuf_shower/ ubuf_shower_track
      integer    nw_shower_track
      parameter( nw_shower_track = 6 )
 
*** contains defintions for run header user buffer
*
      COMMON /AgCHEAD/ author,machine,date,time,
     >       geant_version,ge_run,ge_rndm_run(2)
*
      character*80 author,machine
      integer      date,time
      real         geant_version
      integer      ge_run,ge_rndm_run(2)
*
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
+KEEP,SCLINK.
*CMZ :  1.30/00 02/04/97  16.22.41  by  Pavel Nevski
*CMZ :  1.00/00 12/08/95  19.37.12  by  Pavel Nevski
*-- Author :
C SLUG link area :    Permanent Links for SLUG:
      INTEGER         LKSLUG,NSLINK
      PARAMETER       (NSLINK=40)
      COMMON /SCLINK/ LKSLUG(NSLINK)
C The following names are equivalenced to LKSLUG.
C The equivalence name is the one used in SLINIB.
      INTEGER LKGLOB,LKDETM,LKTFLM,LKTFLT,LKAMOD,LKAGEV,LKAMCH,LKADIG,
     +        LKMAPP,LKMFLD,LKRUNT,LKEVNT,LKARAW,LKATRI,LKAPRE,LKARP1,
     +        LKARP2,LKARP3,LKDSTD,LKRUN2,LKEVN2,LKVER2,LKKIN2,LKHIT2,
     +        LKGENE
C                                       Link to:
      EQUIVALENCE (LKSLUG(1),LKGLOB)   ! top of temporary HEPEVT Zebra tree
      EQUIVALENCE (LKSLUG(2),LKDETM)   ! top of subdetector structure
      EQUIVALENCE (LKSLUG(3),LKTFLM)   ! permanent track filter structure
      EQUIVALENCE (LKSLUG(4),LKTFLT)   ! temporary track filter structure
      EQUIVALENCE (LKSLUG(5),LKAMOD)   ! MODule parameters (Dont know this)
      EQUIVALENCE (LKSLUG(6),LKAGEV)   ! Link to general event structure
      EQUIVALENCE (LKSLUG(7),LKAMCH)   ! MonteCarlo Hits ( not GEANT I guess)
      EQUIVALENCE (LKSLUG(8),LKADIG)   ! DIGitized hits (again not GEANT...?)
      EQUIVALENCE (LKSLUG(9),LKMAPP)   ! map structure
      EQUIVALENCE (LKSLUG(10),LKMFLD)  ! magnetic field banks
      EQUIVALENCE (LKSLUG(11),LKRUNT)  ! run tree bank (vertical structure)
      EQUIVALENCE (LKSLUG(12),LKEVNT)  ! event tree bank (vertical struct)
      EQUIVALENCE (LKSLUG(13),LKARAW)  ! raw data structure
      EQUIVALENCE (LKSLUG(14),LKATRI)  ! trigger banks
      EQUIVALENCE (LKSLUG(15),LKAPRE)  ! preprocessed hits
      EQUIVALENCE (LKSLUG(16),LKARP1)  ! reconstuction phase 1 banks
      EQUIVALENCE (LKSLUG(17),LKARP2)  ! reconstuction phase 2 banks
      EQUIVALENCE (LKSLUG(18),LKARP3)  ! reconstuction phase 3 banks
      EQUIVALENCE (LKSLUG(19),LKDSTD)  ! DST data banks
      EQUIVALENCE (LKSLUG(20),LKRUN2)  ! run tree bank for secondary run
      EQUIVALENCE (LKSLUG(21),LKEVN2)  ! event tree bank for secondary events
      EQUIVALENCE (LKSLUG(22),LKVER2)  ! secondary GEANT VERT bank
      EQUIVALENCE (LKSLUG(23),LKKIN2)  ! secondary GEANT KINE bank
      EQUIVALENCE (LKSLUG(24),LKHIT2)  ! secondary GEANT HITS bank
      EQUIVALENCE (LKSLUG(26),LKGENE)  ! old slug ZEBRA generator structure
+KEEP,AGCHEAD.
*CMZ :  1.30/00 24/03/97  21.25.13  by  Pavel Nevski
*-- Author :    Pavel Nevski   24/03/97
*
*** contains defintions for run header user buffer
*
      COMMON /AgCHEAD/ author,machine,date,time,
     >       geant_version,ge_run,ge_rndm_run(2)
*
      character*80 author,machine
      integer      date,time
      real         geant_version
      integer      ge_run,ge_rndm_run(2)
*
+KEEP,asflags.
*CMZ :  1.30/00 15/04/96  21.56.54  by  Pavel Nevski
*-- Author :    Pavel Nevski   15/04/96
      INTEGER      NFLAGS
      PARAMETER    (NFLAGS=15)
      CHARACTER*4  CFLAG(NFLAGS)
      DATA CFLAG   /'PNOW','PRIN','DEBU','GEOM','HIST','GRAP',
     >              'SIMU','DIGI','RECO','MFLD','ANAL','BACK',
     >              'RESA','RESB','RESC'/
*    ---------------------------------------------------------
+KEEP,agckine.T=geant. ---------------------------------------------------------
*CMZ :          02/07/97  12.34.36  by  Pavel Nevski
*CMZ :  1.30/00 17/04/97  21.01.16  by  Pavel Nevski
*CMZU:  1.00/01 14/01/96  17.46.29  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/01/96
*    AGI general data card information
      Integer          IKineOld,IdInp,Kevent,
     >                 Iback,IbackOld,IbMode,IbBefor,IbAfter,
     >                 IbCurrent,IvCurrent,Ioutp,IoutpOld
      Real             AVflag,AVcoor,AVsigm,Ptype,PTmin,PTmax,
     >                 Etamin,Etamax,PhiMin,PhiMax,Ptflag,
     >                 Zmin,Zmax,BgMult,BgTime,BgSkip,
     >                 Pxmin,Pxmax,Pymin,Pymax,Pzmin,Pzmax
      COMMON /AgCKINE/ IKineOld,IdInp,Kevent(3),
     >                 AVflag,AVcoor(3),AVsigm(3),
     >                 Ptype,PTmin,PTmax,Etamin,Etamax,
     >                 PhiMin,PhiMax,Ptflag,Zmin,Zmax,
     >                 Pxmin,Pxmax,Pymin,Pymax,Pzmin,Pzmax
      COMMON /AgCKINB/ Iback,IbackOld,IbMode,IbBefor,IbAfter,
     >                 BgMult,BgTime,BgSkip,IbCurrent,IvCurrent
      COMMON /AgCKINO/ Ioutp,IoutpOld
      Character*20     CoptKine,CoptBack,CoptOutp
      COMMON /AgCKINC/ CoptKine,CoptBack,CoptOutp
      Character*20     CrunType
      COMMON /AgCKINR/ CrunType
      Integer          Ncommand
      Character*20     Ccommand
      COMMON /AgCCOMD/ Ncommand,Ccommand
      Integer          IUHIST
      Character*80            CFHIST,CDHIST
      COMMON /AgCHIST/ IUHIST,CFHIST,CDHIST
*
      Integer          NtrSubEV,NkineMax,NhitsMax,NtoSkip,NsubToSkip,
     >                 Nsubran,ItrigStat,NsubEvnt,IsubEvnt,
     >                 Make_Shadow,Flag_Secondaries
      Real             Cutele_Gas,VertexNow
      COMMON /AgCSUBE/ NtrSubEV,NkineMax,NhitsMax,
     >                 NtoSkip,NsubToSkip,Nsubran(2)
      COMMON /AgCSTAR/ Make_Shadow,Cutele_Gas,Flag_Secondaries
      COMMON /AgCstat/ ItrigSTAT,NsubEvnt,IsubEvnt,VertexNow(3)
*
*    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
+KEEP,agcclus. -----------------------------------------------------------------
*CMZ :  1.30/00 30/07/96  19.09.55  by  Pavel Nevski
*CMZ :  1.00/00 12/03/95  20.40.54  by  Pavel Nevski
*-- Author :    Pavel Nevski, Sasha Rozanov
*                                            clustering bank
      Integer          Ndig,Ktyp,Lh,Nclu,Kdig,Ltra,Ktypdig,Nodig
      Real                          Fdig,Zdig,Edig
      Parameter        (Lh=1024)
      Common /ARCdigt/ Ndig,Ktyp,Fdig(Lh),Zdig(Lh),Edig(Lh),
     +                           Nclu(Lh),Kdig(lh),Ltra(Lh)
      COMMON /AGCCLUS/ Ktypdig(Lh),NoDig(Lh)
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+KEEP,agclink.
*CMZ :  1.00/00 08/11/95  00.06.17  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/08/95
*   links for dynamic banks access
       INTEGER    NALINKMAX,AG_NLINK,AG_LINK
       PARAMETER  (NALINKMAX=100)
       COMMON /AGCLINK/ AG_NLINK,AG_LINK(0:NALINKMAX)
*      - - - - - - - - - - - - - - - - - - - - - -
 
+KEEP,STAFUNC.
*CMZ :  1.30/00 28/04/96  17.35.25  by  Pavel Nevski
*CMZ :  1.00/01 25/12/95  16.55.37  by  Pavel Nevski
*CMZ :  1.00/00 06/05/94  23.36.52  by  Pavel Nevski
*-- Author :
C Declare types for the things used in the statement function STAFUNC
      INTEGER IIIII, LVPRIN,LVGEOM,LVHIST,LVGRAP,LVDEBU,LWPRIN,
     +        LWDEBU,LVSIMU,LVDIGI,LVRECO,LVMFLD,LVANAL,LVBACK
C
C Statement Functions for ZEBRA
C datacard value are in LW PRIN/DEBU, current print is in LV PRIN
C
      LVPRIN(IIIII)=IQ(LQ(LKDETM-IIIII)+1)
      LVDEBU(IIIII)=IQ(LQ(LKDETM-IIIII)+2)
      LWPRIN(IIIII)=IQ(LQ(LKDETM-IIIII)+2)
      LWDEBU(IIIII)=IQ(LQ(LKDETM-IIIII)+3)
      LVGEOM(IIIII)=IQ(LQ(LKDETM-IIIII)+4)
      LVHIST(IIIII)=IQ(LQ(LKDETM-IIIII)+5)
      LVGRAP(IIIII)=IQ(LQ(LKDETM-IIIII)+6)
      LVSIMU(IIIII)=IQ(LQ(LKDETM-IIIII)+7)
      LVDIGI(IIIII)=IQ(LQ(LKDETM-IIIII)+8)
      LVRECO(IIIII)=IQ(LQ(LKDETM-IIIII)+9)
      LVMFLD(IIIII)=IQ(LQ(LKDETM-IIIII)+10)
      LVANAL(IIIII)=IQ(LQ(LKDETM-IIIII)+11)
      LVBACK(IIIII)=IQ(LQ(LKDETM-IIIII)+12)
 
+KEEP,QUEST.
*CMZ :  1.30/00 16/03/97  19.06.37  by  Pavel Nevski
*CMZ :  1.00/00 17/03/92  15.48.20  by  R. DeWolf
*-- Author :
      INTEGER      IQUEST
      COMMON/QUEST/IQUEST(100)
+KEEP,TYPING.
*CMZ :  1.00/00 17/03/92  15.48.23  by  R. DeWolf
*-- Author :
+SELF,IF=TYPE
      IMPLICIT NONE
+SELF.
+KEEP,agcrtab. -----------------------------------------------------------------
*CMZ :  1.30/00 15/04/97  14.55.24  by  Pavel Nevski
*CMZ :  1.00/00 13/12/95  17.37.23  by  A. DellAcqua
*-- Author :    Pavel Nevski   06/02/95
*
*     Commons for the inner detector digi reconstruction
      Integer           Lstack,     Lr,   Lhead,   Lpack
      Parameter        (Lstack=2000,Lr=15,Lhead=52,Lpack=512)
*
*                                            subsystem descriptor
      Integer          Isys,Nplane,Itp,Iset,Idet,kkk,kfi,krz,mrz,NumPmx,
     +                 Nadr,Istart,Inamd,Iaxr,Iaxt,Iaxz,Ires, nam,nmx
      Real             Rstack,drzm,RRmin,RRmax,ZZmin,ZZmax
*
      Common /AgCRtab/ Isys,Nplane,Itp,Iset,Idet,kkk,kfi,krz,mrz,drzm,
     +                 RRmin,RRmax,ZZmin,ZZmax,
     +                 NumPmx,Nadr,Istart,Inamd,Iaxr,Iaxt,Iaxz,Ires,
     +                 Nam(15),Nmx(15),  Rstack(Lr,Lstack)
      Integer                            Istack(Lr,Lstack)
      Equivalence      (Rstack,Istack)
*                                            plane descriptor
      Real             rzp,RZmin,RZmax,Fmin,Fmax,Dfi,Dzr,tilt,sas,Fcent
      Integer          Nfi,Nzr,Nump,Iadr,Jres,Lpacku
      Common /AgCRta1/ rzp,RZmin,RZmax,Fmin,Fmax,Dfi,Dzr,tilt,sas,Fcent,
     +                 Nfi,Nzr,Nump,Iadr,Jres,Lpacku
*                                            detector size
      Integer          Ishape,Npar
      Real                         AgTran,   AgRmat,    Par
      Common /ARCplan/ Ishape,Npar,AgTran(3),AgRmat(10),Par(50)
*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
+KEEP,agcrdig.
*CMZ :  1.00/00 04/06/95  23.12.34  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/12/94
*  AGCRDIG is communication between AgFHIT0/1, AgFDIGI, AgFPATH, AGFDPAR.
      Integer          IWA,   JS,JD,JX,JXD,JDS,JDU
      COMMON /AGCRDIG/ IWA(2),JS,JD,JX,JXD,JDS,JDU
      Integer          Iprin,Nvb,Nw,Last,Mb,Nc1,Nc2,Iv,Ia
      Character*4                                         cs,cd
      COMMON /AGCHITV/ Iprin,Nvb,Nw,Last,Mb,Nc1,Nc2,Iv,Ia,cs,cd
*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+KEEP,agcbuff.
*CMZ :  1.00/00 06/02/95  14.55.02  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
*     buffer for hit/digi maps
      Integer          Ibuf,Lbuf
      Parameter        (Lbuf=500 000)
      Common /AGCBUFF/ Ibuf(Lbuf)
*     - - - - - - - - - - - - - -
+KEEP,AGCDOCL.
*CMZ :  1.00/00 06/01/95  17.28.51  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/12/94
C     common for the documentation supporting links
      Integer           LDarea(2),L1Doc,L2Doc,LKDoc,Ldoc,Ldete,Lpar
      COMMON /AGCDOCL/  LDarea,   L1Doc,L2Doc,LKDoc,Ldoc,Ldete,Lpar
C     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
+KEEP,agcdig.
*CMZ :  1.00/00 07/02/95  23.16.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   20/12/94
*   AGCDIGA is for internal AGSDIG0/1 communication only
      INTEGER        NLOCAL,   JS,JD,JDX,JX,JXD,JDU,LOCAL
      COMMON/GCLOCA/ NLOCAL(2),JS,JD,JDX,JX,JXD,JDU,LOCAL(14)
      Integer        Iset,Idet,NW,NV,ND,NVU,NDU
      COMMON/AGCDIGA/Iset,Idet,NW,NV,ND,NVU,NDU
*     - - - - - - - - - - - - - - -
*
+KEEP,agcstep. -----------------------------------------------------------------
*CMZ :  1.30/00 30/07/96  19.09.55  by  Pavel Nevski
*CMZ :  1.00/01 29/01/96  13.28.10  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/12/94
* Connection between AgGSTEP, AgGHIT and a user step routine.
      Real              vect0,vloc0,vloc,xloc,Astep,Adestep,Hits
      COMMON /AGCSTEP/  vect0(7),vloc0(7),vloc(7),xloc(7),
     +                  Astep,Adestep
      COMMON /AGCSTEPH/ Hits(15)
      Integer           IhaveMore
      COMMON /AGCSTEPI/ IhaveMore
*
+KEEP,Agchit.  -----------------------------------------------------------------
*CMZ :  1.00/00 03/06/95  13.31.56  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/12/94
*  AGCHITL and AGCHITV are communication between AgFHIT0/1/AggetDIG,AgFPATH.
      Integer          IWA,   JS,JD,JX,JDX,JXD,JDS,JDU
      COMMON /AGCHDIG/ IWA(2),JS,JD,JX,JDX,JXD,JDS,JDU
      Integer          Iprin,Iv,Ia,Nv,Mb,Nc1,Nc2,NumMX,Lp
      Parameter        (Lp=15)
      Real             Org,Fct
      Character*4      cs,cd
      COMMON /AGCHITV/ Iprin,Iv,Ia,Nv,Mb,Nc1,Nc2,cs,cd,
     >                 Org(Lp),Fct(Lp),NumMX(Lp)
*
+KEEP,AGECOM. -----------------------------------------------------------------
*CMZ :          06/01/98  12.22.43  by  Pavel Nevski
*CMZ :  1.30/00 17/11/96  22.43.56  by  Pavel Nevski
*CMZ :  1.00/01 30/11/95  13.23.57  by  Pavel Nevski
*CMZ :  1.00/00 01/06/95  14.24.55  by  Pavel Nevski
*-- Author :    Pavel Nevski   23/11/94
      CHARACTER*20 AG_MODULE,  AG_TITLE,  AG_EXNAME,   AG_PARLIST,
     +             AG_MATERIAL,AG_MIXTURE,AG_COMPONENT,AG_MEDIUM,
     +             AG_CHDIR
      CHARACTER*4  AG_VOLUME,AG_MOTHER,AG_SHAPE,AG_CNICK,AG_KONLY,
     +             AG_OPTION,AG_ORT,AG_MARK
      INTEGER      AG_BEGCOM,AG_IVOLUME,AG_IMOTHER,AG_IGNUM,AG_ISHAPE,
     +             AG_IMED,AG_IMAT,AG_IFIELD,AG_IDTYPE,AG_NLMAT,AG_ORTI,
     +             AG_IERROR,AG_NWBUF,AG_NPAR,AG_ISTATUS,AG_IROT,AG_JDU,
     +             AG_NBITS,AG_ISET,AG_IDET,AG_ISVOL, AG_ATTRIBUTE(6),
     +             AG_WORK, AG_SEEN,AG_LSTY,AG_LWID,AG_COLO,AG_FILL,
     +             AG_LEVEL,AG_NDIV,AG_IAXIS,AG_NDVMAX,AG_NPDV,AG_NCOPY,
     +             AG_IPRIN,AG_RESET1,AG_RESET2,AG_BEGSCR,AG_ENDSCR,
     +             AG_IRESER,AG_LSTACK,AG_NWUHIT,AG_NWUVOL,AG_MAGIC,
     +             AG_LDETU,AG_NPDIV,AG_NZ,AG_IGEOM,AG_IDEBU,AG_IGRAP,
     +             AG_IHIST,AG_IMFLD,AG_SERIAL,AG_STANDALONE,AG_ISIMU,
     +             AG_ENDSAVE,IPRIN
      REAL         AG_FIELDM,AG_TMAXFD,AG_STEMAX,AG_DEEMAX,AG_EPSIL,
     +             AG_STMIN,AG_DENS,AG_RADL,AG_ABSL,AG_THETAX,AG_THETAY,
     +             AG_THETAZ,AG_ALFAX,AG_ALFAY,AG_ALFAZ,AG_PHIX,AG_PHIY,
     +             AG_ALPHAX,AG_ALPHAY,AG_ALPHAZ, AG_PHIZ, AG_TWIST,
     +             AG_DX, AG_DX1, AG_DX2, AG_DY, AG_DY1,AG_DY2,
     +             AG_THET, AG_THE1, AG_THE2, AG_PHI, AG_PHI1, AG_PHI2,
     +             AG_ALPH, AG_ALP1, AG_ALP2, AG_RMIN, AG_RMAX, AG_RMN,
     +             AG_RMX, AG_ZI, AG_RMN1, AG_RMN2, AG_RMX1, AG_RMX2,
     +             AG_H1, AG_H2, AG_BL1, AG_BL2, AG_TL1, AG_TL2,AG_DPHI,
     +             AG_DZ, AG_TWIS, AG_X, AG_Y, AG_Z, AG_A, AG_ZA, AG_W,
     +             AG_STEP, AG_C0, AG_PAR, AG_AA,AG_ZZ,AG_WW,AG_TYPE,
     +             AG_STACK,AG_UBUF,AG_XHMAX,AG_YHMAX,AG_ZHMAX,
     +             AG_RHMAX,AG_FHMAX,AG_FHMIN,AG_BIN,AG_DMAXMS,
     +             AG_LX, AG_LY, AG_LZ, AG_HX, AG_HY, AG_HZ,
     +             AG_P1, AG_P2
      PARAMETER   (AG_LSTACK=130, AG_NWUHIT=10, AG_NWUVOL=3,
     +             AG_MAGIC=-696969, AG_LDETU=250)
      COMMON/AGCGLOB/AG_MODULE, AG_CHDIR,   AG_LEVEL,   AG_IDTYPE,
     +              AG_IERROR,  AG_STANDALONE,          IPRIN,
     +              AG_IPRIN,   AG_IGEOM,   AG_IDEBU,   AG_IGRAP,
     +              AG_IHIST,   AG_IMFLD,   AG_ISIMU
C Inherited variables saved during internal calls
      COMMON/AGCPARA/AG_BEGCOM, AG_IVOLUME, AG_IMOTHER, AG_IGNUM,
     +              AG_ISHAPE,  AG_IMED,    AG_IMAT,    AG_IFIELD,
     +              AG_FIELDM,  AG_TMAXFD,  AG_STEMAX,  AG_DEEMAX,
     +              AG_EPSIL,   AG_STMIN,   AG_DENS,    AG_RADL,
     +              AG_ABSL,    AG_DX,      AG_DX1,     AG_DX2,
     +              AG_DY,      AG_DY1,     AG_DY2,
     +              AG_RMN1,    AG_RMN2,    AG_RMX1,    AG_RMX2,
     +              AG_THET,    AG_THE1,    AG_THE2,
     +              AG_PHI,     AG_PHI1,    AG_PHI2,
     +              AG_ALPH,    AG_ALP1,    AG_ALP2,
     +              AG_H1,      AG_BL1,     AG_TL1,
     +              AG_H2,      AG_BL2,     AG_TL2,
     +              AG_RMIN,    AG_RMAX,    AG_DPHI,    AG_NPDIV,
     +              AG_NZ,      AG_DZ,      AG_TWIS,
     +              AG_LX,      AG_LY,      AG_LZ,
     +              AG_HX,      AG_HY,      AG_HZ,
     +              AG_A,       AG_ZA,      AG_W,       AG_NLMAT,
     +              AG_WORK,    AG_SEEN,    AG_LSTY,
     +              AG_LWID,    AG_COLO,    AG_FILL,
     +              AG_SERIAL,  AG_ISVOL,   AG_ISTATUS,
     +              AG_ZI(16),  AG_RMN(16), AG_RMX(16),
     +              AG_VOLUME,  AG_MOTHER,  AG_SHAPE,   AG_CNICK,
     +                                                  AG_ENDSAVE,
     +              AG_RESET1,  AG_THETAX,  AG_THETAY,  AG_THETAZ,
     +              AG_ALFAX,   AG_ALFAY,   AG_ALFAZ,
     +              AG_PHIX,    AG_PHIY,    AG_PHIZ,
     +              AG_X,       AG_Y,       AG_Z,
     +              AG_STEP,    AG_C0,      AG_NDIV,
     +              AG_IAXIS,   AG_NDVMAX,  AG_ORTI,    AG_NCOPY,
     +              AG_RESET2,
     +              AG_KONLY,   AG_ORT,     AG_MARK
C local variables valid inside same block
      COMMON/AGCLOCA/AG_BEGSCR, AG_UBUF(100), AG_PAR(100),
     +              AG_AA(20),  AG_ZZ(20),    AG_WW(20),   AG_NWBUF,
     +              AG_XHMAX,   AG_YHMAX,     AG_ZHMAX,    AG_RHMAX,
     +              AG_FHMAX, AG_FHMIN, AG_NBITS, AG_BIN,  AG_TYPE,
     +              AG_IROT,  AG_NPAR,  AG_ISET,  AG_IDET, AG_JDU,
     +              AG_IRESER,                             AG_ENDSCR,
     +              AG_TITLE,   AG_EXNAME,    AG_PARLIST,  AG_MATERIAL,
     +              AG_MIXTURE, AG_COMPONENT, AG_MEDIUM,   AG_OPTION
      COMMON/AGCSTAC/AG_STACK(AG_LSTACK,15)
      EQUIVALENCE  (AG_ATTRIBUTE,AG_WORK),(AG_STEMAX,AG_DMAXMS),
     +             (AG_ALFAX,AG_ALPHAX),  (AG_ALFAY,AG_ALPHAY),
     +             (AG_ALFAZ,AG_ALPHAZ),  (AG_TWIST,AG_TWIS),
     +             (AG_P1,AG_HX),         (AG_P2,AG_HY),
     +             (AG_NPDIV,AG_NPDV)
*    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
 
 
+KEEP,RBBANK. ------------------------------------------------------------------
*CMZ :  1.30/00 02/04/97  18.53.56  by  Pavel Nevski
*CMZ :  1.00/00 07/03/95  21.11.16  by  Pavel Nevski
*-- Author :  by Pavel Nevski
C   - combined DETM + Reconstruction bank access variables - AGI version
      CHARACTER         CNAM*4
      INTEGER           LU,BIG,MM,INAM,II,KK,IADR,LENG,IOD,IOX,IrbDIV,
     >                  LDD,NDDMAX,NDD,DDL,NFR,FRTAB
      PARAMETER         (LDD=5,NDDMAX=100,MM=2,BIG=99999)
      COMMON /RBXBANK/  LU, CNAM,II,KK,IADR,LENG,IOD,IOX,IrbDIV
      COMMON /RBXLIST/  NDD,DDL(LDD,NDDMAX)
      COMMON /RBXFORM/  NFR,FRTAB(NDDMAX)
      EQUIVALENCE       (CNAM,INAM)
*
+PATCH,REBANK. ================================================================
*CMZ :  1.00/00 19/12/95  09.59.59  by  G. Poulard
+DECK,RBCDIR,T=geant. ----------------------------------------------------------
*CMZ :  1.00/00 30/06/95  13.07.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                subroutine   R B C D I R  (Cname,NVL);
*                                                                    *
*  Description:                                                      *
*                                                                    *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,SCLINK,RBBANK.
CHARACTER  Cname*(*);   Integer    NVL(5),Link,Ia;
;                                                           /* save link */
 Call Rebank (Cname,NVL,BIG,Link,Ia);
 If Link==0 { <W> Cname; (' RBCDIR: Directory does not exist: ',A); Return; }
 LKAR P2=Link;
   END
 
+DECK,RBFIND,T=geant. ----------------------------------------------------------
*CMZ :  1.00/00 27/11/94  15.30.46  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 subroutine   R B F I N D
*                                                                    *
**********************************************************************
+CDE,TYPING,RBBANK.
Integer i1,i2,ic,jdd; Data Jdd/1/;
;
  IF Inam#DDL(1,Jdd)                                         " fast search "
  {  i1=1; i2=NDD;    While i2-i1>1
     {  ic=(i1+i2)/2; If (Inam-DDL(1,ic)) :Lt:,:Equal:,:Gt:;
        :Lt: i2=ic; Next;        :Gt: i1=ic;
     }                                                       " normal search "
     Do ic=i1,i2 { If (Inam==DDL(1,ic)) goto :Equal:; }
     Iadr=0;  IOD=3;  Leng=MM;  Return;  :Equal: Jdd=ic;
  }  Iadr=DDL(2,Jdd);  Leng=DDL(3,Jdd);  IOD=DDL(4,Jdd);
   END
 
+DECK,RBCOPY,T=geant. ----------------------------------------------------------
*CMZ :  1.00/00 30/06/95  13.07.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
        subroutine   R B C O P Y  (Cname,NVL,Ndim,Npar,Array)
*                                                                    *
*  Description:                                                      *
*                                                                    *
**********************************************************************
+CDE,TYPING,GCBANK,SCLINK,RBBANK.
CHARACTER  Cname*(*);    Integer    NVL(*),Npar,Array(*),Link,Ia,Ndim;
;                                                         /*  get access  */
 Call REbank (Cname,NVL,-Ndim,Link,Ia);
 " special counting request - return only number of banks, not data "
 If  NVL(kk)==0 { NVL(kk)=II-1; Npar=0; Return; }
;                                                        /* check and copy */
 Npar=-1; Check Link>0; Npar=min(Ndim,IQ(Link-1));
 If (Npar>0) Call UCOPY (IQ(Link+1+Ia),Array,Npar);
   END
 
+DECK,RBSTORE,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 30/06/95  13.07.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
        subroutine   R B S T O R E (Cname,NVL,Form,Npar,Array)
*                                                                    *
*  Description:                                                      *
*                                                                    *
**********************************************************************
+CDE,TYPING,GCBANK,SCLINK,RBBANK.
CHARACTER*(*)  Cname,FORM;     Integer  NVL(*),Npar,Array(*),Link,Ia;
;                                                 /* get format index */
 Cnam=FORM(1:4); Unless 1<=Inam<=Nfr
 { If Nfr>=100   { Output Form;
                 (' RBSTORE error: too many different FORMATS defined ! '/,
                  ' probably you use immediate constant ? last format=',A);}
   Nfr+=1; Call MZFORM('RECB',Form,FrTab(Nfr));   Inam=Nfr;   FORM(1:4)=Cnam;
 }
;                                                   /*  store data  */
   IOX=FrTab(Inam); Call REbank (Cname,NVL,Npar,Link,Ia);  Check Link>0;
   Call UCOPY (Array,IQ(Link+1+Ia),Npar);  If (NVL(kk)==0) NVL(kk)=II;
   END
 
+DECK,REBANK,T=geant. ----------------------------------------------------------
*CMZ :          16/03/98  03.28.56  by  Pavel Nevski
*CMZ :  1.30/00 16/04/97  22.11.16  by  Pavel Nevski
*CMZU:  1.00/01 21/12/95  22.17.57  by  Pavel Nevski
*CMZ :  1.00/00 03/10/95  18.17.59  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
            Subroutine   R E B A N K  (Cname,NVL,Npar,Link,Ia)
*                                                                    *
* Input:                                                             *
*  Cname - 'Unix-like' path to the data block: /dir1/.../name.exte   *
*  NVL   - Bank numbers in their linear structures                   *
*  Npar >0 Bank is requested for writing, may be created or expanded *
*       <0 BAnk is requested for reading, should not be changed      *
* Output:                                                            *
*  Link  - returned link pointer to the bank, >0 if bank was found   *
*  Ia    - displacement in the bank for a raw by raw mode            *
*                                                                    *
**********************************************************************
+CDE,TYPING,QUEST,GCBANK,SCLINK,RBBANK.
  INTEGER      NVL(*),Npar,LinkUp,Link,ia,Need,NV1,
               J,IE,J0,IL,JL,NS,ND,NV,Lm,LENOCC
  CHARACTER    Cname*(*),Del*1
 
Replace[ERR#;]  with [;OUTPUT kk,NVL(kk),IL,#1; (' REBANK ERROR: ',2x,
                      'level/copy/link=',3i4,' needed/found=',3i6); Return; ]
 
if (Lu<=0) Lu=6
 
"  Set starting directory - top level or current "
KK=0; {J0,J}=1;  While Cname(J0:J0)=='/' {J0=J0+1}
If J0>1
{  " Get RECB/DETM bank address and make sure that it has been booked "
    If     Cname(J0:J0+3)=='DETM'
   { If (LK Detm==0) Call MZBOOK(IxCons,LKAR P2,LK Detm,1,'DETM',50,50,50,5,0)
     IrbDIV=IxCons;   Link=LK Detm;   KK=1;
   }
   else If Cname(J0:J0+3)=='RECB'
   { If (LKAR P1==0) Call MZBOOK(IxDIV,LKAR P2,LKAR P1, 1,'RECB',MM,MM,10,2,0)
     IrbDIV=IxDIV;    LINK=LKAR P1;   KK=1;
   }
   else If Cname(J0:J0+3)=='SECT' | Cname(J0:J0+3)=='TRIG' " old way of calling recb "
   { If (LKAR P1==0) Call MZBOOK(IxDIV,LKAR P2,LKAR P1, 1,'RECB',MM,MM,10,2,0)
     IrbDIV=IxDIV;    LINK=LKAR P1;   KK=0;
   }
   else If Cname(J0:J0+3)=='SETS'
   { IrbDIV=IxCons;   Link=JSET;      KK=1; }
   else
   { "set externally" Link=LKAR P2;   KK=1; }
 
   LKAR P2=Link;  J=J0+5*KK;  If (Cname(J-1:J-1)='*' | Link<=0) Return;
}
else { LINK=LKAR P2 }
                                    "  search requested level "
Lm=LENOCC(Cname);  Check Lm>=J+3;
 
:Search_level: Loop
{ J=J0+5*KK;  KK+=1;  LinkUp=Link;  NS=IQ(LinkUp-2);
  Cnam=Cname(J:J+3);  Del=Cname(J+4:J+4);  If(J+4>Lm) Del='*';
  NV1=0; NV=NVL(KK);  JL=NS+1;  II=1;
  IF (NV==0 & Npar>0) NV=BIG       " 0 means the free element "
                                   "   Find structural link   "
  :Check_link: Do IL=1,NS
  {  Link=LQ(LinkUp-IL);   If Link==0 { JL=min(IL,JL); Next; }
     Check Inam==IQ(Link-4);     JL=IL
     :Linear_search: do II=2,NV+1
     { NV1=IQ(Link-5);  If (NV1==NV) Break;  If (NV1> NV) GOTO :new_bank:
***
       * on CHAIN entry: last item, no links, no next bank:
*      im=AgMODE('REBANK_pack_bank_groups_together',iam,1)
*      If (ii==2 & Nv==Big & Del=='*' & LQ(Link-1)==0 & LQ(Link)==0)
       If (ii==2 & Del=='*' & LQ(Link-1)==0 & LQ(Link)==0)
       {  Nd=IQ(Link-1);  Del='.';  kk-=1;  Break :Search_level:; }
***
       JL=0;  LinkUP=Link;  Link=LQ(Link);   If (Link==0) GOTO :new_bank:
     } Nd=IQ(Link-1);       GOTO :Next_level:
  }
                                    "   create a new bank   "
  :new_bank: Link=0; IF Npar>0
  { IF (JL>NS) Call MZPUSH (IrbDIV,LinkUp,MM,0,' ')
    IF Del#'/' & Npar<BIG { Leng=Npar; IOD=IOX; } else { Call RBFIND; }
 
    Call MZBOOK (IrbDIV,Link,LinkUp,-JL,Cnam,MM,MM,Leng,IOD,0);
    if NV<BIG {IQ(link-5)=NV} else {IQ(link-5)=NV1+1};   Nd=0;
  }
  :Next_level: If (Del!='/' | Link==0) Break
}
                    "   end of request chain, copy and update LAST pointers "
  Leng=Iabs(Npar);  If (Leng==BIG) Call RBFIND;
  Ia=0;  Ie=Leng;
  If Del=='.'
  {  kk+=1; Ia=Nd; If (NVL(kk)>0) Ia=Leng*(NVL(kk)-1); Ie=Ia+Leng; II=Ie/Leng;
     "print *,' Packing kk,NVL,leng,ia,ie,ii = ',Cnam,kk,NVL(kk),leng,ia,ie,ii"
  }
  If Npar>0 & Link>0
  {  Need=Ie-IQ(Link-1); " If Need>leng { Err Ie,Nd; } "
     If (Need>0)   Call MZPUSH(IrbDIV,Link,0,NEED,' ')
     if (Del=='.') IQ(Link-5)=-Ie/Leng
  }
  IQUEST(1)=0
END
 
 
+DECK,RBDEF,T=geant.
*CMZ :  1.00/00 07/09/95  19.44.56  by  Pavel Nevski
*-- Author :    Pavel Nevski
********************************************************************
*                                                                  *
      subroutine   R B D E F  (CNAME,FIRST,LAST,FORM,COMMENT)
*                                                                  *
********************************************************************
+CDE,TYPING,GCBANK,RBBANK. - Reconstruction bank access variables
*
      CHARACTER*(*) CNAME,FORM
      INTEGER       FIRST,LAST,COMMENT,LOCF,I,J
 
*   - FIND PLACE
      IF (LU==0) LU=6
      CNAM=CNAME(1:4)
*   - names will be ordered in the table
      Do J=1,NDD { IF (DDL(1,J)>INAM) Break; }
 
*   - is there a free place left ?
      IF NDD>NDDMAX
      { OUTPUT CNAME; (' RBDEF Fatal Error - lack of space, Bank=',A4); STOP }
 
*   - shift upper part of the table
      DO I=NDD,J,-1 {  CALL UCOPY(DDL(1,I),DDL(1,I+1),LDD) }
      NDD=NDD+1
 
*   - STORE a DDL line
      DDL(1,J)=INAM
      DDL(2,J)=LOCF(FIRST)-LOCF(IQ)
      DDL(3,J)=LOCF(LAST)-LOCF(FIRST)+1
      CALL MZFORM(CNAME,FORM,DDL(4,J))
      DDL(5,J)=COMMENT
*
      END
 
+DECK,RBGET,T=geant.
*CMZ :  1.30/00 10/01/97  07.02.21  by  Pavel Nevski
*CMZ :  1.00/00 07/09/95  19.30.39  by  Pavel Nevski
*-- Author :    Pavel Nevski
********************************************************************
*                                                                  *
               function   R B G E T  (CNAME,NVL)
*                                                                  *
* Modifications:                                                   *
* PN, 27/11/96 - counting access redone. Result is always >=0      *
********************************************************************
+CDE,TYPING,GCBANK,RBBANK. - Reconstruction bank access variables
*
      CHARACTER CNAME*(*)
      INTEGER RBGET,NVL(*),LINK,IA,L
*
      CALL REBANK (CNAME,NVL,-BIG,LINK,IA)
*
*     Special counting request (last NVL = 0)
      IF NVL(KK)==0
      { L=Link
        If L>0&Ia>0 { RBGET=II-1 " row count" }
        ELSE        { RBGET=0; while L>0 { RBGET+=1; L=LQ(L) }}
        Return
      }
*     CHECK window ACCESS  (bank access successful):
      RBGET=-1;      Check LINK>0
      RBGET=0;       Check IADR!=0
*     DATA READY:
      L=MIN(IQ(LINK-1)-IA,LENG);       RBGET=L
      IF (L>0) CALL UCOPY (IQ(LINK+1+IA),IQ(IADR+1),L)
*
      END
 
+DECK,RBPUT,T=geant.
*CMZ :  1.30/00 17/07/96  18.51.59  by  Pavel Nevski
*CMZ :  1.00/00 07/09/95  22.43.41  by  Pavel Nevski
*-- Author :    Pavel Nevski
********************************************************************
*                                                                  *
                 function    R B P U T  (CNAME,NVL)
*                                                                  *
********************************************************************
+CDE,TYPING,GCBANK,RBBANK. - Reconstruction bank access variables
*
      CHARACTER CNAME*(*)
      INTEGER   RBPUT,NVL(*),LINK,IA
 
*     possible error - writing out of chain
      CALL REBANK (CNAME,NVL,BIG,LINK,IA);     RBPUT=-1
      Check LINK>0 & IADR!=0
 
*     DATA READY
      CALL UCOPY (IQ(IADR+1),IQ(LINK+1+IA),LENG)
*     Special counting request ? (Last NVL = 0)
      RBPUT=LENG;     IF (NVL(KK)==0) RBPUT=II
      END
 
 
+DECK,rbdrop,T=geant.
*CMZ :  1.30/00 17/07/96  18.51.59  by  Pavel Nevski
*CMZ :  1.00/00 19/11/95  23.54.52  by  Pavel Nevski
*-- Author :    Pavel Nevski
********************************************************************
*                                                                  *
               subroutine   R B D R O P  (CNAME,NVL)
*                                                                  *
* Modifications:       ReBANK(..Len=0..) ->  No RBDEF call needed  *
********************************************************************
+CDE,TYPING,GCBANK,RBBANK. - Reconstruction bank access variables
*
      CHARACTER CNAME*(*)
      INTEGER   NVL(*),LINK,IA
*
      CALL REBANK (CNAME,NVL,0,LINK,IA)
*
      Check LINK>0 & IADR!=0
      Check NVL(KK)>0 & IA==0
      CALL  MZDROP(IrbDIV,Link,' ')
*
      END
 
+DECK,rbpushd,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 05/06/96  14.16.44  by  Pavel Nevski
*CMZU:  1.00/01 06/01/96  21.35.37  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/96
************************************************************************
      SUBROUTINE   R B P U S H D
*                                                                      *
* Description : save a default directory into the RB stack             *
*                                                                      *
************************************************************************
+CDE, TYPING,GCUNIT,GCBANK,SCLINK,RBBANK.
      INTEGER          Nbp,IP1STACK,    IP2STACK,    IEND,IDSTACK
      COMMON /RBSTACK/ Nbp,IP1STACK(20),IP2STACK(20),IEND,IDSTACK(20)
      Logical          First/.true./
*
   If (First) then
       First=.false.
       Call MZLINK(IxStor,'RBSTACK',IP1STACK,IP1STACK,IEND)
   endif
*
   If (Nbp<20) then
      Nbp+=1; IP1STACK(Nbp)=LKARP1; IP2STACK(Nbp)=LKARP2; IDSTACK(Nbp)=IrbDiv;
   else
      <w>;(' RBPUSHD Error: link stack overflow, default bank may be lost')
   endif
*
      END
 
 
+DECK,rbpopd,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 05/06/96  14.31.30  by  Pavel Nevski
*CMZU:  1.00/01 06/01/96  21.35.37  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/96
************************************************************************
      SUBROUTINE   R B P O P D
*                                                                      *
* Description : restore default directory from the RB stack            *
*                                                                      *
************************************************************************
+CDE, TYPING,GCUNIT,GCBANK,SCLINK,RBBANK.
      INTEGER          Nbp,IP1STACK,    IP2STACK,    IEND,IDSTACK
      COMMON /RBSTACK/ Nbp,IP1STACK(20),IP2STACK(20),IEND,IDSTACK(20)
*
   If (Nbp>0) then
      LKARP1=IP1STACK(Nbp); LKARP2=IP2STACK(Nbp); IrbDiv=IDSTACK(Nbp); Nbp-=1;
   else
      <w>;(' RBPOPD Error: link stack empty, default bank may be lost')
   endif
*
      END
 
 
+deck,aslsetba,T=geant.
*CMZ :  1.00/00 03/10/95  18.17.59  by  Pavel Nevski
*-- Author :
********************************************************************
*                                                                  *
            subroutine   ASLSETBA (CHDET,CBank,NPAR,PAR)
*                                                                  *
*     Put CBank parameter bank for detector CHDET into ZEBRA       *
*     Input:  CHDET - detector name                                *
*             CBank - parameter bank name                          *
*             NPAR  - number of parameters to store (counting PAR1)*
*                     If it exceeds the existing bank length,      *
*                     the bank is pushed to the length needed      *
*             PAR   - array of parameters, declared integer not to *
*                     corrupt (possibly) formatted banks           *
*                                                                  *
* Modifications:                            * 21/01/94 - P.Nevski  *
*    If the bank has been previously created by a datacard input   *
*    ( in this case its first word is always DUMMY=-787878)        *
*    only the dummy(undefined) words are rewritten by PAR values.  *
*    VERY useful! datacards may be read before bank definition but *
*    still their input overwrites default definitions called later *
********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
*
      CHARACTER*(*) CHDET,CBank
      INTEGER       NPAR,LdetP,I,PAR(Npar)
      REAL          DUMMY/-787878/
*
    Call ASLDETBA (CHDET,CBank,Npar,LdetP);      Check LdetP>0
    IF  Q(LdetP+1)==DUMMY
         {  DO  I=1,ABS(Npar) { IF (Q(LdetP+I)==DUMMY) IQ(LdetP+I)=PAR(I)}}
    ELSE {  Call UCOPY(PAR,Q(LdetP+1),ABS(Npar)) }
    END
 
+deck,aslgetba,T=geant.
*CMZ :  1.00/00 03/10/95  18.17.59  by  Pavel Nevski
*-- Author :    Pavel Nevski
********************************************************************
*                                                                  *
          subroutine    ASLGETBA (CHDET,CBank,NPMAX,Npar,PAR)
*                                                                  *
*     Get CBank parameter bank for detector CHdet from ZEBRA       *
*     Input:  CHdet - detector name                                *
*             CBank - parameter bank name                          *
*             NPMAX - maximum number of parameters to return       *
*     Output: Npar  - number of parameters returned(including PAR1)*
*             PAR   - array of parameters,,declared integer not to *
*                     corrupt (possibly) formatted banks           *
*                                                                  *
* Modifications:  Skip empty words ( DUMMY=Nothing!)     10.10.93  *
********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
*
      INTEGER       NPMAX,Npar,LdetP,I,PAR(NPmax)
      REAL          DUMMY/-787878/
      CHARACTER*(*) CHdet,CBank
      SAVE          LdetP
*
* this is not completely correct because LdetP should be a protected link
* saved somewhere in SCLINKs. Dont know yet what to do.     - PN 11.05.95
   Npar=0
   IF NPMAX>0 { "first bank " Call ASLDETBA (CHdet,CBank,0,LdetP) }
   ELSE       { " next bank " If  (LdetP>0)  LdetP=LQ(LdetP)      }
*
   Check " if the bank is there"  LdetP>0
   Npar=MIN(IQ(LdetP-1),ABS(NPMAX))
   DO I=1,Npar  { IF (Q(LdetP+I)!=DUMMY) PAR(I)=IQ(LdetP+I) }
   END
 
+deck,asldetba,T=geant.
*CMZ :  1.30/00 28/07/96  23.49.57  by  Pavel Nevski
*CMZ :  1.00/00 03/10/95  18.17.59  by  Pavel Nevski
*-- Author :    Pavel Nevski
*********************************************************************
*                                                                   *
         subroutine    ASLDETBA (CHdet,CBank,Npar,LdetP)
*                                                                   *
* This routine gives users access to DET* banks associated with DETE*
* Input: CHdet - 4-character detector name,                         *
*        CBank - 4-character bank name (starting with DET normally) *
*        Npar  - #0 - this is a request to store parameters:        *
*                  >0 create or rewrite single bank (first)         *
*                  <0 new bank is added in a linear structure       *
*              -  0 - request to get a link to an existing bank     *
* Output:LdetP - if >0 - link to the appropriate bank               *
*                                                                   *
* Modifications: More protection put to creat/extend bank - 03.09.93*
*                New words in bank are filled with DUMMY  - 10.10.93*
*                Order of banks in a linear chain changed - 15.02.94*
*                Use SHUNT to free first link for DETP    - 28.07.96*
*********************************************************************
+CDE,TYPING,GCBANK,SCLINK,GCUNIT.
*CDE,SLDBNK. - Slug auxilary common for SLDETBA routine
      CHARACTER*4  CHFOR
      INTEGER      IOWDS
      COMMON /SLDBNK/ CHFOR,IOWDS(16)
*
      INTEGER      Npar,Mpar,IND,LDETE,LdetP,NEED,NS,IL,JL,NF,INAM,LOLD,I,N
      CHARACTER*4  CHdet,CBank
      REAL         DUMMY/-787878/
*
  LdetP=0
  Mpar=ABS(Npar)
  Call ASLDETN(CHdet,IND)
  IF IND<=0          " the Faculty is not yet booked "
  {"<w> CHdet;(' ASLDETBA: Detector ',a4,' not found in DETM bank !');" return}
*
  LDETE=LQ(LKDETM-IND)
  IF LDETE==0        " same check - technical error  "
  { <w> CHdet,Ind;(' ASLDETBA: bank for ',a4,' not found at index',i5); return}
 
* Try to find existing data set and store input data in it, or get an emty link
  NS=IQ(LDETE-2); NF=0;     Call UCTOH(CBank,INAM,4,4)
  DO IL=1,NS                " Check structural links "
  {  LdetP=LQ(LDETE-IL); IF (LdetP==0 & NF=0) NF=IL;
     IF (LdetP>0 & IQ(LdetP-4)==INAM) GO TO :f:
  }
 
* Bank is not found: if this is a reading request - quit, else book a new link
  LdetP=0;  IF (Mpar==0) return;
  IF NF==0    { IL=NS+1;  Call MZPUSH(IxCONS,LDETE,2,0,' ') }
  else        { IL=NF  }
  IF CBank=='DETP' & IL!=1  "special case - always the first bank"
  {  DO I=IL,2,-1 " {LQ(LDETE-i)=LQ(LDETE-(i-1))}; "
     { Call ZSHUNT(IxCons,LQ(LDETE-(i-1)),LDETE,-IL,1) }
     LQ(LDETE-1)=LdetP;  IL=1
  }
*
:f: IF "bank already exist" LdetP>0 & "it is the first bank" Npar>=0
    {  LOLD = IQ(LdetP-1);        NEED = Mpar-LOLD
       IF (NEED>0) Call MZPUSH(IxCONS,LdetP,0,NEED,' ')
    }
    else " create a new bank (with a required format) "
    {  LOLD=0;         NEED=Mpar;          JL=-IL;        N=1
      " if a linear chain, insert it AT THE END ! (pln, 15.02.94) "
       while Npar<0 & LdetP>0 { JL=0; LDETE=LdetP;  LdetP=LQ(LdetP); N+=1; }
       IF (CHFOR!=CBank | IOWDS(1)==0) IOWDS(1)=3
       Call MZBOOK(IxCONS,LdetP,LDETE,JL,CBank,0,0,Mpar,IOWDS,0)
       If (LdetP>0) IQ(LdetP-5)=N
    }
* Fill new words in the bank with DUMMY value
  IF NEED>0  {  DO I=LOLD+1,Mpar { Q(LdetP+I)=DUMMY } }
   END
 
 
+DECK,ASLDETN,T=geant.
*CMZ :  1.00/00 03/10/95  18.17.59  by  Pavel Nevski
*-- Author :    R. DeWolf   15/07/91
**********************************************************************
*                                                                    *
                SUBROUTINE  ASLDETN(CHDET,IDET)
*                                                                    *
* Given a 4-character detector name, return a user detector number   *
* which is the link number in DETM for the desired DETE bank.        *
**********************************************************************
+CDE,TYPING,GCBANK,SCLINK.
      CHARACTER*(*) CHDET
      INTEGER       IDET
                    IDET=0
      IF (LKDETM>0) CALL GLOOK(CHDET,IQ(LKDETM+1),IQ(LKDETM-1),IDET)
      END
 
 
+PATCH,GEANT3. ================================================================
*CMZ :  1.00/00 19/12/95  09.59.59  by  G. Poulard
+DECK,MAIN.
*CMZ :          25/11/97  09.57.18  by  Pavel Nevski
*-- Author :
C_PLN_20-oct-94v_ux_2.
CUNIT(9) ANO(10) SBKK(11) CRS(12) MDEF(13) MINP(14) FRT(15) LABL(16)
CMERR(17) INDF(18) SEQN(19) TYP(20) LIST(21) MCOM(22) NEST(23) NSCN(24)
CPCOM(25) LAZY(26) MRKL(27) SFLG(28) MTRC(29) SEQF(30) DFLT(31) BASE(32)
CBLGR(33) FREE(34) LOMRK(35) TMX(36) NMX(37) RMX(38) INDC(39) MXX(40)
CNSIG(41) RSIG(42) TSIG(43) ISK(44) JSK(45) KSK(46) LSK(47) MSK(48)
CNSK(49) USK(50) YSK(51) EOF(52) INDM(53) HIST(54) QCHR(55) MOUT(56)
CFOUT(57) EOUT(58) MODE(59) LOX(60) LEFT(61) MCNT(62) MIF(63) KFE(64)
CKFB(65) KTE(66) KTB(67) NGN(68) SQ(69) EOL(70) GEO(71) XTR(72)
CUPLO(73) SPOK(74) ICUR(75) BLA(76) BAT(77) BLB(78) TRM(79) LPR(80)
CRPR(81) LSB(82) RSB(83) LCB(84) RCB(85) BQ(86) DQ(87) XTR(88)
CXTR(89) DED(90) NIL(91) LNS(92) RNS(93) RIF(94) LIF(95) RDQ(96)
CLDQ(97) RMB(98) LMB(99) ZRO(100) ALT(101) RNG(102) LIP(103) RIP(104)
CLQ(105) RQ(106) GA(107) GP(108) LGB(109) RGB(110) NAT(111) NLB(112)
CNEU(113) MF1(114) MF2(115) MF3(116) MF4(117) MF5(118) MF6(119) MF7(120)
CMF8(121)_MF9(122)_MFA(123)_MFB(124)_MFC(125)_MFD(126)
CNODE6 NSM100 NEGC20 NSX120 BFF132 MXU256000 MNXBF193043 HOME224521
CEVLIM1000 MXERR100 G1237 G0236 G2238 G11247 G13249 G14250
CR1405 R0404 R80484 R100504 T1537 T0536 T2538 T72608
CW1255_W0254_W7261_W72326_W73327_W80334
CSREG1 UREG201 GBF237 WBF255 RBF405 TBF537 ISET669 OSET769
CMORF869 TRT969 0CT1225 1CT1345 2CT1465 3CT1585 4CT1705 5CT1825
C6CT1945 7CT2065 8CT2185 9CT2305 ACT2425 BCT2545 CCT2665 DCT2785
CECT2905 FCT3025 GCT3145 HCT3265 ICT3385 JCT3505 ISK3625 JSK3675
CKSK3725_LSK3775_MSK3825_NSK3875_USK3975_YSK4025_PJT4075_MBF4175
C !ANNOTATE;
C-page 7----============================================================
C======------
      PROGRAM MAIN
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      EQUIVALENCE(O(1),B),(O(2),E),(O(3),R),(O(4),S), (O(5),V),(O(6),U),
     *(O(7),W),(O(8),X),(C,O(12)),(MXC,O(43)),(O(22),M)
C PLN - 20-03-93 - no binary output. LONG->LLONG
C Arguments of INITAL are:
C I/O  Units = Definitions, Listing, FORTRAN, Errors, GEANT3
C Then =  Starting FORTRAN label and Inital input line length
C when making cmz, select generate all and change C+SELF,'. '
C 25-05-95 LINF call in EXPAND commented out.
      CALLINITAL(30,6,5,6,7,0,120)
      IW=193043
      X=W
      STATUS=MUSER('INIT','     ',0)
      IF (STATUS.NE.1) THEN
         CALLMESAGE(15, 35, 0,0)
      END IF
      GOTO10
20    IF(O(54).GT.0) O(M+5)=O(M+5)+1
      CALLEXPAND(A)
30    IF (S.GT.U) THEN
         IF (O(23).GT.0) THEN
            CALLEXPAND(-1)
            GOTO30
         END IF
         S=224521
         U=S-1
         GOTO10
      END IF
      M=O(32)+O(S)
40    IF(O(M).EQ.0)GOTO50
      M=O(M)
      D=M+6
      MXD=O(M+3)
      O(74)=0
      MBK=0
      O(69)=0
      MQ=0
      DD=0
      A=0
      T=S
      V=S
      IF(O(29).GE.4) CALLMACTRC(2,D,MXD)
      IF(O(29).GE.4) CALLMACTRC(5,V,U+1)
      IF(O(54).GT.0) O(M+4)=O(M+4)+1
60    IF(V.GT.U)GOTO61
         IF (O(V).EQ.O(97)) THEN
            V=V+O(V+1)+3
            GOTO60
         END IF
         IF (MQ.EQ.0) THEN
            IF (O(D).EQ.O(113)) THEN
               O(S-2*(A+1)-1)=V
               O(S-2*(A+1)-2)=V
               D=D+2
               MQ=1
               DD=0
               IF(O(D-6).EQ.O(107))DD=D
               PP=D
               QQ=O(D-1)+D
               GOTO60
            END IF
            IF (O(D).EQ.O(84)) THEN
               IF (O(D+1).LE.100.AND.O(32).GT.1585) THEN
                  O(S-2*(A+1)-1)=V
                  O(S-2*(A+1)-2)=V
                  D=D+1
                  MQ=1
                  DD=0
                  IF(O(D-5).EQ.O(107))DD=D
                  PP=D
                  QQ=D
70                IF(O(QQ).EQ.O(85))GOTO71
                     QQ=QQ+1
                     IF (QQ.GT.MXD) THEN
                        CALLMESAGE(14, 20, 0,0)
                        GOTO40
                     END IF
                  GOTO 70
71                CONTINUE
                  GOTO60
               END IF
            END IF
            IF (O(D).EQ.O(V)) THEN
               IF (O(V).LT.O(107)) THEN
                  IF( O(105).EQ.O(D)) O(69)=O(69)+1
                  IF( O(106).EQ.O(D)) O(69)=O(69)-1
                  IF(O(D).EQ.O(99)) MBK=1
                  IF(O(D).EQ.O(98)) MBK=0
                  V=V+1
                  T=V
                  GOTO80
               END IF
            END IF
            IF (O(V).EQ.O(76)) THEN
               IF (O(69)+MBK.EQ.0) THEN
                  V=V+1
                  GOTO60
               END IF
            END IF
            IF (O(D).EQ.O(107)) THEN
               N1=O(D+1)
               N2=O(D+2)
               N3=O(D+3)
               D=D+4
               T=V
               O(S-2*(A+1)-1)=V
               O(S-2*(A+1)-2)=V
               A=A+1
               DD=D
               KC=0
               KB=0
               KP=0
               GOTO60
            END IF
         ELSE
            AA=V
            IF(O(69).NE.0)AA=0
            GOTO90
         END IF
100      IF (O(V).EQ.O(76)) THEN
            IF (MQ.EQ.1) THEN
               V=V+1
               GOTO60
            END IF
         END IF
         IF(DD.EQ.0)GOTO40
         IF (O(74).GT.0) THEN
            IF (O(DD-5).EQ.O(107)) THEN
               O(74)=0
               A=A-1
               GOTO90
            END IF
         END IF
110      CONTINUE
            IF (O(T).EQ.O(97)) THEN
               T=T+O(T+1)+3
               GOTO110
            END IF
C       PN, 24.11.97
            IF(O(T).EQ.O(106))GOTO40
            IF (MBK.GT.0) THEN
120            IF( O(99).EQ.O(T)) MBK=MBK+1
               IF( O(98).EQ.O(T)) MBK=MBK-1
               IF (MBK.EQ.0) THEN
                  V=T
                  O(S-2*(A)-2)=V
                  GOTO111
               END IF
               T=T+1
               IF(T.GT.U)GOTO40
               GOTO120
            END IF
            IF (O(T).EQ.O(105)) THEN
               NB=1
130            IF(NB.EQ.0)GOTO131
                  T=T+1
                  IF(T.GT.U)GOTO40
                  IF( O(105).EQ.O(T)) NB=NB+1
                  IF( O(106).EQ.O(T)) NB=NB-1
               GOTO 130
131            CONTINUE
            END IF
            IF (O(69).EQ.0) THEN
               IF( O(84).EQ.O(T)) KC=KC+1
               IF( O(85).EQ.O(T)) KC=KC-1
               IF(KC.LT.0)GOTO40
               IF (N1.GT.0) THEN
                  IF(38.EQ.O(T)) KP=KP+1
                  IF(46.EQ.O(T)) KP=KP-1
                  IF(KP.LT.0)GOTO40
               END IF
               IF (N2.GT.0) THEN
                  IF( O(82).EQ.O(T)) KB=KB+1
                  IF( O(83).EQ.O(T)) KB=KB-1
                  IF(KB.LT.0)GOTO40
               END IF
               IF (N3.GT.0) THEN
                  IF(O(T).EQ.O(79))GOTO40
               END IF
            END IF
            T=T+1
            IF (T.GT.U) THEN
               IF(O(15).EQ.1)GOTO40
               GOTO10
            END IF
            IF (KC+KP+KB.EQ.0) THEN
               IF(MQ.EQ.0) D=DD
140            V=T
               O(S-2*(A)-2)=V
               GOTO111
            END IF
         GOTO 110
111      CONTINUE
         GOTO60
150      IF(DD.NE.0)O(S-2*(A)-2)=T
         A=A+1
         IF(AA.NE.0)O(S-2*(A)-1)=AA
         O(S-2*(A)-2)=V
         D=Q
         MQ=0
80       D=D+1
         IF(D.GE.MXD)GOTO20
      GOTO 60
61    CONTINUE
160   IF(O(15).EQ.1)GOTO40
      IF (S.EQ.U) THEN
         S=224521
         O(S)=O(U)
         U=S
      END IF
10    O(55)=O(76)
C   IF(MTRCg1) PRINT *,' *** in QUE C,U=',C,U;
C            m a i n    i n p u t   l o o p
      KX=0
170   CONTINUE
         U=U+1
         IF(U.GT.256000) CALLMESAGE(15, 1, 0,0)
         O(U)=O(C)
         C=C+1
         IF(C.GT.O(43))CALLNXTCRD
C      IF(MTRCg1) PRINT *,' input ',CHAR(.(.U+MNOSET));
         IF (O(U).EQ.O(84)) THEN
            O(55)=O(U)
            KX=1
180         IF(KX.EQ.0)GOTO181
C          IF(MTRCg1&.Un' ') PRINT *,'   put ',CHAR(.(.U+MNOSET));
               U=U+1
               IF(U.GT.256000) CALLMESAGE(15, 1, 0,0)
               O(U)=O(C)
               C=C+1
               IF(C.GT.O(43))CALLNXTCRD
               IF( O(84).EQ.O(U)) KX=KX+1
               IF( O(85).EQ.O(U)) KX=KX-1
               IF (O(73).EQ.1) THEN
                  IF (52.LE.O(U) .AND. O(U) .LE. 77) O(U)=O(U)-52+10
               END IF
C         lower TO UPPER
            GOTO 180
181         CONTINUE
            O(55)=O(76)
         END IF
         IF (O(U).EQ.O(87)) THEN
190         IF (O(26).NE.1) O(55)=O(87)
            O(U)=O(97)
            U=U+1
C        Open citation,
            Y=U
200         IF(O(C).EQ.O(87).OR.C.GT.MXC)GOTO201
               U=U+1
               IF(U.GT.256000) CALLMESAGE(15, 1, 0,0)
               O(U)=O(C)
               C=C+1
            GOTO 200
201         CONTINUE
C       now copy it and
            U=U+1
            O(U)=O(96)
            O(Y)=U-Y-1
            IF (O(Y).EQ.0) THEN
               U=U-2
               O(U)=O(76)
C       always close it.
            END IF
            IF (C.GT.MXC) THEN
               IF (O(26).EQ.1) THEN
                  O(55)=O(76)
                  CALLNXTCRD
                  GOTO10
               END IF
C          On EOL reset it
C         else
               CALLNXTCRD
               U=U+1
               GOTO190
            END IF
C       or continue,
C      else
            O(55)=O(76)
            C=C+1
            IF(C.GT.O(43))CALLNXTCRD
            GOTO10
C       otherwise done !
         END IF
         IF (O(U).EQ.O(86) .AND. O(28).GT.0) THEN
            O(55)=O(U)
            O(U)=O(105)
210         CONTINUE
               U=U+1
               IF(U.GT.256000) CALLMESAGE(15, 1, 0,0)
               O(U)=O(C)
               C=C+1
               IF(C.GT.O(43))CALLNXTCRD
               IF (O(U).EQ.O(86)) THEN
                  IF (O(C).NE.O(86)) THEN
                     O(U)=O(106)
                     O(55)=O(76)
                     GOTO211
C            else ''
                  END IF
                  C=C+1
                  IF(C.GT.O(43))CALLNXTCRD
               END IF
            GOTO 210
211         CONTINUE
         END IF
         IF (O(U).EQ.O(76)) THEN
            IF (S.NE.U) THEN
               IF(O(U-1).EQ.O(76)) U=U-1
            END IF
220         CONTINUE
               IF(C.EQ.MXC.OR.O(C).NE.O(76))GOTO221
               C=C+1
            GOTO 220
221         CONTINUE
         END IF
         IF (O(73).EQ.1) THEN
            IF (52.LE.O(U) .AND. O(U) .LE. 77) O(U)=O(U)-52+10
         END IF
C   lower TO UPPER
         IF (KX.EQ.0) THEN
            IF(O(U).EQ.O(79))GOTO171
            IF( O(82).EQ.O(U)) O(11)=O(11)+1
            IF( O(83).EQ.O(U)) O(11)=O(11)-1
         END IF
      GOTO 170
171   CONTINUE
      GOTO30
50    IF (O(23).GT.0) THEN
         X=X+1
         IF(X.GT.O(40)) CALLMESAGE(15, 3, 0,0)
         O(X)=O(S)
         S=S+1
         IF (O(X).EQ.O(92).AND.O(32).NE.1345) THEN
230         CONTINUE
               X=X+1
               IF(X.GT.O(40)) CALLMESAGE(15, 3, 0,0)
               O(X)=O(S)
               S=S+1
               IF(O(X).EQ.O(93))GOTO231
            GOTO 230
231         CONTINUE
         END IF
         GOTO30
      END IF
240   CONTINUE
         IF (O(S).EQ.O(79)) THEN
            IF (W.GE.IW) W=LINF (IW,W,15)
         ELSE IF (O(S).EQ.O(97)) THEN
            IF (O(68).EQ.0) THEN
               NERD=LINF(S+2,S+O(S+1)+1,12)
               S=S+O(S+1)+2
            END IF
         ELSE IF (O(S).EQ.O(92)) THEN
            O(24)=1
         ELSE IF (O(S).EQ.O(93)) THEN
            O(24)=0
         ELSE IF (O(68).EQ.0) THEN
            W=W+1
            O(W)=O(S)
            IF (O(W).EQ.O(105)) THEN
250            IF(O(W).EQ.O(106))GOTO251
                  W=W+1
                  S=S+1
                  O(W)=O(S)
               GOTO 250
251            CONTINUE
            END IF
         END IF
         S=S+1
         IF(S.GT.U .OR. O(24).EQ.0)GOTO241
      GOTO 240
241   CONTINUE
C   P, Q, V, U, AA   was   (PP,QQ,VV,IU,T )
      GOTO30
90    CS=0
      MFL=0
      O(74)=0
      VS=V
      O(45)=3675
      O(46)=3725
      P=PP
      Q=QQ
260   IF(P.GE.Q)GOTO261
         IF (O(VS).EQ.O(76)) THEN
            IF (VS.EQ.AA) THEN
               VS=VS+1
               AA=AA+1
               IF(VS.GT.U)GOTO160
               GOTO260
            END IF
         END IF
         IF (O(P).LE.100) THEN
            J = O(P)+1585
270         IF (O(J).EQ.0) THEN
               CALLMESAGE(14, 15, P,Q+1)
               GOTO280
            END IF
            J=O(J)
            R=P
            IF(O(54).GT.0) O(J+4)=O(J+4)+1
            PS=J+6
            QS=O(J+3)
            IF(O(29).GE.6) CALLMACTRC(2,PS,QS)
290         IF(PS.GE.QS)GOTO291
               IF(O(PS).NE.O(R))GOTO270
               PS=PS+1
               R=R+1
            GOTO 290
291         CONTINUE
            O(45)=O(45)+1
            O(O(45))=Q
            O(45)=O(45)+1
            O(O(45))=R
            IF(O(45).GT.3724)CALLMESAGE(15, 19, 0,0)
            P=O(J+2)+6
            Q=O(O(J+2)+3)
            IF(O(29).GE.4) CALLMACTRC(5,VS,U)
            IF(O(54).GT.0) O(J+5)=O(J+5)+1
         ELSE IF (O(P).LT.O(106)) THEN
            P=P+1
            JMP=O(P-1)-100
            GOTO(300,310,320,330,340),JMP
300         IF (MFL.EQ.0) THEN
               VS=O(O(46)-1)
            ELSE
               N=1
350            IF(N.EQ.0)GOTO351
                  IF( O(103).EQ.O(P)) N=N+1
                  IF( O(104).EQ.O(P)) N=N-1
                  P=P+1
                  IF(P.GT.Q)CALLMESAGE(14, 27, 0,0)
               GOTO 350
351            CONTINUE
               P=P-1
            END IF
            GOTO260
320         O(46)=O(46)+1
            O(O(46))=CS
            O(46)=O(46)+1
            O(O(46))=VS
            O(46)=O(46)+1
            O(O(46))=P
            IF(O(46).GT.3774)CALLMESAGE(15, 20, 0,0)
            CS=0
            GOTO260
330         P=P+2
            IF (MFL.EQ.1) THEN
               CS=CS+1
               IF (CS.LT.O(P-1)) THEN
                  P=O(O(46))
                  GOTO260
               END IF
            END IF
            IF(CS.GE.O(P-2))MFL=1
            IF( MFL.EQ.0 ) VS=O(O(46)-1)
            IF ((O(46).EQ.3725)) THEN
               CALLMESAGE(14, 17, 0,0)
               GOTO280
            END IF
            NUL=O(O(46))
            O(46)=O(46)-1
            NUL=O(O(46))
            O(46)=O(46)-1
            CS=O(O(46))
            O(46)=O(46)-1
            GOTO360
310         P=P+2
            MFL=0
            IF ((O(P-2).LE.O(VS)).AND.(O(VS).LE.O(P-1))) THEN
               MFL=1
               VS=VS+1
               IF(VS.GT.U)GOTO160
            END IF
            GOTO360
340         WS=VS
            MFL=1
            IF (O(P).EQ.O(76)) THEN
370            IF(O(WS).NE.O(76).OR.O(P).NE.O(76))GOTO371
                  WS=WS-1
                  P=P+1
               GOTO 370
371            CONTINUE
            END IF
380         IF(O(P).EQ.O(106))GOTO381
               IF(O(P).NE.O(WS).OR.WS.GT.U) MFL=0
               P=P+1
               WS=WS+1
            GOTO 380
381         CONTINUE
            P=P+1
            IF(MFL.EQ.1)VS=WS
360         IF(MFL.EQ.1)GOTO260
            IF(O(P).NE.O(101) .AND. O(P).NE.O(104))GOTO280
         ELSE
            CALLMESAGE(14, 19, P,Q+11)
            GOTO280
         END IF
      GOTO 260
261   CONTINUE
      IF (.NOT.(O(45).EQ.3675)) THEN
         P=O(O(45))
         O(45)=O(45)-1
         Q=O(O(45))
         O(45)=O(45)-1
         GOTO260
      END IF
CSUCCESSFULL
      O(74)=1
      V=VS
      IF(O(29).GE.6) CALLMACTRC(6,PP,QQ)
      GOTO150
280   O(74)=0
      GOTO100
      END
+DECK,expand.
*CMZ :          06/11/97  12.11.44  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE EXPAND (F)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
C F is the number of the macro arguments
      EQUIVALENCE(O(1),B),(O(2),E),(O(3),R),(O(4),S), (O(5),V),(O(6),U),
     *(O(7),W),(O(8),X)
      DATA KGN/0/,SEF/0/
Cif nested decrement nest, recover environment
      T=0
      IF (F.LT.0) THEN
         O(23)=O(23)-1
         IF(O(23).EQ.0) O(15)=SEF
         DO 21 K = 1,6
            O(K)=O(6+U+1-K)
21       CONTINUE
         J=O(O(O(51)))
         IF ((10.LE.J).AND.(J.LE.12 .OR. J.EQ.30)) THEN
            IF (J.EQ.10) THEN
               JV=NIB(X,16)
C         convert = ex number
            ELSE
               IF (J.EQ.30) THEN
                  JV=USER(W+1,X)
               ELSE
                  JV=LEXP(W+1,X)
               END IF
C      compute
            END IF
            IF (O(63).EQ.0) THEN
               IF (J.EQ.12) THEN
                  X=W+LLONG(W,JV,10,0)
C            if pending {IF} if 'c' convert to decimal
               ELSE
                  IF (J.NE.30) THEN
                     X=W+1
                     O(X)=JV
                  END IF
               END IF
C                                leave binary
            ELSE
               X=W
               O(63)=O(63)-1
               IF (JV.EQ.0) THEN
                  P=O(65)
                  Q=O(64)
C               otherwise           false pointers
               ELSE
                  P=O(67)
                  Q=O(66)
               END IF
C                                true pointers
               O(44)=O(44)+1
               O(O(44))=O(64)+1
               O(44)=O(44)+1
               O(O(44))=E
               IF(O(44).GT.3674)CALLMESAGE(15, 18, 0,0)
               B=P
               E=Q
C          stack the pointers on I stack
            END IF
         END IF
C    pop Y stack for for base and w
         NUL=O(O(51))
         O(51)=O(51)-1
         W=O(O(51))
         O(51)=O(51)-1
         O(32)=O(O(51))
         O(51)=O(51)-1
C    not nested. find and  print Macro COMMENTS - commented out by PN
      ELSE
C    C=S; UNTIL C>V { IF .C==LDQ { NERD=LINF(C+2,C+.(C+1)+1,'C'); C=C+.(
C   C+1)+2;} +C; }
C    IF (MTRC>0) PRINT *,' F,S,V=',F,S,V;
C    save no.args, set cielX, get rep ptrs
         O(S-1)=F
         O(40)=S-2*F-3
         R=O(O(22)+2)
         B=R+6
         E=O(R+3)
C    increment count, if too big turn on trace
         R=O(R)
         O(62)=O(62)+1
         IF (O(62).GT.1000) THEN
            CALLMESAGE(14, 4, 0,0)
            O(29)=2
         END IF
         IF(O(29).GE.2) CALLMACTRC(22,O(22),S)
         IF (O(23).EQ.0) X=W
C   if ind print MATCHED...
C  IF(MTRCg1) PRINT *,'      begin main replacement loop ,B,E=',B,E;
Cbegin main replacement loop
      END IF
30    CONTINUE
C    IF(MTRCg1) PRINT *,' ===> ',CHAR(.(.B+MNOSET));
40       IF(B.GE.E)GOTO41
            IF (O(B).LT.O(107) .OR. O(B).EQ.O(113)) THEN
               X=X+1
               IF(X.GT.O(40)) CALLMESAGE(15, 3, 0,0)
               O(X)=O(B)
               B=B+1
               GOTO40
            END IF
            B=B+1
C       IF(MTRCg1) PRINT *,'  ==> ',CHAR(.(.B+MNOSET));
            JMP=O(B-1)-O(106)
            GOTO(50,60,70,80),JMP
60          IF ((1.LE.O(B)).AND.(O(B).LE.O(S-1))) THEN
               A=O(S-2*(O(B))-1)
               N=O(S-2*(O(B))-2)
90             IF(A.GE.N)GOTO91
                  X=X+1
                  IF(X.GT.O(40)) CALLMESAGE(15, 3, 0,0)
                  O(X)=O(A)
                  A=A+1
               GOTO 90
91             CONTINUE
               GOTO100
            END IF
            CALLMESAGE(15, 4, B,E)
50          IF (O(B).EQ.12) THEN
C          IF(MTRCg0) PRINT *,'   => ',CHAR(.(.B+MNOSET));
               B=B+1
               IF (O(B).EQ.23) THEN
                  IF (O(68).EQ.0) THEN
                     KGN=1
                     O(68)=1
                  ELSE
                     KGN=KGN+1
                  END IF
               ELSE IF (O(B).EQ.16) THEN
                  IF (O(68).EQ.1) THEN
                     KGN=KGN+1
                  END IF
               ELSE IF (O(B).EQ.14) THEN
                  KGN=KGN-1
                  IF(KGN.LE.0) O(68)=0
               END IF
               IF (O(71).NE.0) THEN
                  IF(O(68).EQ.0) O(32)=1705
                  IF(O(68).NE.0)O(32)=1225
               END IF
               GOTO100
            END IF
            IF(O(68).EQ.0)CALLKAT
            GOTO100
70          IF (O(B).EQ.O(107)) THEN
C          IF(MTRCg1) PRINT *,'   => ',CHAR(.(.B+MNOSET));
               B=B+1
               IF (O(B).EQ.16) THEN
                  B=B+1
                  IF (1.GT.O(B).OR.O(B).GT.O(S-1) ) CALLMESAGE(15, 4, B,
     *            E)
                  X=X+LLONG(X,O(S-2*(O(B))-2)-O(S-2*(O(B))-1),10,0)
                  IF(X.GT.O(40))CALLMESAGE(15, 3, 0,0)
                  B=B+2
                  GOTO40
               END IF
               IF (O(B).EQ.13) THEN
                  B=B+1
                  T=1
110               CONTINUE
                     IF( O(109).EQ.O(B)) T=T+1
                     IF( O(110).EQ.O(B)) T=T-1
                     IF(T.EQ.0)GOTO111
                     X=X+1
                     IF(X.GT.O(40)) CALLMESAGE(15, 3, 0,0)
                     O(X)=O(B)
                     B=B+1
                  GOTO 110
111               CONTINUE
                  GOTO100
               END IF
               IF (O(B).EQ.15) THEN
                  X=X+1
                  O(X)=O(97)
                  X=X+1
                  KRAP=X
                  KRAQ=O(23)
                  GOTO100
               END IF
            END IF
            O(23)=O(23)+1
            IF(O(23).EQ.1)SEF=O(15)
            O(15)=1
            O(51)=O(51)+1
            O(O(51))=O(32)
            O(51)=O(51)+1
            O(O(51))=W
            O(51)=O(51)+1
            O(O(51))=B
            IF(O(51).GT.4074)CALLMESAGE(15, 34, 0,0)
            W=X
            GOTO100
80          IF (KRAP.NE.0.AND.KRAQ.EQ.O(23)) THEN
               X=X+1
               O(X)=O(96)
               O(KRAP)=X-KRAP-1
               KRAP=0
               GOTO40
            END IF
            DO 121 K = 1,6
               O(O(40)-K)=O(K)
121         CONTINUE
            U=O(40)-7
            V=U+1
            Z=O(O(51))
            Y=O(Z)
            IF(O(Z+2).EQ.O(105)) Y=0
            IF((9.LT.Y).AND.(Y.LT.16.OR.Y.EQ.30)) Y=O(31)
            IF(0.GT.Y.OR.Y.GE.8) CALLMESAGE(15, 17, B,E)
            O(32)=Y*120+1225
            GOTO41
100         B=B+1
         GOTO 40
41       CONTINUE
         IF(O(23).GT.0)GOTO31
         IF ((O(44).EQ.3625)) THEN
            IF(R.LE.0)GOTO31
            B=R+6
            E=O(R+3)
            R=O(R)
         ELSE
            E=O(O(44))
            O(44)=O(44)-1
            B=O(O(44))
            O(44)=O(44)-1
         END IF
      GOTO 30
31    CONTINUE
C IF(MTRCg1) PRINT *,' end main replacement loop  ,B,E=',B,E;
      IF(O(29).GE.2) CALLMACTRC(33,W,X)
130   IF(X.LE.W)GOTO131
         V=V-1
         O(V)=O(X)
         X=X-1
      GOTO 130
131   CONTINUE
      S=V
99999 RETURN
      END
+DECK,KAT.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE KAT
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      EQUIVALENCE(O(1),B),(O(2),E),(O(3),R),(O(4),S), (O(5),V),(O(6),U),
     *(O(7),W),(O(8),X)
      EQUIVALENCE (L,O(47)),(M,O(48))
      IF(O(B).LT.19.OR.O(B).GT.30) CALLMESAGE(15, 7, B-2,E)
      B=B+1
      JMP=O(B-1)-18
      GOTO(20,30,40,50,60,70,80,90,100,110,120,130),JMP
20    T=O(B)+78
      X=X+1
      O(X)=O(T)
      GOTO 99999
30    CALLKRUNC(0)
      GOTO 99999
40    IF (O(B).EQ.12) THEN
         X=X+LLONG(X,O(L-O(B+1))+O(B+2),10,1)
         B=B+2
         GOTO 99999
      END IF
      IF (O(B).EQ.16) THEN
         O(16)=O(16)+10
         X=X+LLONG(X,O(16),10,0)
         GOTO 99999
      END IF
      IF (O(B).EQ.28) THEN
         B=B+1
         O(47)=O(47)+1
         O(O(47))=NIB(X,10)
         IF(O(47).GT.3824)CALLMESAGE(15, 21, 0,0)
         GOTO140
      END IF
      IF (O(B).EQ.30) THEN
         B=B+1
         IF(O(B).EQ.1)O(L-1)=O(L)
         L=L-1
         IF (L.LT.3775) THEN
            CALLMESAGE(14, 7, 0,0)
            L=L+1
         END IF
         GOTO150
      END IF
      CALLMESAGE(15, 7, B-2,E)
50    IF (O(B).EQ.28) THEN
         B=B+1
         O(48)=O(48)+1
         O(O(48))=O(B)
         IF(O(48).GT.3874)CALLMESAGE(15, 22, 0,0)
         GOTO 99999
      END IF
      IF (O(B).EQ.27) THEN
         B=B+1
         O(M)=O(B)
         GOTO 99999
      END IF
      IF (O(B).EQ.30) THEN
         X=X+1
         O(X)=O(M)
         M=M-1
         IF (M.LT.3825) THEN
            CALLMESAGE(14, 8, 0,0)
            M=M+1
         END IF
         GOTO 99999
      END IF
      CALLMESAGE(15, 7, B-2,E)
60    IBG=O(X)
      X=X-1+LLONG(X-1,IBG,10,1)
      GOTO 99999
70    CALLDEFINE(S)
      GOTO 99999
80    O(63)=1
      B=B+4
      O(67)=B+O(B-1)
      O(66)=B+O(B-2)
      O(65)=B+O(B-3)
      O(64)=B+O(B-4)
      B=B-1
      GOTO 99999
90    O(16)=O(16)+10
      O(47)=O(47)+1
      O(O(47))=O(16)
      IF(O(47).GT.3824)CALLMESAGE(15, 21, 0,0)
140   IF (O(B).EQ.1) THEN
         Z=O(L-1)
         O(L-1)=O(L)
         O(L)=Z
      END IF
150   IF(O(B).NE.1.AND.O(B).NE.0)STOP18
      GOTO 99999
100   IUNI=O(B)
      REWIND IUNI
      GOTO 99999
120   IF(O(29).GE.1) CALLMACTRC(22,O(22),S)
      B=B-1
      GOTO 99999
110   T=O(B)
      B=B+1
      IF ((0.LT.O(B)).AND.(O(B).LT.5)) THEN
         T=T+26*O(B)
         B=B+1
      END IF
      NBA=0
      GOTO160
130   T=201+O(B)
      B=B+1
      NBA=O(X)
      X=X-1
160   IF (O(B).EQ.43) THEN
         O(T)=O(T)+1
         GOTO 99999
      END IF
      IF (O(B).EQ.42) THEN
         O(T)=O(T)-1
         GOTO 99999
      END IF
      IF (O(B).EQ.41) THEN
         O(T)=O(X)
         X=X-1
         GOTO 99999
      END IF
      IF (O(B).EQ.12) THEN
         X=X+1
         O(X)=O(T)
         IF (NBA.GT.1) X=X-1+LLONG(X-1,O(T),NBA,1)
         GOTO 99999
      END IF
      CALLMESAGE(15, 7, B-3,E)
99999 RETURN
      END
+DECK,DEFINE.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE DEFINE(S)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      DIMENSION L(3)
      IF (O(S-2*(1)-1).EQ.O(S-2*(1)-2)) THEN
         CALLMESAGE(14, 1, 0,0)
         GOTO 99999
      END IF
      O(20)=O(31)
      IF ( O(S-2*(2)-1).NE.O(S-2*(2)-2) )O(20)=O(O(S-2*(2)-1))
      DO 21 K = 1,3
         A=O(S-2*(K)-1)
         T=O(S-2*(K)-2)
         N=A-1
         Z=0
30       IF(A.GT.T)GOTO31
            N=N+1
            O(N)=O(A)
            A=A+1
            IF (O(N).EQ.O(86)) THEN
               IF (K.EQ.3 .OR. O(28).GT.0) THEN
                  IF (Z.EQ.0) THEN
                     O(N)=O(105)
                     Z=1
                  ELSE
                     IF (O(A).EQ.O(86) .AND. A.LE.T) THEN
                        A=A+1
                     ELSE
                        O(N)=O(106)
                        Z=0
                     END IF
                  END IF
               END IF
            ELSE IF (O(N).EQ.O(76)) THEN
               IF (Z.EQ.0) THEN
40                IF(O(A).NE.O(76).OR.A.GE.T)GOTO41
                     A=A+1
                  GOTO 40
41                CONTINUE
               END IF
            ELSE IF (O(N).EQ.O(78)) THEN
               IF (O(A).EQ.O(78)) THEN
                  A=A+1
               ELSE
                  O(N)=O(108)
               END IF
            ELSE IF (O(N).EQ.O(77)) THEN
               IF (O(A).EQ.O(77)) THEN
                  A=A+1
               ELSE
                  O(N)=O(107)
               END IF
            END IF
            IF (O(33).EQ.0) THEN
               IF (K.EQ.3) THEN
                  IF(O(N).EQ.O(84))O(N)=O(109)
                  IF(O(N).EQ.O(85))O(N)=O(110)
               END IF
            END IF
         GOTO 30
31       CONTINUE
         O(S-2*(K)-2)=N
         L(K)=O(S-2*(K)-2)-O(S-2*(K)-1)
21    CONTINUE
      IF(O(20).LT.12 .OR. O(20) .GT.14)GOTO50
      B=O(S-2*(1)-1)
      E=O(S-2*(1)-2)
      IF (O(20).EQ.14) THEN
         M=1585+O(B)
      ELSE
         M=1705+O(B)
      END IF
60    IF (O(M).EQ.0) THEN
         IF (O(20).EQ.12) THEN
            O(20)=O(31)
            GOTO50
         END IF
         CALLMESAGE(14, 2, 0,0)
         GOTO 99999
      END IF
      M=O(M)
      P = M+6
      LP=O(M+3)-P
      IF(LP.NE.L(1))GOTO60
      A=B
70    IF(O(P).NE.O(A))GOTO71
         P=P+1
         A=A+1
         IF(A.GE.E)GOTO80
      GOTO 70
71    CONTINUE
      GOTO60
80    IF (O(20).NE.12) THEN
C   d-link template
         IF(O(M).NE.0)O((O(M))+1)=O(M+1)
         O(O(M+1))=O(M)
C   fix cat pointer
         C=O(M+2)
C   mark macro dead
C   d-link all cats
         O(M+2)=O(90)
90       IF(C.EQ.0)GOTO91
            O(C+2)=O(90)
            C=O(C)
         GOTO 90
91       CONTINUE
         IF(O(13).GT.0)CALLMACTRC(13,0,S)
         GOTO 99999
      END IF
      NEED= 6+L(3)
      IF(NEED.GT. 193042-O(34)) CALLKRUNC(NEED)
      C=O(M+2)
100   IF(O(C).EQ.0)GOTO101
         C=O(C)
      GOTO 100
101   CONTINUE
      O(C)=O(34)
      O(O(34))=0
      O(O(34)+1)=C
      O(O(34)+2)=O(91)
      O(O(34)+3)=O(34)+NEED
      O(34)=O(34)+NEED
      A=O(S-2*(3)-2)
      K=L(3)
      DO 111 J = 1,K
         O(O(34)-J)=O(A-J)
111   CONTINUE
      IF(O(13).GT.0)CALLMACTRC(12,0,S)
      GOTO 99999
50    NEED=L(1)+L(3)+2*6
      IF (NEED.GT.193042-O(34)) CALLKRUNC(2+NEED)
      A=O(S-2*(1)-1)
      Z=A+L(1)-1
      P=O(34)
      F=P+6
      I=F
120   IF(A.GT.Z)GOTO121
         O(F)=O(A)
         F=F+1
         A=A+1
      GOTO 120
121   CONTINUE
      IF (O(I).EQ.O(84) .AND. O(20).GT.2) THEN
         CALLMESAGE(14, 21, O(S-2*(1)-1),O(S-2*(1)-2))
         GOTO 99999
      END IF
      IF (O(I).GT.O(105)) THEN
         CALLMESAGE(14, 9, O(S-2*(1)-1),O(S-2*(1)-2))
         GOTO 99999
      END IF
      IF (0.GT.O(20).OR.O(20).GT.7) THEN
         CALLMESAGE(14, 12, O(S-2*(1)-1),O(S-2*(1)-2))
         GOTO 99999
      END IF
      I=O(I) + 1225 + O(20)*120
      O(P)=O(I)
      IF(O(P).NE.0)O((O(P))+1)=P
      O(P+1)=I
      O(I)=P
      O(P+2)=F
      O(P+3)=F
      O(F)=0
      O(F+1)=P+2
      O(F+3)=F+6+L(3)
      O(F+2)=O(91)
      R=F
      F=P+NEED
      E=O(S-2*(3)-2)
      K=L(3)
      IF (K.NE.0) THEN
         CALLDOIT(E-K,E)
         DO 131 J = 1,K
            O(F-J)=O(E-J)
131      CONTINUE
      END IF
      IF (O(13).GT.0) CALLMACTRC(15,P,R)
      O(34)= P +NEED
      O(60)=193042-O(34)
      O(61)=(100*O(60))/(193042-4175)
99999 RETURN
      END
+DECK,DOIT.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C----------------------------------------------------------------
      SUBROUTINE DOIT(A,Z)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      DIMENSION S(900)
      X=0
      T=Z
20    IF(T.LT.A)GOTO21
         IF (O(T).EQ.O(95)) THEN
            IF (O(T-1).EQ.O(94)) THEN
               S(X+1)=T+1
               S(X+2)=O(T)
               X=X+2
               T=T-1
            ELSE
               S(X+1)=T+1
               X=X+1
30             IF(O(T).EQ.O(107).AND.O(T+1).EQ.25)GOTO31
                  T=T-1
                  IF(T.LT.A)GOTO 99999
               GOTO 30
31             CONTINUE
               P=T+6
               O(P-1)= S(X)-P
               X=X-1
               IF (S(X).EQ.O(95)) THEN
                  O(P-4)= S(X-2)-P
                  O(P-3)= S(X-1)-P
                  O(P-2)= O(P-3)-2
                  X=X-3
               ELSE
                  O(P-2)=S(X)-P
                  O(P-3)=S(X)-P
                  O(P-4)=S(X)-P
                  X=X-1
               END IF
            END IF
         ELSE IF (O(T).EQ.O(94)) THEN
            S(X+1)= T
            X=X+1
         END IF
         T=T-1
      GOTO 20
21    CONTINUE
99999 RETURN
      END
+DECK,KRUNC.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE KRUNC(R)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      IF (O(35).NE.0) THEN
         M=O(35)
20       IF(M.EQ.O(34))GOTO21
            IF (O(M+2).GE.0) THEN
               IF(O(M).NE.0)O((O(M))+1)=O(M+1)
               O(O(M+1))=O(M)
            END IF
            O(M+2)=O(90)
            M=O(M+3)
         GOTO 20
21       CONTINUE
      END IF
      N=4175
      M=O(N+3)
      D=0
      O(O(34))=0
30    IF(N.EQ.O(34))GOTO31
         M=N
         N= O(M+3)
C    P=predecessor S=successor C=concatenation
         P=O(M+1)
         S=O(M)
         C=O(M+2)
         IF (C.EQ.O(90)) THEN
            D=D+ N-M
            GOTO30
         END IF
         IF (S.GT.0) O(S+1)=O(S+1)-D
         IF (C.GT.0) O(N+1)=O(N+1)-D
         O(P)=O(P)-D
         O(M+3)=O(M+3)-D
C   MOVE IT
         DO 41 I = M,N
            O(I-D)=O(I)
41       CONTINUE
      GOTO 30
31    CONTINUE
      O(34)=O(34)-D
      O(O(34))=0
      IF (R.GT.D)CALLMESAGE(15, 6, 0,0)
      O(60)=193042-O(34)
      O(61)=(100*O(60))/(193042-4175)
      IF(R.EQ.0)CALLMESAGE(13,1,D,0)
99999 RETURN
      END
+DECK,NIB.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      FUNCTION NIB(L,B)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      M=1
      N=0
20    IF(O(L).NE.O(76))GOTO21
         L=L-1
      GOTO 20
21    CONTINUE
30    IF(0.GT.O(L).OR.O(L).GE.B)GOTO31
         N=N+O(L)*M
         M=M*B
         L=L-1
      GOTO 30
31    CONTINUE
      IF (O(L).EQ.42) THEN
         L=L-1
         N=-N
      END IF
      NIB=N
99999 RETURN
      END
+DECK,LLONG.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      FUNCTION LLONG(LOC,NUM,B,IND)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      IF(O(68).NE.0)GOTO 99999
      N=IABS(NUM)
      L=LOC
      I=N/B
      J=1
      IF (IND.EQ.0) THEN
         L=L+1
         O(L)=O(76)
      END IF
20    IF(I.LE.0)GOTO21
         I=I/B
         J=J+1
      GOTO 20
21    CONTINUE
CCOUNT DIGITS IN EXPANSION
      IF (NUM.LT.0) THEN
         L=L+1
         O(L)=42
      END IF
      LLONG=L-LOC+J
30    CONTINUE
         K=N/B
         O(L+J)=N-K*B
         N=K
         J=J-1
         IF(J.LE.0)GOTO31
      GOTO 30
31    CONTINUE
99999 RETURN
      END
+DECK,N5.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      FUNCTION N5(L,M,K)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      J=537+4
      N5=NIB(J,10)
      IF (L.GT.N5.OR.N5.GT.M) THEN
         CALLMESAGE(14, 3, 0,0)
         N5=K
      END IF
99999 RETURN
      END
+DECK,USER.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      FUNCTION USER(A,Z)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      CHARACTER*132 IN,OUT
      DO 21 K = A,Z
         IN(K-A+1:K-A+1)=CHAR(O(769+O(K)))
21    CONTINUE
      LENOUT=LEN(OUT)
      STATUS=MUSER(IN(2:Z-A),OUT,LENOUT)
      IF (STATUS.NE.1) THEN
         CALLMESAGE(14, 30, A,Z+1)
         Z=A
         O(A)=36
      ELSE
         Z=A+LENOUT-1
         DO 31 K = A,Z
            O(K)=O(969+ICHAR(OUT(1+K-A:)))
31       CONTINUE
      END IF
      USER=1
99999 RETURN
      END
+DECK,LEXP.
*CMZ :          04/11/97  02.51.29  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      FUNCTION LEXP(A,Z)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      DIMENSION P(100)
      EQUIVALENCE(N,O(49)),( P(1),O(4075) )
      IF (O(A+1).EQ.O(105)) THEN
         LEXP=1
         B=A+1
         C=B+1
         NQ=1
         MXC=Z
20       CONTINUE
            IF( O(105).EQ.O(C)) NQ=NQ+1
            IF( O(106).EQ.O(C)) NQ=NQ-1
            IF(NQ.EQ.0)GOTO21
            C=C+1
            IF(C.GT.MXC) CALLMESAGE(15, 35, 0,0)
         GOTO 20
21       CONTINUE
         D=C+1
         E=D+1
         IF (O(E).NE.O(105)) THEN
            LONE=1
            MP=E
            MQ=Z
            MV=B+1
            MU=C
            IF (ISPEC(MP,MQ,MV,MU,LONE).NE.3) LEXP=0
         ELSE
30          IF(E.GT.Z-1)GOTO31
               IF(O(B).NE.O(E)) LEXP=0
               B=B+1
               E=E+1
            GOTO 30
31          CONTINUE
            IF(B.NE.D) LEXP=0
         END IF
         IF(O(D).EQ.91) LEXP=1-LEXP
         GOTO 99999
      END IF
      LEXP=0
      NFLG=0
      N=3875
      MNN=N+2
      O(N-1)=38
      O(N)=0
      B=A
40    IF(B.GT.Z)GOTO41
         IF ((0.LE.O(B)).AND.(O(B).LE.9)) THEN
            O(N)=0
            NFLG=1
50          IF(0.GT.O(B).OR.O(B).GT.9)GOTO51
               O(N)=10*O(N)+O(B)
               B=B+1
            GOTO 50
51          CONTINUE
         ELSE IF (O(B).EQ.O(76)) THEN
            B=B+1
         ELSE
            T=B
            IF ((10.LE.O(T)).AND.(O(T).LE.29)) THEN
               X=O(T)*O(T+1)
               T=T+2
               IF (O(T).EQ.29.OR.O(T).EQ.13) THEN
                  X=X+O(T)
                  T=T+1
               END IF
               X=X/20
               IF((10.LT.X).AND.(X.LT.33))GOTO60
               GOTO70
            END IF
            X=O(T)
            T=T+1
            IF (X.EQ.45.AND.O(T).EQ.45) THEN
               T=T+1
               X=36
            ELSE IF (X.EQ.91) THEN
               X=29
               IF (O(T).EQ.41) THEN
                  T=T+1
                  X=16
               END IF
            ELSE IF (X.EQ.87) THEN
               X=30
               IF (O(T).EQ.41) THEN
                  T=T+1
                  X=14
               END IF
            ELSE IF (X.EQ.41) THEN
               X=18
               IF (O(T).EQ.88) THEN
                  T=T+1
                  X=11
               END IF
            ELSE IF (X.EQ.88) THEN
               X=23
               IF (O(T).EQ.41) THEN
                  T=T+1
                  X=11
               END IF
            ELSE IF (X.EQ.(89)) THEN
               X=32
            ELSE IF (X.EQ.(90)) THEN
               X=13
            END IF
            IF(P(X).EQ.0)GOTO70
60          IF(X.LT.10.OR.X.GT.O(81) .OR. (X.EQ.O(81).AND.NFLG.EQ.0))
     *      GOTO70
            IF (P(X)/100.GT.P(O(N-1))/100.OR.X.EQ.O(80)) THEN
               NFLG=0
               O(49)=O(49)+1
               O(O(49))=X
               O(49)=O(49)+1
               O(O(49))=0
               IF(O(49).GT.3974)CALLMESAGE(15, 23, 0,0)
               B=T
               GOTO40
            END IF
            IF (N.EQ.MNN) THEN
               LEXP=O(N)
               GOTO 99999
            END IF
            K=P(O(N-1))
            NFLG=1
            JMP=K-((K/100)*100)-1
            GOTO(80,90,100,110,120,130,140,150,160,170,180,190,200,210,
     *      220),JMP
140         IF (O(N).EQ.0) THEN
               CALLMESAGE(14, 10, 0,0)
               GOTO70
            END IF
            O(N-2) = O(N-2) / O(N)
            GOTO230
150         O(N-2) = O(N-2) * O(N)
            GOTO230
130         O(N-2) = O(N-2) + O(N)
            GOTO230
120         O(N-2) = O(N-2) - O(N)
            GOTO230
160         O(N-2) = O(N-2) **O(N)
            GOTO230
80          O(N-2) = O(N)
            B=T
            GOTO230
110         O(N-2) = 1-O(N)
            GOTO230
190         IF(O(N-2) .NE. O(N))GOTO240
            GOTO250
200         IF(O(N-2) .EQ. O(N))GOTO240
            GOTO250
180         IF(O(N-2) .LE. O(N))GOTO240
            GOTO250
210         IF(O(N-2) .GT. O(N))GOTO240
            GOTO250
170         IF(O(N-2) .GE. O(N))GOTO240
            GOTO250
220         IF(O(N-2) .LT. O(N))GOTO240
            GOTO250
100         IF(O(N-2).EQ.1 .AND. O(N).EQ.1)GOTO240
            GOTO250
90          IF(O(N-2).EQ.1 .OR. O(N).EQ.1)GOTO240
            GOTO250
240         O(N-2)=1
            GOTO230
250         O(N-2)=0
230         N=N-2
         END IF
      GOTO 40
41    CONTINUE
70    CALLMESAGE(14, 23, A,Z+1)
99999 RETURN
      END
+DECK,ISPEC.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      FUNCTION ISPEC(PP,QQ,VV,IU,T)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      P=PP
      Q=QQ
      U=IU+1
      C=0
      M=0
      B=0
      V=VV
      O(45)=3675
      O(46)=3725
20    IF(P.GE.Q)GOTO21
         IF (O(V).EQ.O(76)) THEN
            IF (V.EQ.T) THEN
               V=V+1
               T=T+1
               IF(V.GT.U)GOTO30
               GOTO20
            END IF
         END IF
         IF (O(P).LE.100) THEN
            QQ=Q
            J = O(P)+1585
40          IF (O(J).EQ.0) THEN
               CALLMESAGE(14, 15, P,Q+1)
               GOTO50
            END IF
            J=O(J)
            R=P
            E=J+6
            F=O(J+3)
            IF(O(29).GE.6) CALLMACTRC(2,E,F)
            IF(O(54).GT.0) O(J+4)=O(J+4)+1
60          IF(E.GE.F)GOTO61
               IF(O(E).NE.O(R))GOTO40
               E=E+1
               R=R+1
            GOTO 60
61          CONTINUE
            P=O(J+2)+6
            Q=O(O(J+2)+3)
            IF(O(29).GE.4) CALLMACTRC(5,V,U)
            O(45)=O(45)+1
            O(O(45))=QQ
            O(45)=O(45)+1
            O(O(45))=R
            IF(O(45).GT.3724)CALLMESAGE(15, 19, 0,0)
            IF(O(54).GT.0) O(J+5)=O(J+5)+1
         ELSE IF (O(P).LT.O(106)) THEN
            P=P+1
            JMP=O(P-1)-100
            GOTO(70,80,90,100,110),JMP
70          IF (M.EQ.0) THEN
               V=O(O(46)-1)
            ELSE
               N=1
120            IF(N.EQ.0)GOTO121
                  IF( O(103).EQ.O(P)) N=N+1
                  IF( O(104).EQ.O(P)) N=N-1
                  P=P+1
                  IF(P.GT.Q)CALLMESAGE(14, 27, 0,0)
               GOTO 120
121            CONTINUE
               P=P-1
            END IF
            GOTO20
90          O(46)=O(46)+1
            O(O(46))=C
            O(46)=O(46)+1
            O(O(46))=V
            O(46)=O(46)+1
            O(O(46))=P
            IF(O(46).GT.3774)CALLMESAGE(15, 20, 0,0)
            C=0
            GOTO20
100         P=P+2
            IF (M.EQ.1) THEN
               C=C+1
               IF (C.LT.O(P-1)) THEN
                  P=O(O(46))
                  GOTO20
               END IF
            END IF
            IF(C.GE.O(P-2))M=1
            IF( M.EQ.0 ) V=O(O(46)-1)
            IF ((O(46).EQ.3725)) THEN
               CALLMESAGE(14, 17, 0,0)
               GOTO50
            END IF
            NUL=O(O(46))
            O(46)=O(46)-1
            NUL=O(O(46))
            O(46)=O(46)-1
            C=O(O(46))
            O(46)=O(46)-1
            GOTO130
80          P=P+2
            M=0
            IF ((O(P-2).LE.O(V)).AND.(O(V).LE.O(P-1))) THEN
               M=1
               V=V+1
               IF(V.GT.U)GOTO30
            END IF
            GOTO130
110         W=V
            M=1
            IF (O(P).EQ.O(76)) THEN
140            IF(O(W).NE.O(76).OR.O(P).NE.O(76))GOTO141
                  W=W-1
                  P=P+1
               GOTO 140
141            CONTINUE
            END IF
150         IF(O(P).EQ.O(106))GOTO151
               IF(O(P).NE.O(W).OR.W.GT.U)M=0
               P=P+1
               W=W+1
            GOTO 150
151         CONTINUE
            P=P+1
            IF(M.EQ.1)V=W
130         IF(M.EQ.1)GOTO20
            IF(O(P).NE.O(101) .AND. O(P).NE.O(104))GOTO50
         ELSE
            CALLMESAGE(14, 19, P,Q+11)
            GOTO50
         END IF
      GOTO 20
21    CONTINUE
      IF (.NOT.(O(45).EQ.3675)) THEN
         P=O(O(45))
         O(45)=O(45)-1
         Q=O(O(45))
         O(45)=O(45)-1
         GOTO20
      END IF
      O(74)=1
      VV=V
      ISPEC=3
      IF(O(29).GE.6) CALLMACTRC(6,PP,QQ)
      GOTO 99999
50    O(74)=0
      ISPEC=2
      GOTO 99999
30    ISPEC=1
99999 RETURN
      END
+DECK,MACTRC.
*CMZ :          04/11/97  02.51.29  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE MACTRC(W,R,S)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      IF ( O(23).GT.0 .AND. O(29).LT.3 .AND. W.NE.4)GOTO 99999
      IF (W.EQ.2) THEN
         CALLDUMDUM(255,45,37,37,37,22,42,29,27,34,47)
         O(255+4)=(O(32)-1225)/120
         CALLCRIT(R,S)
      ELSE IF (W.EQ.4) THEN
         CALLDUMDUM(255,47,45,28,29,27,10,23,16,14,47)
         CALLCRIT(R,S)
      ELSE IF (W.EQ.5) THEN
         CALLDUMDUM(255,47,37,10,16,10,18,23,28,29,47)
         CALLCRIT(R,S)
      ELSE IF (W.EQ.6) THEN
         CALLDUMDUM(255,47,37,24,20,47,28,25,14,12,47)
         CALLCRIT(R,S)
      END IF
      IF (W.EQ.33) THEN
         CALLDUMDUM(255,47,47,27,14,13,30,12,14,13,47)
         IF(O(23).GT.0) O(255+1)=O(23)
         CALLCRIT(R+1,S+1)
      ELSE IF (W.EQ.15) THEN
         CALLDUMDUM(255,47,47,13,14,15,18,23,14,13,47)
         CALLCRIT(R+6,O(R+3))
         IF (R+6.LT.O(R+3)) THEN
            CALLDUMDUM(255,47,47,47,47,31,10,21,30,14,47)
            O(255+2)=O(20)
            CALLCRIT(S+6,O(S+3))
         ELSE
            CALLDUMDUM(255,47,23,30,21,21,47,31,10,21,47)
            CALLCRIT(S,S)
         END IF
      ELSE IF (W.EQ.12) THEN
         CALLDUMDUM(255,47,10,25,25,14,23,13,14,13,47)
         CALLCRIT(O(S-2*(3)-1),O(S-2*(3)-2) )
         CALLDUMDUM(255,47,47,47,47,47,47,47,29,24,47)
         CALLCRIT(O(S-2*(1)-1),O(S-2*(1)-2) )
      ELSE IF (W.EQ.13) THEN
         CALLDUMDUM(255,47,47,27,14,22,24,31,14,13,47)
         CALLCRIT(O(S-2*(1)-1),O(S-2*(1)-2) )
      ELSE IF (W.EQ.22) THEN
         CALLDUMDUM(255,47,47,22,10,29,12,17,14,13,47)
         IF (O(R+6).LT.0) GOTO 99999
         O(255+1)=(O(32)-1225)/120
         CALLCRIT(R+6,O(R+3) )
         K=O(S-1)
         IF (K.NE.0) THEN
            DO 21 M = 1,K
               CALLDUMDUM(255,47,47,47,47,10,27,16,47,47,47)
               O(255+8)=M
               T=O(S-2*(M)-1)
               N=O(S-2*(M)-2)
               IF (T.NE.N) CALLCRIT(T,N)
21          CONTINUE
         END IF
      END IF
99999 RETURN
      END
+DECK,CRIT.
*CMZ :          04/11/97  02.51.29  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE CRIT(A,Z)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      DIMENSION TITO(9)
      DATA SH/35/
      B=A
20    IF(B.GE.Z)GOTO21
         C=255+9
         IF (O(255).EQ.47) THEN
            C=C+SH
         END IF
C    PLN - dense tracing
30       IF(C.GE.334.OR.B.GE.Z)GOTO31
            C=C+1
            O(C)=O(B)
            B=B+1
            IF(O(C).EQ.O(76))O(C)=37
            IF(O(C).GT.100+11) O(C)=100
            IF(O(C).EQ.-1) O(C)=O(82)
            IF(O(C).EQ.-2) O(C)=O(83)
            IF(O(C).EQ.-3 .OR.O(C).EQ.-4)O(C)=91
         GOTO 30
31       CONTINUE
         IF (O(255).EQ.47) THEN
            DO 41 C1 = 255+1,255+9
               O(C1+SH)=O(C1)
               O(C1)=TITO(C1-255)
41          CONTINUE
            CALLRW(33,O(56),255,C)
            DO 51 C1 = 255,334
               O(C1)=47
51          CONTINUE
            GOTO 99999
         ELSE
            DO 61 C1 = 255+1,255+9
               TITO(C1-255)=O(C1)
61          CONTINUE
         END IF
      GOTO 20
21    CONTINUE
99999 RETURN
      END
+DECK,MESAGE.
*CMZ :          12/11/97  16.26.54  by  Pavel Nevski
*CMZU:  1.00/01 06/12/95  00.55.09  by  Pavel Nevski
*CMZ :  1.00/00 06/10/95  14.09.54  by  Pavel Nevski
*-- Author :
C-----------------------------------------------------------------------
C-------------
      SUBROUTINE MESAGE (LEVEL,NO,K1,K2)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      IF (LEVEL.EQ.14 .OR. LEVEL.EQ.15) O(17)=O(17)+1
      CALLFIND(LEVEL,NO,K1)
      IF(K2.NE.0)CALLMACTRC(4,K1,K2)
      IF (LEVEL.EQ.13) THEN
         CALLFIND(13,2,O(60))
         CALLFIND(13,3,O(61))
      END IF
      IF (LEVEL .LE.14) THEN
         IF(O(17).LT.100)RETURN
         CALLFIND(15,10,0)
      END IF
      IF (O(55).EQ.O(86).OR. O(55).EQ.O(87)) THEN
         O(17)=O(17)+1
         IF(O(55).EQ.O(86)) CALLFIND(16,5,0)
         IF(O(55).EQ.O(87)) CALLFIND(16,4,0)
      END IF
      IF (O(47).GT.3775.OR.O(48).GT.3825) O(17)=O(17)+1
      IF (O(48).GT.3825) THEN
         CALLFIND(16,3,O(48)-3825)
      END IF
20    IF(O(47).LE.3775)GOTO21
         CALLFIND(16,2,O(O(47)))
         O(47)=O(47)-1
      GOTO 20
21    CONTINUE
      CALLFIND(13,3,O(61))
      STATUS=MUSER('EXIT','    ',0)
      IF (STATUS.NE.1) THEN
         O(17)=O(17)+1
      END IF
      IF (O(17).EQ.0) THEN
         CALLFIND(16,6,0)
      ELSE
         CALLFIND(16,7,O(17))
         STOP 'Geant3 compilation error(s) occured'
      END IF
C     CALL TIMEX(TT); PRINT *,' elapsed time = ',TT
      STOP 'GEANT3 parser terminated normally'
      END
+DECK,FIND.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C-----------------------------------------------------------------------
C---------------
      SUBROUTINE FIND(L,N,V)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      A=255
      C=A+9
      Q=1945+L
20    IF (O(Q).NE.0) THEN
         Q=O(Q)
         IF(O(Q+7).NE.N)GOTO20
         R=O(Q+2)+6
         S=O(O(Q+2)+3)
30       IF(R.GE.S)GOTO31
            C=C+1
            O(C)=O(R)
            R=R+1
         GOTO 30
31       CONTINUE
      ELSE
         C=C+LLONG(C,N,10,0)
      END IF
      IF(L.EQ.15) CALLDUMDUM(255,47,45,45,45,15,10,29,10,21,47)
      IF(L.EQ.14) CALLDUMDUM(255,47,45,32,10,27,23,18,23,16,47)
      IF (L.EQ.13.OR.L.EQ.16) THEN
         CALLDUMDUM(255,47,47,47,47,47,47,47,47,47,47)
         IF(V.NE.0) NERD=LLONG(A,V,10,0)
      END IF
      CALLRW(L,O(56),A,C)
      DO 41 K = A,C
         O(K)=O(76)
41    CONTINUE
      C=255+8
99999 RETURN
      END
+DECK,LINF.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C-----------------------------------------------------------------------
C------------
      FUNCTION LINF(A,Z,IND)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      DATA LAST/0/,KUR/0/,KIT/1/,KUT/0/
      LINF=A-1
      O(62)=0
      IF (O(A).EQ.O(96) .OR. (IND.EQ.12 .AND. (O(25).EQ.0.OR.O(10).EQ.1)
     *) ) GOTO 99999
      KST=0
      H=0
      B=A
      I=255
      KUT=KUR
      IF(O(B).NE.O(75))GOTO20
      B=B+2
      KIT=O(B-1)-1
      KUR=KUR+KIT
      KUT=KUR
      IF(KIT.NE.0)GOTO20
      KUT=KUT-1
      KIT=1
20    CONTINUE
      DO 31 J = 255,334
         O(J)=O(76)
31    CONTINUE
      IF (IND.EQ.15) THEN
40       IF(I.GE.261.OR.B.GT.Z)GOTO41
            IF (O(B).EQ.O(76)) THEN
               B=B+1
               GOTO40
            END IF
            IF ((0.LE.O(B)).AND.(O(B).LE.9)) THEN
               O(I)=O(B)
               I=I+1
               B=B+1
            ELSE
               GOTO41
            END IF
         GOTO 40
41       CONTINUE
         NPL=65
         D=45
         KOFF=7
      ELSE
         NPL=71
         D=12
         O(255)=D
         KOFF=MAX(MIN(80,O(39)),2)
      END IF
      IF (B.GT.Z) THEN
         IF (I.GT.255) THEN
            CALLRW(33,O(57),255,261)
            IF(IND.EQ.15)CALLMESAGE(14, 14, 0,0)
            GOTO 99999
         END IF
      END IF
      C=254+KOFF+KUT*O(18)
      IF(KUT.GT.LAST)C=C-O(18)
      IF(C.GT.254+50)C=254+7
C non-empty output line
      I=C
50    IF(B.GT.Z)GOTO51
         LIMC=MIN0(B+NPL,Z)
60       IF(B.GT.LIMC .OR. I.GT.326)GOTO61
            IF (IND.EQ.15 .AND. O(B).EQ.O(86)) THEN
               IF(I.GE.326)GOTO61
               O(I)=O(B)
               I=I+1
            END IF
            IF (O(B).EQ.O(70)) THEN
               B=B+1
               GOTO61
            END IF
            O(I)=O(B)
            I=I+1
            B=B+1
         GOTO 60
61       CONTINUE
         IF (O(30).EQ.2) THEN
            DO 71 K = 1,8
               O(334-K+1)=O(O(36)-K+1)
71          CONTINUE
         ELSE IF (O(30).EQ.1) THEN
            K=LLONG(327,O(19)-1,10,0)
         END IF
         DO 81 K = 255,326
            IF(O(K).EQ.O(105))KST=1
            IF(O(K).EQ.O(106))KST=0
81       CONTINUE
C    BREAK LINES ONLY AT <NICE> PLACES
         IF (I.GT.326) THEN
            IF (IND.EQ.15 .AND. KST .EQ. 0) THEN
90             IF(O(I-1).GE.38)GOTO91
                  B=B-1
                  I=I-1
                  O(I)=O(76)
               GOTO 90
91             CONTINUE
            END IF
         END IF
C   LOOKOUT
         CALLRW(33,O(57),255,334)
         DO 101 K = 255,334
            O(K)=O(76)
101      CONTINUE
         I=C
         IF (IND.EQ.15) THEN
            O(255+5)=D
         ELSE
            O(255)=D
         END IF
         IF (KST.GT.0) THEN
            I=261
            O(261-1)=45
         END IF
      GOTO 50
51    CONTINUE
      IF(IND.EQ.12) O(A)=O(96)
      LAST=KUR
99999 RETURN
      END
+DECK,DUMDUM.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE DUMDUM(L,A,B,C,D,E,F,G,H,I,J)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      O(L)=A
      O(L+1)=B
      O(L+2)=C
      O(L+3)=D
      O(L+4)=E
      O(L+5)=F
      O(L+6)=G
      O(L+7)=H
      O(L+8)=I
      O(L+9)=J
99999 RETURN
      END
+DECK,cccard.
*CMZ :          13/12/97  08.40.14  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE CCCARD(K)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      CHARACTER EXT*2, CL*120, C0*1, C1*1, CC*2
      CHARACTER*160 FILE,PILE
      COMMON /NAMEF/ N,FILE
      JMP=K
      GOTO(20,30,40,50,60,70,60,60,80,60,60,90,100,110,60,60,120,130,
     *140,150,160,60,60,60,60,60),JMP
20    O(10) =N5(0,2,1)
      GOTO 99999
30    O(37) =N5(0,132,132)
      O(38)=404+O(37)
      O(36)=536+O(37)
      GOTO 99999
40    O(41)=N5(10,132,132)
      O(43)=536+O(41)
      O(42)=404+O(41)
      GOTO 99999
50    O(13)=N5(0,2,0)
      GOTO 99999
70    O(15) =1
      GOTO 99999
80    IF (O(537+2).LT.10) THEN
         O(53)=N5(0,50,2)
         GOTO 99999
      END IF
      CL='   '
      K0=0
      K1=0
      K2=0
      DO 171 R = 405,O(38)
         C0=C1
         C1=CHAR(O(R))
         IF(C1.EQ.'; ')GOTO171
         K0=K0+1
         CL(K0:K0)=C1
         IF (C0.EQ.'  ' .AND. C1.NE. '  ') K1=K0
         IF (C0.NE. '  ' .AND. C1.EQ.'  ') K2=K0
171   CONTINUE
      IF (K2.EQ.0 .OR. K1.EQ.0 .OR. K1.GT.K2) GOTO 180
      CC=CL(K1:K1)//CL(K2-1:K2-1)
      IF (CC.EQ.''''''.OR.CC.EQ.'""'.OR.CC.EQ.'<>'.OR.CC.EQ.'()'.OR.CC.
     *EQ.'[]'.OR.CC.EQ.'{}') THEN
         K1=K1+1
         K2=K2-1
      END IF
      PILE=CL(K1:K2-1)
      M=K2-K1
      O(50)=O(50)+1
      O(O(50))=O(9)
      IF(O(50).GT.4024)CALLMESAGE(15, 30, 0,0)
      O(9)=O(9)+1
190   OPEN (O(9),FILE=PILE(1:M) , STATUS='OLD',FORM='FORMATTED',ERR=200)
      GOTO 99999
200   OPEN (O(9),FILE=PILE(1:M)//'.g' , STATUS='OLD',FORM='FORMATTED',
     *ERR=210)
      GOTO 99999
210   OPEN (O(9),FILE=PILE(1:M)//'.h' , STATUS='OLD',FORM='FORMATTED',
     *ERR=220)
      GOTO 99999
220   OPEN (O(9),FILE=PILE(1:M)//'.inc', STATUS='OLD',FORM='FORMATTED',
     *ERR=230)
      GOTO 99999
230   IF (PILE(1:1).EQ.'/ ') GOTO 180
240   OPEN (O(9),FILE='../inc/'//PILE(1:M),STATUS='OLD',FORM='FORMATTED'
     *,ERR=250)
      GOTO 99999
250   OPEN (O(9),FILE='../inc/'//PILE(1:M)//'.g', STATUS='OLD',FORM='FOR
     *MATTED',ERR=260)
      GOTO 99999
260   OPEN (O(9),FILE='../inc/'//PILE(1:M)//'.h', STATUS='OLD',FORM='FOR
     *MATTED',ERR=270)
      GOTO 99999
270   OPEN (O(9),FILE='../inc/'//PILE(1:M)//'.inc',STATUS='OLD',FORM='FO
     *RMATTED',ERR=180)
      GOTO 99999
180   IF (CC.NE.'[]') WRITE(O(58),*)
     *   ' *WARNING! INCLUDE FILE NOT FOUND: ',CL(1:K0)
      O(9)=O(O(50))
      O(50)=O(50)-1
C (WARN I T1,TMX);
      GOTO 99999
90    O(21)=1
      GOTO 99999
100   O(15) =0
      GOTO 99999
110   O(21)=0
      GOTO 99999
120   O(26)=N5(0,1,1)
      GOTO 99999
130   I =N5(1,99,8)
      REWIND I
      GOTO 99999
140   O(30)=N5(0,2,0)
      GOTO 99999
150   O(29)=N5(0,9,0)
      GOTO 99999
160   O(50)=O(50)+1
      O(O(50))=O(9)
      IF(O(50).GT.4024)CALLMESAGE(15, 30, 0,0)
      O(9)=N5(1,99,O(9))
C+SELF,IF=UNIX.
      EXT='.a'
      EXT(2:2)=CHAR(ICHAR(EXT(2:2))+O(9)-1)
280   OPEN (O(9),FILE=FILE(1:N)//EXT ,STATUS='OLD')
C+SELF.
      GOTO 99999
60    CALLMESAGE(14, 22, 0,0)
99999 RETURN
      END
+DECK,INITAL.
*CMZ :          13/12/97  15.00.11  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE INITAL(I1,I2,I3,I4,I5,I6,I7)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      EQUIVALENCE(O(1),B),(O(2),E),(O(3),R),(O(4),S), (O(5),V),(O(6),U),
     *(O(7),W),(O(8),X)
      CHARACTER*160 FILE,FF,FFO,FFL,FFE
      COMMON /NAMEF/ NN,FILE
C PLN - 20-mar-93   -    this was for writing binary out - not used in m
Cy version
C IF I3<0 {MODE=1;SEQN=5;KOUNT=FREE+1;FRT=0;UNIT=5;
C
C           .(1)=0;.(2)=KOUNT; WRITE(MINP) (O(K),K=1,KOUNT);
C
C     QUIT;}
      CHARACTER*2 CL
      DO 21 K = 8,256000
         O(K)=0
21    CONTINUE
      O(9)=I1
      IUNI=I1
      O(56)=I2
      O(57)=I3
      O(58)=I4
      O(14)=I5
      O(16)=I6
      O(37)=I7
      O(41)=O(37)
      O(38)=404+O(37)
      O(36)=536+O(37)
      O(43)=536+O(41)
      O(42)=404+O(41)
C+SELF,IF=UNIX.
      J=0
      FF='-i'
30    CONTINUE
         J=J+1
         CL=FF
         CALLGETARG(J,FF)
         I=LENOCC(FF)
         IF(I.EQ.0)GOTO31
         N=I
         DO 41 K = 1,I
            IF (FF(K:K).EQ.'. ') N=K-1
41       CONTINUE
         IF (CL.EQ.'-i') THEN
            FILE=FF
            NN=N
            FFO=FF(1:N)//'.f'
            FFL=FF(1:N)//'.l'
            FFE=FF(1:N)//'.e'
         END IF
         IF (CL.EQ.'-o') THEN
            FFO=FF(1:I)
            FFL=FF(1:N)//'.l'
            FFE=FF(1:N)//'.e'
         END IF
         IF (CL.EQ.'-l') THEN
            O(56)=12
            FFL=FF(1:N)//'.l'
         END IF
         IF (CL.EQ.'-e') THEN
            O(58)=13
            FFE=FF(1:N)//'.e'
         END IF
         IF (FF.EQ.'-h') THEN
            STOP 'usage: geant3 [-i] file[.g] [-o,e,l file]'
         END IF
      GOTO 30
31    CONTINUE
      OPEN (O(9),FILE='geant3.def', STATUS='OLD')
      OPEN (O(57),FILE=FFO, STATUS='UNKNOWN')
      IF (O(56).NE.6) OPEN (O(56),FILE=FFL, STATUS='UNKNOWN')
      IF (O(58).NE.6) OPEN (O(58),FILE=FFE, STATUS='UNKNOWN')
C+SELF.
      CALLRAW
      O(32)=1705
      DO 51 K = 1,6
         O(K)=224521
51    CONTINUE
      O(40)=224521
      O(55)=O(76)
      O(113)=113
      O(75)=-13
      O(70)=-14
      O(U)=O(79)
      W=193043-1
      O(W)=O(79)
      CALLDUMDUM(44,3625,3675,3725,3775,3825,3875,3975,4025,0,0)
      CALLNXTCRD
99999 RETURN
      END
+DECK,RAW.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE RAW
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      EQUIVALENCE(O(1),B),(O(2),E),(O(3),R),(O(4),S), (O(5),V),(O(6),U),
     *(O(7),W),(O(8),X)
      DIMENSION P(100),BOO1(0:26),BOO2(0:26)
      EQUIVALENCE(P(1),O(4075))
      DATA K1/24000/
      DATA (BOO1(K),K=0,26)/26,24,24,24,24,8,0,3,38,107,1,1,0,46,107,1,
     *1,0,38,107,1,1,0,46,107,24,0/
      DATA (BOO2(K),K=0,26)/26,24,24,24,24,8,0,3,-1,107,0,0,0,-2,107,0,
     *0,0,-1,107,0,0,0,-2,107,24,0/
      CALLRW(0,O(9),405,O(38))
      CALLRW(0,O(9),769,769+114)
      CALLRW(23,O(56),405,405+21)
      CALLRW(23,O(57),405,405+21)
CMAKE INPUT AND OUTPUT SAME
      DO 21 K = 769,868
         O(K-100)=O(K)
21    CONTINUE
      DO 31 K = 1,100
         J=O(669+K-1)
         O(969+J) = K-1
31    CONTINUE
      O(31)=4
      O(34)=4175
      DO 41 K = 1,10
         O(K+100)=K+100
         O(K+110)=K+110
         O(100-K)=-K
41    CONTINUE
C              BLANK BAT BLB TRM LPR RPR LSB RSB LCB RCB
      CALLDUMDUM(76, 47, 81, 80, 79, 38, 46, 78, 84, 85, 86)
      O(86)=48
      O(87)=82
      DO 51 K = 0,5
         BOO1(K) = BOO1(K)+K1
         BOO2(K) = BOO2(K)+K1+100
51    CONTINUE
      DO 61 K = 0,26
         O(K+K1) = BOO1(K)
         O(K+100+K1) = BOO2(K)
61    CONTINUE
      CALLDEFINE(K1+8)
      CALLDEFINE(K1+108)
      P(46)=101
      P(38)=202
      P(89)=303
      P(90)=404
      P(91)=505
      P(42)=706
      P(43)=707
      P(44)=808
      P(45)=809
      P(47)=910
      P( 32)=303
      P( 12)=404
      P( 29)=505
      P( 11)=611
      P( 14)=612
      P( 16)=613
      P( 18)=614
      P( 23)=615
      P( 30)=616
      O(31)=6
99999 RETURN
      END
+DECK,RW.
*CMZ :  1.30/00 08/05/96  22.31.52  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE RW(WICHIN,DFILE,FROM,TO)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      CHARACTER*155 INCH(5),OUCH,SHAD
      CHARACTER*66 STARS
      CHARACTER*1 TAB
      INTEGER STF/0/,LIL/0/,TABI,BUFI(200),EVIL(200),PV(5)/5*0/,LM(5)/5*
     *0/,LINE(100)/100*0/
      DATA STARS (1:66)/' **********************************************
     *******************'/
C STATEMENT FUN
      ROUND(K)=MOD(K,5)+1
C
      IBK=ICHAR('  ')
      LINL = MAX(TO-FROM+1,0)
      IF( WICHIN.NE.0) GOTO 20
      LIL=ROUND(LIL)
      LM(LIL)=LINL
      INCH(LIL) (1:LM(LIL))=';   '
+SELF,IF=UNIX.
      TABI=9
      READ(DFILE,'(A)', END=30) INCH(LIL) (1:LM(LIL))
+SELF.
      IF (DFILE.LT.100) LINE(DFILE)=LINE(DFILE)+1
      O(19)=LINE(DFILE)
      TAB=CHAR(TABI)
      K=FROM-1
      DO 41 P = 1,LM(LIL)
         IF(K.GE.TO)GOTO41
         K=K+1
         O(K)=ICHAR(INCH(LIL)(P:P))
         IF (O(K).EQ.TABI) THEN
C       {K=K,MIN((FROM+((K-FROM)/8+1)*8),TO);
            O(K)=IBK
C      }
         END IF
41    CONTINUE
      DO 51 K = K+1,TO
         O(K)=IBK
51    CONTINUE
      GOTO 99999
20    WICH=WICHIN
      IF(12.LT.WICH .AND. WICH.LT.19 )WICH=33
      CX = 0
CLAST NONBLANK ->
      LAN = 0
      DO 61 L = 1,LINL
         QC = O(FROM+L-1)
         BUFI(L)=QC
         IF (WICH.EQ.33) THEN
            SHAD(L:L) = '  '
            IF (DFILE.EQ.O(57)) THEN
               IF (QC.EQ.O(105)) THEN
                  QC=O(86)
                  STF=1
               END IF
               IF (QC.EQ.O(106)) THEN
                  QC=O(86)
                  STF=0
               END IF
               IF (STF.EQ.0 .AND. BUFI(1).NE.12) THEN
C             PLN correction 20-mar-93 - output in fortran only in capit
C            al
                  IF (QC.LT.0 .OR. QC.GT.50) THEN
                     IF (QC.LT.78) THEN
                        QC=QC-42
C                   .(FROM+L-1) = QC;
                     ELSE
                        CX=CX+1
                        EVIL(CX) = QC
                        SHAD(L:L)='| '
                     END IF
                  END IF
               END IF
            END IF
            QC=O(QC+769)
         END IF
         OUCH(L:L)=CHAR( QC )
         IF (QC .NE. IBK) LAN=L
61    CONTINUE
C- Nev - 15/04/96 - include statement is produced as in C with .inc exte
Cntion
      IF (OUCH(1:10).EQ.'C include ') THEN
         OUCH(1:10) ='#include "'
         DO 71 L = 11,LAN
            IF(OUCH(L:L).EQ.'  ')GOTO80
71       CONTINUE
         L=LAN+1
80       OUCH(L:L+4)='.inc"'
         LAN=MAX(LAN,L+4)
         CALL CUTOL(OUCH(1:LAN))
C- NEV - 19/03/93 - switch listing off !
      END IF
      IF (DFILE .NE. O(56) .OR. O(21) .NE. 0) THEN
         I=1
C   If (DFILE==MOUT & LAN>12) I=12;
         WRITE(DFILE,'(A)') OUCH(I:LAN)
      END IF
      IF (CX.GT.0) THEN
         WRITE (O(58),'(1X,A)')OUCH(1:LAN)
         WRITE (O(58),'(1X,A)')SHAD(1:LAN)
         WRITE (DFILE,'(A)')SHAD(1:LAN)
         IF (DFILE.EQ.O(57)) THEN
            WRITE(DFILE,'('' Illegal FORTRAN characters '')')
            WRITE(O(58), '(''  geant error detected in the following lin
     *es of the source file:'')')
            O(17)=O(17)+1
            DO 91 K = 1,5
               PV(K) = ABS ( ROUND(LIL+K-1) )
91          CONTINUE
            WRITE(O(58),'(1X,A)') STARS
            DO 101 K = 1,5
               WRITE(O(58),'(I5,1X,A)') O(19)+K-5,INCH(PV(K))(1:LM(PV(K)
     *         ))
101         CONTINUE
            WRITE(O(58),'(1X,A)') STARS
         END IF
      END IF
      IF (WICHIN.EQ.14 .OR. WICHIN.EQ.15) THEN
         DO 111 K = 1,5
            PV(K) = ABS ( ROUND(LIL+K-1) )
111      CONTINUE
         WRITE(O(58),'(1X,A)') STARS
         DO 121 K = 1,5
            WRITE(O(58),'(1X,A)') INCH(PV(K)) (1:LM(PV(K)))
121      CONTINUE
         WRITE(O(58),'(1X,A)') STARS
         WRITE(O(58),'(1X,A)') OUCH(1:LAN)
         WRITE(O(57),'(A)') OUCH(1:LAN)
      END IF
      GOTO 99999
30    O(52)=1
99999 RETURN
      END
+DECK,MUSER.
*CMZ :  1.00/00 19/09/95  15.17.28  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      FUNCTION MUSER(IN,OUT,LENOUT)
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      CHARACTER*132 IN,OUT
C ARGUMENTS are: Input string, Output string, Output lengt=
      MUSER=1
99999 RETURN
      END
 
+DECK,geant3,T=text.
*CMZ :          29/12/97  21.15.22  by  Pavel Nevski
*CMZ :  1.30/00 15/04/97  17.15.59  by  Pavel Nevski
*-- Author :    PN
C_geant3_UNIX_compiler..v....3....v....4....v....5....v....6....v....7....v....8....v....9....v....100..v....110..v...
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$_(,.=-+/*) ':%?abcdefghijklmnopqrstuvwxyz{;#@"!}[]<>|&~?\`^????C|r{}bdep<>@#s?????
%N
(E1) (NULL TEMPLATE IN RULE DEFINITION)             (F1) (STRING OR STATEMENT TOO LONG)
(E2) (the BLOCK was not CREATed)                    (F2) (ERROR IN COUNT FIELD OF QUANTIFIER)
(E3) (UNKNOWN COLUMN 1 DIRECTIVE. DEFAULT ASSUMED)  (F3) (GEANT3 WORK SPACE EXCEEDED)
(E4) (1000 RULES EVALUATED WITH NO OUTPUT)          (F4) (NOSUCH ARG. IN TEMPLATE OF RULE.)
(E7) (NO LABEL FOR THIS RIGHT BRACKET)              (F5) (ERROR IN EVALUATOR IF-THEN-ELSE)
(E8) (the END-OF-BLOCK does not match any block)    (F6) (NUMBER OF RULES EXCEEDS CAPACITY)
(E9) (FIRST SYMBOL IN TEMPLATE MUST BE PRINTABLE)   (F7) (ILLEGAL USE OF BREAK SYMBOL)
(EA) (DIVISION BY ZERO IN C-EXPRESSION)             (F8) (TOO MANY FORTRAN STATEMENT LABELS GENERATED)
(EB) (INVALID OPERATOR IN C-EXPR)                   (F9) (ILLEGAL SYMBOL IN RULE DEFINITION)
(EC) (INCORRECT RULE FORMAT. IGNORED.)              (FA) ( WARNINGS ISSUED>100)
(ED) (UNCLOSED STRING PREDICATE)                    (FB) (GEANT3 RULE-SPACE EXCEEDED)
(EE) (NULL FOLLOWS FORTRAN LABEL)                   (FH) (UNKNOWN PRIMITIVE )
(EF) (UNDEFINED SPECIFIER)                          (FI) (EVALUATOR IF-ELSE NESTING TOO DEEP)
(EG) (UNCLOSED LOOP OR BLOCK)                       (FJ) (INDIRECT SPECIFIER REFERENCES>50)
(EH) (INCORRECT SPECIFICATION)                      (FK) (QUALIFIERS+QUANTIFIERS IN ONE SPECIFIER>50)
(EJ) (INVALID SPECIFICATION)                        (FL) (FORTRAN LABELS ON STACK>50)
(EK) (MISSING RIGHT BRACE ON SPECIFIER)             (FM) (NESTING LEVEL GREATER THAN 50)
(EL) (TEMPLATE MAY NOT BEGIN WITH PARAMETER MARKER) (FN) (MORE THAN 100 OPERANDS+OPERATORS IN C-EXPR)
(EM) (ILLEGAL SYMBOL, COLUMN 1 DIRECTIVE)           (FY) (LEVELS OF EVALUATOR NESTING>50)
(EN) (INVALID C-EXPRESSION)                         (FU) (INPUT UNITS PENDING>50)
(EP) (INCORRECT NESTING OF EVALUATOR IF-ELSE)       (EU) (ERROR FROM USER ROUTINE)
(FZ) (ERROR DURING USER INITIALIZATION)
(D1) (LOCATIONS RECOVERED)                          (D2) (LOCATIONS REMAINING)
(D3) (PERCENT RULE CAPACITY REMAINING)              (D4) (EOF ON INPUT UNIT)
(G1) (END OF GEANT3 INPUT)    (G2) (LABEL NOT USED)      (G3) (UNCLOSED BLOCKS)
(G4) (UNCLOSED COMMENT)       (G5) (UNCLOSED STRING)     (G6) (NO GEANT3 ERRORS DETECTED)
(G7) (GEANT3 ERROR(S))
;
 (!ANNOTATE;)    4(1@SA=;)        (!NOANNOTATE;)    4(0@SA=;)  "M-in => F-out as comments"
 (!COMMENTS;)    4(1@SP=;)        (!NOCOMMENTS;)    4(0@SP=;)  "M-comments => F-comments "
 (!DEFINE;)      4(1@SD=;)        (!NODEFINE;)      4(0@SD=;)  "New macro => M-listing   "
 (!STRINGS;)     4(1@SS=;)        (!NOSTRINGS;)     4(0@SS=;)  "M-input ' => F-output '' "
 (!UPLOW;)       4(1@SL2=;)       (!NOUPLOW;)       4(0@SL2=;) "M-input case UN/Sensitive"
 (!LIST;)        4(1@SL=;)        (!NOLIST;)        4(0@SL=;)  "write M-listing file     "
 (!FORTRAN;)     4(1@SF=;)        (!GEANT3;)        4(0@SF=;)   (!GEANT;)        4(0@SF=;)
 (!BLACK;)       4(1@SX=;)        (!GREEN;)         4(0@SX=;)
 (!LOCAL;)       4(@SYC@SZ=;)     (!ENDLOCAL;)      4(@K;0@SZ=)
 (!RECOVER;)     4(@K;)           (!CONDITIONAL;)   4(1@SJ2=)
 (!TRACE@110;)   4(#1@ST=;)       (!NOTRACE;)       4(0@ST=;)
 (!REPORT@110;)  4(1@SS1=;)       (!DEFAULT@110;)   4(#1@SV=;)
 (!MODE@110;)    4(#1@SX1=;)      (!TRIGGER (@111)) 4(#1@SK=)
 (!LABELS@110;)  4([B(#1)]@SG=;)  (!SEQUENCE@110;)  4([B(#1)]@SJ=;)
 (!EUNIT@110;)   4(#1@SK2=;)      (!INDENTC@110;) 4(#1@SD1=;)
 (!INDENTM@110;) 4(#1@SR1=;)      (!INDENTF@110;) 4(#1@SI=;)
 (GENERATE)4(@CG)             (NOGENERATE)4(@CN)           (ENDGENERATE)4(@CE)
 (GENERATE)0(@CG)             (NOGENERATE)0(@CN)           (ENDGENERATE)0(@CE)
 (RESCAN)  4 ((@J6@@111@J7)2(@JZ@JV@@B(@JV@@G1@JW)@JW##1_)) ;      RESCAN;
 ([COMPUTE @001]) 1(@JV@@C(#1)@JW)  ([REDUCE @001])  1(@JV@@E#1@JW)
 ([BINARY(@001)]) 1(@JV@@B(#1)@JW)  ([USER @001])    1(@JV@@U(#1)@JW)
 ([LENGTH @001])  1(@JV@@G#1@JW)    ([WAIT @001])    1(@JV@@D#1@JW)
 ([INCR @001])    1(A@JTU#1+)       ([DECR @001])    1(A@JTU#1-)
 ([NULL @001])    1('@JU#1'='')     ([EXIST @001])   1('@JU#1'~'')
 ([MCUR+])        1(@@SN2C2)        ([MCUR-])        1(@@SN2C0)       ([MCURX]) 1(@@SN2C1)
 ([QUOTE @000])   1('#1')           ([EMIT@000])     1(@SE3C#1@SF3C)    ([P@000]) 1(@JU#1)
 ([COPY @001])    1(A@JTU#1C)       ([COPY@001BASE@001])1(#2@JTU#1C)
 ([SETR @110=@110])            1(@JV@@B(#2)@JWA@JTU#1=)
 ([SETH @110=@110])            1(@JV@@A #2 @JWA@JTU#1=)
 ({IF}@010{@010})              1(@JTP0000@JV@@C(#1)@JW@JH#2@JG)
 ({IF}@010{@010}{ELSE}{@010})  1(@JTP0000@JV@@C(#1)@JW@JH#2@JG@JH#3@JG)
 (APPEND[@000]TO[@000])        4(@JL#2@JKC@JL#1@JK)
 (APPEND'@000'TO'@000')        4(@JL#2@JKC@JL#1@JK)
 (DFN[@000]AS[@000])           4(@JL[2#1]@JK @JL[1#2]@JK)
 (REPLACE[@000]WITH[@000])     4(@JL[2#1]@JK @JL[1#2]@JK)
 (SPECIFY @000 AS @000;)       4(@JL#1@JK3@JL[3#2]@JK)
 (KEEP[@000.@000;@000])        4(@JL+CDE,[2#1];@JK @JL[1"#1 included:";#3;]@JK;)
 
 (##) 2 (@JT111)                " [#]  ---> <MARKER><LENGTH(BINARY)>#1 "
 ([ARB;])2(@JT001) ([(ARB;)])2(@JT101)   ([{ARB;}])2(@JT011)   ([({ARB;})])2(@JT111)
                   ([{(ARB;)}])2(@JT111) ([ARB]) 2(@JT000)     ([(ARB)]) 2(@JT100)
                   ([{ARB}]) 2(@JT101)   ([({ARB})]) 2(@JT110) ([{(ARB)}]) 2(@JT110)
 !DEFAULT 1;  REPLACE["[ARB]"]   WITH   [@JV@@F#1@JW] ;         !DEFAULT 4;
"----------------------------------------------------------------------------------------"
 !CONDITIONAL;  !STRINGS;
 SPECIFY MRF{@000}           AS   [B(100+#1)];                            "100=NSM"
 SPECIFY |                   AS   MRF{1};
 SPECIFY (@111...@111)       AS   MRF{2}#1#2;
 SPECIFY {@111}              AS   MRF{3}#1MRF{4}11;
 SPECIFY (@111){@111}        AS   MRF{3}#2MRF{4}[B(#1)][B(#1)];
 SPECIFY (@111,@111){@111}   AS   MRF{3}#3MRF{4}[B(#1)][B(#2)];
 REPLACE [REMOVE@000'@000']  WITH [@JL[2#2]@JK
                             {IF}'#1'='SPECIFIER'{E@JL@JK}
                             {ELSE}{{IF}'#1'='RULE'{D@JL@JK}
                             {ELSE}{[EMIT**ILLEGAL REMOVE]} } ];
 REMOVE SPECIFIER'MRF{@000}';
"----------------------------------------------------------------------------------------"
 !BLACK;
" Syntaxis rules start here.  BLACK means generate rules,  GREEN - execute them "
  SPECIFY  GENSWITCH AS {'ON'|'OFF'};
  SPECIFY  DIGIT  AS (0...9);   SPECIFY LETTER AS (A..._);   SPECIFY ALPHAS AS (0..._);
  SPECIFY  NAME   AS (1,8){LETTER};        SPECIFY NUMBER  AS  (1,8){DIGIT};
  SPECIFY  IDENT  AS LETTER(0,9){ALPHAS};  SPECIFY  OSYS   AS  {(0,6){LETTER}};
  SPECIFY  GENAME AS (1,16){ALPHAS};
  SPECIFY  REL   AS  {'<'|'<='|'=='|'>'|'>='|'=>'|'~='|'##'|'='};
  SPECIFY  OPR   AS  {'+'|'-'|'*'|'/'|'**'};
  SPECIFY  0SYS  AS  {'<='|'=>'|'>='|'=>'|'<'|'>'|'=='|'='|'~='|'##'|'!='};
  SPECIFY  1SYS  AS  {'WHILE'|'UNTIL'|'LOOP'|'DO'|'FOR '|'UNTUL'};
  SPECIFY  2SYS  AS  {'IF'|'UNLESS'};
  SPECIFY  3SYS  AS  {2SYS|1SYS};
  SPECIFY  4SYS  AS  {(1,5){DIGIT}};
  SPECIFY  5SYS  AS  {(0,5){DIGIT}};
  SPECIFY  6SYS  AS  {(1,32){LETTER}};
  SPECIFY  7SYS  AS  {'BREAK'|'NEXT'};
  SPECIFY  8SYS  AS  {'WHILE'|'UNTIL'};
  SPECIFY  9SYS  AS  {':'|';'|'}'};
  SPECIFY 10SYS  AS  {(1,32){ALPHAS}};
  SPECIFY  SSYS  AS  {'PROGRAM'|'FUNCTION'|'SUBROUTINE'};
  SPECIFY  GSYS0 AS  {'COMPONENT'|'MIXTURE'|'MEDIUM'|'MATERIAL'|'ATTRIBUTE'|'POSITION'|'SHAPE'|'CREATE AND POSITION'};
  SPECIFY  GSYS1 AS  {'AUTHOR'|'CREATED'};
  SPECIFY  GSYS2 AS  {'MODULE'|'BLOCK'|'FILL'|'USE'|'HITS'|'DIGI'};
  SPECIFY  GSYSH AS  {'HITS'|'DIGI'};
  SPECIFY  GSYSA AS  {GSYS0|GSYS1|GSYS2|GSYSH};
  SPECIFY  GSYSN AS  {(4,4){LETTER}};
  SPECIFY  KSYS1 AS  {'IFIELD'|'FIELDM'|'TMAXFD'|'EPSIL'|'STEMAX'|'DMAXMS'|'RADL'|'NLMAT'};
  SPECIFY  KSYS2 AS  {'NDIV'|'STEP'|'IAXIS'|'C0'|'NDVMAX'|'STMIN'|'DEEMAX'|'ABSL'|'DENS'};
  SPECIFY  KSYS3 AS  {'PHIX'|'THETAX'|'PHIY'|'THETAY'|'PHIZ'|'THETAZ'|'SERIAL'|'MOTHER'};
  SPECIFY  KSYS4 AS  {'ALPHAX'|'ALPHAY'|'ALPHAZ'|'ALFAX'|'ALFAY'|'ALFAZ'|'ORT'|'NCOPY'};
  SPECIFY  KSYS5 AS  {'WORK'|'SEEN'|'LSTY'|'LWID'|'COLO'|'FILL'|'ISVOL'|'KONLY'};
  SPECIFY  KSYS6 AS  {'H1'|'TL1'|'BL1'|'DX1'|'DY1'|'PHI1'|'THE1'|'ALP1'|'NPDIV'};
  SPECIFY  KSYS7 AS  {'H2'|'TL2'|'BL2'|'DX2'|'DY2'|'PHI2'|'THE2'|'ALP2'|'NPDV'};
  SPECIFY  KSYS8 AS  {'DX'|'DY'|'DZ'|'RMIN'|'RMAX'|'DPHI'|'NZ'|'ALPH'|'THET'|'TWIS'|'TWIST'};
  SPECIFY  KSYS9 AS  {'RMN1'|'RMN2'|'RMX1'|'RMX2'|'RMN'|'RMX'|'ZI'|'AA'|'ZZ'|'WW'|'PHI'};
  SPECIFY  KSYSC AS  {'LX'|'LY'|'LZ'|'HX'|'HY'|'HZ'|'P1'|'P2'};
  SPECIFY  KSYS0 AS  {KSYS1|KSYS2|KSYS3|KSYS4|KSYS5|KSYS6|KSYS7|KSYS8|KSYS9|KSYSC|LETTER};
" if anything survived until here this is an error "
  REPLACE [;[GSYSA] [IDENT]#;]    WITH [; <unrecognized geant operator> : #1 #2 #3; ]
  REPLACE [;<#>[GSYSA] [IDENT]#;] WITH [; <unrecognized geant operator> : #2 #3 #4; ]
 
  DFN [SET<[GENAME]>=[GENSWITCH];] AS
  [{IF}'#2'='ON'{!DEFAULT 0; DFN[<#1>] AS [GENERATE]; !DEFAULT 4; DFN[<#1>] AS [GENERATE]}
   {ELSE}   {!DEFAULT 0; DFN[<#1>] AS [NOGENERATE]; !DEFAULT 4; DFN[<#1>] AS [NOGENERATE]}]
  !DEFAULT 0; DFN[<END>] AS [ENDGENERATE];!DEFAULT 4; DFN[<END>] AS [ENDGENERATE]
;
  REPLACE [:[10SYS]:]     WITH [@Q0 REPLACE[:[P1]:]WITH[@LC00] @LC00@LU0]
  REPLACE[;:[10SYS]:]     WITH [;[REDUCE :[P1]:]]
  REPLACE[(#,#=#)]        WITH [[EMIT(][P1],[P2]=[P3])]
  REPLACE[;[4SYS][9SYS]]  WITH [[EMIT;[P1]CONTINUE];[P2]]
  REPLACE [{]             WITH [;[EMIT ***********ILLEGAL LEFT BRACKET;]]
 
!GREEN;
  REPLACE[{]           WITH [;[MCUR+] @MSY]
  REPLACE[}]           WITH [;[MCUR-] [7@MU@@];]
  REPLACE[ENDBLOCK]    WITH [;[MCUR-] [7@MU@@]; [SETR B=0]]
  REPLACE[}ELSE{]      WITH [;[MCURX] @MRU[EMITELSE];]
  REPLACE[}ELSEIF#{]   WITH [;[MCURX] @MRT[EMITELSE IF ][5([P1])] THEN;]
  REPLACE[}[8SYS]#;]   WITH [[EMITIF] {IF}'[P1]'='WHILE'{([5~([P2])])}
                                      {ELSE} {[5([P2])]}      BREAK;}];
  " :label: condition operator"
  REPLACE [;[5SYS]IF(#)#;]     WITH [;[EMIT[P1]IF]      ([5([P2])]) [P3];]
  REPLACE [;[5SYS]ELSEIF(#)#;] WITH [;[EMIT[P1]ELSEIF]  ([5([P2])]) [P3];]
  REPLACE [;[5SYS]CHECK#;]     WITH [;"Skip Unless [P2]";[EMIT[P1]IF] ([5~([P2])]) NEXT;]
  REPLACE [;[5SYS][2SYS] (#)]  WITH [;" Check [P3] "
           ;[EMIT[P1]IF]   {IF}'[P2]'='IF' {[5([P3])]}  {ELSE} {([5~([P3])])} ];
  " :label: condition {block} ... "
  REPLACE [;[5SYS]DO #=#;]  WITH [;[MCUR+] "*" @MSX {IF} [NULL 1] {@Q0}
                    {ELSE} {[P1]@LS0[EMIT[P1]CONTINUE];} [7DO([P2]=[P3])]
          ];
   REPLACE [;[5SYS]DO #=#!]  WITH [;[MCUR+] "*" @MSX {IF} [NULL 1] {@Q0}
                    {ELSE} {[P1]@LS0[EMIT[P1]CONTINUE];} [7DO([P2]=[P3])] !
          ];
 REPLACE [;[5SYS]DO[NUMBER]#;]  WITH [[EMIT;[P1]DO [P2]] [P3];     ];
  REPLACE [;[5SYS][3SYS]#{]  WITH [;
            ;[MCUR+]    {IF}'[P2]'=2SYS
               {"*"; " Check [P3] "  @MSZ [EMIT[P1]IF]
                  {IF}'[P2]'='IF' {[5([P3])]}  {ELSE} {([5~([P3])])}  THEN; }
             {ELSE} { {IF}'[P2]'=1SYS
               {"*"; " Loop here      "   @MSX {IF} [NULL 1]  {@Q0}
                    {ELSE} {[P1]@LS0[EMIT[P1]CONTINUE];} [7[P2]([P3])] }  }
          ];
 
  REPLACE [;[5SYS]DOWHILE(#);] WITH [;[P1]WHILE  ([P2]) {; ]
  REPLACE [;[5SYS]ENDDO]       WITH [;[P1];[MCUR-][7@MU@@];]
!DEFAULT 7;
  REPLACE[FOR(#=# #)]    WITH [[P1]=[P2];[EMIT GO TO @LC03];[7([P3])[P1];]]
  REPLACE[LOOP()]        WITH [[EMIT@LC01CONTINUE];]
  REPLACE[WHILE(#)]      WITH [[EMIT@LC01IF]([5~([P1])]) GO TO @LC02;]
  REPLACE[UNTIL(#)]      WITH [[EMIT@LC01IF][5([P1])] GO TO @LC02;]
  REPLACE[DO(#=#,#)]     WITH [{IF}[COPY B] {[P1]=[P2];[EMIT GO TO @LC03];[7(TO [P3])[P1];]}
                               {ELSE} {@MRW[EMITDO @LC01] [P1]=[P2],[P3];} ];
  REPLACE[DO(#=#,#,#)]   WITH [{IF}[COPY B]{[P1]=[P2];[EMIT GOTO @LC03];
                                            [7(TO [P3] BY [P4])[P1];]}
                               {ELSE} {@MRW[EMITDO @LC01] [P1]=[P2],[P3],[P4];} ];
!BLACK;
" REPLACE[([4SYS])]      WITH [  [P1] ]   "                       ;
  REPLACE[(BY # TO #)#;] WITH
   [@LC01[P3]=[P3]+([P1]);[EMIT@LC03IF](([P1])*([P3]-([P2])).GT.0) GO TO @LC02;]
  REPLACE[(TO #)#;]      WITH
   [@LC01[P2]=[P2]+1;[EMIT@LC03IF]([P2]-([P1]).GT.0) GO TO @LC02;]
  REPLACE[(TO #BY #)#;]  WITH [(BY [P2] TO [P1])[P3];]
 
  REPLACE[Z@@] WITH [[EMIT;END IF];]
  REPLACE[T@@] WITH [[EMIT;END IF];]
  REPLACE[U@@] WITH [[EMIT;END IF];]
  REPLACE[W@@] WITH [[EMIT;@LC01CONTINUE;@LC02CONTINUE];@LU0]
  REPLACE[X@@] WITH [[EMIT;GO TO @LC01;@LC02CONTINUE];@LU0]
  REPLACE[Y@@] WITH [;]
  REPLACE[0@@] WITH [[EMITILLEGAL SYNTAX];]
;
  REPLACE[V@@] WITH [ [EMIT @LC01 CALL AgSPOPB;]  GO TO SYSNAME, (@LC00SYSLIST@LC09);
                     "End of Local Procedure [REDUCE SYSNAME]";
                      REMOVE RULE'SYSLIST@LC09'; REMOVE RULE'SYSNAME'  @LU0    ]
!DEFAULT 4;
 REPLACE [PROCEDURE#;]   WITH
         [[REDUCE :BLOCK_[P1]:]@LS0 @Q0    "Call To Local Procedure [P1]"
          [REDUCE APPEND[,@LC00]TO[SYSLIST@LC19]]
          [EMIT ASSIGN @LC00 TO BLOCK_[P1];
           GO TO [COMPUTE :BLOCK_[P1]:];@LC00CONTINUE] ;@LU0@LU0
         ];
 REPLACE [;BLOCK [6SYS] #;] WITH
        [ {IF} [COPY M] {[EMIT; Call AgSENDM; RETURN;]}      [SETR M=0]
          {IF} [COPY B] {;" EndBlock inserted"; ENDBLOCK;}   [SETR B=1]
          @MSV;[MCUR+] [REDUCE :BLOCK_[P1]:]@LS0   "Begin Local Procedure [P1]"  " #1 #2 "
          [REDUCE REPLACE [SYSNAME] WITH [BLOCK_[P1]] ]  [EMIT @LC00CONTINUE] ;
          $Title='#1'; $Module=Module; $Mark='V00'; CALL AgSPUSH; $Module=Module; "*";
        ;]
 REPLACE [;BLOCK [6SYS] #{] WITH
        [ {IF} [COPY M] {[EMIT; Call AgSENDM; RETURN;]}  [SETR M=0]
          @MSV;[MCUR+] [REDUCE :BLOCK_[P1]:]@LS0   "Begin Local Procedure [P1]"  " #1 #2 "
          [REDUCE REPLACE [SYSNAME] WITH [BLOCK_[P1]] ]  [EMIT @LC00CONTINUE]
          $Title='#1'; $Module=Module; CALL AgSPUSH; $Module=Module; "*";
       ;]
 REPLACE [LEAVE#;]      WITH
        [{IF} [NULL 1] {GO TO @LC02;} {ELSE}{GO TO [COMPUTE :[P1]:+2];}];
"-----------------------------------------------------------------------------------------"
; " logical expressions "
  (&)5(.AND.)   (|)5(.OR.)   (~)5(.NOT.)    (!)5(.NOT.)                         ;
  (=)5(.EQ.)    (>)5(.GT.)   (<)5(.LT.)     (!=)5(.NE.)   (~!=)5(.EQ.)          ;
  (~=)5(.NE.)   (~>)5(.LE.)   (~<)5(.GE.)   (==)5(.EQ.)                         ;
  (=<)5(.LE.)   (>=)5(.GE.)   (<=)5(.LE.)   (=>)5(.GE.)   (~##)5(.EQ.)          ;
  (~<=)5(.GT.)  (~=>)5(.LT.)  (~=<)5(.GT.)  (~>=)5(.LT.)  (~~=)5(.EQ.)  (~==)5(.NE.);
  (~(~(@110)))        5((#1))             (~((@110)))         5(~(#1))          ;
  (~(@110[0SYS]@110)) 5(#1~#2#3)          (~(@110&@110))      5(~(#1)\~(#2))    ;
  (~(@110|@110))      5((~(#1))&(~(#2)))  (~(@110\@110))      5((~(#1))&(~(#2)));
  (~((@110)))         5 (~(#1))           (##) 5 (~=)         (\) 5 (|)         ;
  ( <[IDENT]< ) 5 ( <#1&#1< )  (~(@110 <[IDENT]< @110)) 5 (~(#1 <#2&#2< #3))    ;
  (<=[IDENT]<=) 5 (<=#1&#1<=)  (~(@110<=[IDENT]<=@110)) 5 (~(#1<=#2&#2<=#3))    ;
;
      REMOVE RULE'(@110)@110(@110)';      " phase one finish "
;
 REPLACE[OUTF(#)#;(#)] WITH [@Q0WRITE([P1],@LC00)[P2];@LC00FORMAT@LU0([P3]);]
 REPLACE[OUTPUT#;(#)]  WITH [@Q0WRITE(Lu,@LC00)[P1];@LC00FORMAT@LU0([P2]);]
 REPLACE[INPUT#;(#)]   WITH [@Q0READ (Li,@LC00)[P1];@LC00FORMAT@LU0([P2]);]
 REPLACE[<W>#;(#)]     WITH [@Q0WRITE(Lout,@LC00)[P1];@LC00FORMAT@LU0([P2])]
 REPLACE[<R>#;(#)]     WITH [@Q0READ (Linp,@LC00)[P1];@LC00FORMAT@LU0([P2])]
 REPLACE[{#=#,#;]      WITH [@MSW ;[MCUR+] @Q0 DO @LC01 [P1] = [P2],[P3];]
;
 REPLACE [;BREAK;]     WITH [;[EMIT GO TO @LC02];]
 REPLACE [;BREAK:#:;]  WITH [;[EMIT GO TO][COMPUTE :[P1]:+2];]
 REPLACE [)BREAK;]     WITH [)[EMIT GO TO @LC02];]
 REPLACE [)BREAK:#:;]  WITH [)[EMIT GO TO][COMPUTE :[P1]:+2];]
 REPLACE [;NEXT;]      WITH [;[EMIT GO TO @LC01];]
 REPLACE [;NEXT:#:;]   WITH [;[EMIT GO TO][COMPUTE :[P1]:+1];]
 REPLACE [)NEXT;]      WITH [)[EMIT GO TO @LC01];]
 REPLACE [)NEXT:#:;]   WITH [)[EMIT GO TO][COMPUTE :[P1]:+1];]
 
 DFN[RHO(# #)] AS [{IF}[EXIST 2]{[REDUCE APPEND[:#1:,]TO[TLIST]]RHO(#2 )}
                       {ELSE}{[REDUCE APPEND[:#1:]TO[TLIST]]GOTO(TLIST),JMP;
                               REMOVERULE'TLIST'                         }]
 DFN [CASE#OF(#)]     AS   [ "Case #1  Of (#2) selected " JMP=#1; RHO(#2)];
 REPLACE [}REPEAT]    WITH [}] ;
 REPLACE ['']         WITH [[EMIT']] ;
 
" some C-like constructions "
 REPLACE[;#-=#;]      WITH [;#1=#1-#2;]                  ;
 REPLACE[;#*=#;]      WITH [;#1=#1*#2;]                  ;
 REPLACE[;#+=#;]      WITH [;#1=#1+#2;]                  ;
 REPLACE[;#/=#;]      WITH [;#1=#1/#2;]                  ;
 REPLACE[;IF(#)#-=#;] WITH [;IF(#1) #2=#2-#3;]      ;
 REPLACE[;IF(#)#+=#;] WITH [;IF(#1) #2=#2+#3;]      ;
 REPLACE[;IF(#)#*=#;] WITH [;IF(#1) #2=#2*#3;]      ;
 REPLACE[;IF(#)#/=#;] WITH [;IF(#1) #2=#2/#3;]      ;
 REPLACE[{#,#}=#;] WITH [{IF}[EXIST 1]{;[P1]=[P3]; ;{[P2],}=[P3]};]
 REPLACE [-1+1)] WITH [)];
 REPLACE [;[GENAME]={#,#}]   WITH
         [ {IF}[EXIST 2]  {[INCR O]; #1([COPY O])=#2; #1={#3,} } {ELSE} {[SETR O=0];}]
 REPLACE [;_[NUMBER]_[IDENT].[IDENT]={#,#}]   WITH
         [ {IF}[EXIST 4]  {[INCR O]; #2.#3([COPY O],#1)=#4;
           _#1_#2.#3={#5,} } {ELSE} {[SETR O=0];}]
 REPLACE [;[GENAME]={#(#:#)}] WITH [; DO $i=#3,#4 {  #1($i-#3+1)=#2($i); };]
 REPLACE [;[GENAME]={#(#:#,#:#)}] WITH [;  DO $j=#5,#6 { DO $i=#3,#4
                                      { #1($i-#3+1,$j-#5+1)=#2($i,$j); } };]
;
     !UPLOW; !DEFAULT 4; !BLACK;
;
 "----------------------------------------------------------------------"
 " register      P    H     M     N,U,V,W   O,Q     E     B     A       "
 " assignement  prin hist module  struct    vect  1cont Block StrCnt    "
 "----------------------------------------------------------------------"
 DFN [_P_ #;]         AS   [$$D#1; PROGRAM    #1; $$T#1;]  ;
 DFN [_F_ #;]         AS   [$$D#1; FUNCTION   #1; $$T#1;]  ;
 DFN [_S_ #;]         AS   [$$D#1; SUBROUTINE #1; $$T#1;]  ;
 DFN [_B_ #;]         AS   [$$D#1; BLOCK DATA #1; $$T#1;]  ;
 REPLACE [;[SSYS]#;]  WITH [!LABELS 1000; !LOCAL; [SETR E=1][SETR N=2];
                                 [EMIT #1 #2;] ^sub(#2());]
 REPLACE [^sub(#(#)#);]   with [DFN [^subname] AS ['#1'];]
 REPLACE [^sub(# #(#)#);] with [^sub(#1#2());]
 REPLACE [;END!#;]        with [ ;"#1";END;]
 DFN [;END;]          AS   [[EMIT; {IF}[COPY E]{ 1CONTINUE [SETR E=0]; }
                             {IF}[COPY M]{CALL AGSENDM; [SETR M=0]} END;]
                            [SETR H=0] [SETR P=0] !END LOCAL; !LABELS 1000; !LOCAL;];
 DFN [RETURN]         AS   [[EMIT GO TO 1];]                         ;
 DFN [QUIT]           AS   [[EMIT GO TO 1];]                         ;
 DFN [(([GENAME]))]   AS   [(#1)]                                    ;
 DFN[COMMON/#/#/#/#;] AS   [COMMON /#1/ #2; COMMON /#3/ #4;]         ;
 REPLACE[<H>]         WITH [[INCR H]]                                ;
 REPLACE[<P>]         WITH [[INCR P]]                                ;
;
 DFN [/*#*/]  AS
 [;"..."  "-----------------------------------------------------------"
   "#1"   "-----------------------------------------------------------" "...";]
 REPLACE [;_[NUMBER]_[GENAME]([NUMBER])=]          WITH [;#2(#3,#1)=]
 REPLACE [;_[NUMBER]_[IDENT].[IDENT]([NUMBER])=]   WITH [;#2.#3(#4,#1)=]
 REPLACE [;[GENAME]={#;]     with  [[INCR Q]; _[COPY Q]_#1={#2,}; #1={]
 REPLACE [;[GENAME]={#;#}]   with  [[INCR Q]; _[COPY Q]_#1={#2,};
                                    [INCR Q]; _[COPY Q]_#1={#3,}; [SETR Q=0]]
 REPLACE [;[IDENT].[IDENT]={#;] with [[INCR Q];_[COPY Q]_#1.#2={#3,}; #1.#2={]
 REPLACE [;[IDENT].[IDENT]={#;#}] with [[INCR Q];_[COPY Q]_#1.#2={#3,};
                               [INCR Q]; _[COPY Q]_#1.#2={#4,}; [SETR Q=0]]
 
"-------------------    g e a n t 3   d e f i n i t i o n s   -----------------------"
  Replace [;MODULE [6SYS] #;] with
          [;SUBROUTINE #1;" #1 #2";    Implicit None;
            Character*20 Module/'#1'/; Character*80 Mcomment/'#2'/;
            Character*60 Bank_Title/'*'/;
            Logical FIRST; Data FIRST/.true./; Save FIRST;
            Integer JUMPAD; External JUMPAD;
            Integer Ok; Parameter (Ok=0);
            Integer %i/0/,%j/0/;  Save %i,%j;
            [SETR M=1][SETR N=2][SETR V=0][SETR W=0][SETR O=0][SETR U=0]
            [SETR Q=0][SETR B=0][SETR A=0] ]
  Replace [;*#;] with ["* #1";]
  Replace [;BEGIN;] with [;"*"; CALL AgSBEGM(Module,Iprin); IF(Iprin<0) RETURN;]
 
 " Geant3 OPERATOR definition - skip assignements before and keep them in PARLIST "
  REPLACE [;[GSYS0]#{#,#}#;]   WITH
          [ {IF}[EXIST 3]  {[INCR O]; IF (#2==[COPY O]) { #1 #3 #5; }; #1 #2{#4,}#5;}
            {ELSE} {;"*"; UNLESS (0<#2&#2<=[COPY O]) { Print *,
            ' Error in #1 #2=',#2,': switch is outside range'; NEXT;} [SETR O=0];"*"; }]
  REPLACE [,;]  with [;]
  REPLACE [;<#>[GSYS0][10SYS];]  with
          [; %TITLE = '#3'; %EXNAME = '#2'; %ParList = '#1';Call Ax#2;"*"; ]
  REPLACE [;<#>[GSYS0][10SYS] [KSYS0]=#;]      with  [; %#4 = #5; <#1_#4>#2 #3; ]
  REPLACE [;<#>[GSYS0][10SYS],[KSYS0]=#;]      with  [; %#4 = #5; <#1_#4>#2 #3; ]
  REPLACE [;<#>[GSYS0][10SYS] [KSYS0]=# #=#;]  with  [; %#4 = #5; <#1_#4>#2 #3  #6=#7; ]
  REPLACE [;<#>[GSYS0][10SYS],[KSYS0]=# #=#;]  with  [; %#4 = #5; <#1_#4>#2 #3  #6=#7; ]
  REPLACE [;[GSYS0][10SYS];] with
          [;" Geant #1 : #2 ===> inherited arguments used <==="; Call AgSRESET;
           %TITLE = '#2'; %EXNAME = '#1'; %ParList = 'NONE'; Call Ax#1;"*";]
  REPLACE [;[GSYS0][10SYS] [KSYS0]=#;] with
          [;" Geant #1 : #2 ===> #3=#4 <==="; Call AgSRESET; %#3 = #4; <#3>#1 #2;]
  REPLACE [;[GSYS0][10SYS] [KSYS0]=# #=#;] with
          [;" Geant #1 : #2 ===> #3=#4 #5=#6 <===";
              Call AgSRESET; %#3 = #4; <#3>#1 #2 #5=#6;]
 
  REPLACE [;CREATE[GSYSN]#;]   with
          [;{IF}[COPY M]{ Call AGSBEGM(Module,Iprin); IF (Iprin<0) Return; }
           ;" Create #1 :#2 ";  PROCEDURE #1  ; "*"; ]
  REPLACE [;CREATE[GSYSN] [KSYS0]=#;]   with [; %#2 = #3; CREATE #1; ]
  REPLACE [;CREATE[GSYSN] [KSYS0]=# #=] with [; %#2 = #3; CREATE #1 #4=]
  REPLACE [;CONTENT [GSYSN];]  with  [ ;Integer BLOCK_#1;]
  REPLACE [;CONTENT #,#;]      with  [ {IF}[EXIST 1] {;Integer BLOCK_#1; CONTENT #2,;}
                                       {ELSE} {;}]
" --------------------------------------------------------------------------------"
Replace [;STRUCTURE#{#}]     with  [;STRUCTURE#1{#2,}]
Replace [;STRUCTURE#{#,#}]   with
   [;{IF}[EXIST 2] { {IF}'#2'='REAL SYSTEM ( 2)' {[SETR N=0]}
                     [INCR N] [INCR W] [SETR X=[COPY N]]
    "-" ^stv{#1,#2}; STRUCTURE #1{#3,}} {ELSE}
   {"-" Integer   Len_#1,Llen_#1,Link_#1;
        Parameter (Len_#1=[COPY N],Llen_#1=[COPY W]);
        Integer   Flag_#1/0/,Map_#1(2,Llen_#1),IDNum_#1(10)/10*0/;
        Character Names_#1(Llen_#1)*12,Commen_#1(Llen_#1)*40/Llen_#1*' '/;
        Real      Bank_#1(len_#1);  Character*60 Bpath_#1/' '/;
        Save      Flag_#1,Map_#1,IdNum_#1,Names_#1,Commen_#1,Bpath_#1;
        {IF}[COPY U]{ Common   /#1wnd/  Link_#1, Bank_#1;  }
        {ELSE}      { Data   Link_#1/0/,Bank_#1/Len_#1*0/;  Save  Link_#1,Bank_#1; }
                     DFN[q(link_#1] AS [Q(AG_LINK(Link_#1)]
       "*"  [SETR N=2][SETR W=0][SETR V=0][SETR U=0];
  }]
Replace [;STRUCTURE/#/]      with  [;[SETR U=1] STRUCTURE #1]
Replace [;COMMON STRUCTURE]  with  [;[SETR U=1] STRUCTURE]
Replace [;OLD STRUCTURE]     with  [;[SETR N=0] STRUCTURE]
replace [^stv{#,#}]          with  [^sck{REAL        #1_#2}; ^std{#1,R.#2}]
replace [^stv{#,REAL #}]     with  [^sck{REAL        #1_#2}; ^std{#1,R.#2}]
replace [^stv{#,INT  #}]     with  [^sck{INTEGER     #1_#2}; ^std{#1,I.#2}]
replace [^stv{#,CHAR #}]     with  [^sck{CHARACTER*4 #1_#2}; ^std{#1,H.#2}]
replace [^sck{#}]            with  [#1]
replace [^sck{#(#,[IDENT])}] with  [#1]
replace [^sck{#([IDENT]#)}]  with  [#1]
replace [^std{#,[LETTER].[IDENT]}]    with   [^std{#1,#2.#3()}]
" order is important: V is changed in dim, N is send to X and copied at the end !"
replace [^std{#,[LETTER].[IDENT](#)}] with
   [  DFN [dis_#1_#3] AS [[COPY N]];
      {IF}'#2'='R'{DFN [dis_#1_#3] AS [NINT(q(link_#1+[COPY N]))]
                   DFN [ind_#1_#3] AS [[COMPUTE [COPY N]+1000000]]}
      {IF}'#2'='I'{DFN [dis_#1_#3] AS [Iq(link_#1+[COPY N])]
                   DFN [ind_#1_#3] AS [[COPY N]]}
      equivalence (Bank_#1([COPY N]),#1_#3,re_#1_#3),(Names_#1([COPY W]),N#1_#3);
      equivalence (Commen_#1([COPY W]),C#1_#3),(Map_#1(1,[COPY W]),M#1_#3);
      character   C#1_#3*40, N#1_#3*12/'#2.#3'/;
      Integer     M#1_#3(2)/^dim{#1:#4}/;
      Real        re_#1_#3;  ^def(#1,#2,#3:#4)
   ]
replace [^dim{#:#}]   with [ {IF}[EXIST 2] {^dim{#1:#2,1}} {ELSE} {^dim{#1:1,1}} ]
replace [^dim{#:#,#}] with [ [INCR V] {IF}'#2'=NUMBER{#2} {ELSE}{-ind_#1_#2},
                                     {IF}'#3'=NUMBER{#3} {ELSE}{-ind_#1_#3}   ]
replace [^dim{#:[NUMBER],[NUMBER]}] with [[SETR N=[COPY N]+[REDUCE #2*#3]-1]#2,#3]
replace [^def(#)] with [ ]
"                          dynamic access definition                     "
replace [Hq(l] with [Iq(l]
replace [Rq(l] with [q(l]
replace [^def(#,[LETTER],#:)] with [DFN[#1.#3] AS [#2q(link_#1+[COPY X])] ]
replace [^def(#,[LETTER],#:[NUMBER])]   with
        [ DFN[#1.#3(##)] AS [#2q(link_#1^+([COPY X]-1+##1))] ]
replace [^def(#,[LETTER],#:[IDENT])]    with  [ DFN[#1_#3(##)] AS [#1_#3]
          DFN[#1.#3(##)] AS [#2q(lq(link_#1-[COPY V])^+(2+##1))]
          DFN[#1_#3(] AS [#1.#3(]          ]
replace [^def(#,[LETTER],#:[NUMBER],[NUMBER])] with
        [ DFN[#1.#3(##,##)] AS [#2q(link_#1^+((##2*#4)+[COPY X]-1-#4+##1))] ]
replace [^def(#,[LETTER],#:[NUMBER],[IDENT])] with   [ DFN[#1_#3(##)] AS [#1_#3]
          DFN[#1.#3(##,##)] AS [#2q(lq(link_#1-[COPY V])^+((##2*#4)+2-#4+##1))]
          DFN[#1_#3(] AS [#1.#3(]          ]
replace [^def(#,[LETTER],#:[IDENT],#)]        with   [ DFN[#1_#3(##)] AS [#1_#3]
          DFN[#1.#3(##,##)] AS [#2q(lq(link_#1-[COPY V])^+(2+##1)^+((##2-1)*dis_#1_#4))]
          DFN[#1_#3(] AS [#1.#3(]          ]
Replace [^+(#)]        with [+(#1)]
Replace [^+([NUMBER])] with [+#1]
Replace [^+(0*#)]      with [   ]
Replace [^+(1*#)]      with [+#1]
Replace [^+(([NUMBER][OPR][NUMBER])] with  [^+([COMPUTE  #1#2#3]]
Replace [^+(-[NUMBER][OPR][NUMBER]]  with  [^+([COMPUTE -#1#2#3]]
Replace [^+([NUMBER][OPR][NUMBER]]   with  [^+([COMPUTE  #1#2#3]]
"---------------------------------------------------------------------------------"
  Replace [SECURE [IDENT] #;]     with  [; IF (LINK_#1==0) LINK_#1=-1; ]
  Replace [;FILL #!#;]         with  [;[SETR S=0] [SETR Q=0] "*"BEGIN;
                   " Filling bank #1 - #2"; Bank_Title='#2'; ^bname=#1;(#1/) f]
  REPLACE [;USE #;] with [;" use default #1 bank"[SETR S=0]; ^bname=#1;(#1/) u;]
  REPLACE [;USE # [GENAME]=#;] with
                             [;" use #1 bank "[SETR S=0]; ^bname=#1;(#1/) u #2=#3;]
  REPLACE [;USE [GSYSN]DIG/] with [; USE /DETM/#1/]
  REPLACE [;USE [GSYSN]GEO/] with [; USE /DETM/#1/]
  Replace [ENDFILL#;] with [;"*#1";]
  Replace [^bname=#; ]           with [^short(#1)=#1;]
  Replace [^bname=#(#)]          with [^bname=#1]
  Replace [^short(#)=#;]         with [BPath_#1='#2*'; ^btit #1]
  Replace [^short(#/#)]          with [^short(#2)]
  Replace [^btit#([IDENT]/#)]    with [[INCR S] IDNum_#1([COPY S])={IF}[EXIST 3]{1}{ELSE}{0};
                                                                       ^btit#1(#3)]
  Replace [^btit#([IDENT](#)/#)] with [[INCR S] IDNum_#1([COPY S])=#3; ^btit#1(#4)]
  Replace [^btit#(/#)]           with [^btit#1(#2)]
  Replace [^btit#()]             with [^bfu #1]
  Replace [^bfu [IDENT] f]       with  [^fyll #1 " " ]
  Replace [^fyll [IDENT]] with [;  Call AgDOCUM (MODULE,
     MComment,Author,Created,Bank_Title,'#1',BPath_#1,IDNum_#1,[COPY S],
     Map_#1,Names_#1,Commen_#1,Bank_#1,Len_#1,Llen_#1,Link_#1,Flag_#1);
           "*" [SETR S=0];]
" - significant comment in the next line to prevent arg1 merge with next word "
  Replace [^fyll [IDENT] [GENAME]=#!#;]  with [;"#4"; #1_#2=#3; C#1_#2='#4';  ^fyll #1  "-" ]
  Replace [^fyll [IDENT] [GENAME]={#;]   with [;[INCR Q]_[COPY Q]_#1_#2={#3,};^fyll #1 #2={]
  Replace [^fyll [IDENT] [GENAME]={#;#}!#;]  with  [;[INCR Q]_[COPY Q]_#1_#2={#3,};
           [INCR Q]_[COPY Q]_#1_#2={#4,};  "#5"; C#1_#2='#5'; [SETR Q=0] ^fyll #1 ]
  Replace [ENDFILL] with [;"*";]
 
"  Replace [^bfu [IDENT] u [GENAME]=#;] with [; #1_#2=#3;                                   "
"                                    call AgDGETP(^subname,'*',-999,'#1',N#1_#2,#1_#2,        "
"    BPath_#1,IDNum_#1,[COPY S],Map_#1,Names_#1,Bank_#1,Len_#1,Llen_#1,Link_#1,Flag_#1); ]; "
 
  Replace [^bfu [IDENT] u#;] with [; call AgDGETP(^subname,'*',-999,'#1',' ',Bank_#1,
   Bpath_#1,IDNum_#1,[COPY S],Map_#1,Names_#1,Bank_#1,Len_#1,Llen_#1,Link_#1,Flag_#1) #2 ;]
 
  Replace [call AgDGETP(#,#,#,#,' ',Bank_#,#) #=# #;] with [ #5_#7=#8;
           call AgDGETP(#1,#2,#3,#4,'#7',re_#5_#7,#6) #9 ;]
  Replace [call AgDGETP(#,#,-999,#) STAT=# #;] with [call AgDGETP(#1,#2,#4,#3) #5 ;]
  Replace [call AgDGETP(#,'*',#)    OPER=# #;] with [call AgDGETP(#1,'#3',#2)  #4 ;]
 
"---------------------------------------------------------------------------------"
 
  REPLACE [;[GSYS1] #;] with [" #1 #2 "; Character*40 #1 /'#2'/;
           "* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*";]
  REPLACE [;[GSYSH]  [GSYSN] #;]  with
          [;"Defining Hits: #3";    %Title = '#2';  %EXNAME = '#1'; %TYPE=%Magic;
             Call AgsDETV('#2'); "*";  ~HITS #2 #3; Call AgsDETU('#2'); "*"; ]
  REPLACE [;[GSYSH]  [GSYSN] #=#:#;]  with
          [;"Defining Hits: #3=#4:#5";   %Title = '#2';  %EXNAME = '#1'; %TYPE=#4;
             Call AgsDETV('#2'); "*";  ~HITS #2 #3:#5; Call AgsDETU('#2'); "*"; ]
  REPLACE [;~HITS [GSYSN] [NAME]:#:#;]  with
          [;  %Parlist='#2'; %Title = 'DETH'; %Nbits = %magic;  %bin=#3;
              {IF}[EXIST 4]{ ~HITPAR(#4); }
              {ELSE} { %FHmin=%Magic; %FhMax=%Magic; %Option='*'; }
              Call AgsDETH ({IF} '#2'='USER' {JUMPAD(#1STEP)} {ELSE} {0}); "*"; ]
  REPLACE [;~HITS [GSYSN] [NAME]:[NUMBER]:#;]  with
          [;  %Parlist='#2'; %Title = 'DETH'; %Nbits = #3;  %bin=%Magic;
              {IF}[EXIST 4]{ ~HITPAR(#4); }
              {ELSE} { %FHmin=%Magic; %FhMax=%Magic; %Option='*'; }
              Call AgsDETH ({IF} '#2'='USER' {JUMPAD(#1STEP)} {ELSE} {0}); "*"; ]
  REPLACE [;~HITS [GSYSN] [NAME]:-[NUMBER]:#;]  with
          [;  %Parlist='#2'; %Title = 'DETH'; %Nbits =-#3;  %bin=%Magic;
              {IF}[EXIST 4]{ ~HITPAR(#4); }
              {ELSE} { %FHmin=%Magic; %FhMax=%Magic; %Option='*'; }
              Call AgsDETH ({IF} '#2'='USER' {JUMPAD(#1STEP)} {ELSE} {0}); "*"; ]
  REPLACE [;~HITS [GSYSN] [NAME]:# [NAME]]  with   [;~HITS #1 #2:#3; ~HITS #1 #4]
  REPLACE [;~HITPAR((#,#)#);]   With [;             %Option='*';
             {IF}[EXIST 1]{ %FhMin = #1; } {ELSE} { %FhMin = %Magic;}
             {IF}[EXIST 2]{ %FhMax = #2; } {ELSE} { %FhMax = %Magic;}     ]
  REPLACE [;~HITPAR([OSYS]#);] With [;
             {IF}[EXIST 1]{ %Option='#1';} {ELSE} { %Option='*'; }
             %FhMin = %Magic; %FhMax = %Magic; ]
  REPLACE [;~HITPAR([OSYS](#,#)#);] With [;
             {IF}[EXIST 1]{ %Option='#1';} {ELSE} { %Option='*';    }
             {IF}[EXIST 2]{ %FhMin = #2; } {ELSE} { %FhMin = %Magic;}
             {IF}[EXIST 3]{ %FhMax = #3; } {ELSE} { %FhMax = %Magic;}     ]
;
  " use %Orti instead if %ORT variable "
  REPLACE [;%ORT=#;] with [      {IF} '#1'='XYZ'{;" standart axes used ";}
                         {ELSE} {{IF} '#1'='YZX'{;%Orti=1;}
                         {ELSE} {{IF} '#1'='ZXY'{;%Orti=2;} } }
                          ]
  REPLACE [;POSITION [GSYSN] IN [NAME] ] with [;POSITION #1 MOTHER='#2' ]
  REPLACE [;CREATE AND POSITION [GSYSN]] with [;CREATE #1;  POSITION #1 ]
  Replace[ERROR(#)] with
         [<W> %L(%Module),%L(%Volume),%L(%Exname),%L(%ParList),%L(%Title);
          (' Error in Module ',A,' Block ',A,' Executing ',A/
            10x,' Parameter list is ',A,' For ',A);
          write(LOUT,*) #1;  %Ierror +=1 ;  RETURN; ]
  Replace[ERROR(#,=#,#)] with [ERROR(#1,' #2 =',#2,#3)]
;
Replace[$]  with [ag_];
DFN [$$D#;]  as  ["+DECK,#1.                " ]
DFN [$$T#;]  as
[ "**********************************************************************"
  "* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*"
  "* . . . . . . . . . . #1 . . . . . . . . . . . . . . . . . . . .*"
  "* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*"
  "* Original Version: . . . . . . . . . . . . . . . . . . . . . . . . .*"
  "* Modifications : . . . . . . . . . . . . . . . . . . . Not done yet *"
  "**********************************************************************"
  Implicit NONE " - Implicit better coding !"; "*" ;
]
Replace [+CDE,#;] with [; include #1.inc;]
"===================================================================="
"---  G E A N T commons: GCONST,GCNUMB,GCKINE,GTMED,GTRACK,GCFLAG ---"
"===================================================================="
Replace[+CDE,GCBANK] With ["  - Dynamic core for the GEANT data (v3.15)  "
  Integer KWBANK,KWWORK,NZEBRA,IXSTOR,IXDIV,IXCONS,LMAIN,LR1,JDIGI,JDRAW,
          JHEAD,JHITS,JKINE,JMATE,JPART,JROTM,JRUNG,JSET,JSTAK,JGSTAT,JTMED,
          JTRACK,JVERTX,JVOLUM,JXYZ,JGPAR,JGPAR2,JSKLT,IQ,IWS,LQ,JCG;
  Real    ZVERSN,GVERSN,FENDQ,WS,Q;
  PARAMETER (KWBANK=69000,KWWORK=5200);
  COMMON
 /GCBANK/NZEBRA,GVERSN,ZVERSN,IXSTOR,IXDIV,IXCONS,FENDQ(16),LMAIN,LR1,WS(KWBANK)
 /GCLINK/ JDIGI,JDRAW, JHEAD,JHITS ,JKINE, JMATE ,JPART,JROTM,JRUNG, JSET,
          JSTAK,JGSTAT,JTMED,JTRACK,JVERTX,JVOLUM,JXYZ, JGPAR,JGPAR2,JSKLT;
  DIMENSION IQ(2),Q(2),LQ(8000),IWS(2);
  EQUIVALENCE (Q(1),IQ(1),LQ(9)),(LQ(1),LMAIN),(IWS(1),WS(1)),(JCG,JGSTAT);
];
Replace[+CDE,GCFLAG] With ["  - Flags and variables to control the run   "
  Integer        Idebug,Idemin,Idemax,Itest,Idrun,Idevt,Ieorun,Ieotri,
                 Ievent,Iswit,Ifinit,Nevent,Nrndm;
  COMMON/GCFLAG/ Idebug,Idemin,Idemax,Itest,Idrun,Idevt,Ieorun,Ieotri,
                 Ievent,Iswit(10),Ifinit(20),Nevent,Nrndm(2);
];
Replace[+CDE,GCKINE] With ["  - Kinematics of current track              "
  Integer        Ikine,Itra,Istak,Ivert,Ipart,Itrtyp,Napart,Ipaold;
  Real           Pkine,Amass,Charge,Tlife,Vert,Pvert;
  COMMON/GCKINE/ Ikine,Pkine(10),Itra,Istak,Ivert,Ipart,Itrtyp,Napart(5),
                 Amass,Charge,Tlife,Vert(3),Pvert(4),Ipaold;
]
Replace[+CDE,GCKING] With ["  - Kinematics of generated secondaries      "
  Integer         KCASE,NGKINE,IFLGK,MXGKIN,MXPHOT,NGPHOT;
  PARAMETER       (MXGKIN=100, MXPHOT=800);
  REAL            GKIN,TOFD,XPHOT,GPOS;
  COMMON /GCKING/ KCASE,NGKINE,GKIN(5,MXGKIN),TOFD(MXGKIN),IFLGK(MXGKIN)
         /GCKIN2/ NGPHOT,XPHOT(11,MXPHOT)
         /GCKIN3/ GPOS(3,MXGKIN);
]
Replace[+CDE,GCMATE] With ["  - Parameters of current material           "
  Integer Nmat,Namate;     Real A,Z,Dens,Radl,Absl;
  COMMON/GCMATE/ NMAT,NAMATE(5),A,Z,Dens,Radl,ABSL ;
]
Replace[+CDE,GCNUM]  With ["  - Current number for various items         "
  Integer        Nmate,Nvolum,Nrotm,Ntmed,Ntmult,Ntrack,Npart,Nstmax,
                 Nvertx,Nhead,Nbit,NALIVE,NTMSTO;
  COMMON/GCNUM/  Nmate,Nvolum,Nrotm,Ntmed,Ntmult,Ntrack,Npart,Nstmax,
                 Nvertx,Nhead,Nbit;
  COMMON/GCNUMX/ NALIVE,NTMSTO;
]
Replace[+CDE,GCONST] With ["  - Natural constants (or considered as such)"
  REAL           PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS,EMMU,PMASS,AVO;
  COMMON/GCONST/ PI,TWOPI,PIBY2,DEGRAD,RADDEG,CLIGHT,BIG,EMASS;
  COMMON/GCONSX/ EMMU,PMASS,AVO;
]
Replace[+CDE,GCTMED] With ["  - parameters of current tracking medium    "
  Integer        Numed,Natmed,Isvol,Ifield,Iupd,ISTpar,NUMold;
  Real           Fieldm,TmaxFD,Stemax,DEEmax,Epsil,STmin,Cfield,Prec;
  COMMON/GCTMED/ NUmed,NATmed(5),ISVOL,IField,Fieldm,TmaxFD,Stemax,
                 DEEmax,Epsil,STmin,CField,Prec,Iupd,ISTpar,NUmold;
]
Replace[+CDE,GCTRAK] With ["  - track parameters at current point        "
  Integer        Nmec,Lmec,Namec,Nstep,MAXnst,IGnext,INWvol,IStop,IGAuto,
                 IEKbin,ILOSL,IMULL,INGOTO,NLdown,NLevin,NLVsav,IStory;
  Real           Vect,GEtot,GEkin,Vout,DEstep,DEstel,Safety,
                 SLeng,Step,Snext,SField,TOFG,GEkrat,UPwght;
  COMMON/GCTRAK/ Vect(7),GEtot,GEkin,Vout(7),Nmec,Lmec(30),Namec(30),Nstep,
                 MAXnst,DEstep,DEstel,Safety,SLeng,Step,Snext,SField,TOFG,
                 GEkrat,UPwght,IGnext,INWvol,IStop,IGAuto,IEKbin,ILOSL,IMULL,
                 INGOTO,NLdown,NLevin,NLVsav,IStory;
]
Replace[+CDE,GCUNIT] With ["  - GEANT description of logical units       "
  COMMON/GCUNIT/ LIN,LOUT,NUNITS,LUNITS(5);
  INTEGER        LIN,LOUT,NUNITS,LUNITS;
  COMMON/GCMAIL/ CHMAIL;
  CHARACTER*132  CHMAIL;
]
Replace[+CDE,GCVOLU] With ["  - Multi-level current volume description   "
  Integer  NLEVEL,NAMES,NUMBER,LVOLUM,LINDEX,INFROM,NLEVMX,NLDEV,LINMX;
  Real     GTRAN,GRMAT,GONLY,GLX;
  COMMON /GCVOLU/ NLEVEL,NAMES(15),NUMBER(15),LVOLUM(15),LINDEX(15),INFROM,
       NLEVMX,NLDEV(15),LINMX(15),GTRAN(3,15),GRMAT(10,15),GONLY(15),GLX(3);
]
Replace[+CDE,GCSETS] With ["  - Identification of the current sensitive detector "
   INTEGER         IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV;
   COMMON /GCSETS/ IHSET,IHDET,ISET,IDET,IDTYPE,NVNAME,NUMBV(20);
]
Replace [+CDE,GCCUTS] With ["  - Cuts for tracking           "
      Real          CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM,
                    DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS;
      COMMON/GCCUTS/CUTGAM,CUTELE,CUTNEU,CUTHAD,CUTMUO,BCUTE,BCUTM,
                    DCUTE ,DCUTM ,PPCUTM,TOFMAX,GCUTS(5);
]
Replace [+CDE,GCTIME] With [" execution time control "
  real            TIMINT,TIMEND;
  Integer                       ITIME,IGDATE,IGTIME;
  COMMON /GCTIME/ TIMINT,TIMEND,ITIME,IGDATE,IGTIME;
]
replace [+CDE,GCSTAK] with [" geant stack definitions "
      INTEGER  NJTMAX,NJTMIN,NTSTKP,NTSTKS,NDBOOK,NDPUSH,NJFREE,NJGARB,
               NJINVO,LINSAV,LMXSAV,NWSTAK,NWINT,NWREAL,NWTRAC,ISTORD;
      PARAMETER (NWSTAK=12,NWINT=11,NWREAL=12,NWTRAC=NWINT+NWREAL+5);
      COMMON /GCSTAK/ NJTMAX, NJTMIN, NTSTKP, NTSTKS, NDBOOK, NDPUSH,
                      NJFREE, NJGARB, NJINVO, LINSAV(15), LMXSAV(15);
      EQUIVALENCE (ISTORD,NJTMIN);
]
replace [+CDE,GCPHYS] with [" geant physics flags "
      INTEGER IPAIR,ICOMP,IPHOT,IPFIS,IDRAY,IANNI,IBREM,IHADR,IMUNU,
              IDCAY,ILOSS,IMULS,IRAYL,ILABS,ISYNC,ISTRA;
      REAL    SPAIR,SLPAIR,ZINTPA,STEPPA,SCOMP,SLCOMP,ZINTCO,STEPCO,
              SPHOT,SLPHOT,ZINTPH,STEPPH,SPFIS,SLPFIS,ZINTPF,STEPPF,
              SDRAY,SLDRAY,ZINTDR,STEPDR,SANNI,SLANNI,ZINTAN,STEPAN,
              SBREM,SLBREM,ZINTBR,STEPBR,SHADR,SLHADR,ZINTHA,STEPHA,
              SMUNU,SLMUNU,ZINTMU,STEPMU,SDCAY,SLIFE, SUMLIF,DPHYS1,
              SLOSS,SOLOSS,STLOSS,DPHYS2,SMULS,SOMULS,STMULS,DPHYS3,
              SRAYL,SLRAYL,ZINTRA,STEPRA,SLABS,SLLABS,ZINTLA,STEPLA;
      COMMON/GCPHYS/IPAIR,SPAIR,SLPAIR,ZINTPA,STEPPA,ICOMP,SCOMP,SLCOMP,ZINTCO,STEPCO,
                    IPHOT,SPHOT,SLPHOT,ZINTPH,STEPPH,IPFIS,SPFIS,SLPFIS,ZINTPF,STEPPF,
                    IDRAY,SDRAY,SLDRAY,ZINTDR,STEPDR,IANNI,SANNI,SLANNI,ZINTAN,STEPAN,
                    IBREM,SBREM,SLBREM,ZINTBR,STEPBR,IHADR,SHADR,SLHADR,ZINTHA,STEPHA,
                    IMUNU,SMUNU,SLMUNU,ZINTMU,STEPMU,IDCAY,SDCAY,SLIFE, SUMLIF,DPHYS1,
                    ILOSS,SLOSS,SOLOSS,STLOSS,DPHYS2,IMULS,SMULS,SOMULS,STMULS,DPHYS3,
                    IRAYL,SRAYL,SLRAYL,ZINTRA,STEPRA;
      COMMON/GCPHLT/ILABS,SLABS,SLLABS,ZINTLA,STEPLA,ISYNC,ISTRA;
]
replace [+CDE,GCLIST] with [" geant control lists "
      INTEGER       NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT,NSTAT,
                    LHSTA,LGET ,LSAVE,LSETS,LPRIN,LGEOM,LVIEW,LPLOT,LSTAT;
      COMMON/GCLIST/NHSTA,NGET ,NSAVE,NSETS,NPRIN,NGEOM,NVIEW,NPLOT,NSTAT,
                    LHSTA(20),LGET (20),LSAVE(20),LSETS(20),LPRIN(20),
                    LGEOM(20),LVIEW(20),LPLOT(20),LSTAT(20);
]
replace [+CDE,GCSCAL] with [" geant scan links "
      INTEGER      MXSLNK, ISLINK, LSLAST, LSCAN, LSTEMP, LSPARA, LSERAY;
      PARAMETER   (MXSLNK=100);
      COMMON/GCSCAL/ ISLINK(MXSLNK);
      EQUIVALENCE (LSLAST,ISLINK(MXSLNK));
      EQUIVALENCE (LSCAN ,ISLINK(1)),(LSTEMP,ISLINK(2));
      EQUIVALENCE (LSPARA,ISLINK(3)),(LSERAY,ISLINK(4));
]
replace [+CDE,GCPUSH] with [" geant bank increment sizes "
      INTEGER       NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ;
      COMMON/GCPUSH/NCVERT,NCKINE,NCJXYZ,NPVERT,NPKINE,NPJXYZ;
]
" geant common done, now all the rest  ";
replace [+CDE,QUEST]  with [; INTEGER IQUEST;  COMMON/QUEST/IQUEST(100);]
REPLACE [+CDE,SCLINK] With [;  "  - SLUG link area for detectors and I/O     "
  INTEGER LVROOT,LKROOT;  COMMON/SCROOT/LVROOT(2);  EQUIVALENCE (LKROOT,LVROOT);
  INTEGER NSLINK,LKSLUG,LKGLOB,LKDETM,LKTFLM,LKTFLT,LKAMOD,LKAGEV,LKAMCH,LKADIG,
          LKMAPP,LKMFLD,LKRUNT,LKEVNT,LKARAW,LKATRI,LKAPRE,LKARP1,LKARP2,LKARP3,
          LKDSTD,LKRUN2,LKEVN2,LKVER2,LKKIN2,LKHIT2,LKGENE;
  PARAMETER (NSLINK=40);              COMMON/SCLINK/LKSLUG(NSLINK);
  EQUIVALENCE (LKSLUG(1),LKGLOB)  " top of temporary HEPEVT Zebra tree        ";
  EQUIVALENCE (LKSLUG(2),LKDETM)  " subdetector structure                     ";
  EQUIVALENCE (LKSLUG(3),LKTFLM)  " permanent track filter structure          ";
  EQUIVALENCE (LKSLUG(4),LKTFLT)  " temporary track filter structure          ";
  EQUIVALENCE (LKSLUG(5),LKAMOD)  " MODule parameters (Don't know whatisthis  ";
  EQUIVALENCE (LKSLUG(6),LKAGEV)  " general event struc.(Different from EVNT? ";
  EQUIVALENCE (LKSLUG(7),LKAMCH)  " MonteCarlo Hits ( not GEANT I guess)      ";
  EQUIVALENCE (LKSLUG(8),LKADIG)  " DIGitized hits (again not GEANT...?)      ";
  EQUIVALENCE (LKSLUG(9),LKMAPP)  " map structure                             ";
  EQUIVALENCE (LKSLUG(10),LKMFLD) " magnetic field banks                      ";
  EQUIVALENCE (LKSLUG(11),LKRUNT) " run tree bank (preliminary run vert.struc.";
  EQUIVALENCE (LKSLUG(12),LKEVNT) " event tree bank (preliminary event vert.s.";
  EQUIVALENCE (LKSLUG(13),LKARAW) " raw data structure                        ";
  EQUIVALENCE (LKSLUG(14),LKATRI) " trigger banks                             ";
  EQUIVALENCE (LKSLUG(15),LKAPRE) " preprocessed hits                         ";
  EQUIVALENCE (LKSLUG(16),LKARP1) " reconstuction phase 1 banks               ";
  EQUIVALENCE (LKSLUG(17),LKARP2) " reconstuction phase 2 banks               ";
  EQUIVALENCE (LKSLUG(18),LKARP3) " reconstuction phase 3 banks               ";
  EQUIVALENCE (LKSLUG(19),LKDSTD) " DST data banks                            ";
  EQUIVALENCE (LKSLUG(20),LKRUN2) " run tree bank for secondary run           ";
  EQUIVALENCE (LKSLUG(21),LKEVN2) " event tree bank for secondary events      ";
  EQUIVALENCE (LKSLUG(22),LKVER2) " secondary GEANT VERT bank                 ";
  EQUIVALENCE (LKSLUG(23),LKKIN2) " secondary GEANT KINE bank                 ";
  EQUIVALENCE (LKSLUG(24),LKHIT2) " secondary GEANT HITS bank                 ";
  EQUIVALENCE (LKSLUG(26),LKGENE) " old slug ZEBRA generator structure        ";
];
REPLACE[+CDE,STAFUNC] with [" Declare control flags in detector bank";
      INTEGER IIIII, LVPRIN,LWPRIN,LWDEBU,LVGEOM,LVHIST,LVGRAP,
              LVDEBU,LVSIMU,LVDIGI,LVRECO,LVMFLD,LVANAL,LVBACK;
      LVPRIN(IIIII)=IQ(LQ(LKDETM-IIIII)+1);
      LVDEBU(IIIII)=IQ(LQ(LKDETM-IIIII)+2);
      LWPRIN(IIIII)=IQ(LQ(LKDETM-IIIII)+2);
      LWDEBU(IIIII)=IQ(LQ(LKDETM-IIIII)+3);
      LVGEOM(IIIII)=IQ(LQ(LKDETM-IIIII)+4);
      LVHIST(IIIII)=IQ(LQ(LKDETM-IIIII)+5);
      LVGRAP(IIIII)=IQ(LQ(LKDETM-IIIII)+6);
      LVSIMU(IIIII)=IQ(LQ(LKDETM-IIIII)+7);
      LVDIGI(IIIII)=IQ(LQ(LKDETM-IIIII)+8);
      LVRECO(IIIII)=IQ(LQ(LKDETM-IIIII)+9);
      LVMFLD(IIIII)=IQ(LQ(LKDETM-IIIII)+10);
      LVANAL(IIIII)=IQ(LQ(LKDETM-IIIII)+11);
      LVBACK(IIIII)=IQ(LQ(LKDETM-IIIII)+12);
];
Replace [+CDE,ASFLAGS] with [" names and order of control flags ";
      INTEGER      NFLAGS;
      PARAMETER    (NFLAGS=15);
      CHARACTER*4  CFLAG(NFLAGS);
      DATA CFLAG   /'PNOW','PRIN','DEBU','GEOM','HIST','GRAP','SIMU','DIGI',
                    'RECO','MFLD','ANAL','BACK','RESA','RESB','RESC'/;
]
Replace[+CDE,RBBANK] with [;" - Reconstruction bank access variables "
  Character  Cnam*4;
  Integer    Lu,BIG,MM,Inam,II,KK,Iadr,Leng,IrbDIV,
             IOD,IOX,LDD,NDDmax,Ndd,DDL,Nfr,FrTab;
  Parameter (LDD=5, NDDmax=100);
  COMMON /RBXBANK/  Lu, Cnam,II,KK,Iadr,Leng,IOD,IOX,IrbDIV
         /RBXLIST/  Ndd,DDL(LDD,NDDmax)  /RBXFORM/  Nfr,FrTab(NDDmax);
  Equivalence (Cnam,Inam);   Data  BIG /99999/,MM/2/;
];
Replace [+CDE,AGCLINK] with [;" - links for dynamic bank access    "
       INTEGER    NALinkMAX,AG_NLink,AG_Link;
       PARAMETER  (NALinkMAX=100);
       COMMON /AGCLink/ AG_NLink,AG_Link(0:NALinkMAX);
];
replace[+CDE,AGCDOCL] with  [;"  common for the documentation supporting links "
      Integer           LDarea(2),L1Doc,L2Doc,LKDoc,Ldoc,Ldete,Lpar;
      COMMON /AGCDOCL/  LDarea,   L1Doc,L2Doc,LKDoc,Ldoc,Ldete,Lpar;
]
REPLACE [+CDE,AGECOM] with [;" - Advanced Geant interface ";
  character*20  %Module,%Title,%ExName,%ParList,%ChDir,
                %material,%mixture,%component,%medium;
  character*4   %Volume,%Mother,%Shape,%Cnick,%Konly,%Option,%Ort,%Mark;
  Integer       %BegCom,%Ivolume,%Imother,%Ignum,%Ishape,%Imed,%Imat,%Ifield,
                %NLmat,%Ierror,%NWBUF,%Npar,%Istatus,%Irot,%NBits,%Serial,
                %Attribute(6),%Work,%Seen,%Lsty,%Lwid,%Colo,%Fill,%Jdu,%Orti,
                %Ndiv,%Iaxis,%NdvMax,%Iprin,%Reset1,%Reset2,%BegScr,%EndScr,
                %Idtype,%Iset,%Idet,%Isvol,%level,%ireser,%Igeom,%Standalone,
                %LSTACK,%NwuHit,%NwuVol,%Magic,%LDETU,%NpDiv,%NpDv,%Nz,%Ncopy,
                %Idebu,%Igrap,%Ihist,%Imfld,%Isimu,%EndSave,Iprin;
  Real          %FIELDM,%TMAXFD,%STEMAX,%DEEMAX,%EPSIL,%STMIN,%Dens,%RadL,%AbsL,
                %Thetax,%Thetay,%Thetaz,%Alfax,%Alfay,%Alfaz,%Phix,%Phiy,%Phiz,
                %Alphax,%Alphay,%Alphaz,%Type,
                %dx,   %dx1,  %dx2,  %dy,   %dy1,  %dy2, %DMAXMS, %Twist,
                %thet, %the1, %the2, %phi,  %phi1, %phi2, %alph, %alp1, %alp2,
                %Rmin, %Rmax, %Rmn,  %Rmx,  %Zi ,  %rmn1, %rmn2, %rmx1, %rmx2,
                %h1,   %h2,   %bl1,  %bl2,  %tl1,  %tl2,  %Dphi, %dz,   %Twis,
                %x, %y, %z,   %A, %Za, %W,  %Step, %C0, %Par,    %AA, %ZZ, %WW,
                %LX,  %LY,  %LZ,  %HX,  %HY,  %HZ, %P1, %P2,
                %Stack,%UBUF,%Xhmax,%Yhmax,%Zhmax,%Rhmax,%FhMax,%Fhmin,%bin;
  Parameter     (%LSTACK=130,%NwuHit=10,%NwuVol=3,%MAGIC=-696969,%LDETU=250);
 
  COMMON/AGCGLOB/ %Module,%ChDir,%Level,%Idtype,%Ierror,%Standalone,Iprin,
                  %Iprin,%Igeom,%Idebu,%Igrap,%Ihist,%Imfld,%Isimu;
  "Inherited variables a: saved during internal calls"
  "                    b: reset at the entry in a block and then saved"
  COMMON/AGCPARA/ %BegCom, %Ivolume, %Imother, %Ignum, %Ishape, %Imed, %Imat, %Ifield,
        %FIELDM, %TMAXFD, %STEMAX, %DEEMAX, %EPSIL, %STMIN, %Dens, %Radl, %AbsL,
        %dx,   %dx1,  %dx2,  %dy,   %dy1,  %dy2,  %rmn1, %rmn2, %rmx1, %rmx2,
        %thet, %the1, %the2, %phi,  %phi1, %phi2, %alph, %alp1, %alp2,
        %h1,   %bl1,  %tl1,  %h2,   %bl2,  %tl2,  %Rmin, %Rmax, %Dphi, %Npdiv,
        %Nz,   %dz,   %Twis, %LX,   %LY,   %LZ,   %HX,   %HY,   %HZ,
        %A, %Za, %W, %NLmat, %Work, %Seen, %Lsty, %Lwid, %Colo, %Fill,
        %Serial, %Isvol,  %Istatus, %Zi(16), %Rmn(16), %Rmx(16),
        %Volume, %Mother, %Shape,   %Cnick,                           %EndSave,
        %Reset1,%Thetax,%Thetay,%Thetaz,%Alfax,%Alfay,%Alfaz,%Phix,%Phiy,%Phiz,
        %x,%y,%z, %Step,%C0,%Ndiv,%Iaxis,%NdvMax,%Orti,%Ncopy,         %Reset2,
        %Konly, %Ort, %Mark;
  "local variables valid inside same block "
  COMMON/AGCLOCA/ %begScr,%UBUF(100),%Par(100),%AA(20),%ZZ(20),%WW(20),%NwBuf,
                 %Xhmax,%Yhmax,%Zhmax,%Rhmax,%FhMax,%FhMin,%Nbits,%Bin,%Type,
                 %Irot,%Npar,%Iset,%Idet,%JDU,%ireser,                %EndScr,
                 %Title,%Exname,%Parlist,%material,%mixture,
                 %component,%medium,%Option;
  COMMON/AGCSTAC/ %Stack(%LSTACK,15);
  Equivalence    (%Attribute,%Work),(%STEMAX,%DMAXMS),(%Alphax,%Alfax),
                 (%Alphay,%Alfay),(%Alphaz,%Alfaz),(%Twist,%Twis),(%NpDiv,%NpDv),
                 " temporarly " (%P1,%HX),(%P2,%HY)
];
Replace [+CDE,AGCKINE] with [;"   AGI general data card information "
      Integer          IKineOld,IdInp,Kevent,
                       Iback,IbackOld,IbMode,IbBefor,IbAfter,
                       IbCurrent,IvCurrent,Ioutp,IoutpOld;
      Real             AVflag,AVcoor,AVsigm,Ptype,PTmin,PTmax,
                       Etamin,Etamax,PhiMin,PhiMax,Ptflag,
                       Zmin,Zmax,BgMult,BgTime,BgSkip,
                       Pxmin,Pxmax,Pymin,Pymax,Pzmin,Pzmax;
      COMMON /AgCKINE/ IKineOld,IdInp,Kevent(3),
                       AVflag,AVcoor(3),AVsigm(3),
                       Ptype,PTmin,PTmax,Etamin,Etamax,
                       PhiMin,PhiMax,Ptflag,Zmin,Zmax,
                       Pxmin,Pxmax,Pymin,Pymax,Pzmin,Pzmax;
      COMMON /AgCKINB/ Iback,IbackOld,IbMode,IbBefor,IbAfter,
                       BgMult,BgTime,BgSkip,IbCurrent,IvCurrent;
      COMMON /AgCKINO/ Ioutp,IoutpOld;
      Character*20     CoptKine,CoptBack,CoptOutp;
      COMMON /AgCKINC/ CoptKine,CoptBack,CoptOutp;
      Character*20     CrunType;
      COMMON /AgCKINR/ CrunType;
      Integer          Ncommand;
      Character*20     Ccommand;
      COMMON /AgCCOMD/ Ncommand,Ccommand;
      Integer          IUHIST;
      Character*80            CFHIST,CDHIST;
      COMMON /AgCHIST/ IUHIST,CFHIST,CDHIST;
;
      Integer          NtrSubEV,NkineMax,NhitsMax,NtoSkip,NsubToSkip,Nsubran,
                       ItrigStat,NsubEvnt,IsubEvnt,Make_Shadow,Flag_Secondaries;
      Real             Cutele_Gas,VertexNow;
      COMMON /AgCSUBE/ NtrSubEV,NkineMax,NhitsMax,NtoSkip,NsubToSkip,Nsubran(2);
      COMMON /AgCSTAR/ Make_Shadow,Cutele_Gas,Flag_Secondaries;
      COMMON /AgCstat/ ItrigSTAT,NsubEvnt,IsubEvnt,VertexNow(3);
]
Replace [+CDE,AGCSTEP] with [;" Connection between AgGSTEP, AgGHIT and a user step routine ";
    Real              vect0,   vloc0,   vloc,   xloc   ,Astep,Adestep,HITS;
    Integer           IhaveMore;
    COMMON /AGCSTEP/  vect0(7),vloc0(7),vloc(7),xloc(7),Astep,Adestep;
    COMMON /AGCSTEPH/ HITS(15);
    COMMON /AGCSTEPI/ IhaveMore;
]
Replace [+CDE,AGCRDIG] with [;" communication between AgFHIT0/1,FDIGI,FPATH,FDPAR ";
    Integer          IWA,   JS,JD,JX,JXD,JDS,JDU;
    COMMON /AGCRDIG/ IWA(2),JS,JD,JX,JXD,JDS,JDU;
    Integer          Iprin,Nvb,Nw,Last,Mb,Nc1,Nc2,Iv,Ia;
    Character*4                                         cs,cd;
    COMMON /AGCHITV/ Iprin,Nvb,Nw,Last,Mb,Nc1,Nc2,Iv,Ia,cs,cd;
];
Replace [+CDE,AGCDIG] with [;" for internal AGSDIG0/1 communication only ";
      INTEGER        NLOCAL,   JS,JD,JDX,JX,JXD,JDU,LOCAL;
      COMMON/GCLOCA/ NLOCAL(2),JS,JD,JDX,JX,JXD,JDU,LOCAL(14);
      Integer        Iset,Idet,NW,NV,ND,NVU,NDU;
      COMMON/AGCDIGA/Iset,Idet,NW,NV,ND,NVU,NDU;
];
Replace [+CDE,AGCBUFF] with [;"     buffer for hit/digi maps ";
    Integer          Ibuf,Lbuf;
    Parameter        (Lbuf=500 000);
    Common /AGCBUFF/ Ibuf(Lbuf);
];
Replace [+CDE,AGCRTAB] with ["  Commons for the inner detector digi reconstruction "
      Integer           Lstack,     Lr,   Lhead,   Lpack;
      Parameter        (Lstack=2000,Lr=15,Lhead=52,Lpack=512);
                       "                  subsystem descriptor         "
      Integer          Isys,Nplane,Itp,Iset,Idet,kkk,kfi,krz,mrz,NumPmx,
                       Nadr,Istart,Inamd,Iaxr,Iaxt,Iaxz,Ires, nam,nmx;
      Real             Rstack,drzm,RRmin,RRmax,ZZmin,ZZmax;
      Common /AgCRtab/ Isys,Nplane,Itp,Iset,Idet,kkk,kfi,krz,mrz,drzm,
                       RRmin,RRmax,ZZmin,ZZmax,
                       NumPmx,Nadr,Istart,Inamd,Iaxr,Iaxt,Iaxz,Ires,
                       Nam(15),Nmx(15),  Rstack(Lr,Lstack);
      Integer                            Istack(Lr,Lstack);
      Equivalence      (Rstack,Istack);
                       "                      plane descriptor         "
      Real             rzp,RZmin,RZmax,Fmin,Fmax,Dfi,Dzr,tilt,sas,Fcent;
      Integer          Nfi,Nzr,Nump,Iadr,Jres,Lpacku;
      Common /AgCRta1/ rzp,RZmin,RZmax,Fmin,Fmax,Dfi,Dzr,tilt,sas,Fcent,
                       Nfi,Nzr,Nump,Iadr,Jres,Lpacku;
                       "                      detector size            "
      Integer          Ishape,Npar;
      Real                         AgTran,   AgRmat,    Par;
      Common /ARCplan/ Ishape,Npar,AgTran(3),AgRmat(10),Par(50);
"     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  ";
]
Replace [+CDE,TRBANK] with ["           - Track point bank                "
      INTEGER         LTB,NTB,LPNT,ISPOINT;
      PARAMETER       (LTB=10000,LPNT=12);
      REAL            TRPOINT,DTRPOINT;
      COMMON /TRBANK/ NTB,TRPOINT(LPNT,LTB);
      COMMON /TRBANI/     ISPOINT(LTB);
      COMMON /TRBANJ/     DTRPOINT(LTB);
      REAL            OPNT,XPNT,DPNT,SPNT,APNT,EPNT,PPNT;
      COMMON /TRKPNT/ OPNT,XPNT(3),DPNT,SPNT(2),APNT(3),EPNT,PPNT;
      REAL            PIXB,PIXE,GAAS,SCTT,ZSCT,SITV,SIT,MSGC,XTRT;
      DATA            PIXB,PIXE,GAAS,SCTT,ZSCT,SITV,SIT,MSGC,XTRT
                      / 1,   2,   3,   4,   5,   6,  7,   8,   9  /;
"     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ";
]
Replace [+CDE,PAWC] with [" Hbook-Paw store "
      INTEGER     NWPAW,IXPAWC,IHDIV,IXHIGZ,IXKU,        LMAIN;
      REAL                                       FENC   ,      HCV;
      COMMON/PAWC/NWPAW,IXPAWC,IHDIV,IXHIGZ,IXKU,FENC(5),LMAIN,HCV(9989);
      INTEGER   IQ        ,LQ;
      REAL            Q;
      DIMENSION IQ(2),Q(2),LQ(8000);
      EQUIVALENCE (LQ(1),LMAIN),(IQ(1),LQ(9)),(Q(1),IQ(1));
]
Replace [+CDE,TYPING] with [;Implicit None;];
" - - - - - - - - - - - - - - - - - - - - - - - - - - - "
"                    cmz part                           ";
 REPLACE [;+INCLUDE]    WITH  [;+CDE,]
 REPLACE [;+CDE,#.#;]   WITH  [;+CDE,#1;]
 REPLACE [;+CDE,#,]     WITH  [{IF} [EXIST 1] {;+CDE,#1};+CDE,]
 REPLACE [;+DECK,#;]    WITH  [;"* DECK,#1";];
 REPLACE [;CDECK ID,#;] WITH  [;"* DECK,#1";];
 REPLACE [;+PATCH,#;]   WITH  [;"* PATCH,#1";];
 Replace [;*KEEP,#;]    with  [;"* KEEP,#1";!FORTRAN;];
 Replace [*KEEP,#;]     with  [;"* KEEP,#1";!FORTRAN;];
 Replace [*KEND.;]      with  [;"* KEND.";!GEANT3; ];
;
Replace[PRIN[DIGIT]]  With [{IF} '#1'='0' {;<W>} {ELSE} {; IF (Iprin>=#1) <W>}]
Replace[%] with [ag_];
Replace[;%[IDENT]={#}] with [;$#1={#2};]
Replace[%L(#)] with [#1(1:Lenocc(#1))]
;
!COMMENTS; !INDENT F3; !INDENT C3; !INDENT M3; !NODEFINE; !TRACE0;
!RECOVER;  !DEFAULT 4; !BLACK;     !MODE 0;    !UPLOW;
%B80     - Lrecl in G-input
%C81     - significant columns  should be < 132
%Q1      - stop comments at the end of each line
REPLACE  [! #;] with [" #1";]
REPLACE  [;;]   with [;]
%INCLUDE [detmsys.def]
%S1  - number fortran file with source line numbers
%U7  - read file.g
;;
%%
 
 
+DECK,nxtcrd.
*CMZ :          06/11/97  12.14.26  by  Pavel Nevski
*-- Author :
C------------------------------------------------------------------
      SUBROUTINE NXTCRD
      IMPLICIT INTEGER (A-Z)
      DIMENSIONO(256000)
      COMMON /NAMO/O
      DATA LL/0/,KEEP/0/
      INTEGER FS(8)/8*0/
      CHARACTER*8 CF/'    '/
      O(62)=0
      IF(O(52).EQ.2) CALLMESAGE(16,1,0,0)
      IBK=ICHAR('   ')
20    IF (O(52).EQ.1) THEN
         O(52)=0
         O(9)=O(O(50))
         O(50)=O(50)-1
         CALLMESAGE(13,4,U,U)
         IF (O(9).EQ.0) THEN
            O(52)=2
            O(15)=1
            O(12)=O(43)
            O(O(12))=O(79)
            GOTO 99999
         END IF
      END IF
      CALLRW(0,O(9),405,O(38))
      IF (O(52).EQ.1) THEN
         O(12)=537
         DO 31 T = 537,O(43)
            O(T)=47
31       CONTINUE
         IF (O(15).EQ.0 .AND. KEEP.GT.0 .AND. O(55).EQ.85) THEN
            KEEP=KEEP-1
            O(537)=86
            LL=0
            GOTO40
         END IF
         GOTO20
      END IF
C Shift line to D positions to generate ';'(TRM) automatically
      D=MAX(O(43)-O(36),0)
      IF (O(969+O(405)).EQ.50 .OR. O(15).GT.0) D=0
      DO 51 K = 537,537+D
         O(K)=47
51    CONTINUE
      BF=537-405+D
      R2=405
      TF=0
      MF=0
      CALLVZERO(FS,8)
      CF='  '
C convert to internal code and get first four letters in capital (FS)
      DO 61 K = 405,O(38)
         T=O(969+O(K))
         O(K+BF)=T
         IF (O(K).NE.IBK) THEN
            R2=K
            MF=MIN(MF+1,8)
            IF ((52.LE.T).AND.(T.LE.72)) T=T-52+10
            FS(MF)=T
            CF(MF:MF)=CHAR(O(K))
C      TF is the 6th symbol
            IF (MF.EQ.1 .AND. K-405.EQ.5) TF=T
         END IF
61    CONTINUE
C+SEQN;
      O(12)=537
      O(237)=O(76)
      CALLCLTOU(CF)
Cprevious last symbol
      LO=LL
C new last symbol
      TL=R2+BF
      LL=O(TL)
C Recognize comment line
      IF (D.GT.0) THEN
         IF (O(538).EQ.45 .OR. (O(538).EQ.83 .OR. O(538).EQ.12 .OR. O(
     *   538).EQ.54 ) .AND. (37.LE.O(538+1)).AND.(O(538+1).LE.50)) THEN
            O(537)=O(79)
            O(538)=82
            O(TL+1)=82
C      first, remove the explicit continuation sign from the current lin
C      e
            LL=47
         ELSE
            IF ( O(TL).EQ.37 .OR. O(TL).EQ.93 ) O(TL)=47
C       possible continuations: $_(,.=-+/*) ... <>|&^?\
            O(537)=O(79)
C      FORTRAN continuation (6th symbol): ,.=-+ >|& or </* preceeded by
C      ,.=-+
C      F
            IF (TF.GT.35) THEN
               IF (((39.LE.TF).AND.(TF.LE.43)) .OR. (88.LE.TF).AND.(TF.
     *         LE.90)) THEN
                  O(537)=47
                  O(537+6)=47
C            F
               ELSE IF ((((44.LE.TF).AND.(TF.LE.45)).OR.TF.EQ.87) .AND.
     *         (39.LE.LO).AND.(LO.LE.45)) THEN
                  O(537)=47
                  O(537+6)=47
               END IF
            END IF
C      MORTRAN continuation: line ends with =-+,_\; or starts with { or
C      ELSE after }
            IF (LO.GT.35.OR.FS(1).EQ.78) THEN
               IF (((41.LE.LO).AND.(LO.LE.43)).OR.(LO.EQ.37.OR.LO.EQ.93.
     *         OR.LO.EQ.39.OR.LO.EQ.79.OR.FS(1).EQ.78).OR. (LO.EQ.84.
     *         AND.CF(1:4).EQ.'ELSE')) THEN
                  O(537)=47
               END IF
C       Recognize comment line
            END IF
            IF (O(537).EQ.O(79) .OR. LO.EQ.O(79)) THEN
               IF (FS(1).EQ.45) THEN
                  O(538)=82
                  O(TL+1)=82
                  LL=47
               END IF
               IF (O(538).EQ.12 .AND. (37.LE.O(538+1)).AND.(O(538+1).LE.
     *         50)) THEN
                  O(538)=82
                  O(TL+1)=82
                  LL=47
               END IF
            END IF
         END IF
      END IF
      IF (O(537).EQ.50) THEN
         IF (O(538).EQ.14) THEN
            O(237)=1
            O(405)=O(769+O(76))
            O(405+1)=O(405)
            O(12)=538+1
         ELSE IF (O(538).EQ.50) THEN
            O(52)=1
C       FRT=1
            GOTO20
         ELSE IF ((10.LE.O(538)).AND.(O(538).LE.35)) THEN
            CALLCCCARD(O(538)-9)
            O(12)=O(43)
            O(O(12))=O(79)
         ELSE IF ((52.LE.O(538)).AND.(O(538).LE.77)) THEN
            CALLCCCARD(O(538)-51)
            O(12)=O(43)
            O(O(12))=O(79)
         END IF
         IF (O(52).EQ.1 .OR. O(538).EQ.22 .OR. O(538).EQ.15) THEN
            O(12)=O(43)
            O(O(12))=O(79)
            GOTO 99999
         END IF
      END IF
      IF (O(538).EQ.43) THEN
         IF (CF(1:5).EQ.'+KEEP' .OR. CF(1:5).EQ.'+DECK' .OR. CF(1:6).EQ.
     *   '+PATCH') THEN
            O(537)=79
            IF (O(55).EQ.85) THEN
               O(537)=86
               KEEP=KEEP-1
            END IF
            IF (CF(1:5).EQ.'+KEEP') THEN
               IF (CF(1:6).EQ.'+KEEP,') THEN
                  O(538)=79
                  O(537+6)=85
                  O(O(36))=40
                  KEEP=KEEP+1
               ELSE
                  O(538)=82
               END IF
            END IF
         END IF
      END IF
40    IF (O(21).EQ.1) THEN
         DO 71 J = 238,254
            O(J)=O(76)
71       CONTINUE
         IF (O(30).EQ.1) THEN
            J=LLONG(238,O(19),10,0)
         ELSE IF (O(30).EQ.2) THEN
            DO 81 J = 1,8
               O(237+J)=O(O(43)+J)
81          CONTINUE
         END IF
         IF (O(68).NE.0)O(247)=33
         O(249)=O(55)
C   IF (QCHR==) print *,' Geant Warning: literal expression not closed i
C   n line '
         J=LLONG(250,O(11),10,0)
         IF (O(53).EQ.0) THEN
            W=254
C      NMX
            DO 91 K = 1,R2-405+D
               W=W+1
               O(W)=O(536+K)
91          CONTINUE
            CALLRW(18,O(56),237,W)
         ELSE
            I=MOD(MAX0(O(53)*O(11),0),90)
            L=537
            M=O(43)
100         IF(O(L).NE.O(76).OR.L.EQ.M)GOTO101
               L=L+1
            GOTO 100
101         CONTINUE
110         IF(O(M).NE.O(76).OR.L.EQ.M)GOTO111
               M=M-1
            GOTO 110
111         CONTINUE
120         CONTINUE
               W=255
               DO 131 Y = 1,I
                  O(W)=O(76)
                  W=W+1
131            CONTINUE
140            IF(W.GT.368 .OR. L.GT.M)GOTO141
                  O(W)=O(L)
                  W=W+1
                  L=L+1
               GOTO 140
141            CONTINUE
               CALLRW(18,O(56),237,W-1)
               IF(L.GT.M)GOTO121
               DO 151 K = 237,255
                  O(K)=O(76)
151            CONTINUE
            GOTO 120
121         CONTINUE
         END IF
      END IF
      IF (O(15).EQ.1 .AND. O(537).NE.50 .AND. O(537).NE.83 .AND. O(537).
     *NE.79) THEN
         CALLRW(23,O(57),405,R2)
         GOTO20
      END IF
      IF (O(10).EQ.1) THEN
         NERD=LINF(537,537+(R2-405),10)
      END IF
99999 RETURN
      END
+PATCH,GEANT. (GXINT) =========================================================
*CMZ :  1.00/00 19/12/95  10.00.03  by  G. Poulard
+KEEP,TRCOM3.
*CMZ :  1.00/00 26/08/95  00.39.30  by  Pavel Nevski
*-- Author :
      DOUBLE PRECISION A, B, S, TN, T, COSL, SINL, COSP, SINP, COSL1
      INTEGER          NEW
      COMMON /TRCOM3/ A(5,5), B(5,5), S(15),
     +                TN(3), T(5), COSL, SINL, COSP, SINP, COSL1, NEW
*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+DECK,GSNGTR.
*CMZ :  1.30/00 05/03/96  15.55.16  by  Unknown
*CMZ :  1.00/01 02/02/96  10.45.45  by  G. Poulard
*CMZ :  3.21/02 29/03/94  15.41.30  by  S.Giani
*-- Author :
      SUBROUTINE GSNGTR(X,P,IACT,SNEXT,SNXT,SAFE,INSIDE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *                                                                *
C.    *    Routine to determine the shortest distance from the point   *
C.    *    X(1-3) to the boundary of the shape of type GTRA defined    *
C.    *    by the parameters P along the vector X(4-6). If INSIDE is   *
C.    *    1 then the point is inside the shape and the distance is    *
C.    *    returned as SNEXT. If INSIDE is 0 then the point is         *
C.    *    outside the shape and if the line hits the shape then       *
C.    *    if the new distance is less than the                        *
C.    *    old value of SNEXT the new distance is returned as SNEXT.   *
C.    *                                                                *
C.    *          Called by : GNEXT, GTNEXT                             *
C.    *          A.C.McPherson   22nd April 1985.                      *
C.    *                                                                *
C.    *   Shekhtman: SL,SL1,SM,SM1 declared as DOUBLE PRECISION        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCUNIT
C
+SELF, IF=-SINGLE
      DOUBLE PRECISION X0,Y0,DXDZ,DYDZ,A,B,C,DISC,X1,X2,X3,SN,CP,SMALL
      DOUBLE PRECISION SL,SL1,SM,SM1
+SELF
      LOGICAL FIRST  / .TRUE. /
      LOGICAL LPRINT / .TRUE. /
!
      PARAMETER (SMALL=1E-10)
C
      DIMENSION X(6),P(30),SN(2,5),IOUT(5),X0(4),Y0(4),DXDZ(4),DYDZ(4)
C.
C.                ---------------------------------------------
C.
C
C               Compute Safety distance
C
      IF(IACT.LT.3) CALL GSAGTR(X,P,SAFE,INSIDE)
      SNXT=BIG
      IF (IACT .EQ. 0) GO TO 999
      IF (IACT .EQ. 1) THEN
        IF (SNEXT .LT. SAFE) GO TO 999
      ENDIF
C
C               First compute the distance along the line to the
C               boundaries.
C
C               The distance to the planes defined by z=+/-P(1).
C
      IF(X(6).EQ.0.0) THEN
          SN(1,1)=BIG
          SN(2,1)=BIG
          GOTO 10
      ENDIF
      SN(1,1)=(-P(1)-X(3))/X(6)
      SN(2,1)=(P(1)-X(3))/X(6)
      IF(X(6).GT.0.0) GO TO 10
      ST=SN(2,1)
      SN(2,1)=SN(1,1)
      SN(1,1)=ST
   10 CONTINUE
C
C               The distance to the remaining four surfaces.
C
      DO 20 I=1,4
      X0(I)=P(I*4+11)
      Y0(I)=P(I*4+12)
      DXDZ(I)=P(I*4+13)
      DYDZ(I)=P(I*4+14)
   20 CONTINUE
C
      DO 65 I=1,4
      J=I+1
      IF(J.EQ.5) J=1
C
      A=(X(4)-DXDZ(I)*X(6))*(DYDZ(J)-DYDZ(I))*X(6) -
     +(X(5)-DYDZ(I)*X(6))*(DXDZ(J)-DXDZ(I))*X(6)
C
      B=(X(4)-DXDZ(I)*X(6))*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X(3)) +
     +(X(1)-X0(I)-DXDZ(I)*X(3))*(DYDZ(J)-DYDZ(I))*X(6) -
     +(X(5)-DYDZ(I)*X(6))*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X(3)) -
     +(X(2)-Y0(I)-DYDZ(I)*X(3))*(DXDZ(J)-DXDZ(I))*X(6)
C
      C=(X(1)-X0(I)-DXDZ(I)*X(3))*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X(3))
     + - (X(2)-Y0(I)-DYDZ(I)*X(3))*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X(3))
C
      IOUT(I+1)=0
      IF(C.GT.0.0) IOUT(I+1)=1
C
C             The solutions are in the normal form:
C             s = (-B+/-SQRT(B*B-4.0*A*C))*0.5/A
C
      SN(1,I+1)=BIG
      SN(2,I+1)=BIG
      IF(ABS(A).GT.1.0E-10) GO TO 30
C
C             A = 0 only one solution.
C
      IF(ABS(B).LT.1.0E-10) GO TO 60
C
      SN(1,I+1)=-C/B
      GO TO 60
C
   30 CONTINUE
      IF(ABS(C).GT.1.0E-10) GO TO 40
      SN(1,I+1)=0.0
      SN(2,I+1)=0.0
      IF(ABS(B).LT.1.0E-10) GO TO 60
      SN(1,I+1)=-C/B
      IF(C.EQ.0.0) SN(1,I+1)=SIGN(SMALL,B)
      SN(2,I+1)=-B/A
      GO TO 50
C
   40 CONTINUE
      DISC=B*B-A*C*4.0
      IF(DISC.LT.0.0) GO TO 60
      IF(DISC.GT.0.0) DISC=SQRT(DISC)
      SN(1,I+1)=(-B-DISC)*0.5/A
      SN(2,I+1)=(-B+DISC)*0.5/A
C
   50 CONTINUE
      IF(SN(2,I+1).GT.SN(1,I+1)) GO TO 60
      ST=SN(2,I+1)
      SN(2,I+1)=SN(1,I+1)
      SN(1,I+1)=ST
C
   60 CONTINUE
C
      DO 65 K=1,2
      IF(ABS(SN(K,I+1)).GT.1.0E+05.OR.ABS(SN(K,I+1)).LT.1.0E-05)
     +GO TO 65
C
      X1=X(1)+SN(K,I+1)*X(4)
      X2=X(2)+SN(K,I+1)*X(5)
      X3=X(3)+SN(K,I+1)*X(6)
      CP=(X1-X0(I)-DXDZ(I)*X3)*(Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X3)
     + - (X2-Y0(I)-DYDZ(I)*X3)*(X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X3)
      CP=CP/SQRT((X0(J)-X0(I)+(DXDZ(J)-DXDZ(I))*X3)**2+
     +   (Y0(J)-Y0(I)+(DYDZ(J)-DYDZ(I))*X3)**2)
C
      IF(ABS(CP).LT.0.0001) GO TO 65
      IF(ABS(CP/SN(K,I+1)).LT.1.0E-06) GO TO 65
      IF ( FIRST.AND.LPRINT ) THEN
           IF (First) Print *,' * GSNGTR: corrected version *'
           FIRST = .FALSE.
           WRITE(CHMAIL,1020) I,K,SN(K,I+1)
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1021) X
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1022) X1,X2,X3,CP
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1023) A,B,C,DISC
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1024) INSIDE
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1025) X0
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1026) Y0
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1027) DXDZ
           CALL GMAIL(0,0)
           WRITE(CHMAIL,1028) DYDZ
           CALL GMAIL(0,0)
      ENDIF
 1020 FORMAT('0 GSNGTR ERROR - I,K =',2I2,' SN =',E13.5)
 1021 FORMAT(' X =',6F15.6)
 1022 FORMAT(' X1,X2,X3 =',3F15.6,' CP =',E15.6)
 1023 FORMAT(' A =',E15.6,' B =',E15.6,' C =',E15.6,' DISC =',E15.6)
 1024 FORMAT(' INSIDE =',I3)
 1025 FORMAT('   X0 =',4E15.6)
 1026 FORMAT('   Y0 =',4E15.6)
 1027 FORMAT(' DXDZ =',4E15.6)
 1028 FORMAT(' DYDZ =',4E15.6)
C
   65 CONTINUE
C
C
C             Have computed the two distances for the z planes and
C             the four surfaces. Combine them accordingly as to
C             whether the point is inside or outside the shape.
C
      IF(INSIDE.EQ.0) GO TO 80
C
C             Point is inside shape.
C
      DO 70 I=1,5
      DO 70 J=1,2
      IF(SN(J,I).GT.0.0.AND.SN(J,I).LT.SNXT) SNXT=SN(J,I)
   70 CONTINUE
      GO TO 999
C
   80 CONTINUE
C
C             Point is outside shape.
C
      IOUT(1)=0
      IF(ABS(X(3)).GT.P(1)) IOUT(1)=1
C
C             For each of five sets of SN and IOUT, IOUT(I) equal to 1
C             indicates that the point is outside the shape by the Ith
C             test, SN(1,I) is the distance to the first change in the
C             test and SN(2,I) is the distance to the second change.
C             The remaining logic just attempts to find a distance when
C             the line is inside by all five tests, bearing in mind that
C             for some tests the line can start inside, leave and return
C             inside.
C
      SL=-1.0
      SM=BIG
      SM1=BIG
      DO 100 I=1,5
      IF(IOUT(I).EQ.0) GO TO 90
      IF(SN(2,I).LT.0.0) GO TO 999
      IF(SN(1,I).LT.0.0.AND.SN(2,I).GT.SL) SL=SN(2,I)
      IF(SN(1,I).GT.SL) SL=SN(1,I)
      IF(SN(1,I).GE.0.0.AND.SN(2,I).LT.SM) SM=SN(2,I)
      GO TO 100
   90 CONTINUE
      IF(SN(1,I).LT.0.0.AND.SN(2,I).GE.0.0.AND.SN(2,I).LT.SM) SM=SN(2,I)
      IF(SN(1,I).LT.0.0.OR.SN(1,I).GT.SM1) GO TO 100
      IF(SN(1,I).GE.SN(2,I)) GO TO 100
      SM1=SN(1,I)
      SL1=SN(2,I)
  100 CONTINUE
C
C             SL is the largest of the five distances to the first
C             time the line is inside. SM is the smallest to the
C             last time the point is inside. SM1 is the smallest
C             distance to when the line is temporarily outside
C             one of the tests.
C
      IF(SM.LE.SL) GO TO 999
      IF(SM1.GT.SL) GO TO 130
C
  110 CONTINUE
C
C             In this loop SL is updated by the return after SM1
C             if SM1 is less than SL.
C
      SL=SL1
      IF(SM.LE.SL) GO TO 999
      SM1=SM
C
      DO 120 I=1,5
      IF(IOUT(I).EQ.1) GO TO 120
      IF(SN(2,I).LE.SL.OR.SN(1,I).GT.SM1) GO TO 120
      IF(SN(1,I).GE.SN(2,I)) GO TO 120
      SM1=SN(1,I)
      SL1=SN(2,I)
  120 CONTINUE
C
      IF(SM1.GT.SL) GO TO 130
C
      GO TO 110
  130 CONTINUE
C
      IF(SL.LT.SNXT) SNXT=SL
C
  999 CONTINUE
      END
+DECK,GFLRAD
*CMZ :  1.00/00 25/05/95  03.58.23  by  A. James Cook
*-- Author :
      SUBROUTINE GFLRAD(IAXIS,ISH,IROT,DX,PARS,CL,CH,IERR)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    ROUTINE TO COMPUTE THE LIMITS IN R FOR THE SHAPE ISH        *
C.    *    DISPLACED BY THE VECTOR DX AND ROTATED BY THE MATRIX IROT.  *
C.    *    IF IAXIS = 4 THE R IS THE XY PLANE R, IF IAXIS = 5 IT IS    *
C.    *    THE 3 DINEMSIONAL SPACE R. THE SHAPE HAS NPAR PARAMETERS    *
C.    *    IN THE ARRAY PARS. THE LOWER LIMIT IS RETURNED IN CL AND    *
C.    *    THE HIGHER IN CH. IF THE CALCULATION CANNOT BE PERFORMED    *
C.    *    IERR IS SET TO 1 OTHERWISE IT IS SET TO 0.                  *
C.    *                                                                *
C.    *    ==>Called by : GFCLIM                                       *
C.    *         Author  A.McPherson  *********                         *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCONSP
+SEQ,GCSHNO
      DIMENSION DX(3),PARS(11),X(3),XT(3)
C.
C.           --------------------------------------------------
C.
      IERR=1
C
C            FIRST CALCULATE THE LENGTH OF THE DISPLACEMENT OF THE
C            ORIGIN.
C
      DXS=DX(1)*DX(1)+DX(2)*DX(2)
      IF(IAXIS.EQ.5) DXS=DXS+DX(3)*DX(3)
      IF(DXS.GT.0.0) DXS=SQRT(DXS)
C
      IF(ISH.GT.4.AND.ISH.NE.10.AND.ISH.NE.28) GO TO 40
C
C          CUBOIDS, TRAPEZOIDS, PARALLELEPIPEDS.
C
      CH=0.0
      CL=DXS
C
      DO 30 IP=1,8
C
C           THIS IS A LOOP OVER THE 8 CORNERS.
C           FIRST FIND THE LOCAL COORDINATES.
C
      IF(ISH.EQ.28) THEN
C
C            General twisted trapezoid.
C
         IL=(IP+1)/2
         I0=IL*4+11
         IS=(IP-IL*2)*2+1
         X(3)=PARS(1)*IS
         X(1)=PARS(I0)+PARS(I0+2)*X(3)
         X(2)=PARS(I0+1)+PARS(I0+3)*X(3)
         GO TO 20
C
      ENDIF
C
      IP3=ISH+2
      IF(ISH.EQ.10) IP3=3
      IF(ISH.EQ.4) IP3=1
      X(3)=PARS(IP3)
      IF(IP.LE.4) X(3)=-X(3)
      IP2=3
      IF(ISH.GT.2.AND.X(3).GT.0.0) IP2=4
      IF(ISH.EQ.1.OR.ISH.EQ.10) IP2=2
      IF(ISH.EQ.4) IP2=4
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP2=8
      X(2)=PARS(IP2)
      IF(MOD(IP+3,4).LT.2) X(2)=-X(2)
      IP1=1
      IF(ISH.NE.1.AND.ISH.NE.10.AND.X(3).GT.0.0) IP1=2
      IF(ISH.EQ.4) IP1=5
      IF(ISH.EQ.4.AND.X(3).GT.0.0) IP1=IP1+4
      IF(ISH.EQ.4.AND.X(2).GT.0.0) IP1=IP1+1
      X(1)=PARS(IP1)
      IF(MOD(IP,2).EQ.1) X(1)=-X(1)
C
      IF(ISH.NE.10) GO TO 10
      X(1)=X(1)+X(2)*PARS(4)+X(3)*PARS(5)
      X(2)=X(2)+X(3)*PARS(6)
   10 CONTINUE
C
      IF(ISH.NE.4) GO TO 20
      IP4=7
      IF(X(3).GT.0.0) IP4=11
      X(1)=X(1)+X(2)*PARS(IP4)+X(3)*PARS(2)
      X(2)=X(2)+X(3)*PARS(3)
   20 CONTINUE
C
C          ROTATE.
C
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          NOW COMPUTE RMIN = PROJECTED R ON DX AND RMAX = R
C          AND UPDATE LIMITS IF NECESSARY.
C
      R2=(XT(1)+DX(1))**2+(XT(2)+DX(2))**2
      IF(IAXIS.EQ.5) R2=R2+(XT(3)+DX(3))**2
      R=SQRT(R2)
      IF(R.GT.CH) CH=R
C
      IF(CL.LE.0.0) GO TO 30
C
      XPT=DX(1)*XT(1)+DX(2)*XT(2)
      IF(IAXIS.EQ.5) XPT=XPT+DX(3)*XT(3)
      IF(DXS.LE.1.0E-05) GO TO 30
      RMN=DXS+XPT/DXS
      IF(RMN.LT.CL) CL=RMN
C
   30 CONTINUE
C
      IF(CL.LE.0.0) CL=0.0
C
      IERR=0
      GO TO 999
C
   40 CONTINUE
      IF(ISH.GT.8.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14)GO TO 80
C
C             TUBES AND CONES.
C
      IP3=3
      IF(ISH.GT.6.AND.ISH.NE.NSCTUB.AND.ISH.NE.13.AND.ISH.NE.14) IP3=1
      DZ=PARS(IP3)
      R=PARS(2)
      IF(ISH.EQ.NSCTUB) THEN
        S1 = (1.0-PARS(8))*(1.0+PARS(8))
        IF( S1 .GT. 0.0) S1 = SQRT(S1)
        S2 = (1.0-PARS(11))*(1.0+PARS(11))
        IF( S2 .GT. 0.0) S2 = SQRT(S2)
        IF( S2 .GT. S1 ) S1 = S2
        DZ = DZ+R*S1
      ENDIF
**
      IF(ISH.EQ.13) THEN
**
**       APPROXIME TO A CYLINDER WHIT RADIUS
**       EQUAL TO THE ELLIPSE MAJOR AXIS
**
         RMN=0.0
         IF(PARS(1).GT.R) R=PARS(1)
         GOTO 50
      ENDIF
      RMN=PARS(1)
*
      IF(ISH.EQ.14) THEN
        R = SQRT(PARS(2)**2+(PARS(3)*TAN(PARS(4)*DEGRAD))**2)
        GO TO 50
      ENDIF
C
      IF(ISH.LE.6.OR.ISH.EQ.NSCTUB) GO TO 50
C
      R=PARS(3)
      IF(PARS(5).GT.R) R=PARS(5)
      RMN=PARS(2)
      IF(PARS(4).LT.RMN) RMN=PARS(4)
C
   50 CONTINUE
C
C          ROTATE THE LOCAL Z AXIS.
C
      X(1)=0.0
      X(2)=0.0
      X(3)=1.0
      JROT=LQ(JROTM-IROT)
      XT(1)=X(1)
      XT(2)=X(2)
      XT(3)=X(3)
      IF(IROT.NE.0) CALL GINROT(X,Q(JROT+1),XT)
C
C          COMPUTE RMIN AND RMAX ASSUMING COMPLETE TUBE HALF
C          LENGTH DZ AND RADIUS R.
C
      CH=DXS+R
      CL=DXS-R
      DO 60 IS=-1,1,2
         R2=(DX(1)+IS*DZ*XT(1))**2+(DX(2)+IS*DZ*XT(2))**2
         IF(IAXIS.EQ.5) R2=R2+(DX(3)+IS*DZ*XT(3))**2
         R1=SQRT(R2)
         CH=MAX(CH,R1+R)
         CL=MIN(CL,R1-R)
   60 CONTINUE
      IF(CL.LT.0.0) CL=0.0
      IF(IROT.EQ.0.AND.DXS.LT.1.0E-05) CL=RMN
      IERR=0
C
      GO TO 999
C
   80 CONTINUE
      IF(ISH.GT.9) GO TO 999
C
C           SPHERE.
C
      CL=DXS-PARS(2)
      IF(CL.LT.0.0) CL=0.0
      CH=DXS+PARS(2)
      IF(IAXIS.EQ.5.AND.DXS.LT.1.0E-05) CL=PARS(1)
      IERR=0
C
  999 CONTINUE
      END
+DECK,GGORDQ.
*CMZU:  1.00/01 25/01/96  14.17.49  by  A. DellAcqua
*CMZ :  3.21/02 29/03/94  15.41.28  by  S.Giani
*-- Author :
      SUBROUTINE GGORDQ (IVO)
C.
C.    *****************************************************************
C.    *                                                               *
C.    *    Find and order the boundaries of the contents of the       *
C.    *    IVOth volume, with respect to coordinate IAX :             *
C.    *           IAX = 1    X Axis                                   *
C.    *           IAX = 2    Y Axis                                   *
C.    *           IAX = 3    Z Axis                                   *
C.    *           IAX = 4    Rxy                                      *
C.    *           IAX = 5    Rxyz                                     *
C.    *           IAX = 6    PHI   (PHI=0 => X axis)                  *
C.    *           IAX = 7    THETA (THETA=0 => Z axis)                *
C.    *    All values of IAX will be tried and then that value is     *
C.    *    chosen, that results in the smallest number of volumes per *
C.    *    division.                                                  *
C.    *    Called by : GGCLOS                                         *
C.    *    Author: Stephan Egli (large parts are copies of GGORD)     *
C.    *                                                               *
C.    *****************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
*
 
      DIMENSION CLOW(500),CHIGH(500),CORD(1000),ITYPE(1000),
     +ICONT(500),ICON(1000),ICONS(500)
      EQUIVALENCE (CLOW(1),WS(1)),(CHIGH(1),WS(501))
      EQUIVALENCE (CORD(1),WS(1001)),(ITYPE(1),WS(2001))
      EQUIVALENCE (ICONT(1),WS(3001)),(ICON(1),WS(3501))
      EQUIVALENCE (ICONS(1),WS(4501))
C
      CHARACTER*4 NAME
 
C.    ------------------------------------------------------------------
*
      JVO = LQ(JVOLUM-IVO)
      CALL UHTOC(IQ(JVOLUM+IVO),4,NAME,4)
      NIN = Q(JVO+3)
      IAXNOW = 0
      IF(IQ(JVO-2).EQ.NIN+2) THEN
*
* *** This is to allow re-entry in the routine from the interactive
* *** version.
         JNEAR = LQ(JVO-NIN-1)
         IF(JNEAR.GT.0) THEN
            JSB = LQ(JNEAR)
            IF(JSB.GT.0) THEN
               IAXNOW = Q(JSB+1)
            ENDIF
         ENDIF
      ENDIF
      IF(IAXNOW.EQ.0) THEN
         IAXNOW=-Q(JVO+1)
      ENDIF
*   assume that ordering can not be done unless proven otherwise
      Q(JVO+1)=0.
      RBEST=1.E9
 
* try all possible axes
 
      DO 1 IAX=1,7
 
*   count number of additional words needed and total number of volumes
*   in all divisions
 
      NCOALL=0
*
* *** Find the upper and lower coordinates of each content
*
      DO 50 IN = 1,NIN
         CALL GFCLIM (JVO, IN, IAX, CLOW(IN), CHIGH(IN), IERR)
         IF (IERR.NE.0) GOTO 1
   50 CONTINUE
*
* *** Order the coordinate limits, keeping track of the associated
*           content number
*
      CALL GFCORD (NIN, CLOW, CHIGH, CORD, ITYPE, ICON)
      NC = NIN*2
*
*  **   Count and load up the distinct boundaries
*
      IBO = 0
      DO 60 IC = 1,NC
         IBO = IBO +1
         IF (IBO.EQ.1) GO TO 60
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) IBO = IBO -1
   60 CONTINUE
      NDIV  = IBO -1
      IF (IAX.EQ.6) NDIV = IBO
 
*   *   Load up number of contents in each section
*
      IDIV    = 0
      NCONT   = 1
      ICONT(1)= ICON(1)
      IF (IAX.NE.6) GO TO 70
      NCONT   = 0
      NSTOR   = 0
      ICONT(1)= 0
      DO 65 IN = 1,NIN
         IF (CHIGH(IN).GT.CLOW(IN)) GO TO 65
*           (this content straddles PHI=0.)
         NSTOR = NSTOR +1
         ICONS(NSTOR) = IN
         IF (ICON(1).EQ.IN) GO TO 65
*           (IN is in 1st division as well)
         NCONT = NCONT +1
         ICONT(NCONT) = IN
   65 CONTINUE
*
      IF (ITYPE(1).EQ.2) GO TO 70
*            (first boundary is a low, add the new content)
      NCONT = NCONT +1
      ICONT(NCONT) = ICON(1)
*
   70 CONTINUE
*
      DO 130 IC = 2,NC
         IDIV = IDIV +1
         IF (CORD(IC)-CORD(IC-1).LT.1.E-4) GO TO 90
*
*          New division, load up last division
*
         IF (NCONT.LE.0) GO TO 100
         NCOALL=NCOALL+NCONT
         GO TO 100
   90    CONTINUE
         IDIV = IDIV -1
*
  100    CONTINUE
*
*         Update contents of current division
*
         IF (ITYPE(IC).EQ.1) GO TO 120
*
*         This boundary was a high, so one less content
*
         ICP = 0
         DO 110 ICNT = 1,NCONT
            IF (ICONT(ICNT).EQ.ICON(IC)) ICP=1
         IF (ICP.EQ.1) ICONT(ICNT) = ICONT(ICNT+1)
  110    CONTINUE
         NCONT = NCONT -1
         GO TO 130
*
  120    CONTINUE
*
*          This boundary was a low, so one extra content
*
         NCONT = NCONT +1
         ICONT(NCONT) = ICON(IC)
*
  130 CONTINUE
*
      IF(IAX.EQ.6) NCOALL = NCOALL+NSTOR
      RNOW=FLOAT(NCOALL)/NDIV
      IF(RNOW.LT.RBEST)THEN
        IAXOPT=IAX
        RBEST=RNOW
        NDIVB=NDIV
      ENDIF
 
* end of loop over IAX
 
1     CONTINUE
 
 
* now the best axis is selected - compare with axis requested by CALL
* to GSORD (if any)
 
      IF(IAXNOW.GT.0)THEN
 
*        WRITE (CHMAIL,1002) NAME,NIN,IAXOPT,NDIVB,RBEST,IAXNOW
*        CALL  GMAIL (0, 0)
 1002   FORMAT(' GGORDQ : Volume ',A4,2X,'NIN=',I4,' IAX=',I2,2X,
     +    'NDIV=',I3,2X,'NVOL/DIV=',F5.1,2X,'IAX wanted by user:',I2)
 
      ELSE
 
*        WRITE (CHMAIL,1003) NAME,NIN,IAXOPT,NDIVB,RBEST
*        CALL  GMAIL (0, 0)
 1003   FORMAT(' GGORDQ : Volume ',A4,2X,'NIN=',I4,' IAX=',I2,2X,
     +    'NDIV=',I3,2X,'NVOL/DIV=',F5.1)
 
      ENDIF
 
* overwrite old axis and store sorting information for new axis
 
      Q(JVO+1)=-IAXOPT
      CALL GGORD(IVO)
 
      END
+DECK,GSCHIT
*CMZ :  1.30/00 02/06/96  16.40.08  by  Pavel Nevski
*CMZ :  1.00/00 16/08/95  01.09.49  by  Pavel Nevski
*-- Author :
      SUBROUTINE GSCHIT(ISET,IDET,ITRA,NUMBV,HITS,NHSUM,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Store HITS values into detector IUDET of set IUSET       *
C.    *                                                                *
C.    *       NUMBV  volume numbers                                    *
C.    *       HITS  array of values for the elements of current hit    *
C.    *       ITRA  track number associated to this hit                *
C.    *       IHIT  output parameter containing the hit number         *
C.    *             If IHIT=0  hit has not been stored                 *
C.    *                                                                *
C.    *       Same action as GSAHIT but in case the physical volume    *
C.    *       specified by NUMBV contains already some hit for the     *
C.    *       same track, then the routine will sum up the last NHSUM  *
C.    *       elements of the hit.                                     *
C.    *        In order to use that routine , no packing must be       *
C.    *        specified for these NHSUM last hits.                    *
C.    *        If NHSUM.LE.0 then GSCHIT is the same as GSAHIT.        *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+seq,GCVOLU
+SEQ,GCUNIT
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(*),HITS(*)
      PARAMETER (MAXINT=2147483647)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      CALL GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
      IF (IHIT.LE.1)  GO TO 999
      IF (NHSUM.LE.0) GO TO 999
C
      NV=IQ(JD+1)
      NH=IQ(JD+3)
      NW=NV+NH+1
      JNEWH = JHD+(IHIT-1)*NW
      JCURR = JNEWH
C
      DO 30 I=1,IHIT-1
         JCURR = JCURR-NW
C
C             Check if track number is ITRA
C
         IF (ITRA.NE.IQ(JCURR+1)) GO TO 999
C
C             Check if volume numbers are the same
C
         DO 10 J=2,NV+1
            IF (IQ(JCURR+J).NE.IQ(JNEWH+J)) GO TO 30
   10    CONTINUE
C
C             Volumes are the same. Now sum the last NHSUM hits
C
         DO 20 K=NW,NW-NHSUM+1,-1
            IF (IQ(JCURR+K).GT.MAXINT-IQ(JNEWH+K)) THEN
               NMESS=NMESS+1
               IF (NMESS.LT.3) THEN
                  WRITE (CHMAIL,10000) IQ(JSET+ISET),IQ(JS+IDET)
10000             FORMAT(' ***** GSCHIT OVERFLOW WARNING FOR SET= ',
     +                                               A4,' DET= ',A4)
                  CALL GMAIL(0,0)
               ENDIF
               GO TO 999
            ELSE
               IQ(JCURR+K)=IQ(JCURR+K)+IQ(JNEWH+K)
            ENDIF
   20    CONTINUE
C
C             Remove temporarily stored hit
C
*****    IHIT=IHIT-1
         IHIT=IHIT-I
         IQ(JH+IDET)=IQ(JH+IDET)-NW
         GO TO 999
   30 CONTINUE
C
  999 CONTINUE
      END
 
 
 
 
+DECK,GUSCNTR.
*CMZ :  1.30/00 12/05/97  15.31.50  by  Pavel Nevski
*CMZU:  1.00/00 17/03/94  10.22.21  by  Andrea DellAcqua
*-- Author :    *MRT : by Pavel Nevski
*----------------------------------------------------------------------*
      SUBROUTINE GUSCNTR(PRECOR)
*                                                                      *
* Description :  routine to control a looping near a boundary          *
* Arguments   :  PRECOR  (modified) GEANT tracking precision           *
*                                                                      *
* Author      :  Pavel Nevski                       Date : 25/05/93    *
* Modification:  Never done                                            *
*----------------------------------------------------------------------*
+CDE,TYPING.
+CDE,GCTMED.  - GEANT common GCTMED (version 3.15)
+CDE,GCTRAK.  - GEANT common GCTRACK (version 3.15)
+CDE,GCVOLU.  - Multi-level current volume description
+CDE,GCUNIT.  - Geant logical units
*
      INTEGER ICNT,IPRI,MSTEP,LU
      REAL SAFEOLD,ONLY,PRECOR
      DATA ICNT,MSTEP /0,0/
      IPRI=0
      SAFEOLD = SAFETY+STEP
      ONLY=GONLY(NLEVEL)
C   Check IGNEXT==1 & SAFETY<0 & STEP<10*PREC & ONLY>0
      IF (IGNEXT.EQ.1 .AND. SAFETY.LT.0 .AND. STEP.LT.10*PREC
     *    .AND.  ONLY.GT.0 .AND. INWVOL.EQ.0) THEN
         ICNT=ICNT+1
      ELSE
         ICNT=0
      END IF
C   Check ICNT==10
      IF (ICNT.EQ.10) THEN
         IFIELD =0
      END IF
C   Check 11<=ICNT<=18
      IF (11.LE.ICNT.AND.ICNT.LE.18) THEN
         PRECOR=PRECOR*2
      END IF
C   Check 20<=ICNT<=20
      IF (20.LE.ICNT.AND.ICNT.LE.20) THEN
         IPRI =1
      END IF
C   Check NSTEP>=MSTEP+1000
      IF (NSTEP.GE.MSTEP+1000) THEN
         MSTEP = NSTEP
         IPRI=0
      END IF
C   Check NSTEP==MAXNST
      IF (NSTEP.EQ.MAXNST) THEN
         IPRI=3
      END IF
C   If Amax1(Abs(Vect(1)),Abs(Vect(2)))>Rmx \ Abs(Vect(3))>Zmx [Istop=1;]
C   Check IPRI>0
      IF (IPRI.LE.0)GO TO 1
      CALL GPCXYZ
      LU=LOUT
      WRITE(LU,10) NSTEP,ICNT,IGNEXT,PREC,SAFETY,SNEXT,PRECOR
10    FORMAT(5x,'Nstep,icnt,IGnext,Prec,Safety,Snext,Precor=',
     >       2I5,I3,4F10.4)
1     CONTINUE
      END         ! GUSCNTR
+DECK,Gtrack.
*CMZ :          08/12/97  13.35.34  by  Pavel Nevski
*CMZ :  1.30/00 17/04/97  14.00.58  by  Pavel Nevski
*CMZU:  1.00/00 11/07/94  15.46.40  by  Pavel Nevski
*-- Author :
      SUBROUTINE GTRACK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Controls tracking of current particle,                   *
C.    *        up to end of track for sequential tracking mode, or     *
C.    *        through current volume for parallel tracking mode.      *
C.    *                                                                *
C.    *    ==>Called by : GUTRAK                                       *
C.    *       Authors   : R.Brun, F.Bruyant                            *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+CDE, GCKINE.
+CDE, GCKING.
+CDE, GCMATE.
+CDE, GCPHYS.
+CDE, GCPARM.
+CDE, GCSETS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCUNIT.
+CDE, GCFLAG.
+CDE, GCNUM.
+SEQ,GCJUMP, IF=USRJMP
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      DIMENSION CUTS(10),MECA(5,13)
      EQUIVALENCE (CUTS(1),CUTGAM),(MECA(1,1),IPAIR)
      SAVE PRECOR
+SELF,IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF,IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
C.
C.    ------------------------------------------------------------------
      ISTOP = 0
      EPSCUR = EPSMAC
      NSTOUT = 0
      INWOLD = 0
      LSAMVL = .FALSE.
*
* *** Check validity of tracking medium and material parameters
*
   10 IF (NUMED.NE.NUMOLD) THEN
         NUMOLD = NUMED
         IUPD   = 0
         JTM    = LQ(JTMED- NUMED)
         DO 20 I = 1,5
            NATMED(I) = IQ(JTM+I)
   20    CONTINUE
         NMAT     = Q(JTM + 6)
         ISVOL    = Q(JTM + 7)
         IFIELD   = Q(JTM + 8)
         FIELDM   = Q(JTM + 9)
         TMAXFD   = Q(JTM + 10)
         STEMAX   = Q(JTM + 11)
         DEEMAX   = Q(JTM + 12)
         EPSIL    = Q(JTM + 13)
         STMIN    = Q(JTM + 14)
         PRECOR   = MIN(0.1*EPSIL, 0.0010)
         IF (LQ(JTM).EQ.0) THEN
            IF (ISTPAR.NE.0) THEN
               DO 30 I = 1,10
                  CUTS(I) = Q(JTMED+I)
   30          CONTINUE
               DO 40 I = 1,13
                  MECA(1,I) = Q(JTMED+10+I)
   40          CONTINUE
               ILABS = Q(JTMED+10+21)
               ISYNC = Q(JTMED+10+22)
               ISTRA = Q(JTMED+10+23)
               ISTPAR = 0
            ENDIF
         ELSE
            JTMN = LQ(JTM)
            DO 50 I = 1,10
               CUTS(I) = Q(JTMN+I)
   50       CONTINUE
            DO 60 I = 1,13
               MECA(1,I) = Q(JTMN+10+I)
   60       CONTINUE
            ILABS = Q(JTMN+10+21)
            ISYNC = Q(JTMN+10+22)
            ISTRA = Q(JTMN+10+23)
            ISTPAR = 1
         ENDIF
*
         JMA   = LQ(JMATE-NMAT)
         JPROB = LQ(JMA-4)
         JMIXT = LQ(JMA-5)
         DO 70 I = 1,5
            NAMATE(I) = IQ(JMA+I)
   70    CONTINUE
         A    = Q(JMA +6)
         Z    = Q(JMA +7)
         DENS = Q(JMA +8)
         RADL = Q(JMA +9)
         ABSL = Q(JMA +10)
         IF(IQ(JTM-2).GE.3.AND.LQ(JTM-3).NE.0.AND.ITCKOV.NE.0.AND.
     +      LQ(LQ(JTM-3)-3).NE.0.AND.Z.GE.1.) THEN
*
* ***  In this tracking medium Cerenkov photons are generated and
* ***  tracked. Set to 1 the corresponding flag.
*
            IMCKOV = 1
         ELSE
            IMCKOV = 0
         ENDIF
*
*
*  **   Update precomputed quantities
*
         IMULL = IMULS
         IF (ILOSS.LE.0) THEN
            DEEMAX = 0.
            ILOSL = 0
         ELSEIF (DEEMAX.GT.0.) THEN
            ILOSL = ILOSS
         ELSE
            ILOSL = 0
         ENDIF
      ENDIF
*
      IF(LSAMVL) THEN
*
*       If now the particle is entering in the same volume where
*       it was exiting from last step, and if it has done this for
*       more than 5 times, we decrease the precision of tracking
         NSTOUT=NSTOUT+1
         IF(MOD(NSTOUT,5).EQ.0) THEN
            EPSCUR=NSTOUT*EPSMAC
*            WRITE(CHMAIL,10000)ITRA,ISTAK,NTMULT,NAPART
*10000          FORMAT(' *** GTRAcCK *** Boundary loop: track ',
*     +         I6,' stack ',I6,' NTMULT ',I8,1X,5A4)
*            CALL GMAIL(1,0)
*            WRITE (CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
*            CALL GMAIL(0,0)
*            WRITE(CHMAIL,10100) EPSCUR
*10100          FORMAT('                Precision now set to ',G10.3)
*            CALL GMAIL(0,1)
         ENDIF
      ELSE
         NSTOUT = 0
         EPSCUR = EPSMAC
      ENDIF
*
      INWVOL = 1
*
* *** Compute SET and DET number if volume is sensitive
*
*      IF (JSET.GT.0) THEN
*         IF(ISVOL.GT.0) THEN
*            CALL GFINDS
*         ELSE
*            IHSET = 0
*            IHDET = 0
*            ISET = 0
*            IDET = 0
*            IDTYPE = 0
*            NVNAME = 0
*         ENDIF
*      ENDIF
*
*    Clear step dependent variables
*
   80 NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NGPHOT = 0.
      IGNEXT = 0
      INWOLD = INWVOL
      PREC   = MAX(PRECOR,MAX(ABS(VECT(1)),ABS(VECT(2)),
     +                        ABS(VECT(3)),SLENG)*EPSCUR)
*
*     Give control to user at entrance of volume (INWVOL=1)
*
      IF (INWVOL.EQ.1) THEN
+SELF, IF=-USRJMP
         CALL GUSTEP
+SELF, IF=USRJMP
         CALL JUMPT0(JUSTEP)
+SELF
         IF (ISTOP.NE.0) GO TO 999
         INWVOL = 0
      ENDIF
*
* *** Propagate particle up to next volume boundary or end of track
*
      INGOTO = 0
      NLEVIN = NLEVEL
      IF (IPARAM.NE.0) THEN
         IF (GEKIN.LE.PACUTS(ITRTYP)) THEN
            NMEC = NMEC+1
            LMEC(NMEC) = 26
            ISTOP = 2
+SELF, IF=-USRJMP
            CALL GUPARA
+SELF, IF=USRJMP
            CALL JUMPT0(JUPARA)
+SELF
            GO TO 90
         ENDIF
      ENDIF
      IF      (ITRTYP.EQ.1) THEN
         CALL GTGAMA
      ELSE IF (ITRTYP.EQ.2) THEN
         CALL GTELEC
      ELSE IF (ITRTYP.EQ.3) THEN
         CALL GTNEUT
      ELSE IF (ITRTYP.EQ.4) THEN
         CALL GTHADR
      ELSE IF (ITRTYP.EQ.5) THEN
         CALL GTMUON
      ELSE IF (ITRTYP.EQ.6) THEN
         CALL GTNINO
      ELSE IF (ITRTYP.EQ.7) THEN
         CALL GTCKOV
      ELSE IF (ITRTYP.EQ.8) THEN
         CALL GTHION
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(10+ITRTYP)
      STLOSS=STEP
*
*     Check for possible endless loop
*
   90 NSTEP = NSTEP +1
      IF (NSTEP.GT.MAXNST) THEN
         IF (ISTOP.EQ.0) THEN
            ISTOP = 99
            IF (IDEBUG.GT.0) THEN
            NMEC  = NMEC +1
            LMEC(NMEC) = 30
            WRITE(CHMAIL,10200) MAXNST
            CALL GMAIL(1,0)
            WRITE(CHMAIL,10250) IEVENT,IDEVT,(NRNDM(I),I = 1,2)
            CALL GMAIL(0,0)
            WRITE(CHMAIL,10300)ITRA,ISTAK,NTMULT,(NAPART(I),I=1,5),
     +      TOFG*1.E9
            CALL GMAIL(0,1)
10200       FORMAT(' *** GTRACK *** More than ',I6,
     +             ' steps, tracking abandoned!')
10250       FORMAT('                IEVENT=',I7,' IDEVT=',I7,
     +             ' Random Seeds = ',I10,2X,I10)
10300       FORMAT('                Track',I6,' stack',I6,' NTMULT',
     +             I8,1X,5A4,'Time of flight ',F10.3,' ns')
            ENDIF
         ENDIF
      ENDIF
*
* *** Give control to user at end of each tracking step
*
      SAFETY = SAFETY -STEP
+SELF, IF=-USRJMP
      CALL GUSTEP
+SELF, IF=USRJMP
      CALL JUMPT0(JUSTEP)
+SELF
C - pln - 11/7/94  - add user control over loopers
      CALL GUSCNTR(PRECOR)
*
      IF (ISTOP.NE.0) GO TO 999
*
*      Renormalize direction cosines
*
      PMOM = SQRT(VECT(4)**2+VECT(5)**2+VECT(6)**2)
      IF(PMOM.GT.0.) THEN
         CMOD = 1./PMOM
         VECT(4) = VECT(4)*CMOD
         VECT(5) = VECT(5)*CMOD
         VECT(6) = VECT(6)*CMOD
      ENDIF
*
      IF (INWVOL.EQ.0) GO TO 80
*
      IF (NJTMAX.GT.0) THEN
         CALL GSTRAC
         IF (NLEVIN.EQ.0) GO TO 100
         GO TO 999
      ELSE
         IF (NLEVIN.GE.NLEVEL) THEN
            INFROM = 0
         ELSE
            IF (NLEVIN.EQ.0) GO TO 100
            INFROM = LINDEX(NLEVIN+1)
         ENDIF
         IF (NLEVIN.NE.NLEVEL) INGOTO = 0
         NLEVEL = NLEVIN
*
         CALL GTMEDI (VECT, NUMED)
         IF (NUMED.NE.0) THEN
            SAFETY = 0.
            GO TO 10
         ENDIF
      ENDIF
*
*     Track outside setup, give control to user (INWVOL=3)
*
  100 INWVOL = 3
      ISTOP  = 1
      ISET   = 0
      IDET   = 0
      NMEC   = 0
      STEP   = 0.
      DESTEL = 0.
      DESTEP = 0.
      NGKINE = 0
      NLCUR  = NLEVEL
      NLEVEL = 1
+SELF, IF=-USRJMP
      CALL GUSTEP
+SELF, IF=USRJMP
      CALL JUMPT0(JUSTEP)
+SELF
      NLEVEL = NLCUR
*                                                             END GTRACK
  999 END
+DECK,GXDZ.
*CMZ :  1.30/00 25/05/96  05.56.55  by  Pavel Nevski
*CMZ :  1.00/00 20/11/95  03.51.01  by  Pavel Nevski
*-- Author :
      SUBROUTINE GXDZ
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      DZEBRA control commands                                   *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                                                                *
C.    * Modifications:                                                 *
C.    *  PN, 20.11.95: change unit 10 to 61 due to SGI problems        *
C.    *  PN, 25.05.96: reaccess link in DISP command after RZ access   *
C.    *  PN, 25.05.96: default documentation file detm.rz introduced   *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCUNIT
+SEQ,GCXLUN
      COMMON/GCLTMP/LTEMPA(3)
      COMMON/QUEST/IQUEST(100)
      CHARACTER*20  CHOPT
      CHARACTER*4   BNAME
      CHARACTER*32  CHPATL
      CHARACTER*255 DOCFIL
      CHARACTER*10  CHTOP
      CHARACTER*12  CHTDIR
      CHARACTER*12  CDEF/'detm.rz'/
      LOGICAL       EXST
C.
C.    ------------------------------------------------------------------
C.
      CALL KUPATL(CHPATL,NPAR)
      INQUIRE  (FILE='detm.rz',EXIST=EXST)
*
      IF(CHPATL.EQ.'SHOW')THEN
         CALL KUGETC(BNAME,NCH)
         CALL KUGETI(NUMBER)
         CALL KUGETC(CHOPT,NCH)
         LOC=LZLOC(IXSTOR,BNAME,NUMBER)
         IF(LOC.NE.0)THEN
            CALL DZSHOW('DZSHOW',IXSTOR,LOC,CHOPT,0,0,0,0)
         ENDIF
*
      ELSEIF(CHPATL.EQ.'SURV')THEN
         CALL KUGETC(BNAME,NCH)
         CALL KUGETI(NUMBER)
         LOC=LZLOC(IXSTOR,BNAME,NUMBER)
         IF(LOC.NE.0)THEN
            CALL DZSURV('DZSURV',IXSTOR,LOC)
         ENDIF
*
      ELSEIF(CHPATL.EQ.'SNAP')THEN
         CALL KUGETI(IDIV)
         CALL KUGETC(CHOPT,NCH)
         CALL DZSNAP('DZSNAP',IDIV,CHOPT)
*
      ELSEIF(CHPATL.EQ.'VERIFY')THEN
         CALL KUGETI(IDIV)
         CALL KUGETC(CHOPT,NCH)
         CALL DZVERI('DZVERI',IDIV,CHOPT)
*
      ELSEIF(CHPATL.EQ.'STORE')THEN
         CALL KUGETI(IXSTOR)
         CALL DZSTOR('DZSTOR',IXSTOR)
*
      ELSEIF (CHPATL.EQ.'DDIV') THEN
+SELF, IF=DZDOC
         CALL KUGETI(IDIV)
         DOCFIL=' '
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC
         If (NCH.le.1 .and. EXST) Then
            DOCFIL=CDEF
            NCH=LENOCC(CDEF)
         EndIf
         CHOPT='IN'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         CHTOP =' '
         CHTDIR=' '
         IF(DOCFIL.NE.' ') THEN
            CALL GXLUNF(61, 3, IFREE)
            IF(IFREE.NE.0) THEN
               LRECL = 256
               CALL RZOPEN(IFREE,CHTOP,DOCFIL(1:NCH),'W',LRECL,ISTAT)
               IF(ISTAT.NE.0) GOTO 999
               CALL RZFILE(IFREE,CHTOP,' ')
               LUNIT(IFREE) = 3
               CHTDIR='//'//CHTOP
            ENDIF
         ENDIF
*
*        Workstation ID is 1 for GEANT
*
         IWTYPE=IGIWTY(1)
         CALL DZDDIV(IDIV,LMAIN,CHTDIR,CHOPT,IWDISP,
     +               IWMETA,ILOCNR,IWTYPE)
         IF(DOCFIL.NE.' ') THEN
            CALL RZEND(CHTOP)
            CLOSE(IFREE)
            LUNIT(IFREE)=0
         ENDIF
+SELF, IF=-DZDOC
*
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
10000    FORMAT(' *** GXDZ *** : Sorry, command not available',
     +          ' in this implementation')
+SELF
      ELSEIF (CHPATL.EQ.'DISP') THEN
+SELF, IF=DZDOC
         CALL KUGETC(BNAME,NCH)
         DOCFIL=' '
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC
         If (NCH.le.1 .and. EXST) Then
            DOCFIL=CDEF
            NCH=LENOCC(CDEF)
         EndIf
         CALL KUGETI(NUMBER)
         CHOPT='N'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         CHTOP =' '
         CHTDIR=' '
         IF (LZLOC(IXSTOR,BNAME,NUMBER).GT.0) THEN
            IF(DOCFIL.NE.' ') THEN
               CALL GXLUNF(61, 3, IFREE)
               IF(IFREE.NE.0) THEN
                  LRECL = 256
                  CALL RZOPEN(IFREE,CHTOP,DOCFIL(1:NCH),
     +                        'W',LRECL,ISTAT)
                  IF(ISTAT.NE.0) GOTO 999
                  CALL RZFILE(IFREE,CHTOP,' ')
                  LUNIT(IFREE) = 3
                  CHTDIR='//'//CHTOP
               ENDIF
            ENDIF
*
*        Workstation ID is 1 for GEANT
*
            IWTYPE=IGIWTY(1)
            LOC=LZLOC(IXSTOR,BNAME,NUMBER)
            CALL DZDISP(IXSTOR,LOC,CHTDIR,CHOPT,IWDISP,
     +                  IWMETA,ILOCNR,IWTYPE)
            IF(DOCFIL.NE.' ') THEN
               CALL RZEND(CHTOP)
               CLOSE(IFREE)
               LUNIT(IFREE)=0
            ENDIF
         ENDIF
+SELF, IF=-DZDOC
*
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
+SELF
      ELSEIF (CHPATL.EQ.'DIRZ') THEN
+SELF, IF=DZDOC
         DOCFIL=CDEF
         CALL KUGETC(DOCFIL,NCH)
         NCH=MAX(NCH,1)
+SELF, IF=UNIX, IF=DZDOC
         CALL CUTOL(DOCFIL(1:NCH))
+SELF, IF=DZDOC
         If (NCH.le.1 .and. EXST) Then
            DOCFIL=CDEF
            NCH=LENOCC(CDEF)
         EndIf
         CHOPT='N'
         IWDISP=1
         IWMETA=0
         ILOCNR=1
         IDZSTR=0
         CALL MZLINT(IDZSTR,'/GCLTMP/',LTEMPA,LTEMPA(3),LTEMPA)
         CALL DZDIRZ(IDZSTR,LTEMPA(3),1,DOCFIL(1:NCH),CHOPT,
     +               IWDISP,IWMETA,ILOCNR)
         LTEMPA(1)=0
+SELF, IF=-DZDOC
         WRITE(CHMAIL,10000)
         CALL GMAIL(0,0)
+SELF
      ENDIF
*
  999 END
+DECK,GXDRAW,If=test.
*CMZ :  1.30/00 17/04/97  17.46.54  by  Pavel Nevski
*CMZ :  3.21/02 28/03/94  01.30.59  by  S.Giani
*-- Author :
      SUBROUTINE GXDRAW
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Drawing commands                                          *
C.    *                                                                *
C.    *       Authors:   R.Brun      **********                        *
C.    *                  P.Zanarini  **********                        *
C.    *                  S.Giani     **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,PAWC
+SEQ,GCUNIT
+SEQ,GCDRAW
+SEQ,GCGOBJ.
+SEQ,GCMUTR
+SEQ,GCSPEE
+SEQ,GCCURS
+SEQ,GCHIL2.
+SEQ,GCURSB.
+SEQ,GCJUMP, IF=USRJMP
+SEQ,GCVDMA.
+SEQ,GCFDIM.
*
      COMMON/QUEST/IQUEST(100)
*
      DIMENSION NNAME(15),NNUMB(15),RVAL(2)
*SG
      DIMENSION VX(4),VXX(4),VVX(4),XV(4),BX(4)
      DIMENSION VY(4),VYY(4),VVY(4),YV(4),BY(4)
      CHARACTER*4 NAME,CHNUMB,IDS,IVS,ICS,NNVV,NVNV,MOTH
      CHARACTER*4 CHNRS,CHAX,YESNO,CENT
      CHARACTER*4 NOPT,SAMP,KSAM,KLSA
      CHARACTER*6 MODE
 
*SG
      CHARACTER*80 CHTEXT
      CHARACTER*32 CHPATL,VNAME
      CHARACTER*64 NAMNUM
*
      CALL AGCHECK
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'BOX ') THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
10000      FORMAT(' *** GXDRAW ***:',
     +            ' No more space to store MCVOL information.')
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
10100      FORMAT(' *** GXDRAW ***: Please reset MCVOL')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(XMIN)
         CALL KUGETR(XMAX)
         CALL KUGETR(YMIN)
         CALL KUGETR(YMAX)
         CALL KUGETR(ZMIN)
         CALL KUGETR(ZMAX)
         IF(XMIN.GE.XMAX.OR.YMIN.GE.YMAX.OR.ZMIN.GE.ZMAX)THEN
            WRITE(CHMAIL,10200)
10200       FORMAT(' Wrong Box limits. Check values ')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='BOX'
         GXMIN(NCVOLS)=XMIN
         GXMAX(NCVOLS)=XMAX
         GYMIN(NCVOLS)=YMIN
         GYMAX(NCVOLS)=YMAX
         GZMIN(NCVOLS)=ZMIN
         GZMAX(NCVOLS)=ZMAX
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
* Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 10 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=-100000
               GXMAX(JJ)=-99999
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-99999
               GZMIN(JJ)=-100000
               GZMAX(JJ)=-99999
   10       CONTINUE
            NCVOLS=0
         ENDIF
      ELSEIF (CHPATL.EQ.'TUBE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX)
         CALL KUGETR(ZDEM)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='TUBE'
         GXMIN(NCVOLS)=RMAX
         GXMAX(NCVOLS)=ZDEM
         GYMIN(NCVOLS)=XMED
         GYMAX(NCVOLS)=YMED
         GZMIN(NCVOLS)=ZMED
         GZMAX(NCVOLS)=0.
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 20 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=0.1
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-100000
               GZMIN(JJ)=-100000
               GZMAX(JJ)=0.
   20       CONTINUE
            NCVOLS=0
         ENDIF
 
      ELSEIF (CHPATL.EQ.'CONE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX1)
         CALL KUGETR(RMAX2)
         CALL KUGETR(ZDEM)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='CONE'
         GXMIN(NCVOLS)=RMAX1
         GXMAX(NCVOLS)=RMAX2
         GYMIN(NCVOLS)=ZDEM
         GYMAX(NCVOLS)=XMED
         GZMIN(NCVOLS)=YMED
         GZMAX(NCVOLS)=ZMED
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 30 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=0.1
               GYMIN(JJ)=0.1
               GYMAX(JJ)=-100000
               GZMIN(JJ)=-100000
               GZMAX(JJ)=-100000
   30       CONTINUE
            NCVOLS=0
         ENDIF
 
      ELSEIF (CHPATL.EQ.'SPHE')THEN
         IHOLE=0
*
*    It's now possible to clip different volumes by different SHAPES !
*    Moreover, one can clip twice each volume by different SHAPES !
*
         NCVOLS=NCVOLS+1
         IF(NCVOLS.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10000)
            CALL GMAIL(0,0)
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NNVV,NCH)
***SG
         CALL KUGETR(RMAX)
         CALL KUGETR(XMED)
         CALL KUGETR(YMED)
         CALL KUGETR(ZMED)
****SG
         GNNVV(NCVOLS)=NNVV
         GNASH(NCVOLS)='SPHE'
         GXMIN(NCVOLS)=RMAX
         GXMAX(NCVOLS)=XMED
         GYMIN(NCVOLS)=YMED
         GYMAX(NCVOLS)=ZMED
         IF(GXMIN(NCVOLS).GT.-99999.)IHOLE=1
*Resetting Mcvol mode
         IF(GNNVV(NCVOLS).EQ.'.')THEN
            IHOLE=0
            DO 40 JJ=1,NCVOLS
               GNNVV(JJ)=' '
               GXMIN(JJ)=0.1
               GXMAX(JJ)=-100000
               GYMIN(JJ)=-100000
               GYMAX(JJ)=-100000
   40       CONTINUE
            NCVOLS=0
         ENDIF
*
      ELSEIF (CHPATL.EQ.'VALCUT') THEN
         CALL KUGETR(XCUT)
         CALL KUGETR(YCUT)
         CALL KUGETR(ZCUT)
*
      ELSEIF (CHPATL.EQ.'SPOT') THEN
         CALL KUGETR(XLPOS)
         CALL KUGETR(YLPOS)
         CALL KUGETR(ZLPOS)
         CALL KUGETI(INTEN)
         CALL GLIGHT(XLPOS,YLPOS,ZLPOS,INTEN)
*
      ELSEIF (CHPATL.EQ.'VAR5D') THEN
         CALL KUGETR(TSEQTO)
         CALL KUGETI(NPROC)
         CALL KUGETI(NMPTOT)
         CALL KUGETR(TOTMBY)
         CALL KUGETR(TSEQ)
         CALL KUGETR(TLAT)
         CALL KUGETR(TNET)
*
      ELSEIF (CHPATL.EQ.'RANG5D') THEN
         CALL KUGETR(X1MIN)
         CALL KUGETR(X1MAX)
         CALL KUGETR(Y1MIN)
         CALL KUGETR(Y1MAX)
         CALL KUGETR(Z1MIN)
         CALL KUGETR(Z1MAX)
*
      ELSEIF (CHPATL.EQ.'DRAW') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         GTHETL=GTHETA
         GPHIL=GPHI
         GPSIL=GPSI
         GU0L=GU0
         GV0L=GV0
         GSCUL=GSCU
         GSCVL=GSCV
         IF(RAYTRA.EQ.1.)THEN
           CALL GDRAYT(NAME,GTHETL,GPHIL,GPSIL,GU0L,GV0L,GSCUL,GSCVL)
         ELSE
           CALL GDRAW(NAME,GTHETL,GPHIL,GPSIL,GU0L,GV0L,GSCUL,GSCVL)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'DVOLUME') THEN
         CALL KUGETI(N)
         IF (N.EQ.0) GO TO 60
         IF (N.LT.0.OR.N.GT.15) GO TO 999
*
         CALL KUGETC(CHTEXT,NCH)
         DO 50 I=1,N
            CALL KUGETL(NAMNUM,NCH)
            CALL UCTOH(NAMNUM,NNAME(I),4,4)
            CALL KUGETL(CHNUMB,NCH)
            CALL KICTON(CHNUMB,NNUMB(I),RVAL)
            IF (IQUEST(1).NE.0) GO TO 999
   50    CONTINUE
*
         CALL KUGETC(CHNRS,NCH)
         NRS=0
         IF (CHNRS.EQ.'DRS') NRS=1
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
   60    CALL GDRVOL(N,NNAME,NNUMB,NRS,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,
     +   GSCV)
*
      ELSEIF (CHPATL.EQ.'DCUT') THEN
         IHOLE=0
         CALL KUGETC(NAME,NCH)
         CALL KUGETC(CHAX,NCH)
         IF (CHAX.EQ.'X'.OR.CHAX.EQ.'1') THEN
            IAX=1
         ELSEIF (CHAX.EQ.'Y'.OR.CHAX.EQ.'2')THEN
            IAX=2
         ELSEIF (CHAX.EQ.'Z'.OR.CHAX.EQ.'3')THEN
            IAX=3
         ENDIF
         CALL KUGETR(CCUT)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL GDRAWC(NAME,IAX,CCUT,GU0,GV0,GSCU,GSCV)
*
      ELSEIF (CHPATL.EQ.'DXCUT') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(CUTTHE)
         CALL KUGETR(CUTPHI)
         CALL KUGETR(CCUT)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL GDRAWX(NAME,CUTTHE,CUTPHI,CCUT,GTHETA,GPHI,GU0,GV0,GSCU,
     +   GSCV)
*
***SG
*
*
*   It's now possible to shift each volume into a more visible place !
*
      ELSEIF(CHPATL.EQ.'SHIFT') THEN
         IF(NSHIFT.EQ.0)KSHIFT=1
         NSHIFT=NSHIFT+1
         IF(NSHIFT.EQ.MULTRA)THEN
            WRITE(CHMAIL, 10300)
10300      FORMAT(' *** GXDRAW ***:',
     +            ' No more space to store SHIFT information.')
            CALL GMAIL(0,0)
            GOTO 999
         ENDIF
         CALL KUGETC(NVNV,NCH)
         CALL KUGETR(XXXX)
         CALL KUGETR(YYYY)
         CALL KUGETR(ZZZZ)
         GNVNV(NSHIFT)=NVNV
         GXXXX(NSHIFT)=XXXX
         GYYYY(NSHIFT)=YYYY
         GZZZZ(NSHIFT)=ZZZZ
*   Resetting Shift mode
         IF(GNVNV(NSHIFT).EQ.'.')THEN
            KSHIFT=0
            DO 70 KK=1,NSHIFT
               GNVNV(KK)=' '
               GXXXX(KK)=0
               GYYYY(KK)=0
               GZZZZ(KK)=0
   70       CONTINUE
            NSHIFT=0
         ENDIF
*
*  To make the detector 'explode'
*
      ELSEIF(CHPATL.EQ.'BOMB')THEN
         CALL KUGETR(BOOM)
         GBOOM=BOOM
*
***SG
*
      ELSEIF (CHPATL.EQ.'DTREE') THEN
*         JSIM=0
         KXXX=0
         NNPAR=NPAR
         CALL KUGETC(NAME,NCH)
         CALL UHTOC(IQ(JVOLUM+1),4,MOMO,4)
         CALL KUGETI(LEVMAX)
         IF(NNPAR.EQ.3)THEN
            CALL KUGETI(ISELT)
            IISELT=ISELT
         ELSE
            ISELT=111
         ENDIF
         IWTY=IGIWTY(1)
         JVSIM=2
         IF(IWTY.GT.10.OR.IWTY.LT.1)JVSIM=1
         IF (NAME.EQ.'    ')NAME=MOMO
         IF (NAME.NE.MOMO) THEN
            INTFLA=10
            CALL GDTREE(MOMO,0,110)
            DO 80 J=1,NUMND2
               IQ(JFINAM+J)=IQ(JNAM1+J)
               IQ(JFISCA+J)=IQ(JSCA1+J)
               IQ(JFIMOT+J)=IQ(JMOT1+J)
   80       CONTINUE
            KXXX=1
            IF(LEVMAX.LT.0)THEN
               LEVMAX=-LEVMAX
               DO 90  II=1,LEVMAX
                  CALL GDTR8(NAME,MOTH,IONL)
                  NAME=MOTH
   90          CONTINUE
               LEVMAX=3
            ENDIF
         ELSE
            INTFLA=10
            CALL GDTREE(NAME,0,110)
            DO 100 J=1,NUMND2
               IQ(JFINAM+J)=IQ(JNAM1+J)
               IQ(JFISCA+J)=IQ(JSCA1+J)
               IQ(JFIMOT+J)=IQ(JMOT1+J)
  100       CONTINUE
            INTFLA=-1
            CALL GDTREE(NAME,LEVMAX,ISELT)
         ENDIF
*
         CALL GDPLST(JVSIM,NAME,LEVMAX,KXXX)
*
      ELSEIF (CHPATL.EQ.'DSPEC') THEN
         CALL KUGETC(NAME,NCH)
         CALL GDSPEC(NAME)
*
      ELSEIF (CHPATL.EQ.'D3DSPEC') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(TETA3)
         CALL KUGETR(PHI3)
         CALL KUGETR(PSI3)
         CALL KUGETR(U03)
         CALL KUGETR(V03)
         CALL KUGETR(ZM3)
         CALL GSPE3D(NAME,TETA3,PHI3,PSI3,U03,V03,ZM3)
*
      ELSEIF (CHPATL.EQ.'DFSPC') THEN
         CALL KUGETC(NAME,NCH)
         ISORT=0
         CALL KUGETC(YESNO,NCH)
         IF (YESNO.EQ.'Y') ISORT=1
         INTER=1
         CALL KUGETC(MODE,NCH)
         IF (MODE.EQ.'B') INTER=0
         CALL GDFSPC(NAME,ISORT,INTER)
*
      ELSEIF (CHPATL.EQ.'DTEXT') THEN
         CALL KUGETR(X0)
         CALL KUGETR(Y0)
         CALL KUGETS(CHTEXT,NCH)
         CALL KUGETR(SIZE)
         CALL KUGETR(ANGLE)
         CALL KUGETI(LWID)
         CALL KUGETC(CENT,NCH)
         IF (CENT.EQ.'LEFT'.OR.CENT.EQ.'-1') THEN
            IOPT=-1
         ELSEIF (CENT.EQ.'RIGHT'.OR.CENT.EQ.'1') THEN
            IOPT=1
         ELSE
            IOPT=0
         ENDIF
         CALL IGSET('TXFP',-60.)
         IWTY=IGIWTY(1)
         IF(IWTY.GT.10.OR.IWTY.LT.1)CALL IGSET('TXFP',-61.)
         CALL GDRAWT(X0,Y0,CHTEXT,SIZE,ANGLE,LWID,IOPT)
         CALL IGSET('TXFP',2.)
*
      ELSEIF (CHPATL.EQ.'DVECTOR') THEN
         CALL KUGETV(VNAME,LPARX,LLL)
         CALL KUGETV(VNAME,LPARY,LLL)
         CALL KUGETI(NP)
         CALL GDRAWV(QQ(LPARX),QQ(LPARY),NP)
*
      ELSEIF (CHPATL.EQ.'DSCALE') THEN
         CALL KUGETR(X0)
         CALL KUGETR(Y0)
         CALL GDSCAL(X0,Y0)
*
      ELSEIF (CHPATL.EQ.'DAXIS') THEN
         CALL KUGETR(XX0)
         CALL KUGETR(YY0)
         CALL KUGETR(ZZ0)
         CALL KUGETR(DDX)
         CALL GDAXIS(XX0,YY0,ZZ0,DDX)
*
      ELSEIF (CHPATL.EQ.'DMAN') THEN
         CALL KUGETR(U0)
         CALL KUGETR(V0)
         CALL KUGETC(MODE,NCH)
         IF (MODE.EQ.'WM1') THEN
            CALL GDWMN1(U0,V0)
         ELSE IF (MODE.EQ.'WM3') THEN
            CALL GDWMN3(U0,V0)
         ELSE IF (MODE.EQ.'WM2') THEN
            CALL GDWMN2(U0,V0)
         ELSE IF (MODE.EQ.'MAN') THEN
            CALL GDMAN(U0,V0)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'DHEAD') THEN
         ISELH=111110
         CALL KUGETI(ISELH)
         CHRSIZ=0.6
         CALL KUGETS(CHTEXT,NCH)
         CALL KUGETR(CHRSIZ)
         CALL GDHEAD(ISELH,CHTEXT,CHRSIZ)
*
      ELSEIF (CHPATL.EQ.'MEASURE') THEN
         CALL IGLOC2(1,NT,U0,V0,U1,V1,ISTAT,'L')
         IF (ISTAT.EQ.0) GO TO 999
         UDIST=(U1-U0)/(GSCU*GZUA)
         VDIST=(V1-V0)/(GSCV*GZVA)
         DIST=SQRT(UDIST*UDIST+VDIST*VDIST)
         WRITE (CHMAIL,'('' MEASURE : '',F9.4,'' CM'')') DIST
         CALL GMAIL(0,0)
*
      ELSEIF (CHPATL.EQ.'MOVE')  THEN
         IWTY=IGIWTY(1)
         IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
            ISTAT=0
            LEP=-ABS(LEP)
            CALL KUGETC(NAME,NCH)
            CALL KUGETC(NOPT,NCH)
            VX(1)=0.
            VX(2)=4.
            VX(3)=4.
            VX(4)=0.
            VY(1)=0.
            VY(2)=0.
            VY(3)=1.
            VY(4)=1.
            VXX(1)=4.
            VXX(2)=8.
            VXX(3)=8.
            VXX(4)=4.
            VYY(1)=0.
            VYY(2)=0.
            VYY(3)=1.
            VYY(4)=1.
            VVX(1)=8.
            VVX(2)=12.
            VVX(3)=12.
            VVX(4)=8.
            VVY(1)=0.
            VVY(2)=0.
            VVY(3)=1.
            VVY(4)=1.
            XV(1)=12.
            XV(2)=16.
            XV(3)=16.
            XV(4)=12.
            YV(1)=0.
            YV(2)=0.
            YV(3)=1.
            YV(4)=1.
            BX(1)=16.
            BX(2)=20.
            BX(3)=20.
            BX(4)=16.
            BY(1)=0.
            BY(2)=0.
            BY(3)=1.
            BY(4)=1.
*****           CALL IGSET('DRMD',2.)
            CALL ISFAIS(1)
            CALL GDCOL1(2)
            CALL IFA(4,VX,VY)
            CALL GDCOL1(3)
            CALL IFA(4,VXX,VYY)
            CALL GDCOL1(4)
            CALL IFA(4,VVX,VVY)
            CALL GDCOL1(6)
            CALL IFA(4,XV,YV)
            CALL GDCOL1(7)
            CALL IFA(4,BX,BY)
            AITXCO=5.
            CALL IGSET('TXCI',AITXCO)
            CALL IGSET('TXFP',-60.)
            CALL GDRAWT(2.,.2,'THETA',.7,0.,4,0)
            CALL GDRAWT(6.,.2,'PHI',.7,0.,4,0)
            CALL GDRAWT(10.,.2,'TRASL',.7,0.,4,0)
            CALL GDRAWT(14.,.2,'ZOOM',.7,0.,4,0)
            CALL GDRAWT(18.,.2,'OFF',.7,0.,4,0)
            CALL IGSET('TXFP',2.)
            LLEP=ABS(LEP)
            IF(LLEP.GT.1)THEN
               LCLC=1
            ELSE
               LCLC=0
            ENDIF
            CALL ISFACI(LCLC)
            CALL IGBOX(0.,20.,20.,1.)
            CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
            IOPTS = INDEX(NOPT,'S')+INDEX(NOPT,'s')
            IOPTT = INDEX(NOPT,'T')+INDEX(NOPT,'t')
            IOPTH = INDEX(NOPT,'H')+INDEX(NOPT,'h')
            IF(IOPTT.NE.0) CALL GDXYZ(0)
            IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
            MO=2
*           OOY2=10.
*           OOX2=10.
            OGSCU=GSCU
            OGSCV=GSCV
*         ipx=1
            CALL IGQWK(1,'MXDS',RVAL)
            IXXX=RVAL(1)
            IYYY=RVAL(2)
            IYYY1=(IYYY*19.)/20.
            DO 110 J=1,1000000
               IF(ISTAT.EQ.2.AND.IOPTT.NE.0) CALL GKXYZ(-.25)
               IF(ISTAT.EQ.2.AND.IOPTH.NE.0) CALL GKHITS('*','*',-.1)
               CALL IRQLC(1,MO,ISTAT,NT,X2,Y2)
*           CALL ISFAIS(1)
*****           CALL IGSET('DRMD',2.)
               IF(MO.NE.-2)THEN
                  IF(X2.GT.0..AND.X2.LT.4..AND.Y2.LT.1.)NBAR=1
                  IF(X2.GT.4..AND.X2.LT.8..AND.Y2.LT.1.)NBAR=2
                  IF(X2.GT.8..AND.X2.LT.12..AND.Y2.LT.1.)NBAR=3
                  IF(X2.GT.12..AND.X2.LT.16..AND.Y2.LT.1.)NBAR=4
                  IF(X2.GT.16..AND.X2.LT.20..AND.Y2.LT.1.)THEN
                     CALL IGSET('DRMD',1.)
                     LEP=-LEP
                     GO TO 999
                  ENDIF
               ENDIF
*           YY22=ABS(Y2-OOY2)
               IF(NBAR.EQ.1) THEN
                  GTHETA=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ELSEIF(NBAR.EQ.2) THEN
*             GBOOM=Y2/10.
                  GPHI=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ELSEIF(NBAR.EQ.3) THEN
*             XX22=ABS(X2-OOY2)
                  GU0=X2
                  GV0=Y2
***             GTHETA=18.*Y2
***             GPHI=18.*Y2
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2.AND.XX22.LT..2)GOTO 177
*             OOY2=Y2
*             OOX2=X2
               ELSEIF(NBAR.EQ.4) THEN
                  GSCU=OGSCU*Y2*.25
                  GSCV=OGSCV*Y2*.25
                  IF(IOPTS.NE.0) MO=-2
                  IF(ISTAT.EQ.0.OR.ISTAT.EQ.2)MO=2
*             IF(YY22.LT..2)GOTO 177
*             OOY2=Y2
               ENDIF
*****           CALL IGSET('DRMD',1.)
               CALL IGPXMP(IPX,IXXX,IYYY1,'O')
               CALL ISFACI(LCLC)
               IF(LCLC.NE.0)CALL IGBOX(0.,20.,20.,1.)
               CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
               IF(IOPTT.NE.0) CALL GDXYZ(0)
               IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
               CALL IGPXMP(IPX,0,0,'CDR')
**       CALL GDRAW(NAME,SGT1,SGT2,SGT3,SGT4,SGT5,SGT6,SGT7)
*       CALL GDXYZ(0)
*       CALL GDHITS('*','*',0,-1,.4)
  110       CONTINUE
         ENDIF
*
      ELSEIF (CHPATL.EQ.'MOVE3D')  THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(GTHETA)
         CALL KUGETR(GPHI)
         CALL KUGETR(GPSI)
         CALL KUGETR(GU0)
         CALL KUGETR(GV0)
         CALL KUGETR(GSCU)
         CALL KUGETR(GSCV)
         CALL KUGETR(GSCZ)
         CALL KUGETC(NOPT,NCH)
         GSCU=GSCU*GSCZ
         GSCV=GSCV*GSCZ
         CALL HPLI
         CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
         IOPTT = INDEX(NOPT,'T')+INDEX(NOPT,'t')
         IOPTH = INDEX(NOPT,'H')+INDEX(NOPT,'h')
         IF(IOPTT.NE.0) CALL GDXYZ(0)
         IF(IOPTH.NE.0) CALL GDHITS('*','*',0,0,.2)
*
      ELSEIF (CHPATL.EQ.'PERSP') THEN
         CALL KUGETC(NAME,NCH)
         CALL KUGETR(DISTT)
         CALL KUGETC(SAMP,NCH)
         IF(DISTT.LT.100.)DISTT=100.
         DPERS=DISTT
         IF(SAMP(1:2).EQ.'ON')THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               LEP=-ABS(LEP)
               CALL IGQWK(1,'MXDS',RVAL)
               IXXX=RVAL(1)
               IYYY=RVAL(2)
               DO 120 II=1,1000000
                  CALL IRQLC(1,2,ISTAT,NT,X2,Y2)
                  IF(ISTAT.EQ.0)GOTO 130
                  DPERS=Y2*100.+100.
                  GTHETA=X2*4.5
                  GPHI=90.-GTHETA
                  CALL IGPXMP(IPX,IXXX,IYYY,'O')
                  CALL GDRAW(NAME,GTHETA,GPHI,GPSI,GU0,GV0,GSCU,GSCV)
                  CALL IGPXMP(IPX,0,0,'CDR')
  120          CONTINUE
  130          CONTINUE
            ENDIF
         ENDIF
 
      ELSEIF (CHPATL.EQ.'LENS') THEN
         ZZFV=0.
         IWTY=IGIWTY(1)
         IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
            CALL KUGETI(KNUM)
            IF(KNUM.EQ.1000)KNUM=MYISEL
            CALL KUGETC(KSAM,NCH)
            KLLM=KNUM
            KLSA=KSAM
            CALL GDLENS(KLLM,KLSA)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'ZOOM') THEN
         CONTINUE
         ZZFV=0.
         ZFU=2.
         CALL KUGETR(ZFU)
         ZFV=ZFU
         CALL KUGETR(ZFV)
         ZZFU=ZFU
         ZZFV=ZFV
         IF(ZZFU.EQ.0.)ZZFV=0.
         IF(ZFU.EQ.0.OR.ZFV.EQ.0)GO TO 140
         IMODE=1
         CALL KUGETI(IMODE)
         UZ0=PLTRNX*.5
         CALL KUGETR(UZ0)
         VZ0=PLTRNY*.5
         CALL KUGETR(VZ0)
         U0 =UZ0
         CALL KUGETR(U0)
         V0 =U0
         CALL KUGETR(V0)
*
         IF(IMODE.GT.1000)THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               ISEL1=IMODE-1000
               CALL GDXZOO(ISEL1,ZFU,ZFV,UZ0,VZ0,U0,V0)
               RETURN
            ENDIF
         ELSEIF(IMODE.EQ.1000)THEN
            IWTY=IGIWTY(1)
            IF(IWTY.LE.10.AND.IWTY.GE.1)THEN
               ISEL1=MYISEL
               CALL GDXZOO(ISEL1,ZFU,ZFV,UZ0,VZ0,U0,V0)
               RETURN
            ENDIF
         ENDIF
*
         IF(IMODE.EQ.0)THEN
*
            CALL GDCURS(UZ0,VZ0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
*
         ELSE IF(IMODE.EQ.1)THEN
*
            CALL IGLOC2(1,NT,UZ1,VZ1,UZ2,VZ2,ISTAT,'R')
            IF (ISTAT.EQ.0) GO TO 999
            IF (UZ2-UZ1.EQ.0.) UZ2=UZ1+PLTRNX/200.
            IF (VZ2-VZ1.EQ.0.) VZ2=VZ1+PLTRNY/200.
            ZFU=PLTRNX/ABS(UZ2-UZ1)
            ZFV=PLTRNY/ABS(VZ2-VZ1)
            UZ0=(UZ1+UZ2)/2.
            VZ0=(VZ1+VZ2)/2.
*
         ELSE IF(IMODE.EQ.2)THEN
*
            CALL GDCURS(UZ0,VZ0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
            CALL GDCURS(U0,V0,JCHAR)
            IF (JCHAR.EQ.0) GO TO 999
*
         ENDIF
*
  140    CALL GDZOOM(ZFU,ZFV,UZ0,VZ0,U0,V0)
*
*
      ELSEIF (CHPATL.EQ.'DXYZ') THEN
         CALL KUGETI(IT)
         CALL GDXYZ(IT)
*
      ELSEIF (CHPATL.EQ.'KXYZ') THEN
         CALL KUGETR(EPSXYZ)
         CALL GKXYZ(EPSXYZ)
*
      ELSEIF (CHPATL.EQ.'DPART') THEN
         CALL KUGETI(IT)
         ISELP = 11
         CALL KUGETI(ISELP)
         CALL KUGETR(SIZE)
         CALL GDPART(IT,ISELP,SIZE)
*
      ELSEIF (CHPATL.EQ.'DHITS') THEN
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IUTR)
         ISYMB=0
         CALL KUGETI(ISYMB)
         CALL KUGETR(SSYMB)
         CALL GDHITS(IVS,ICS,IUTR,ISYMB,SSYMB)
*
      ELSEIF (CHPATL.EQ.'KHITS') THEN
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETR(EPSHIT)
         CALL GKHITS (IVS,ICS,EPSHIT)
*
      ELSEIF (CHPATL.EQ.'DCHIT') THEN
         IUTR =0
         ISYMB=0
         SIZMAX=1.
         KDHIT =4
         HITMIN=0.
         HITMAX=0.
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IUTR)
         CALL KUGETI(ISYMB)
         CALL KUGETR(SIZMAX)
         CALL KUGETI(KDHIT)
         CALL KUGETR(HITMIN)
         CALL KUGETR(HITMAX)
         CALL GDCHIT(IVS,ICS,IUTR,ISYMB,SIZMAX,KDHIT, HITMIN,HITMAX)
*
      ELSEIF (CHPATL.EQ.'DUVIEW') THEN
         CALL KUGETC(IDS,NCH)
         CALL KUGETC(IVS,NCH)
         CALL KUGETC(ICS,NCH)
         CALL KUGETI(IVIEW)
+SELF, IF=-USRJMP
         CALL GUVIEW(IDS,IVS,ICS,IVIEW)
+SELF, IF=USRJMP
         CALL JUMPT4(JUVIEW,IDS,IVS,ICS,IVIEW)
+SELF
      ENDIF
*
  999 END
+DECK,GMEDIA,IF=-OLD.
*CMZ :          13/02/98  18.13.57  by  Pavel Nevski
*CMZ :  1.30/00 30/04/97  22.41.05  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.24.17  by  S.Giani
*-- Author :
      SUBROUTINE GMEDIA (X, NUMED)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Finds in which volume/medium the point X is, and updates the *
C.    *    common /GCVOLU/ and the structure JGPAR accordingly.        *
C.    *                                                                *
C.    *   NUMED returns the tracking medium number, or 0 if point is   *
C.    *         outside the experimental setup.                        *
C.    *                                                                *
C.    *   Called by :  GTREVE, GLTRAC, 'User'                          *
C.    *   Authors   : R.Brun, F.Bruyant, A.McPherson                   *
C.    *               S.Giani.                                         *
C.    *                                                                *
C.    *   Modified by S.Giani (1993) to perform the search according   *
C.    *    to the new 'virtual divisions' algorithm and to build the   *
C.    *    stack of the 'possible overlapping volumes' in the case of  *
C.    *    MANY volumes. Any kind of boolean operation is now possible.*
C.    *    Divisions along arbitrary axis are now possible.            *
C.    *   PN: in MANY volums the search should start from top          *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ, GCFLAG.
+SEQ, GCKINE.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCVDMA.
+SEQ, GCHVIR.
C.
      DIMENSION  X(*)
      REAL       XC(6)
      LOGICAL    BTEST
      CHARACTER  NAME*4
C.
C.    ------------------------------------------------------------------
*
      nvmany=0
      nfmany=0
      new2fl=0
*
      IF (NLEVEL.EQ.0) CALL GMEDIN
*
* SECTION I: The /GCVOLU/ table contains the initial guess for a path
*            in the geometry tree on which X may be found.  Look along this
*            path until X is found inside.  This is the starting position.
*            If this is an ONLY volume with no daughters, we are done;
*            otherwise reset search record variables, proceed to section II.
*
*            The information contained in INFROM has to be invalidated
*            because it has no meaning for the subsequent tracking. INFR
*            is a local variable used to optimise the search in the
*            geometry tree.
*
      INFROM = 0
*
* *** Check if point is in current volume
*
      INFR   = 0
      JVIN   = 0
C
C        PN: in MANY volums the search should start from top
  100 If (NLEVEL.GT.1) then
         If (GONLY(NLEVEL).EQ.0) then
            NLEVEL=NLEVEL-1
            GOTO 100
         endif
      endif
C
C*****  Code Expanded From Routine:  GTRNSF
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*GRMAT(3
     +      ,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*GRMAT(6
     +      ,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*GRMAT(9
     +      ,NLEVEL)
 
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
*
*  **   Point not in current volume, go up the tree
*
         IF (NLEVEL.GT.1) THEN
            NLEVEL = NLEVEL -1
            JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
            NIN = Q(JVO+3)
            IF(NIN.GT.0) THEN
*
*       Do not set INFR whne going up the tree. GMEDIA can be called
*       by the user and it  should not assume  that the previous
*       position has something to do with the current search. INFR
*       is otherwise useful when searching in a 'MANY' volume
*       configuration. This statement is commented for the above reason.
*
*              INFR  =LINDEX(NLEVEL+1)
            ELSE
               INFR  =0
            ENDIF
            GO TO 100
         ELSE
*
*   *      Point is outside setup
*
            NUMED = 0
            GO TO 999
         ENDIF
      ENDIF
*
*  **   Point is in current volume
*
      IF(INFR  .GT.0) THEN
         JIN=LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         JVIN = JIN
      ENDIF
      NLMIN = NLEVEL
      NLMANY = 0
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents recursively for any containing X.
*             Take the first one found, if any, and continue at that
*             level, incrementing NLEVEL and extending /GCVOLU/ tables.
*             This is continued until a level is reached where X is not
*             found in any of the contents, or there are no contents.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            INFR   = 0
            GO TO 200
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT  = LQ(JVO-NIN-1)+1
         NCONT  = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  new2fl=0
                  IF (GONLY(NLEVEL).NE.0.) THEN
                    NLMANY = 0
                    nvmany = 0
                    nfmany = 0
                  ENDIF
                  INFR   = 0
                  GO TO 200
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR  .GT.0) THEN
            JIN = LQ(JVO-INFR  )
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLEVEL.GT.NLMANY) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
            nfmany=nvmany+1
         ENDIF
         if(new2fl.eq.0)then
            nvmany=nvmany+1
            manyle(nvmany)=nlevel
            do 401 i = 1,nlevel
              manyna(nvmany,i)=names(i)
              manynu(nvmany,i)=number(i)
 401        continue
         endif
*
*   *   Go up the tree up to a volume with positioned contents
*
         new2fl=-1
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR  )
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.  The current node (NLEVEL
*             in /GCVOLU/) is the lowest ONLY volume in which X is found.
*             If X was also found in any of its contents, they are MANY
*             volumes: the best-choice is the one among them at the greatest
*             level in the tree, and it is stored.  Otherwise the current
*             volume is the solution.  Before exit, all of the blocking
*             words leftover in the tree must be reset to zero.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
      DO 419 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 418 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  418    CONTINUE
  419 CONTINUE
*
      if(nlmany.eq.0)then
        nvmany=0
        nfmany=0
      endif
      IF (NLMANY.GT.0) CALL GFCVOL
      JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      IF(JVIN.NE.0) IQ(JVIN) = IBCLR(IQ(JVIN),4)
      NUMED = Q(JVO+4)
*                                                             END GMEDIA
  999 IF(JGSTAT.NE.0) CALL GFSTAT(2)
      END
+DECK,GSDETV
*CMZ :  1.30/00 24/05/96  21.28.46  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSDETV (IUSET, IUDET, IDTYPE, NWHI, NWDI, ISET, IDET)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines detector IUDET as a member of set IUSET          *
C.    *     and prepares the DETector structure                        *
C.    *                                                                *
C.    *             Input parameters                                   *
C.    * IUSET     set identifier (4 characters), user defined          *
C.    * IUDET     detector identifier  (4 characters),   name of  an   *
C.    *           existing volume                                      *
C.    * IDTYPE    detector type, user defined                          *
C.    * NWHI      number of words for primary allocation of HITS banks *
C.    * NWDI      number of words for primary allocation of DIGI banks *
C.    *                                                                *
C.    *             Output parameters                                  *
C.    * ISET      position of set in bank JSET                         *
C.    * IDET      position of detector in bank JS=IB(JSET-ISET)        *
C.    *              If ISET=0 or IDET=0  error                        *
C.    * Remarks:                                                       *
C.    * - The path through the volume tree will be automatically set   *
C.    *   in GGDETV,called by GGCLOS, after all volumes have been      *
C.    *   positionned.                                                 *
C.    * - The detector type  IDTYPE is not used  internally by GEANT   *
C.    *   and  can be  defined by  the user  to distinguish  quickly   *
C.    *   between various kinds of detectors,  in the routine GUSTEP   *
C.    *   for example.                                                 *
C.    *                                                                *
C.    *       IQ(JSET+ISET) = IUSET                                    *
C.    *       JS = LQ(JSET-ISET) = pointer to set IUSET                *
C.    *       IQ(JS+IDET)=IUDET                                        *
C.    *       JD= LQ(JS-1)  = pointer to detector IUDET                *
C.    *       IQ(JD+1)=Number of words to store packed volume numbers  *
C.    *       IQ(JD+2)=Number of volume descriptors                    *
C.    *       IQ(JD+3)=Number of words per hit                         *
C.    *       IQ(JD+4)=Number of elements per hit                      *
C.    *       IQ(JD+5)=Number of words per digitisation                *
C.    *       IQ(JD+6)=Number of elements per digitisation             *
C.    *       IQ(JD+7)=NWHI, primary size of hit bank                  *
C.    *       IQ(JD+8)=NWDI, primary size of digitisation bank         *
C.    *       IQ(JD+9)=Number of paths through the JVOLUM tree         *
C.    *       IQ(JD+10)=For aliases only, IDET of mother detector      *
C.    *       IQ(JD+11)=Name of first volume descriptor                *
C.    *       IQ(JD+12)=Number of bits for packing its number          *
C.    *       ...                                                      *
C.    *       IQ(JD+9+2*NV)=Name of last volume descriptor             *
C.    *       IQ(JD+10+2*NV)=Number of bits for packing its number     *
C.    *       then for each possible path                              *
C.    *       list of names and numbers for all levels                 *
C.    *       (The number of levels is entered as number attached to   *
C.    *       the first name which is the top of the JVOLUM tree)      *
C.    *                                                                *
C.    *            The Detector Set data structure JSET                *
C.    *            ------------------------------------                *
C.    *                                                                *
C.    *                                        | JSET                  *
C.    *    NSET            ISET                v         NSET          *
C.    *     ................................................           *
C.    *     |              | |               |  | Set names|           *
C.    *     ................................................           *
C.    *                     | JS                                       *
C.    *                     |                                          *
C.    *    NDET       IDET  v                    NDET                  *
C.    *     ........................................                   *
C.    *     |        |  |  | | Detector names      |                   *
C.    *     ........................................                   *
C.    *                  | JD                                          *
C.    *       -3  -2  -1 v                                             *
C.    *     ................................................           *
C.    *     |   |   |   |  | Volume parameters, in GGDETV  |           *
C.    *     ................................................           *
C.    *              JDH                                               *
C.    *          JDD                                                   *
C.    *      JDU                                                       *
C.    *                                                                *
C.    * The JSET structure is filled by GSDETV + GGDETV, and by        *
C.    *      GSDETH, GSDETD and GSDETU, eventually by GSDETA.          *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors   R.Brun, F.Bruyant    **********                *
C.    *                                                                *
C.    * Modifications:                                                 *
C.    *  PN, 20.04.96:  warning on non-sensetive volume in DEBUG only  *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
+SEQ,GCMZFO.
+CDE,GCFLAG.
      CHARACTER*4 IUSET,IUDET
C.
C.    ------------------------------------------------------------------
C.
      ISET = 0
      IDET = 0
C
C     Check if volume IUDET has been defined
C
      IF (JVOLUM.LE.0) GO TO 920
      NVOLUM = IQ(JVOLUM-1)
      CALL GLOOK (IUDET, IQ(JVOLUM+1), NVOLUM, IVOL)
      IF (IVOL.EQ.0) GO TO 920
C
C     Check that volume IVOL is a sensitive medium
C
      JVO = LQ(JVOLUM-IVOL)
      ITM = Q(JVO+4)
      JTM = LQ(JTMED-ITM)
      IF (Q(JTM+7).EQ.0. .AND. IDEBUG.GT.0) THEN
         WRITE (CHMAIL,1000) IUDET
         CALL GMAIL(0,0)
      ENDIF
C
      IF (JSET.EQ.0)THEN
C
C     Create mother JSET bank
C
         CALL MZBOOK (IXCONS, JSET, JSET, 1, 'SETS', 0,0,0, 5, 0)
         IQ(JSET-5)=0
         NSET = 0
      ELSE
C
         NSET = IQ(JSET-1)
         CALL GLOOK (IUSET, IQ(JSET+1), NSET, ISET)
         IF (ISET.NE.0) GO TO 30
      ENDIF
C
C     Create JSET bank
C
      CALL MZPUSH (IXCONS, JSET, 1, 1, 'I')
      NSET = NSET +1
C
      ISET = NSET
      CALL UCTOH (IUSET, IQ(JSET+ISET), 4, 4)
      CALL MZBOOK (IXCONS, JS, JSET, -ISET, 'SETS', 0,0,0, 5, 0)
      IQ(JS-5) = ISET
C
C     Check if detector has already been defined
C
  30  JS = LQ(JSET-ISET)
      NDET = IQ(JS-1)
      IF (NDET.NE.0)THEN
         CALL GLOOK (IUDET, IQ(JS+1), NDET, IDET)
         IF (IDET.NE.0) GO TO 930
      ENDIF
C
C     If not, create detector bank
C
      CALL MZPUSH (IXCONS, JS, 1, 1, 'I')
      NDET = NDET +1
      IDET = NDET
      CALL UCTOH (IUDET, IQ(JS+IDET), 4, 4)
      CALL MZBOOK (IXCONS, JD, JS, -IDET, 'SEJD', 4,4,100, IOSEJD, 0)
      IQ(JD-5) = IDET
C
      IQ(JD+7) = NWHI
      IQ(JD+8) = NWDI
      IQ(JD+9) = -1
C
C     Now enter Set/Det into JVOLUM data structure
C
      CALL GSATT (IUDET, 'SET ', ISET)
      CALL GSATT (IUDET, 'DET ', IDET)
      CALL GSATT (IUDET, 'DTYP', IDTYPE)
      GO TO 999
C
C     Errors
C
  920 WRITE (CHMAIL,2000) IUDET
      CALL GMAIL(0,0)
      GO TO 999
C
  930 WRITE (CHMAIL,3000)  IUSET, IUDET
      CALL GMAIL(0,0)
C
 1000 FORMAT (' ***** GSDETV - ISVOL=0 FOR DETECTOR ',A4,' - WARNING!')
 2000 FORMAT (' ***** GSDETV ERROR, VOLUME ',A4,' NOT DEFINED')
 3000 FORMAT (' ***** GSDETV ERROR ,SET ',A4, ' DETECTOR ',A4,
     +        ' ALREADY DEFINED')
C
  999 RETURN
      END
+DECK,GXPICK
*CMZ :  1.30/00 31/05/96  19.39.03  by  Unknown
*CMZ :  3.21/02 29/03/94  15.41.33  by  S.Giani
*-- Author :
      SUBROUTINE GXPICK
C.
C.    ******************************************************************
C.    *                                                                *
C.    *      Geometry commands                                         *
C.    *                                                                *
C.    * Point to volume just drawn to pick up medium name, volume name *
C.    * etc. The first point points to the volume, the second point    *
C.    * gives the position of the character string which contains this *
C.    * information.                                                   *
C.    *                                                                *
C.    *       Authors:   S.Egli      **********                        *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCVOLU
+SEQ,GCDRAW
+SEQ,GCBANK
+SEQ,GCSETS
+SEQ,GCTMED
+SEQ,GCMATE
+SEQ,GCUNIT
*
* this COMMON filled in routine GDRAW !
*
      COMMON/GCVHLP/NVLAST
*
      DIMENSION XC(3),XYZ(3),XINVMA(3,3),VL(3),VM(3),VN(3)
      DIMENSION XX(10),YY(10),RHELP(3)
*
      CHARACTER*4 NAMV,CHIDTY
      CHARACTER*20 NAMM
      LOGICAL BTEST
*
* determine inverse matrix xinvma for current view parameters
*
      PH = ABS(MOD(GPHI,360.))
      THET = ABS(MOD(GTHETA,360.))
      IF(THET.LE.180.)GO TO 10
      PH = PH + 180.
      THET = 360. - THET
*
   10 ST = SIN(THET * DEGRAD)
      CT = COS(THET * DEGRAD)
      SP = SIN(PH * DEGRAD)
      CP = COS(PH * DEGRAD)
*
*             VN is new nu axis
*
      VN(1) = ST * CP
      VN(2) = ST * SP
      VN(3) = CT
*
      IF(ABS(VN(2)).GT.0.99999) THEN
*
*             Special case when observer line of sight is along mu:
*             in this case one chooses arbitrarily the vertical axis of
*             plane of projection as the lambda axis and the horizontal
*             as the nu axis
*
         VL(1) = 0.
         VL(2) = 0.
         VL(3) = 1.
         VM(1) = 1.
         VM(2) = 0.
         VM(3) = 0.
      ELSE
*
         VM(1) = 0.
         VM(2) = 1.
         VM(3) = 0.
*
*             Define new lambda axis
*
         CALL CROSS(VM,VN,VL)
         CALL VUNIT(VL,VL,3)
*
*             Define new mu axis
*
         CALL CROSS(VN,VL,VM)
      ENDIF
*
*   now invert matrix defined by VL,VM,VN -> XINVMA
*
      DO 20 I=1,3
         XINVMA(1,I)=VL(I)
         XINVMA(2,I)=VM(I)
         XINVMA(3,I)=VN(I)
   20 CONTINUE
*
      CALL RINV(3,XINVMA,3,RHELP,IFAIL)
      IF(IFAIL.NE.0)THEN
         WRITE(CHMAIL,10100) IFAIL
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
*   perspective projection ?
*
      CALL UCTOH('PERS',IPERS,4,4)
      IF(IPRJ.EQ.IPERS)THEN
         WRITE(CHMAIL,10200)
         CALL GMAIL(0,0)
         GOTO 999
      ENDIF
*
* pick up two points in user coordinates:
*
   30 CALL IRQLC(1,1,ISTAT,NT,U0,V0)
      IF(ISTAT.EQ.0)GOTO 999
      CALL IRQLC(1,1,ISTAT,NT,U1,V1)
      IF(ISTAT.EQ.0)GOTO 999
*
* transform (u0,v0) to coordinates in MARS system:
*  (inverse operation of what is done in routine GDFR3D)
*
*   take zoom parameters into account:
*
      U01=(U0-GZUB-GZUC)/GZUA
      V01=(V0-GZVB-GZVC)/GZVA
*
*   rotate and shift back
*
      UU=+COSPSI*(U01-GU0)+SINPSI*(V01-GV0)
      VV=-SINPSI*(U01-GU0)+COSPSI*(V01-GV0)
      XYZ(1)=UU/GSCU
      XYZ(2)=VV/GSCV
      XYZ(3)=DCUT
*
*   apply xinvma
*
      XC(1)=XINVMA(1,1)*XYZ(1)+XINVMA(1,2)*XYZ(2)+XINVMA(1,3)*XYZ(3)
      XC(2)=XINVMA(2,1)*XYZ(1)+XINVMA(2,2)*XYZ(2)+XINVMA(2,3)*XYZ(3)
      XC(3)=XINVMA(3,1)*XYZ(1)+XINVMA(3,2)*XYZ(2)+XINVMA(3,3)*XYZ(3)
*
*   build up GCVOLU structure with last drawn volume as
*   top of tree
*
      NLEV=1
      LNUM=0
      CALL GLVOLU(NLEV,NVLAST,LNUM,IER)
*
*  determine medium
*
      NUMED=0
      CALL GMEDIA(XC,NUMED)
*
      IF(NUMED.EQ.0)THEN
         WRITE(CHMAIL,10300)
         CALL GMAIL(0,0)
         GOTO 30
      ENDIF
      JTM = LQ(JTMED- NUMED)
      DO 40 I=1,5
   40 NATMED(I)=IQ(JTM+I)
      NMAT   = Q(JTM + 6)
      ISVOL  = Q(JTM + 7)
      IFIELD = Q(JTM + 8)
      FIELDM = Q(JTM + 9)
      TMAXFD = Q(JTM + 10)
      STEMAX = Q(JTM + 11)
      DEEMAX = Q(JTM + 12)
      EPSIL  = Q(JTM + 13)
      STMIN  = Q(JTM + 14)
      CALL UHTOC(NAMES(NLEVEL),4,NAMV,4)
      CALL UHTOC(NATMED,4,NAMM,20)
      DO 50 I=1,20
         IF(NAMM(I:I).EQ.'$')NAMM(I:I)=' '
   50 CONTINUE
      DO 60 I=20,1,-1
         IF(NAMM(I:I).NE.' ')GOTO 70
   60 CONTINUE
   70 NJLAST=I
*
*  determine detector idtype
*
      IF(JSET.GT.0)CALL GFINDS
*
* draw pointer and write volume name,medium
*
      XX(1)=U0
      YY(1)=V0
      XX(2)=U1
      YY(2)=V1
      CALL IPL(2,XX,YY)
*
*  determine text alignment
*
*     protect against double click:
      If (abs(V1-V0)+abs(U1-U0).GT.0) PHI=ATAN2(V1-V0,U1-U0)*RADDEG
      IF(ABS(PHI).LT.90.)THEN
         IHOR=1
      ELSE
         IHOR=3
      ENDIF
      IF(PHI.GT.0.)THEN
         IVER=5
      ELSE
         IVER=1
      ENDIF
      CALL ISTXAL(IHOR,IVER)
*
      IF(.NOT.BTEST(IQ(LQ(JVOLUM-LVOLUM(1))),4))THEN
         CALL ITX(U1,V1,NAMV//'"j# '//NAMM(1:NJLAST))
      ELSE
         WRITE(CHIDTY,10000)IDTYPE
         CALL ITX(U1,V1,NAMV//'"j# '//NAMM(1:NJLAST)//','//CHIDTY)
      ENDIF
      GOTO 30
10000 FORMAT(I4)
10100 FORMAT(' GXPICK: Matrix inversion failed with ',I3,
     +       '; abandoning')
10200 FORMAT(' GXPICK: perspective projection can not be handled')
10300 FORMAT(' GXPICK: point is outside volume')
  999 END
 
+DECK,GXCONT.
*CMZ :  1.30/00 16/04/97  20.12.19  by  Pavel Nevski
*CMZ :  3.21/02 07/07/94  19.47.38  by  S.Giani
*-- Author :
      SUBROUTINE GXCONT
**
**    ******************************************************************
**    *                                                                *
**    *      General control commands                                  *
**    *                                                                *
**    *       Authors:   R.Brun      **********                        *
**    *                  P.Zanarini  **********                        *
**    *                  S.Giani     **********                        *
**    *                                                                *
**    * Modifications:                                 PN, 06 July 96  *
**    *  - strong typing introduced to find undefined variables        *
**    *  - GCTIME common was missing                                   *
**    *  - SPART command corrected ( a la NA49 and Star): Ubuf,        *
**    *    branching ratios and decay modes are KUIP vectors!          *
**    *  - RNDM command with single parameter ISEQ (1-215) recals      *
**    *    standard precomputed sequences.                             *
**    *    If ISEQ=0, sequence is elected according to IGTIME.         *
**    *  - Time control introduced - upon the limit IQUEST(1) is set   *
**    ******************************************************************
**
+CDE,QUEST,PAWC,SCLINK,ZSTATE.
+CDE,GCBANK,GCTMED,GCUNIT,GCFLAG,GCKINE,GCPHYS.
+CDE,GCMULO,GCLIST,GCSTAK,GCDRAW,GCTIME.
*
      Integer      IGIWTY,IwkSty,i,N,Npar,Npk,Nch,Level,Numb,Imat,
     +             NumHit,Llow,Lhigh,Llo1,Lhig1,Llo2,Lhig2,NW,
     +             Idm,Nlmat,Nmec,Kmec,ItMed,Is1,Is2
      Real         A,Z,Dens,RadL,AbsL,ParVal,T
      CHARACTER*20 CHNAME
      CHARACTER*4  CHMECA,CHDEB,CHSET,CHDET,CHMECS(20)
      CHARACTER*32 CHPATL,CHPAR,Cmate,Cpart,Cvec
      External     IGIWTY
* the following is a part of the GCDRAW keeps, forgotten in the official code
      Integer      MyISel
      real         zzfu,zzfv
      Logical      First_QNEXT/.true./
**
**    ------------------------------------------------------------------
**
      IWKSTY = IGIWTY(1)
      CALL KUPATL(CHPATL,NPAR)
*
      IF (CHPATL.EQ.'KINE') THEN
         CALL KUGETI(IKINE)
         NPK=NPAR-1
         DO 10 I=1,NPK
            CALL KUGETR(PKINE(I))
   10    CONTINUE
*
      ELSEIF (CHPATL.EQ.'SORD') THEN
         CALL KUGETI(ISTORD)
*
*     ELSEIF (CHPATL.EQ.'PATR') THEN
*        CALL KUGETI(NJTMAX)
*        CALL KUGETI(NJTMIN)
*        WRITE(CHMAIL,'('' *** GXCONT: Parallel tracking disabled, '',
*    +                  ''see documentation'')')
*        CALL GMAIL(1,1)
*
      ELSEIF (CHPATL.EQ.'RUNG') THEN
         CALL KUGETI(IDRUN)
         CALL KUGETI(IDEVT)
*
      ELSEIF (CHPATL.EQ.'GTIME') THEN
         CALL KUGETR(T)
         CALL KUGETR(TIMEND)
         CALL KUGETI(ITIME)
*
      ELSEIF (CHPATL.EQ.'TRACK') THEN
         IF(JXYZ.NE.0)CALL MZDROP(IXDIV,JXYZ,' ')
         IF(JHITS.NE.0)CALL MZDROP(IXDIV,JHITS,' ')
         CALL MZGARB(IXDIV,0)
         CALL GTREVE
*
      ELSEIF (CHPATL.EQ.'TRIGGER') THEN
         CALL KUGETI(N)
         NEVENT=IEVENT+N
         If (First_QNEXT) then
             First_QNEXT=.false.
             CALL QNEXTE
         else
             CALL QNEXT
         endif
*
      ELSEIF (CHPATL.EQ.'SWITCH') THEN
         CALL KUGETI(I)
         IF(I.GE.1.AND.I.LE.10) THEN
            IF(NPAR.LT.2)THEN
               WRITE(CHMAIL,'('' ISWIT('',I2,'')= '',I3)')I,ISWIT(I)
               CALL GMAIL(0,0)
            ENDIF
            CALL KUGETI(ISWIT(I))
         ENDIF
*
      ELSEIF (CHPATL.EQ.'PRINT') THEN
         CALL KUGETC(CHNAME,NCH)
         N=0
         CALL KUGETI(N)
         CALL GPRINT(CHNAME,N)
*
      ELSEIF (CHPATL.EQ.'DEBUG') THEN
         CALL KUGETC(CHDEB,NCH)
         IF(CHDEB.EQ.'ON')THEN
            IDEBUG=max(IDEBUG,1)
            IDEMIN=1
            IDEMAX=1000000
            ITEST =1
            ITIME =1
         ELSE
            IDEBUG=0
            IDEMIN=0
            IDEMAX=0
         ENDIF
*
      ELSEIF (CHPATL.EQ.'OUTPUT_LP') THEN
         CALL KUGETI(LOUT)
*
      ELSEIF (CHPATL.EQ.'PHITS') THEN
         CALL KUGETC(CHSET,NCH)
         CALL KUGETC(CHDET,NCH)
         CALL KUGETI(NUMHIT)
         IPKHIT=NUMHIT
         CALL GPHITS(CHSET,CHDET)
         IPKHIT=0
*
      ELSEIF (CHPATL.EQ.'PDIGI') THEN
         CALL KUGETC(CHSET,NCH)
         CALL KUGETC(CHDET,NCH)
         CALL GPDIGI(CHSET,CHDET)
*
      ELSEIF (CHPATL.EQ.'MZLOGL') THEN
         IXSTOR=0
         LEVEL=0
         CALL KUGETI(LEVEL)
         CALL MZLOGL(IXSTOR,LEVEL)
*
      ELSEIF (CHPATL.EQ.'PMATE') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPMATX(NUMB)
         ELSE
            CALL GPMATE(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'SMATE') THEN
         CALL KUGETI(IMAT)
         CALL KUGETC(Cmate,NCH)
         CALL KUGETR(A)
         CALL KUGETR(Z)
         CALL KUGETR(DENS)
         CALL KUGETR(RADL)
         CALL KUGETR(ABSL)
         CALL KUGETV(Cvec,LLOW,LHIGH)
         CALL KUGETI(NW)
         CALL GSMATE(IMAT,Cmate,A,Z,DENS,RADL,ABSL,QQ(LLOW),NW)
*
      ELSEIF (CHPATL.EQ.'SMIXT') THEN
         CALL KUGETI(IMAT)
         CALL KUGETC(Cmate,NCH)
         CALL KUGETV(Cvec,LLOW,LHIGH)
         CALL KUGETV(Cvec,LLO1,LHIG1)
         CALL KUGETR(DENS)
         CALL KUGETI(NLMAT)
         CALL KUGETV(Cvec,LLO2,LHIG2)
         CALL GSMIXT(IMAT,Cmate,QQ(LLOW),QQ(LLO1),DENS,NLMAT,QQ(LLO2))
*
      ELSEIF (CHPATL.EQ.'PRMAT') THEN
         CALL KUGETI(Imat)
         CALL KUGETI(IPART)
         CALL KUGETC(CHMECA,NCH)
         CALL GPRMAT(Imat,IPART,CHMECA,NEKBIN,ELOW)
*
      ELSEIF (CHPATL.EQ.'DRMAT') THEN
         CALL KUGETI(Imat)
         CALL KUGETI(IPART)
         IF(NPAR.GT.2) THEN
            NMEC = NPAR-2
            DO 11 KMEC=1,NMEC
               CALL KUGETC(CHMECS(KMEC),NCH)
  11        CONTINUE
         ELSE
            NMEC = 1
            CHMECS(1)='ALL'
         ENDIF
         CALL GDRMAT(Imat,IPART,CHMECS,NMEC)
*
      ELSEIF (CHPATL.EQ.'PLMAT') THEN
         CALL KUGETI(Imat)
         CALL KUGETI(IPART)
         CALL KUGETC(CHMECA,NCH)
         IDM=0
         CALL KUGETI(IDM)
         CALL GPLMAT(Imat,IPART,CHMECA,NEKBIN,ELOW,IDM)
*
      ELSEIF (CHPATL.EQ.'SPART') THEN
         CALL KUGETI(IPART)
         CALL KUGETC(Cpart,NCH)
         CALL KUGETI(ITRTYP)
         CALL KUGETR(AMASS)
         CALL KUGETR(CHARGE)
         CALL KUGETR(TLIFE)
         CALL KUGETV(Cvec,LLOW,LHIGH)
         CALL KUGETI(NW)
         CALL GSPART(IPART,Cpart,ITRTYP,AMASS,CHARGE,TLIFE,QQ(LLOW),NW)
         CALL KUGETV(CVEC,LLO1,LHIG1)
         CALL KUGETV(CVEC,LLO2,LHIG2)
         CALL GSDK  (IPART,QQ(LLO1),IQQ(LLO2))
*
      ELSEIF (CHPATL.EQ.'PPART') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPPARX(NUMB)
         ELSE
            CALL GPPART(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'PRKINE') THEN
         CALL KUGETI(NUMB)
         IF(IWKSTY.GE.1.AND.IWKSTY.LE.10) THEN
            CALL GPKINX(NUMB)
         ELSE
            CALL GPKINE(NUMB)
         ENDIF
*
      ELSEIF (CHPATL.EQ.'STPAR') THEN
         CALL KUGETI(ITMED)
         CALL KUGETC(CHPAR,NCH)
         CALL KUGETR(PARVAL)
         CALL GSTPAR(ITMED,CHPAR,PARVAL)
*
      ELSEIF (CHPATL.EQ.'RNDM') THEN
         IF (NPAR.EQ.0) THEN
            CALL GRNDMQ(IS1,IS2,0,'G')
            WRITE(CHMAIL, 10000) IS1, IS2
10000       FORMAT('  RANDOM NUMBER = ',2I12)
            CALL GMAIL(0,0)
         ELSEIF (NPAR.EQ.1) THEN
            CALL KUGETI(IS1)
            If (IS1.LE.0) IS1=IGTIME
            IS2 = mod(IS1, 215 ) + 1
            CALL GRNDMQ(0, 0, IS2, ' ')
         ELSEIF (NPAR.EQ.2) THEN
            CALL KUGETI(NRNDM(1))
            CALL KUGETI(NRNDM(2))
            If (NRNDM(2).GT.0) THEN
               CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'S')
            else
               IS1 = mod (NRNDM(1),215) + 1
               CALL GRNDMQ( 0, 0, IS1, ' ')
            endif
         ELSE
            WRITE(CHMAIL, 10100)
            CALL GMAIL(0,0)
10100       FORMAT(' Please give up to 2 seeds to initialize',
     +             ' the random number generator')
         ENDIF
         CALL GRNDMQ(NRNDM(1),NRNDM(2),0,'G')
      ENDIF
*
   30 END
 
+DECK,GXPHYS.
*CMZ :  1.30/00 06/07/96  18.25.27  by  Pavel Nevski
*CMZ :  3.21/04 09/11/94  15.31.28  by  S.Ravndal
*-- Author :    R.Brun
      SUBROUTINE GXPHYS
**
**    ******************************************************************
**    *                                                                *
**    *      Physics parameters control commands                       *
**    *                                                                *
**    *       Author:    R.Brun      **********                        *
**    *                                                                *
**    * Modifications:                                PN 06 July 96    *
**    * - strong typing introduced to find undefined variables         *
**    * - GCTRAK.IGAUTO was missing                                    *
**    * - ICKOV was never used. GTMED.ITCKOV is read instead           *
**    * - ITCKOV and ILABS correlated as in GFFGO                      *
**    ******************************************************************
**
+CDE,TYPING,GCBANK,GCPHYS,GCCUTS,GCONSt,GCUNIT,GCMULO,GCTMED,GCTRAK.
*
      Integer       Npar,i,j,Ipart,Imate,Npoint,JTM,JTMi,JM,JMA
      Real          Stepa
      Real          UCUTS(10),ULCUTS(10)
      EQUIVALENCE  (UCUTS(1),CUTGAM)
      Integer       MECA(5,13)
      EQUIVALENCE  (MECA(1,1),IPAIR)
      CHARACTER*6   CUTNAM(10)
      CHARACTER*4   CEN(10)
      CHARACTER*32  CHPATL
      CHARACTER*10  CHNUMB
      PARAMETER    (CHNUMB='1234567890')
      DATA  CUTNAM/'CUTGAM','CUTELE','CUTNEU','CUTHAD','CUTMUO',
     +             'BCUTE' ,'BCUTM' ,'DCUTE' ,'DCUTM' ,'PPCUTM'/
**
**    ------------------------------------------------------------------
**
      CALL KUPATL(CHPATL,NPAR)
*
      IF(CHPATL.EQ.'ANNI')THEN
         CALL KUGETI(IANNI)
*
      ELSEIF(CHPATL.EQ.'AUTO')THEN
         CALL KUGETI(IGAUTO)
*
      ELSEIF(CHPATL.EQ.'BREM')THEN
         CALL KUGETI(IBREM)
*
      ELSEIF(CHPATL.EQ.'CKOV')THEN
         CALL KUGETI(ITCKOV)
*
      ELSEIF(CHPATL.EQ.'COMP')THEN
         CALL KUGETI(ICOMP)
*
      ELSEIF(CHPATL.EQ.'DCAY')THEN
         CALL KUGETI(IDCAY)
*
      ELSEIF(CHPATL.EQ.'DRAY')THEN
         CALL KUGETI(IDRAY)
*
      ELSEIF(CHPATL.EQ.'ERAN')THEN
         CALL KUGETR(EKMIN)
         CALL KUGETR(EKMAX)
         CALL KUGETI(NEKBIN)
         NEKBIN=MIN(NEKBIN,199)
*
      ELSEIF(CHPATL.EQ.'HADR')THEN
         CALL KUGETI(IHADR)
*
      ELSEIF(CHPATL.EQ.'LABS')THEN
         CALL KUGETI(ILABS)
*
      ELSEIF(CHPATL.EQ.'LOSS')THEN
         CALL KUGETI(ILOSS)
         IF(ILOSS.EQ.2)THEN
            IDRAY=0
         ELSE
            IDRAY=1
         ENDIF
*
      ELSEIF(CHPATL.EQ.'MULS')THEN
         CALL KUGETI(IMULS)
*
      ELSEIF(CHPATL.EQ.'MUNU')THEN
         CALL KUGETI(IMUNU)
*
      ELSEIF(CHPATL.EQ.'PAIR')THEN
         CALL KUGETI(IPAIR)
*
      ELSEIF(CHPATL.EQ.'PFIS')THEN
         CALL KUGETI(IPFIS)
*
      ELSEIF(CHPATL.EQ.'PHOT')THEN
         CALL KUGETI(IPHOT)
*
      ELSEIF(CHPATL.EQ.'RAYL')THEN
         CALL KUGETI(IRAYL)
*
      ELSEIF(CHPATL.EQ.'STRA')THEN
         CALL KUGETI(ISTRA)
*
      ELSEIF(CHPATL.EQ.'SYNC')THEN
         CALL KUGETI(ISYNC)
*
      ELSEIF(CHPATL.EQ.'CUTS')THEN
         IF(NPAR.LE.0)THEN
            WRITE(LOUT,10000)
10000       FORMAT(/,' Current PHYSICS parameters:',/)
            DO 10 I=1,10
               CALL GEVKEV(UCUTS(I),ULCUTS(I),CEN(I))
               WRITE(LOUT,10100)CUTNAM(I),ULCUTS(I),CEN(I)
10100          FORMAT(5X,A,' = ',F7.2,1X,A)
   10       CONTINUE
            GO TO 999
         ENDIF
         CALL KUGETR(CUTGAM)
         CALL KUGETR(CUTELE)
         CALL KUGETR(CUTHAD)
         CALL KUGETR(CUTNEU)
         CALL KUGETR(CUTMUO)
         CALL KUGETR(BCUTE)
         CALL KUGETR(BCUTM)
         CALL KUGETR(DCUTE)
         CALL KUGETR(DCUTM)
         CALL KUGETR(PPCUTM)
         CALL KUGETR(TOFMAX)
         CALL KUGETR(GCUTS(1))
         IF(BCUTE.LE.0.)BCUTE=CUTGAM
         IF(BCUTM.LE.0.)BCUTM=CUTGAM
         IF(DCUTE.LE.0.)DCUTE=CUTELE
         IF(DCUTM.LE.0.)DCUTM=CUTELE
         IF(PPCUTM.LT.4.*EMASS)PPCUTM=4.*EMASS
*
      ELSEIF(CHPATL.EQ.'DRPRT')THEN
         CALL KUGETI(IPART)
         CALL KUGETI(IMATE)
         CALL KUGETR(STEPA)
         CALL KUGETI(NPOINT)
         CALL GDRPRT(IPART,IMATE,STEPA,NPOINT)
*
      ELSEIF(CHPATL.EQ.'PHYSI')THEN
         IF(JTMED.GT.0)THEN
            DO 30 I=1,IQ(JTMED-2)
               JTM=LQ(JTMED-I)
               IF(JTM.LE.0)GO TO 30
               IF(IQ(JTM-2).EQ.0)THEN
                  CALL MZPUSH(IXCONS,JTM,10,0,'I')
                  GO TO 30
               ENDIF
               DO 20 J=1,10
                  JTMI=LQ(JTM-J)
                  IF(JTMI.GT.0)THEN
                     CALL MZDROP(IXCONS,JTMI,' ')
                  ENDIF
   20          CONTINUE
   30       CONTINUE
            CALL UCOPY(CUTGAM,Q(JTMED+1),10)
            DO 40 I=1,13
               Q(JTMED+10+I)=MECA(1,I)
   40       CONTINUE
         ENDIF
         IF(JMATE.LE.0)GO TO 999
         DO 60 I=1,IQ(JMATE-2)
            JMA=LQ(JMATE-I)
            IF(JMA.LE.0)GO TO 60
            DO 50 J=1,IQ(JMA-2)
               IF(J.EQ.4.OR.J.EQ.5)GO TO 60
               JM=LQ(JMA-J)
               IF(JM.LE.0)GO TO 50
               CALL MZDROP(IXCONS,JM,'L')
   50       CONTINUE
   60    CONTINUE
         CALL MZGARB (IXCONS, 0)
         CALL GPHYSI
      ENDIF
*
      IF(ILABS.NE.0 .and. ITCKOV.NE.0) ILABS=1
*
  999 END
+DECK,GBRSGE.
*CMZ :  1.30/00 30/10/96  18.46.07  by  Pavel Nevski
*-- Author :    L.Urban
      FUNCTION GBRSGE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates cross-section in current material                  *
C.    *  for discrete(hard) electron BREMSSTRAHLUNG.                   *
C.    *         (SIG in barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRSGA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *                                                                *
C.    *  correction for T> 100 GeV !  (by L.Urban on 23/09/96)         *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCMATE
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
      SAVE C
+SELF,IF=-BETHE.
      PARAMETER (AKSI=1.80,ALFA=0.98,VS=0.0001)
      DATA C1/ 0.430748E-02, 0.576058E-02,-0.122564E-02, 0.114843E-03
     +      ,-0.489452E-05, 0.795991E-07, 0.326746E-02,-0.132872E-02
     +      , 0.217197E-03,-0.179769E-04, 0.766114E-06,-0.125603E-07
     +      , 0.326452E-02,-0.175331E-02, 0.415488E-03,-0.507652E-04
     +      , 0.297569E-05,-0.651741E-07, 0.847189E-03,-0.433923E-03
     +      , 0.116672E-03,-0.166799E-04, 0.110237E-05,-0.263383E-07
     +      , 0.846052E-04,-0.415764E-04, 0.129610E-04,-0.212844E-05
     +      , 0.152871E-06,-0.384393E-08, 0.300838E-05,-0.136833E-05
     +      , 0.507296E-06,-0.943623E-07, 0.720305E-08,-0.187210E-09
     +      , 0.448230E-01,-0.210048E-01, 0.379434E-02,-0.328431E-03
     +      , 0.136710E-04,-0.220593E-06,-0.539248E-02, 0.330244E-02
     +      ,-0.733726E-03, 0.732312E-04,-0.336810E-05, 0.583913E-07
     +      ,-0.106983E-02, 0.378021E-03,-0.384854E-04, 0.978156E-06
     +      , 0.410622E-07,-0.174250E-08,-0.117501E-04,-0.983887E-05
     +      , 0.239644E-05,-0.190104E-06, 0.619226E-08,-0.680932E-10/
      DATA C2/ 0.168074E-03,-0.934609E-04, 0.141293E-04,-0.854216E-06
     +      , 0.183287E-07, 0.932144E-04,-0.234926E-04, 0.136656E-05
     +      , 0.351109E-07,-0.330189E-08, 0.174523E-04, 0.253854E-05
     +      ,-0.171643E-05, 0.183074E-06,-0.566331E-08, 0.111970E-05
     +      , 0.112776E-05,-0.386924E-06, 0.367597E-07,-0.108504E-08
     +      , 0.171604E-07, 0.738801E-07,-0.218761E-07, 0.199032E-08
     +      ,-0.576173E-10,-0.105531E-03, 0.362995E-04,-0.433334E-05
     +      , 0.207664E-06,-0.330250E-08,-0.168293E-05,-0.773204E-06
     +      , 0.227974E-06,-0.159385E-07, 0.321958E-09, 0.167046E-05
     +      ,-0.440761E-06, 0.396377E-07,-0.151053E-08, 0.215624E-10/
+SELF,IF=BETHE.
      PARAMETER (AKSI=1.80,ALFA=1.00,VS=0.0001)
      DATA C1/ 0.111394E-01, 0.138592E-02,-0.274910E-03, 0.198389E-04
     +      ,-0.472291E-06,-0.668760E-09, 0.839876E-02,-0.449619E-02
     +      , 0.917722E-03,-0.874992E-04, 0.390015E-05,-0.653499E-07
     +      , 0.464718E-02,-0.260321E-02, 0.582582E-03,-0.631769E-04
     +      , 0.325801E-05,-0.638109E-07, 0.101243E-02,-0.532089E-03
     +      , 0.129100E-03,-0.161260E-04, 0.958116E-06,-0.212606E-07
     +      , 0.926006E-04,-0.455288E-04, 0.124755E-04,-0.182510E-05
     +      , 0.122078E-06,-0.294182E-08, 0.308111E-05,-0.134712E-05
     +      , 0.436230E-06,-0.751770E-07, 0.552327E-08,-0.140541E-09
     +      , 0.292552E-02,-0.830719E-03, 0.210705E-04, 0.103750E-04
     +      ,-0.953318E-06, 0.236453E-07, 0.110907E-02,-0.219463E-03
     +      , 0.128517E-04,-0.554575E-06, 0.507378E-07,-0.182214E-08
     +      ,-0.639866E-03, 0.209918E-03,-0.250183E-04, 0.138030E-05
     +      ,-0.358845E-07, 0.366305E-09, 0.300095E-04,-0.133668E-04
     +      , 0.198606E-05,-0.133100E-06, 0.414062E-08,-0.485929E-10/
      DATA C2/ 0.938677E-04,-0.613470E-04, 0.981984E-05,-0.646289E-06
     +      , 0.150731E-07, 0.331764E-04, 0.447248E-05,-0.313021E-05
     +      , 0.329777E-06,-0.997210E-08, 0.876484E-08, 0.110042E-04
     +      ,-0.313406E-05, 0.280040E-06,-0.794116E-08,-0.103097E-05
     +      , 0.220550E-05,-0.569158E-06, 0.491359E-07,-0.136987E-08
     +      ,-0.781963E-07, 0.123162E-06,-0.302825E-07, 0.255485E-08
     +      ,-0.702300E-10,-0.193213E-03, 0.640349E-04,-0.720586E-05
     +      , 0.329673E-06,-0.514682E-08, 0.362138E-04,-0.142783E-04
     +      , 0.184063E-05,-0.967983E-07, 0.179386E-08, 0.496130E-06
     +      , 0.210105E-06,-0.538512E-07, 0.372388E-08,-0.812734E-10/
+SELF.
C.
      DATA THIGH,CHIGH/100.,50./
C.    ------------------------------------------------------------------
C.
      GBRSGE=0.
*
      IF(BCUT.LE.0.) GOTO 99
      IF(BCUT.GE.T) GOTO 99
*
      IF(T.GT.THIGH) THEN
          TT=THIGH
        IF(BCUT.GE.THIGH) THEN
            EC=CHIGH
        ELSE
            EC=BCUT
        ENDIF
      ELSE
          TT=T
          EC=BCUT
      ENDIF
*
      E=TT+EMASS
*
C
      X=LOG(E/EMASS)
      Y=LOG(E*VS/EC)
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
            ENDIF
            XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
      FAC=ZZ*(ZZ+AKSI)*E*E*(LOG(TT/EC))**ALFA/(TT*(E+EMASS))
      IF(FAC.LE.0.) GOTO 99
C
      GBRSGE=FAC*S
*
      IF(T.GT.THIGH) THEN
 
       IF(BCUT.LT.THIGH) THEN
        RAT=BCUT/T
        S=(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
        RAT=BCUT/TT
        S=S/(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
       ELSE
        RAT=BCUT/T
        S=(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
        RAT=EC/TT
        S=S/(-LOG(RAT)-2./3.+RAT-RAT*RAT/3.)
       ENDIF
 
        GBRSGE=GBRSGE*S
      ENDIF
*
99    RETURN
*
      END
+DECK,GBRELE.
*CMZ :  1.30/00 30/10/96  18.44.39  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :      L.Urban
      FUNCTION GBRELE(ZZ,T,BCUT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Calculates energy loss by soft Bremsstrahlung                 *
C.    *         (in GeV barn/atom)                                     *
C.    *                                                                *
C.    *    ==>Called by : GBRELA                                       *
C.    *       Author  L.Urban  *********                               *
C.    *  corrected by L.Urban on 23/09/96                              *
C.    *    ( correction for T>100. GeV)                                *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCONSP
+SEQ,GCMATE
      DIMENSION C(100),C1(60),C2(40)
      EQUIVALENCE (C(1),C1(1)),(C(61),C2(1))
+SELF,IF=-BETHE.
      DATA C1/-0.960613E-01, 0.631029E-01,-0.142819E-01, 0.150437E-02
     +      ,-0.733286E-04, 0.131404E-05, 0.859343E-01,-0.529023E-01
     +      , 0.131899E-01,-0.159201E-02, 0.926958E-04,-0.208439E-05
     +      ,-0.684096E+01, 0.370364E+01,-0.786752E+00, 0.822670E-01
     +      ,-0.424710E-02, 0.867980E-04,-0.200856E+01, 0.129573E+01
     +      ,-0.306533E+00, 0.343682E-01,-0.185931E-02, 0.392432E-04
     +      , 0.127538E+01,-0.515705E+00, 0.820644E-01,-0.641997E-02
     +      , 0.245913E-03,-0.365789E-05, 0.115792E+00,-0.463143E-01
     +      , 0.725442E-02,-0.556266E-03, 0.208049E-04,-0.300895E-06
     +      ,-0.271082E-01, 0.173949E-01,-0.452531E-02, 0.569405E-03
     +      ,-0.344856E-04, 0.803964E-06, 0.419855E-02,-0.277188E-02
     +      , 0.737658E-03,-0.939463E-04, 0.569748E-05,-0.131737E-06
     +      ,-0.318752E-03, 0.215144E-03,-0.579787E-04, 0.737972E-05
     +      ,-0.441485E-06, 0.994726E-08, 0.938233E-05,-0.651642E-05
     +      , 0.177303E-05,-0.224680E-06, 0.132080E-07,-0.288593E-09/
      DATA C2/-0.245667E-03, 0.833406E-04,-0.129217E-04, 0.915099E-06
     +      ,-0.247179E-07, 0.147696E-03,-0.498793E-04, 0.402375E-05
     +      , 0.989281E-07,-0.133378E-07,-0.737702E-02, 0.333057E-02
     +      ,-0.553141E-03, 0.402464E-04,-0.107977E-05,-0.641533E-02
     +      , 0.290113E-02,-0.477641E-03, 0.342008E-04,-0.900582E-06
     +      , 0.574303E-05, 0.908521E-04,-0.256900E-04, 0.239921E-05
     +      ,-0.741271E-07,-0.341260E-04, 0.971711E-05,-0.172031E-06
     +      ,-0.119455E-06, 0.704166E-08, 0.341740E-05,-0.775867E-06
     +      ,-0.653231E-07, 0.225605E-07,-0.114860E-08,-0.119391E-06
     +      , 0.194885E-07, 0.588959E-08,-0.127589E-08, 0.608247E-10/
      DATA AKSI,BETA,VE/2.51,0.99,0.00004/
+SELF,IF=BETHE.
      DATA C1/ 0.834459E-02, 0.443979E-02,-0.101420E-02, 0.963240E-04
     +      ,-0.409769E-05, 0.642589E-07, 0.464473E-02,-0.290378E-02
     +      , 0.547457E-03,-0.426949E-04, 0.137760E-05,-0.131050E-07
     +      ,-0.547866E-02, 0.156218E-02,-0.167352E-03, 0.101026E-04
     +      ,-0.427518E-06, 0.949555E-08,-0.406862E-02, 0.208317E-02
     +      ,-0.374766E-03, 0.317610E-04,-0.130533E-05, 0.211051E-07
     +      , 0.158941E-02,-0.385362E-03, 0.315564E-04,-0.734968E-06
     +      ,-0.230387E-07, 0.971174E-09, 0.467219E-03,-0.154047E-03
     +      , 0.202400E-04,-0.132438E-05, 0.431474E-07,-0.559750E-09
     +      ,-0.220958E-02, 0.100698E-02,-0.596464E-04,-0.124653E-04
     +      , 0.142999E-05,-0.394378E-07, 0.477447E-03,-0.184952E-03
     +      ,-0.152614E-04, 0.848418E-05,-0.736136E-06, 0.190192E-07
     +      ,-0.552930E-04, 0.209858E-04, 0.290001E-05,-0.133254E-05
     +      , 0.116971E-06,-0.309716E-08, 0.212117E-05,-0.103884E-05
     +      ,-0.110912E-06, 0.655143E-07,-0.613013E-08, 0.169207E-09/
      DATA C2/ 0.301125E-04,-0.461920E-04, 0.871485E-05,-0.622331E-06
     +      , 0.151800E-07,-0.478023E-04, 0.247530E-04,-0.381763E-05
     +      , 0.232819E-06,-0.494487E-08,-0.336230E-04, 0.223822E-04
     +      ,-0.384583E-05, 0.252867E-06,-0.572599E-08, 0.105335E-04
     +      ,-0.567074E-06,-0.216564E-06, 0.237268E-07,-0.658131E-09
     +      , 0.282025E-05,-0.671965E-06, 0.565858E-07,-0.193843E-08
     +      , 0.211839E-10, 0.157544E-04,-0.304104E-05,-0.624410E-06
     +      , 0.120124E-06,-0.457445E-08,-0.188222E-05,-0.407118E-06
     +      , 0.375106E-06,-0.466881E-07, 0.158312E-08, 0.945037E-07
     +      , 0.564718E-07,-0.319231E-07, 0.371926E-08,-0.123111E-09/
      DATA AKSI,BETA,VE/2.10,1.00,0.001/
+SELF.
      DATA CORFAC/0.805485E-10/
C.
      DATA THIGH,CHIGH/100.,50./
C.    ------------------------------------------------------------------
C.
      GBRELE=0.
 
      IF(BCUT.LE.0.) GOTO 99
************************************
      CUTSAV=BCUT
      IF(BCUT.GT.T) BCUT=T
*************************************
      IF(T.GT.THIGH) THEN
          TT=THIGH
        IF(BCUT.GE.THIGH) THEN
            EC=CHIGH
        ELSE
            EC=BCUT
        ENDIF
      ELSE
          TT=T
          EC=BCUT
      ENDIF
 
      E=TT+EMASS
      IF(BCUT.GT.TT) EC=TT
C
      X=LOG(TT/EMASS)
      Y=LOG(EC/(E*VE))
C
      S=0.
      YY=1.
      DO 30 I=1,2
         XX=1.
         DO 20 J=1,6
            K=6*I+J-6
            S=S+C(K)*XX*YY
            XX=XX*X
  20     CONTINUE
         YY=YY*Y
  30  CONTINUE
      DO 50 I=3,6
         XX=1.
         DO 40 J=1,6
            K=6*I+J-6
            IF(Y.LE.0.) THEN
               S=S+C(K)*XX*YY
            ELSE
               S=S+C(K+24)*XX*YY
            ENDIF
            XX=XX*X
  40     CONTINUE
         YY=YY*Y
  50  CONTINUE
      SS=0.
      YY=1.
      DO 70 I=1,2
         XX=1.
         DO 60 J=1,5
            K=5*I+J+55
            SS=SS+C(K)*XX*YY
            XX=XX*X
  60     CONTINUE
         YY=YY*Y
  70  CONTINUE
      DO 90 I=3,5
         XX=1.
         DO 80 J=1,5
            K=5*I+J+55
            IF(Y.LE.0.) THEN
               SS=SS+C(K)*XX*YY
            ELSE
               SS=SS+C(K+15)*XX*YY
             ENDIF
             XX=XX*X
  80     CONTINUE
         YY=YY*Y
  90  CONTINUE
C
      S=S+Z*SS
      IF(S.LE.0.) GOTO 99
C
+SELF,IF=-BETHE.
      CORR=1./(1.+CORFAC*DENS*Z*E*E/(A*EC*EC))
+SELF,IF=BETHE.
      CORR=1.
+SELF.
      FAC=ZZ*(ZZ+AKSI)*E*E*(EC*CORR/TT)**BETA/(E+EMASS)
      IF(FAC.LE.0.) GOTO 99
C
      GBRELE=FAC*S
 
      IF(T.GT.THIGH) THEN
 
       IF(BCUT.LT.THIGH) THEN
        RAT=BCUT/T
        S=(1.-0.5*RAT+2.*RAT*RAT/9.)
        RAT=BCUT/TT
        S=S/(1.-0.5*RAT+2.*RAT*RAT/9.)
       ELSE
        RAT=BCUT/T
        S=BCUT*(1.-0.5*RAT+2.*RAT*RAT/9.)
        RAT=EC/TT
        S=S/(EC*(1.-0.5*RAT+2.*RAT*RAT/9.))
       ENDIF
 
        GBRELE=GBRELE*S
      ENDIF
******************************************
      BCUT=CUTSAV
******************************************
C
  99  RETURN
      END
 
 
+DECK,GPAIRG.
*CMZ :  1.30/00 19/09/96  18.01.50  by  Pavel Nevski
*CMZ :  3.21/04 21/02/95  11.53.59  by  S.Giani
*-- Author :
      SUBROUTINE GPAIRG
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Simulates e+e- pair production by photons.                    *
C.    *                                                                *
C.    *  The secondary electron energies are sampled using the         *
C.    *  Coulomb corrected BETHE-HEITLER cross-sections.For this the   *
C.    *   modified version of the random number techniques of          *
C.    *   BUTCHER and MESSEL (NUCL.PHYS,20(1960),15) are employed.     *
C.    *                                                                *
C.    *  NOTE :                                                        *
C.    *  (1) Effects due to the breakdown of the BORN approximation at *
C.    *      low energies are ignored.                                 *
C.    *  (2) The differential cross-section implicitly takes account   *
C.    *      of pair production in both nuclear and atomic electron    *
C.    *      fields. However, triplet production is not generated.     *
C.    *                                                                *
C.    *    ==>Called by : GTGAMA                                       *
C.    *       Authors    G.Patrick, L.Urban  *********                 *
C.    *                                                                *
C.    *  Correction: S.Randval:  PEL1 = SQRT((EEL1+EMASS)*TEL1)        *
C.    ******************************************************************
C.
+CDE,GCBANK
+CDE,GCJLOC
+CDE,GCONSP
+CDE,GCTRAK
+CDE,GCKING
+CDE,GCPHYS
+CDE,GCCUTS
      DIMENSION NTYPEL(2)
      DIMENSION RNDM(2)
      LOGICAL ROTATE
      PARAMETER (ONE=1,ONETHR=ONE/3,EMAS2=2*EMASS)
C.
C.    ------------------------------------------------------------------
C.
C             If not enough energy : no pair production
C
      EGAM   = VECT(7)
      IF (EGAM.LT.EMAS2) GO TO 999
C
      KCASE  = NAMEC(6)
      IF(IPAIR.NE.1) THEN
         ISTOP  = 2
         NGKINE = 0
         DESTEP = DESTEP + EGAM
         VECT(7)= 0.
         GEKIN  = 0.
         GETOT  = 0.
         GO TO 999
      ENDIF
C
C             For low energy photons approximate the electron energy by
C             sampling from a uniform distribution in the interval
C             EMASS -> EGAM/2.
C
      IF (EGAM.LE.2.1E - 03)THEN
         CALL GRNDM(RNDM,1)
         EEL1   = EMASS + (RNDM(1)*(0.5*EGAM - EMASS))
         X=EEL1/EGAM
         GO TO 20
      ENDIF
C
      Z3=Q(JPROB+2)
      F=8.*Q(JPROB+3)
      IF(EGAM.GT.0.05) F=F+8.*Q(JPROB+4)
      X0=EMASS/EGAM
      DX=0.5-X0
      DMIN=544.*X0/Z3
      DMIN2=DMIN*DMIN
      IF(DMIN.LE.1.)THEN
         F10=42.392-7.796*DMIN+1.961*DMIN2-F
         F20=41.405-5.828*DMIN+0.8945*DMIN2-F
      ELSE
         F10=42.24-8.368*LOG(DMIN+0.952)-F
         F20=F10
      ENDIF
C
C             Calculate limit for screening variable,DELTA, to ensure
C             that screening rejection functions always remain
C             positive.
C
      DMAX=EXP((42.24-F)/8.368)-0.952
C
C             Differential cross-section factors which form
C             the coefficients of the screening functions.
C
      DSIG1=DX*DX*F10/3.
      DSIG2=0.5*F20
      BPAR   = DSIG1 / (DSIG1 + DSIG2)
C
C             Decide which screening rejection function to use and
C             sample the electron/photon fractional energy BR.
C
   10 CALL GRNDM(RNDM,2)
      IF(RNDM(1).LT.BPAR)THEN
         X=0.5-DX*RNDM(2)**ONETHR
         IREJ=1
      ELSE
         X=X0+DX*RNDM(2)
         IREJ   = 2
      ENDIF
C
C             Calculate DELTA ensuring positivity.
C
      D=0.25*DMIN/(X*(1.-X))
      IF(D.GE.DMAX) GOTO 10
      D2=D*D
C
C             Calculate F1 and F2 functions using approximations.
C             F10 and F20 are the F1 and F2 functions calculated for the
C             DELTA=DELTA minimum.
C
      IF(D.LE.1.)THEN
         F1=42.392-7.796*D+1.961*D2-F
         F2=41.405-5.828*D+0.8945*D2-F
      ELSE
         F1=42.24-8.368*LOG(D+0.952)-F
         F2=F1
      ENDIF
      IF(IREJ.NE.2)THEN
         SCREJ=F1/F10
      ELSE
         SCREJ=F2/F20
      ENDIF
C
C             Accept or reject on basis of random variate.
C
      CALL GRNDM(RNDM,1)
      IF(RNDM(1).GT.SCREJ) GOTO 10
      EEL1=X*EGAM
C
C             Successful sampling of first electron energy.
C
C             Select charges randomly.
C
   20 NTYPEL(1) = 2
      CALL GRNDM(RNDM,2)
      IF (RNDM(1).GT.0.5) NTYPEL(1) = 3
      NTYPEL(2) = 5 - NTYPEL(1)
C
C             Generate electron decay angles with respect to a Z-axis
C             defined along the parent photon.
C             PHI is generated isotropically and THETA is assigned
C             a universal angular distribution
C
      EMASS1 = EMASS
      THETA  = GBTETH(EEL1, EMASS1, X)*EMASS/EEL1
      SINTH  = SIN(THETA)
      COSTH  = COS(THETA)
      PHI    = TWOPI*RNDM(2)
      COSPHI = COS(PHI)
      SINPHI = SIN(PHI)
C
C             Rotate tracks into GEANT system
C
      CALL GFANG(VECT(4),COSAL,SINAL,COSBT,SINBT,ROTATE)
C
C            Polar co-ordinates to momentum components.
C
      NGKINE = 0
      TEL1 = EEL1 - EMASS
      PEL1 = SQRT((EEL1+EMASS)*TEL1)
      IF(TEL1.GT.CUTELE) THEN
         PEL1 = SQRT((EEL1+EMASS)*TEL1)
         NGKINE = NGKINE + 1
         GKIN(1,NGKINE) = PEL1 * SINTH * COSPHI
         GKIN(2,NGKINE) = PEL1 * SINTH * SINPHI
         GKIN(3,NGKINE) = PEL1 * COSTH
         GKIN(4,NGKINE) = EEL1
         GKIN(5,NGKINE) = NTYPEL(1)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL1
         IF(NTYPEL(1).EQ.2) CALL GANNI2
      ENDIF
C
C             Momentum vector of second electron. Recoil momentum of
C             target nucleus/electron ignored.
C
      EEL2=EGAM-EEL1
      TEL2=EEL2-EMASS
      IF(TEL2.GT.CUTELE) THEN
         PEL2 = SQRT((EEL2+EMASS)*TEL2)
         NGKINE = NGKINE + 1
         SINTH=SINTH*PEL1/PEL2
         COSTH=SQRT(MAX(0.,1.-SINTH**2))
         GKIN(1,NGKINE)=-PEL2*SINTH*COSPHI
         GKIN(2,NGKINE)=-PEL2*SINTH*SINPHI
         GKIN(3,NGKINE)=PEL2*COSTH
         GKIN(4,NGKINE)=EEL2
         GKIN(5,NGKINE) = NTYPEL(2)
         TOFD(NGKINE)=0.
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(ROTATE)
     +   CALL GDROT(GKIN(1,NGKINE),COSAL,SINAL,COSBT,SINBT)
      ELSE
         DESTEP = DESTEP + TEL2
         IF(NTYPEL(2).EQ.2) CALL GANNI2
      ENDIF
      ISTOP = 1
      IF(NGKINE.EQ.0) ISTOP = 2
 999  END
 
 
+DECK,GTNEXT.
*CMZ :  1.30/00 16/09/96  23.24.54  by  Pavel Nevski
*-- Author :    Pavel Nevski
      SUBROUTINE GTNEXT
+CDE,GCFLAG,GCVOLU.
      INTEGER IFL/-1/
*                                   message
      IF (ISWIT(10).NE.IFL) then
         IFL=ISWIT(10)
         IF (IFL.EQ.0) PRINT *,' *** GTNEXT: 3.21 tracking logic *** '
         IF (IFL.EQ.1) PRINT *,' *** GTNEXT: soft tracking logic *** '
         IF (IFL.EQ.2) PRINT *,' *** GTNEXT: 3.15 tracking logic *** '
      endif
*                                    logic
      If (IFL.EQ.1 .and. GONLY(NLEVEL).EQ.0 .OR. IFL.GE.2) Then
         CALL GTNEX2      !  3.15
      else
         CALL GTNEX1      !  3.21
      endif
*
      END
+DECK,gtnex1.
*CMZ :  1.30/00 09/09/96  22.04.42  by  Pavel Nevski
*CMZ :  3.21/04 21/03/95  16.13.08  by  S.Giani
*-- Author :
      SUBROUTINE GTNEX1
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *                                                                *
C.    *   Author   : S.Giani (1993)                                    *
C.    *                                                                *
C.    *   This routine is now based on the new 'virtual divisions'     *
C.    *    algorithm to speed up the tracking.                         *
C.    *   The tracking for MANY volumes is not anymore based on a step *
C.    *    search: it is now based on a search through the list of     *
C.    *    'possible overlapping volumes' built by GTMEDI.             *
C.    *    Boolean operations and divisions along arbitrary axis are   *
C.    *     now supported.                                             *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+SEQ, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SEQ,GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
+SEQ, GCVDMA.
      DIMENSION NUMTMP(15),NAMTMP(15)
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      CHARACTER*4 NAME
      dimension iarrin(500),cxm(3),xxm(6)
      REAL      X0(6), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      mycoun=0
      myinfr=0
      newfl=0
      manyfl=0
      tsafet=big
      tsnext=big
401   IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      if(raytra.eq.1..and.imyse.eq.1)then
            CALL UHTOC(NAMES(NLEVEL),4,NAME,4)
            CALL GFIND(NAME,'SEEN',ISSEEN)
            if(isseen.eq.-2.or.isseen.eq.-1)goto 300
      endif
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      sneold=SNEXT
      nnn=0
      nflag=0
      mmm=0
      snxtot=0.
 111  if(nin.gt.1)then
        if(nnn.gt.0)goto 112
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.eq.4)then
         do 1 i=1,6
          xxm(i)=xc(i)
 1       continue
        endif
        divthi=(chmoth-clmoth)/ndivto
        if(iaxis.le.3)then
          cx=xc(iaxis)
          if(xc(iaxis+3).ge.0.)then
            inc=1
          else
            inc=-1
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.4)then
            dr= xc(1)*xc(4)+xc(2)*xc(5)
*            if(dr.eq.0.)print *,'dr.eq.0.'
            if(dr.ge.0.)then
              inc=1
            else
              inc=-1
            endif
          elseif(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
            dfi=xc(1)*xc(5)-xc(2)*xc(4)
            if(dfi.ge.0)then
              inc=1
            else
              inc=-1
            endif
          endif
          xvdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xvdiv
          if((xvdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
            ivdiv=1
          elseif(ivdiv.gt.ndivto)then
            ivdiv=ndivto
          endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
 112    iofset=iq(jvdiv+ivdiv)
        jcont2=jvdiv+iofset+1
        ncont=iq(jcont2)
        if(ncont.eq.0)then
          idmi=iq(jcont2+1)
          idma=iq(jcont2+2)
          llflag=0
        elseif(ncont.eq.1)then
          idmi=iq(jcont2+2)
          idma=iq(jcont2+3)
          in=iq(jcont2+1)
        else
          idmi=iq(jcont2+ncont+1)
          idma=iq(jcont2+ncont+2)
          iii=1
          in=iq(jcont2+iii)
        endif
        if(nnn.eq.0)then
         cxold=cx
         if(inc.gt.0)then
          cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
          if(iaxis.ne.6)then
           safety=min(safety,(cxold-cmin))
          else
           safefi=min(90.,(cxold-cmin))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         else
          cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
          if(iaxis.ne.6)then
           safety=min(safety,(cmax-cxold))
          else
           safefi=min(90.,(cmax-cxold))
           saferr=sqrt(xc(1)**2+xc(2)**2)
           safe22=saferr*sin(safefi)
           safety=min(safety,safe22)
          endif
         endif
        endif
        if(ncont.eq.0)goto 181
      elseif(nin.eq.1)then
        in=1
      endif
*
  150 if(nin.gt.1.and.ncont.gt.1)then
        in=iq(jcont2+iii)
      endif
      if(nin.gt.0)then
*        if(infrom.gt.0.and.myinfr.eq.0.and.newfl.eq.0)then
*          if(in.eq.infrom)goto 171
*        endif
        jin=lq(jvo-in)
        if(.NOT.BTEST(iq(jin),4))then
        else
          goto 171
        endif
      endif
      if(nin.gt.1)then
        llflag=0
        if(mmm.le.500)then
         do 151 ll=1,mmm
          if(iarrin(ll).eq.in)then
            llflag=1
            goto 171
          endif
 151     continue
        endif
        if(llflag.eq.0)then
          mmm=mmm+1
          if(mmm.le.500)then
            iarrin(mmm)=in
          endif
        endif
      endif
      IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 179
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
 179  if((nin.eq.1).or.(nin.gt.1.and.llflag.eq.0))then
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
      ENDIF
      endif
 171  if(nin.eq.1)then
        goto 300
      elseif(nin.ge.1.and.ncont.gt.1)then
           iii=iii+1
           if(iii.le.ncont)goto 150
      endif
*
*   *         Compute distance to boundary of current volume
*
 181  if(nnn.eq.0)then
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               safe=max(safe,0.)
               if(snxt.le.-prec)snxt=big1
               snxt=max(snxt,0.)
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
      endif
      if(iaxis.eq.4)then
       if(idma.eq.ndivto.and.inc.gt.0)goto 400
        cxm(1)=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
        if(idmi.eq.idma)then
          cxm(2)=cxm(1)+divthi
        else
          cxm(2)=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
        endif
        cxm(3)=20000.
        call gntube(xxm,cxm,3,1,SNEXT,snxnew,safe)
        if(snxnew.lt.0.)snxnew=big1
        snxnew=snxnew+.004
        snxtot=snxtot+snxnew
        if(snxtot.lt.SNEXT)then
          xxm(1)=xxm(1)+snxnew*xxm(4)
          xxm(2)=xxm(2)+snxnew*xxm(5)
          xxm(3)=xxm(3)+snxnew*xxm(6)
          call gfcoor(xxm,iaxis,cxnew)
          xevdiv=((cxnew-clmoth)*ndivto/(chmoth-clmoth))+1
          ivdiv=xevdiv
          dr= xxm(1)*xxm(4)+xxm(2)*xxm(5)
*          if(dr.eq.0.)print *,'dr.eq.0.'
          if(dr.ge.0.)then
              inc=1
          else
              inc=-1
          endif
          if((xevdiv-ivdiv).lt.0.0001.and.inc.eq.-1)ivdiv=ivdiv-1
          if(ivdiv.lt.1)then
              ivdiv=1
          elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
          endif
          nnn=nnn+1
          goto 111
        else
          if(inc.gt.0)then
           cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
           safety=min(safety,(cmax-cxold))
          else
           cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
           safety=min(safety,(cxold-cmin))
          endif
          goto 400
        endif
      endif
          if(nnn.ne.0.and.SNEXT.eq.sneold)goto 199
               x0(1) = xc(1) + SNEXT*xc(4)
               x0(2) = xc(2) + SNEXT*xc(5)
               x0(3) = xc(3) + SNEXT*xc(6)
               x0(4) = xc(4)
               x0(5) = xc(5)
               x0(6) = xc(6)
          if(iaxis.le.3)then
            cx=x0(iaxis)
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          else
            call gfcoor(x0,iaxis,cx)
            if(iaxis.eq.6)then
             if((cx-clmoth).lt.-1.)then
              cx=cx+360.
             elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
             endif
             if(cx.gt.chmoth)then
              cx=chmoth
             elseif(cx.lt.clmoth)then
              cx=clmoth
             endif
            endif
            xevdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            ievdiv=xevdiv
            if((xevdiv-ievdiv).lt.0.0001.and.inc.eq.-1)ievdiv=ievdiv-1
            if(ievdiv.lt.1)then
              ievdiv=1
            elseif(ievdiv.gt.ndivto)then
              ievdiv=ndivto
            endif
          endif
 199      if(ievdiv.ge.idmi.and.ievdiv.le.idma)then
            if(inc.gt.0)then
             cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
             if(iaxis.ne.6)then
              safety=min(safety,(cmax-cxold))
             else
              safefi=min(90.,(cmax-cxold))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            else
             cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
             if(iaxis.ne.6)then
              safety=min(safety,(cxold-cmin))
             else
              safefi=min(90.,(cxold-cmin))
              safe22=saferr*sin(safefi)
              safety=min(safety,safe22)
             endif
            endif
            goto 400
          endif
          if(iaxis.eq.6.or.iaxis.le.3)then
           if(ievdiv.lt.idmi.and.inc.gt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idmi=',idmi,' inc.gt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safety=min(safety,abs(cmax-cxold))
             elseif(iaxis.eq.6)then
               cmax=(clmoth+(idma-1)*(chmoth-clmoth)/ndivto)+divthi
               safefi=min(90.,(cmax-cxold))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           elseif(ievdiv.gt.idma.and.inc.lt.0)then
            if(nnn.eq.0.and.iaxis.eq.6
     +      .and.(chmoth-clmoth).eq.360.)nflag=1
            if(nflag.eq.0)then
*             print *,'ievdiv=',ievdiv,' ;idma=',idma,' inc.lt.0'
*             print *,isht,'=isht; ',iaxis,'=iaxis; ',ish,'=ish;'
             if(iaxis.le.3)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safety=min(safety,abs(cxold-cmin))
             elseif(iaxis.eq.6)then
               cmin=clmoth+(idmi-1)*(chmoth-clmoth)/ndivto
               safefi=min(90.,(cxold-cmin))
               safe22=saferr*sin(safefi)
               safety=min(safety,safe22)
             endif
             goto 400
            endif
           endif
          endif
          nnn=nnn+1
          sneold=SNEXT
          if(inc.gt.0)then
            if(iaxis.eq.6)then
             if(idma.eq.ndivto.and.(chmoth-clmoth).eq.360.)then
               ivdiv=1
             else
               ivdiv=idma+1
             endif
            else
             ivdiv=idma+1
            endif
          else
            if(iaxis.eq.6)then
             if(idmi.eq.1.and.(chmoth-clmoth).eq.360.)then
               ivdiv=ndivto
             else
               ivdiv=idmi-1
             endif
            else
             ivdiv=idmi-1
            endif
          endif
          goto 111
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         if(raytra.eq.1.)ingoto=-1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      if(nin.eq.1.and.ignext.ne.0)then
        if(q(jin+8).eq.0.)iact=1
      endif
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      safe=max(safe,0.)
      if(snxt.le.-prec)snxt=big1
      snxt=max(snxt,0.)
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
 400  if(iswit(9).eq.123456789.and.Q(JVO+3).gt.1.)then
        print *,'n. of checked objects = ',mmm
      endif
      if(myinfr.gt.0)then
        jin=lq(jvo-myinfr)
        iq(jin)=ibclr(iq(jin),4)
        myinfr=0
      endif
      if(gonly(nlevel).eq.0..or.nvmany.ne.0) THEN
         if(safety.lt.tsafet)tsafet=safety
         if(snext.lt.tsnext)then
          mycoun=mycoun+1
          tsnext=snext
          tignex=ignext
          tingot=ingoto
          call gscvol
          if(ingoto.gt.0)then
            iq(jgpar2+nlevel+1)=iq(jgpar+nlevel+1)
            lq(jgpar2-nlevel-1)=lq(jgpar-nlevel-1)
          endif
         endif
         if(gonly(nlevel).eq.0.)then
 404       continue
           if(gonly(nlevel-1).eq.0..or.newfl.eq.0)then
             if(gonly(nlevel-1).ne.0.)newfl=1
             nlevel=nlevel-1
             jvo=lq(jvolum-lvolum(nlevel))
             nin=q(jvo+3)
             if(nin.lt.0)goto 404
             myinfr=lindex(nlevel+1)
             jin=lq(jvo-myinfr)
             iq(jin)=ibset(iq(jin),4)
             ignext=0
             goto 401
           endif
         endif
 403   continue
       if(manyfl.lt.nvmany)then
         manyfl=manyfl+1
         if(manyfl.eq.nfmany)goto 403
         levtmp=manyle(manyfl)
         do 402 i=1,levtmp
          namtmp(i)=manyna(manyfl,i)
          numtmp(i)=manynu(manyfl,i)
 402     continue
         call glvolu(levtmp,namtmp,numtmp,ier)
         if(ier.ne.0)print *,'Fatal error in GLVOLU'
         ignext=0
         goto 401
       endif
       if(tsafet.le.safety)safety=tsafet
       if(tsnext.le.snext)then
         snext=tsnext
         ignext=tignex
         ingoto=tingot
         call gfcvol
         nlevin=nlevel
         if(ingoto.gt.0)then
          iq(jgpar+nlevel+1)=iq(jgpar2+nlevel+1)
          lq(jgpar-nlevel-1)=lq(jgpar2-nlevel-1)
         endif
       endif
      endif
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNXT.EQ.BIG1) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
 
+DECK,GTNEX2.
*CMZ :  1.30/00 18/09/96  20.43.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GTNEX2
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   SUBR. GTNEXT                                                 *
C.    *                                                                *
C.    *   Computes SAFETY and, only when new SAFETY is smaller than    *
C.    *    STEP, computes SNEXT.                                       *
C.    *   STEP has to be preset to BIG or to physical step size        *
C.    *                                                                *
C.    *   Called by : GTELEC, GTGAMA, GTHADR, GTMUON, GTNEUT, GTNINO   *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCFLAG.
+SEQ, GCONSP.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
+CDE, GCSHNO.
+SEQ,GCJUMP, IF=USRJMP
C.
      PARAMETER (BIG1=0.9*BIG)
C.
      REAL      X0(3), XC(6), XT(6)
      INTEGER   IDTYP(3,12)
      LOGICAL   BTEST
C.
      DATA  IDTYP / 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 1,
     +              2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 4, 3, 1, 1, 1,
     +              2, 3, 1, 2, 3, 1/
C.
C.    ------------------------------------------------------------------
*
* * *** Transform current point and direction into local reference system
*
      IF (GRMAT(10,NLEVEL).EQ.0.) THEN
         XC(1) = VECT(1) - GTRAN(1,NLEVEL)
         XC(2) = VECT(2) - GTRAN(2,NLEVEL)
         XC(3) = VECT(3) - GTRAN(3,NLEVEL)
         XC(4) = VECT(4)
         XC(5) = VECT(5)
         XC(6) = VECT(6)
      ELSE
C*****  Code Expanded From Routine:  GTRNSF
C
*
         XL1 = VECT(1) - GTRAN(1,NLEVEL)
         XL2 = VECT(2) - GTRAN(2,NLEVEL)
         XL3 = VECT(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     1      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     1      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     1      GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GTRNSF
C*****  Code Expanded From Routine:  GROT
C
         XC(4) = VECT(4)*GRMAT(1,NLEVEL) + VECT(5)*GRMAT(2,NLEVEL) +
     1      VECT(6)*GRMAT(3,NLEVEL)
         XC(5) = VECT(4)*GRMAT(4,NLEVEL) + VECT(5)*GRMAT(5,NLEVEL) +
     1      VECT(6)*GRMAT(6,NLEVEL)
         XC(6) = VECT(4)*GRMAT(7,NLEVEL) + VECT(5)*GRMAT(8,NLEVEL) +
     1      VECT(6)*GRMAT(9,NLEVEL)
*
C*****  End of Code Expanded From Routine:  GROT
      ENDIF
*
* *** Compute distance to boundaries
*
      SNEXT  = STEP
      SAFETY = BIG
      INGOTO = 0
      JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
      ISH    = Q(JVO+2)
      IF (Q(JVO+3).EQ.0.) GO TO 300
      NIN = Q(JVO+3)
      IF (NIN.LT.0) GO TO 200
*
* *** Case with contents positioned
*
      ISEARC = Q(JVO+1)
      IF (ISEARC.GE.-1) GO TO 120
*
*  ** Contents are ordered by (dynamic) GSORD, select neighbours
*
      JSB = LQ(LQ(JVO-NIN-1))
      IAX = Q(JSB+1)
      NSB = Q(JSB+2)
      IF (IAX.LE.3) THEN
         CX  = XC(IAX)
         INC = SIGN(1., XC(IAX+3))
      ELSE
         CALL GFCOOR (XC, IAX, CX)
         IF (IAX.LE.5) THEN
            DR = XC(1)*XC(4) +XC(2)*XC(5)
            IF (IAX.EQ.5) DR = DR +XC(3)*XC(6)
            INC = SIGN(1., DR)
         ELSE IF (IAX.EQ.6) THEN
            INC = SIGN(1., XC(1)*XC(5)-XC(2)*XC(4))
         ELSE
            INC = SIGN(1., XC(3)*(XC(1)*XC(4)+XC(2)*XC(5))
     +                    -XC(6)*(XC(1)*XC(1)+XC(2)*XC(2)))
         ENDIF
      ENDIF
      IDIV = LOCATF (Q(JSB+3), NSB, CX)
      IF (IDIV.LT.0) IDIV = -IDIV
      IF (IAX.NE.6) THEN
         IF (IDIV.EQ.0) THEN
            IF (INC.LT.0.AND.IAX.LE.3) THEN
               SAFETY = Q(JSB+3) -CX
               GO TO 300
            ENDIF
            IDIV = 1
         ELSE IF (IDIV.EQ.NSB) THEN
            IF (INC.GT.0.AND.IAX.NE.7) THEN
               SAFETY = CX -Q(JSB+2+NSB)
               GO TO 300
            ENDIF
            IDIV = NSB -1
         ELSE
            IF (IAX.NE.7) THEN
               IF (INC.GT.0) THEN
                  SAFETY = CX -Q(JSB+2+IDIV)
               ELSE
                  SAFETY = Q(JSB+3+IDIV) -CX
               ENDIF
            ELSE
               SAFETY = 0.
            ENDIF
         ENDIF
      ELSE IF (IAX.EQ.6) THEN
         IF (IDIV.EQ.0) IDIV = NSB
         SAFETY = 0.
      ENDIF
*
      IDIVL = 0
      IDIVB = 0
      JSC0  = LQ(JVO-NIN-2)
  110 NCONT = IQ(JSC0+IDIV)
*
*  ** Loop over (selected) contents
*
      IF (NCONT.EQ.0) THEN
         IF (IDIV.EQ.IDIVL) GO TO 400
         IDIV = IDIV +INC
         IF (IAX.NE.6) GOTO 110
*      (following statement for IAX=6, when division NSB is empty)
         IF (IDIV.GT.NSB) IDIV = 1
         IF (IDIV.EQ.0) IDIV = NSB
         GO TO 110
      ELSE
         ICONT = 1
         JSCV = LQ(JSC0-IDIV)
         GO TO 140
      ENDIF
*
  120 JNEAR = LQ(JVO-NIN-1)
      IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
         CALL GUNEAR (ISEARC, 2, XC, JNEAR)
+SELF, IF=USRJMP
         CALL JUMPT4(JUNEAR, ISEARC, 2, XC, JNEAR)
+SELF
         IF (IQ(JNEAR+1).EQ.0) GO TO 300
      ELSE
         IF (INFROM.GT.0) THEN
            JIN = LQ(JVO-INFROM)
            IF (LQ(JIN-1).NE.0) THEN
               JNE = LQ(JIN-1)
               IF (IQ(JNE+1).GT.1.OR.IQ(JNE+2).NE.0) JNEAR = JNE
            ENDIF
         ENDIF
      ENDIF
      JNEAR = JNEAR +1
      NNEAR = IQ(JNEAR)
      IF (IQ(JNEAR+1).NE.0) THEN
         INEAR = 1
      ELSE
         INEAR = 2
      ENDIF
*
  130 IN = IQ(JNEAR+INEAR)
      GO TO 150
*
  140 IN = IQ(JSCV+ICONT)
*
  150 IF (IN.LT.0)  GO TO 300
      JIN   = LQ(JVO-IN)
      IVOT  = Q(JIN+2)
      JVOT  = LQ(JVOLUM-IVOT)
      IROTT = Q(JIN+4)
*
      IF (BTEST(IQ(JVOT),1)) THEN
*       (case with JVOLUM structure locally developed)
         JPAR = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         DO 169 ILEV = NLDEV(NLEVEL), NLEVEL
            IF (IQ(JPAR+1).EQ.0) THEN
               IF (ILEV.EQ.NLEVEL) THEN
                  JPAR = LQ(JPAR-IN)
               ELSE
                  JPAR = LQ(JPAR-LINDEX(ILEV+1))
               ENDIF
               IF (JPAR.EQ.0) GO TO 170
            ELSE IF (IQ(JPAR-3).GT.1) THEN
               JPAR = LQ(JPAR-LINDEX(ILEV+1))
            ELSE
               JPAR = LQ(JPAR-1)
            ENDIF
  169    CONTINUE
         JPAR = JPAR + 5
         NPAR = IQ(JPAR)
         GO TO 180
      ENDIF
*     (normal case)
  170 NPAR = Q(JVOT+5)
      IF (NPAR.EQ.0) THEN
         JPAR = JIN +9
         NPAR = Q(JPAR)
      ELSE
         JPAR = JVOT +6
      ENDIF
*
*   * Compute distance to boundary of current content
*
C*****  Code Expanded From Routine:  GITRAN
  180 IF (IROTT .EQ. 0) THEN
         XT(1) = XC(1) - Q(5+JIN)
         XT(2) = XC(2) - Q(6+JIN)
         XT(3) = XC(3) - Q(7+JIN)
*
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
*
      ELSE
         XL1 = XC(1) - Q(5+JIN)
         XL2 = XC(2) - Q(6+JIN)
         XL3 = XC(3) - Q(7+JIN)
         JR = LQ(JROTM-IROTT)
         XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
         XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
         XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GITRAN
C*****  Code Expanded From Routine:  GRMTD
         XT(4)=XC(4)*Q(JR+1)+XC(5)*Q(JR+2)+XC(6)*Q(JR+3)
         XT(5)=XC(4)*Q(JR+4)+XC(5)*Q(JR+5)+XC(6)*Q(JR+6)
         XT(6)=XC(4)*Q(JR+7)+XC(5)*Q(JR+8)+XC(6)*Q(JR+9)
*
C*****  End of Code Expanded From Routine:  GRMTD
      ENDIF
*
      IACT = 1
      ISHT = Q(JVOT+2)
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOTRP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,1,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON(XT,Q(JPAR+1),IACT,2,SNEXT,SNXT,SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ELSE
            CALL GNOPAR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.14) THEN
         CALL GNOHYP (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT,Q(JPAR+1),IACT,SNEXT,SNXT,SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         INGOTO = IN
         SNEXT  = SNXT
         IGNEXT = 1
         LQ(JGPAR-NLEVEL-1) = JPAR
         IQ(JGPAR+NLEVEL+1) = NPAR
         IF (ISEARC.EQ.-2) THEN
            IF (MOD(IQ(JSC0),2).NE.0) THEN
               IDIVB = IDIV
            ELSE
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVB = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVB = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVB.LT.0) IDIVB = -IDIVB
               IF (IDIVB.EQ.0) THEN
                  IF (IAX.EQ.6) THEN
                     IDIVB = NSB
                  ELSE
                     IDIVB = 1
                  ENDIF
               ELSE IF (IDIVB.EQ.NSB) THEN
                  IF (IAX.NE.6) IDIVB = NSB - 1
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
      IF (ISEARC.EQ.-2) THEN
         IF (ICONT.EQ.NCONT) THEN
            IF (IDIVL.EQ.0) THEN
               IF (IDIVB.NE.0) THEN
                  IF (IDIV.EQ.IDIVB) GO TO 300
                  IF (.NOT.BTEST(IQ(JVO),2)) THEN
                     IDIVL = IDIVB
                     GO TO 193
                  ENDIF
               ENDIF
*
*   *         Compute distance to boundary of current volume
*
               JPAR = LQ(JGPAR-NLEVEL)
               IACT = 2
               ISH  = Q(JVO+2)
               IF (ISH.LT.5) THEN
                  IF (ISH.EQ.1) THEN
                     CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ELSE IF (ISH.EQ.2) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.3) THEN
                     CALL GNTRAP (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE
                     CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.LE.10) THEN
                  IF (ISH.EQ.5) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.6) THEN
                     CALL GNTUBE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.7) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,1, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.8) THEN
                     CALL GNCONE (XC, Q(JPAR+1),IACT,2, SNEXT,SNXT,SAFE)
                  ELSE IF (ISH.EQ.9) THEN
                     CALL GNSPHR (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ELSE
                     CALL GNPARA (XC, Q(JPAR+1),IACT, SNEXT, SNXT, SAFE)
                  ENDIF
               ELSE IF (ISH.EQ.12) THEN
                  CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.11) THEN
                  CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.13) THEN
                  CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.14) THEN
                  CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE IF (ISH.EQ.28) THEN
                  CALL GSNGTR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,1)
               ELSE IF (ISH.EQ.NSCTUB) THEN
                  CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
               ELSE
                  PRINT *, ' GTNEXT : No code for shape ', ISH
                  STOP
               ENDIF
*
               IF (SAFE.LT.SAFETY) SAFETY = SAFE
               IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
                  SNEXT  = SNXT
                  IGNEXT = 1
                  INGOTO = 0
               ENDIF
*
*   *         Check wether other pseudo-divisions have to be scanned
*
               X0(1) = XC(1) + SNXT*XC(4)
               X0(2) = XC(2) + SNXT*XC(5)
               X0(3) = XC(3) + SNXT*XC(6)
               IF (IAX.LE.3) THEN
                  IDIVL = LOCATF (Q(JSB+3), NSB, X0(IAX))
               ELSE
                  CALL GFCOOR (X0, IAX, CX)
                  IDIVL = LOCATF (Q(JSB+3), NSB, CX)
               ENDIF
               IF (IDIVL.LT.0) IDIVL = -IDIVL
               IF (IDIVL.EQ.0) THEN
                  IF(IAX.EQ.6)THEN
                     IDIVL=NSB
                  ELSE
                     IDIVL=1
                  ENDIF
               ELSEIF (IDIVL.EQ.NSB)THEN
                  IF(IAX.NE.6)IDIVL=NSB-1
               ENDIF
            ELSE
               IF (IDIV.EQ.IDIVB)   GO TO 400
            ENDIF
  193       IF ((IDIV-IDIVL)*INC.GE.0) GO TO 400
            IDIV = IDIV +INC
            GO TO 110
         ELSE
            ICONT = ICONT +1
            GO TO 140
         ENDIF
      ELSE
         IF (INEAR.EQ.NNEAR) GO TO 300
         INEAR = INEAR +1
         GO TO 130
      ENDIF
*
* ***    Case of volume incompletely divided
*
  200 JDIV   = LQ(JVO-1)
      IAXIS  = Q(JDIV+1)
      IVOT   = Q(JDIV+2)
      JVOT   = LQ(JVOLUM-IVOT)
      ISHT   = Q(JVOT+2)
*
*  ** Get the division parameters
*
      IF (NLEVEL.LT.NLDEV(NLEVEL)) THEN
         JPARM = 0
      ELSE
*        (case with JVOLUM structure locally developed)
         JPARM = LQ(LQ(JVOLUM-LVOLUM(NLDEV(NLEVEL))))
         IF (NLEVEL.EQ.NLDEV(NLEVEL)) GO TO 215
         DO 210 ILEV = NLDEV(NLEVEL), NLEVEL-1
            IF (IQ(JPARM+1).EQ.0) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
               IF (JPARM.EQ.0) GO TO 215
            ELSE IF (IQ(JPARM-3).GT.1) THEN
               JPARM = LQ(JPARM-LINDEX(ILEV+1))
            ELSE
               JPARM = LQ(JPARM-1)
            ENDIF
            IF (ILEV.EQ.NLEVEL-1) THEN
               NDIV = IQ(JPARM+1)
               ORIG =  Q(JPARM+2)
               SDIV =  Q(JPARM+3)
            ENDIF
  210    CONTINUE
         GO TO 220
      ENDIF
*     (normal case)
  215 NDIV = Q(JDIV+3)
      ORIG = Q(JDIV+4)
      SDIV = Q(JDIV+5)
*
*  ** Look at the first and the last divisions only
*
  220 IDT  = IDTYP(IAXIS, ISH)
      IF (IDT.EQ.1) THEN
         IN2 = 0
         IF (XC(IAXIS).LT.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE IF (IDT.EQ.2) THEN
         R   = XC(1)**2 + XC(2)**2
         IF (ISH.EQ.9) R = R + XC(3)**2
         R   = SQRT(R)
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.6.OR.ISH.EQ.9) THEN
            IF (R.LT.ORIG) THEN
               IN  = 1
            ELSE
               IN  = NDIV
            ENDIF
         ELSE
**          PRINT *, ' GTNEXT : Partially divided ',ISH,IAXIS
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ENDIF
      ELSE IF (IDT.EQ.4) THEN
         IN2 = 0
         RXY = XC(1)**2 + XC(2)**2
         RXY = SQRT(RXY)
         IF (XC(3).NE.0.0) THEN
            THET = RADDEG * ATAN (RXY/XC(3))
            IF (THET.LT.0.0) THET = THET + 180.0
         ELSE
            THET = 90.
         ENDIF
         IF (THET.LE.ORIG) THEN
            IN  = 1
         ELSE
            IN  = NDIV
         ENDIF
      ELSE
         IN2 = 0
         IF (ISH.EQ.5.OR.ISH.EQ.7) THEN
            IN  = 1
            IF (NDIV.GT.1) IN2 = NDIV
         ELSE
            IF (XC(1).NE.0.0.OR.XC(2).NE.0.0) THEN
               PHI = RADDEG * ATAN2 (XC(2), XC(1))
            ELSE
               PHI = 0.0
            ENDIF
            IF (ISH.EQ.6.OR.ISH.EQ.8) THEN
               IF (PHI.LT.ORIG) THEN
                  IN  = 1
               ELSE
                  IN  = NDIV
               ENDIF
            ELSE
               IN  = 1
               IF (NDIV.GT.1) IN2 = NDIV
            ENDIF
         ENDIF
      ENDIF
*
  225 IF (IDT.EQ.1) THEN
         X0(1) = 0.0
         X0(2) = 0.0
         X0(3) = 0.0
         X0(IAXIS) = ORIG + (IN - 0.5) * SDIV
         IF (ISH.EQ.4.OR.(ISH.EQ.10.AND.IAXIS.NE.1)) THEN
            CALL GCENT (IAXIS, X0)
         ENDIF
         XT(1) = XC(1) - X0(1)
         XT(2) = XC(2) - X0(2)
         XT(3) = XC(3) - X0(3)
         XT(4) = XC(4)
         XT(5) = XC(5)
         XT(6) = XC(6)
      ELSE IF (IDT.EQ.3) THEN
         PH0  = DEGRAD * (ORIG + (IN - 0.5) * SDIV)
         CPHR = COS(PH0)
         SPHR = SIN(PH0)
         XT(1) = XC(1)*CPHR + XC(2)*SPHR
         XT(2) = XC(2)*CPHR - XC(1)*SPHR
         XT(3) = XC(3)
         XT(4) = XC(4)*CPHR + XC(5)*SPHR
         XT(5) = XC(5)*CPHR - XC(4)*SPHR
         XT(6) = XC(6)
      ELSE
         DO 234 I = 1, 6, 2
            XT(I) = XC(I)
            XT(I+1) = XC(I+1)
  234    CONTINUE
      ENDIF
*
      IF (JPARM.NE.0) THEN
         IF (IQ(JPARM-3).GT.1) THEN
            JPAR = LQ(JPARM-IN)
         ELSE
            JPAR = LQ(JPARM-1)
         ENDIF
         JPAR = JPAR + 5
      ELSE
         JPAR = JVOT + 6
      ENDIF
*
      IACT = 1
      IF (ISHT.LT.5) THEN
         IF (ISHT.EQ.1) THEN
            CALL GNOBOX (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.2) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.3) THEN
            CALL GNOTRA (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOTRP (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.LE.10) THEN
         IF (ISHT.EQ.5) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.6) THEN
            CALL GNOTUB (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.7) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.8) THEN
            CALL GNOCON (XT, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISHT.EQ.9) THEN
            CALL GNOSPH (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNOPAR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISHT.EQ.11) THEN
         CALL GNOPGO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.12) THEN
         CALL GNOPCO (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.13) THEN
         CALL GNOELT (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISHT.EQ.28) THEN
         CALL GSNGTR (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE,0)
      ELSE IF (ISHT.EQ.NSCTUB) THEN
         CALL GNOCTU (XT, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISHT
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
      ENDIF
*
      IF (IN2.NE.0) THEN
         IF (IN2.NE.IN) THEN
            IN  = IN2
            GO TO 225
         ENDIF
      ENDIF
*       (later, this section only for concave volumes if INGOTO >0
  300 IACT = 1
      IF (IGNEXT.NE.0) THEN
         IF (.NOT.BTEST(IQ(JVO),2)) IACT = 0
      ENDIF
      JPAR = LQ(JGPAR-NLEVEL)
      IF (ISH.LT.5) THEN
         IF (ISH.EQ.1) THEN
            CALL GNBOX (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE )
         ELSE IF (ISH.EQ.2) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.3) THEN
            CALL GNTRAP (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNTRP (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.LE.10) THEN
         IF (ISH.EQ.5) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.6) THEN
            CALL GNTUBE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.7) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 1, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.8) THEN
            CALL GNCONE (XC, Q(JPAR+1), IACT, 2, SNEXT, SNXT, SAFE)
         ELSE IF (ISH.EQ.9) THEN
            CALL GNSPHR (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ELSE
            CALL GNPARA (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
         ENDIF
      ELSE IF (ISH.EQ.12) THEN
         CALL GNPCON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.11) THEN
         CALL GNPGON (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.13) THEN
         CALL GNELTU (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.14) THEN
         CALL GNHYPE (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE IF (ISH.EQ.28) THEN
         CALL GSNGTR (XC,Q(JPAR+1),  IACT, SNEXT, SNXT, SAFE,1)
      ELSE IF (ISH.EQ.NSCTUB) THEN
         CALL GNCTUB (XC, Q(JPAR+1), IACT, SNEXT, SNXT, SAFE)
      ELSE
         PRINT *, ' GTNEXT : No code for shape ', ISH
         STOP
      ENDIF
*
      IF (SAFE.LT.SAFETY) SAFETY = SAFE
      IF (SNXT.LE.MIN(SNEXT,BIG1)) THEN
         SNEXT  = SNXT
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
  400 IF (GONLY(NLEVEL).EQ.0.) THEN
*
* ***   Case of a 'NOT ONLY' volume -> step search
*
         SAFETY = 0.
         EPSI2  = 0.5*EPSIL
         ST     = SNEXT -EPSI2
         IF (ST.LE.0) GO TO 900
         EPSI3  = 10.*EPSIL
         IF (ST.LE.EPSI3) THEN
            NN = 1
         ELSE
            NN = ST/EPSI3 +1
            ST = ST/NN
         ENDIF
*
         NBIN = 0
         SN   = 0.
  420    SN   = SN +ST
         XT(1) = VECT(1) + SN*VECT(4)
         XT(2) = VECT(2) + SN*VECT(5)
         XT(3) = VECT(3) + SN*VECT(6)
*
         INGOTO = 0
         CALL GINVO2 (XT, ISAME)
         IF (ISAME.EQ.0) THEN
            IF (ST.LE.EPSI2) GO TO 490
            SN   = SN -ST
            ST   = 0.5*ST
            NBIN = 1
            GO TO 420
         ENDIF
*
         IF (NBIN.NE.0) THEN
            IF (ST.LT.EPSI2) THEN
               ST = EPSI2
            ELSE
               ST = 0.5*ST
            ENDIF
            GO TO 420
         ENDIF
         NN = NN -1
         IF (NN.GT.0) GO TO 420
         GO TO 495
*
  490    IF (SN.LT.SNEXT) THEN
            INGOTO = -1
            SNEXT  = SN
            IGNEXT = 1
            GO TO 900
         ENDIF
*
  495    NLEVIN = NLEVEL
      ENDIF
*
* *** Attempt to rescue negative SNXT due to rounding errors
*
  900 IF (SNEXT.LT.0.) THEN
CCC debug
         IF (ISWIT(9).EQ.123456789) THEN
            PRINT *,' GTNEXT : SNEXT,SAFETY,INGOTO=',SNEXT,SAFETY,INGOTO
            CALL GPCXYZ
         ENDIF
CCC
         SAFETY = 0.
         SNEXT  = 0.
         IGNEXT = 1
         INGOTO = 0
      ENDIF
*
      IF(JGSTAT.NE.0) CALL GFSTAT(3)
*                                                             END GTNEXT
      END
+DECK,GINVO1.
*CMZ :  1.30/00 18/09/96  19.58.23  by  Pavel Nevski
*CMZ :  3.21/02 03/07/94  17.14.15  by  S.Giani
*-- Author :
      SUBROUTINE GINVO1 (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
+SEQ, GCHVIR.
C.
      DIMENSION  X(*)
      REAL       XC(6), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
      xc(4)=0.
      xc(5)=0.
      xc(6)=0.
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
       if(nin.gt.1)then
        clmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+3)
        chmoth=q(jvirt+4*(LVOLUM(NLEVEL)-1)+4)
        ndivto=q(jvirt+4*(LVOLUM(NLEVEL)-1)+2)
        iaxis =q(jvirt+4*(LVOLUM(NLEVEL)-1)+1)
        if(iaxis.le.3)then
          ivdiv=((xc(iaxis)-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        else
          call gfcoor(xc,iaxis,cx)
          if(iaxis.eq.6)then
            if((cx-clmoth).lt.-1.)then
              cx=cx+360.
            elseif((cx-chmoth).gt.1.)then
              cx=cx-360.
            endif
            if(cx.gt.chmoth)then
              cx=chmoth
            elseif(cx.lt.clmoth)then
              cx=clmoth
            endif
          endif
          ivdiv=((cx-clmoth)*ndivto/(chmoth-clmoth))+1
            if(ivdiv.lt.1)then
              ivdiv=1
            elseif(ivdiv.gt.ndivto)then
              ivdiv=ndivto
            endif
        endif
        jvdiv=lq(jvirt-LVOLUM(NLEVEL))
        iofset=iq(jvdiv+ivdiv)
        ncont=iq(jvdiv+iofset+1)
        jcont=jvdiv+iofset+1
        if(ncont.eq.0)goto 260
       else
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = 1
       endif
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN = IQ(JCONT+ICONT)
           endif
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
           if(nin.eq.1)then
            in=1
           else
            IN  = IQ(JCONT+ICONT)
           endif
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
         ingt=0
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480
 
  450 ISAME = 0
 
  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+DECK,GINVO2.
*CMZ :  1.30/00 18/09/96  19.59.25  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.24  by  S.Giani
*-- Author :
      SUBROUTINE GINVO2 (X, ISAME)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GINVOL (X, ISAME*)                                    *
C.    *                                                                *
C.    *   Checks if particle at point X has left current volume/medium *
C.    *   If so, returns ISAME = 0 and prepares information useful to  *
C.    *    identify the new volume entered.                            *
C.    *   Otherwise, returns ISAME = 1                                 *
C.    *                                                                *
C.    *   Note : INGOTO is set by GTNEXT, to transmit the information  *
C.    *       on the one volume which has limited the step SNEXT,      *
C.    *       >0 : INth content                                        *
C.    *       =0 : current volume                                      *
C.    *       <0 : -NLONLY, with NLONLY defined as the first 'ONLY'    *
C.    *           level up in the tree for the 'NOT-ONLY' volume       *
C.    *           where the point X is found to be.                    *
C.    *                                                                *
C.    *   Called by : GNEXT, GTELEC, GTHADR, GTMUON, GTNEXT            *
C.    *   Authors   : S.Banerjee, R.Brun, F.Bruyant                    *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCVOLU.
+CDE, GCTRAK.
+SEQ, GCJUMP, IF=USRJMP
C.
      DIMENSION  X(*)
      REAL       XC(3), XT(3)
      LOGICAL    BTEST
C.
C.    ------------------------------------------------------------------
*
* SECTION I: The /GCVOLU/ table contains the presumed location of X in the
*            geometry tree, at level NLEVEL.  The suggestion is that INGOTO
*            is the index of a content at NLEVEL which may also contain X.
*            If this is so, ISAME=0 and return.  INGOTO is left unchanged.
*            If this is not so, have we left the volume at NLEVEL altogether?
*            If so, ISAME=0 and INGOTO=0, return.  Otherwise, this is the
*            starting position for a search.  Reset search record variables
*            and proceed to section II.
*
* *** Check if point is in current volume
*
      INGT = 0
C*****  Code Expanded From Routine:  GTRNSF
C
  100 IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
         XC(1) = X(1) - GTRAN(1,NLEVEL)
         XC(2) = X(2) - GTRAN(2,NLEVEL)
         XC(3) = X(3) - GTRAN(3,NLEVEL)
*
      ELSE
         XL1 = X(1) - GTRAN(1,NLEVEL)
         XL2 = X(2) - GTRAN(2,NLEVEL)
         XL3 = X(3) - GTRAN(3,NLEVEL)
         XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) + XL3*
     +      GRMAT(3,NLEVEL)
         XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) + XL3*
     +      GRMAT(6,NLEVEL)
         XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) + XL3*
     +      GRMAT(9,NLEVEL)
*
      ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
      JVO  = LQ(JVOLUM-LVOLUM(NLEVEL))
*
* Note: At entry the variable INGOTO may contain the index of a volume
* contained within the current one at NLEVEL.  If so, begin by checking
* if X lies inside.  This improves the search speed over that of GMEDIA.
*
      NIN = Q(JVO+3)
      IF ((INGOTO.LE.0).OR.(INGOTO.GT.NIN)) THEN
         INGOTO = 0
      ELSE
*
* ***   Entrance in content INGOTO predicted by GTNEXT
*
         JIN  = LQ(JVO-INGOTO)
         IVOT = Q(JIN+2)
         JVOT = LQ(JVOLUM-IVOT)
         JPAR = LQ(JGPAR-NLEVEL-1)
*
         IROTT = Q(JIN+4)
C*****  Code Expanded From Routine:  GITRAN
C.
C.    ------------------------------------------------------------------
C.
         IF (IROTT .EQ. 0) THEN
            XT(1) = XC(1) - Q(5+JIN)
            XT(2) = XC(2) - Q(6+JIN)
            XT(3) = XC(3) - Q(7+JIN)
*
         ELSE
            XL1 = XC(1) - Q(5+JIN)
            XL2 = XC(2) - Q(6+JIN)
            XL3 = XC(3) - Q(7+JIN)
            JR = LQ(JROTM-IROTT)
            XT(1) = XL1*Q(JR+1) + XL2*Q(JR+2) + XL3*Q(JR+3)
            XT(2) = XL1*Q(JR+4) + XL2*Q(JR+5) + XL3*Q(JR+6)
            XT(3) = XL1*Q(JR+7) + XL2*Q(JR+8) + XL3*Q(JR+9)
*
         ENDIF
C*****  End of Code Expanded From Routine:  GITRAN
*
*   *   Check if point is in content
*
         CALL GINME (XT, Q(JVOT+2), Q(JPAR+1), IYES)
         IF (IYES.NE.0) THEN
*
*          If so, prepare information for volume retrieval, and return
*
            NLEVIN = NLEVEL +1
            LVOLUM(NLEVIN) = IVOT
            NAMES(NLEVIN)  = IQ(JVOLUM+IVOT)
            NUMBER(NLEVIN) = Q(JIN+3)
            LINDEX(NLEVIN) = INGOTO
            LINMX(NLEVIN)  = Q(JVO+3)
            GONLY(NLEVIN)  = Q(JIN+8)
            IF (LQ(LQ(JVOLUM-IVOT)).EQ.0) THEN
               NLDEV(NLEVIN) = NLDEV(NLEVEL)
            ELSE
               NLDEV(NLEVIN) = NLEVIN
            ENDIF
            CALL GTRMUL (GTRAN(1,NLEVEL), GRMAT(1,NLEVEL), Q(JIN+5),
     +                   IROTT, GTRAN(1,NLEVIN), GRMAT(1,NLEVIN))
            ISAME = 0
            GO TO 999
         ENDIF
      ENDIF
*
* End of INGOTO processing
*
      JPAR = LQ(JGPAR-NLEVEL)
      CALL GINME (XC, Q(JVO+2), Q(JPAR+1), IYES)
      IF (IYES.EQ.0) THEN
         ISAME  = 0
         INGOTO = 0
         GO TO 999
      ENDIF
*
*  **   Point is in current volume
*
      NLEVIN = NLEVEL
      NLMIN = NLEVEL
      IF ((INFROM.LE.0).OR.(INFROM.GT.NIN)) THEN
         INFROM = 0
      ENDIF
      INFR = INFROM
      NLMANY = 0
      IF (INGOTO.GT.0) THEN
         INGT = INGOTO
         JIN = LQ(JVO-INGOTO)
         IQ(JIN) = IBSET(IQ(JIN),4)
      ENDIF
*
* SECTION II: X is found inside current node at NLEVEL in /GCVOLU/.
*             Search all contents for any containing X.  Take the
*             first one found, incrementing NLEVEL and extending the
*             /GCVOLU/ tables.  Otherwise if the list of contents is
*             exhausted without finding X inside, proceed to Section III.
* Note: Since Section II is re-entered from Section III, a blocking word
* is used to mark those contents already checked.  Upon exit from Section
* II, these blocking words are cleared at NLEVEL, but may remain set in
* levels between NLEVEL-1 and NLMIN, if any.  They must be cleared at exit.
*
*  **  Check contents, if any
*
  200 JVO = LQ(JVOLUM-LVOLUM(NLEVEL))
      NIN = Q(JVO+3)
*
*   *   Case with no contents
*
      IF (NIN.EQ.0) THEN
         GO TO 300
*
*   *   Case with contents defined by division
*
      ELSEIF (NIN.LT.0) THEN
         CALL GMEDIV (JVO, IN, XC, 1)
         IF (IN.GT.0) THEN
            IF ((GONLY(NLEVEL).EQ.0).AND.
     +          (NLEVEL.LE.NLEVIN)) THEN
                INFR = 0
                INGT = 0
                GO TO 200
             ELSE
                GO TO 450
             ENDIF
         ENDIF
*
*   *  Case with contents positioned
*
      ELSE
         JCONT = LQ(JVO-NIN-1)+1
         NCONT = IQ(JCONT)
         ISEARC = Q(JVO+1)
         IF (ISEARC.LT.0) THEN
*
*       Prepare access to contents, when ordered by GSORD
*
            JSB = LQ(LQ(JVO-NIN-1))
            IAX = Q(JSB+1)
            NSB = Q(JSB+2)
            IF (IAX.LE.3) THEN
               IDIV = LOCATF (Q(JSB+3), NSB, XC(IAX))
            ELSE
               CALL GFCOOR (XC, IAX, CX)
               IDIV = LOCATF (Q(JSB+3), NSB, CX)
            ENDIF
            IF (IDIV.LT.0) IDIV = -IDIV
            IF (IDIV.EQ.0) THEN
               IF (IAX.NE.6) GO TO 260
               IDIV = NSB
            ELSEIF (IDIV.EQ.NSB) THEN
               IF (IAX.NE.6) GO TO 260
            ENDIF
            JSC0  = LQ(JVO-NIN-2)
            NCONT = IQ(JSC0+IDIV)
            JCONT = LQ(JSC0-IDIV)
         ELSE
*
*       otherwise, scan contents (possibly a user selection of them)
*
            JNEAR = LQ(JVO-NIN-1)
            IF (ISEARC.GT.0) THEN
+SELF, IF=-USRJMP
               CALL GUNEAR (ISEARC, 1, XC, JNEAR)
+SELF, IF=USRJMP
               CALL JUMPT4(JUNEAR,ISEARC, 1, XC, JNEAR)
+SELF
            ELSEIF (INFR.GT.0) THEN
               JNUP = LQ(LQ(JVO-INFR)-1)
               IF (JNUP.GT.0) THEN
                  JNEAR = JNUP
               ENDIF
            ENDIF
            JCONT = JNEAR +1
            NCONT = IQ(JCONT)
         ENDIF
*
*     For each selected content in turn, check if point is inside
*
         DO 259 ICONT=1,NCONT
            IN = IQ(JCONT+ICONT)
            IF(IN.EQ.0) THEN
*
*     If the value IQ(JCONT+ICONT)=0 then we are back in the mother.
*     So jump to 260, the search is finished. Clean-up should be done
*     only up to ICONT-1, so we set:
*
               NCONT=ICONT-1
               GOTO 260
            ELSE
            JIN = LQ(JVO-IN)
            IF (.NOT.BTEST(IQ(JIN),4)) THEN
               CALL GMEPOS (JVO, IN, XC, 1)
               IF (IN.GT.0) THEN
                  IF ((GONLY(NLEVEL).EQ.0).AND.
     +                (NLEVEL.LE.NLEVIN)) THEN
                     INFR = 0
                     INGT = 0
                     GO TO 200
                  ELSE
                     GO TO 450
                  ENDIF
               ELSE
                  IQ(JIN) = IBSET(IQ(JIN),4)
               ENDIF
            ENDIF
            ENDIF
  259    CONTINUE
*
  260    IF(NCONT.EQ.NIN) THEN
         DO 268 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  268    CONTINUE
         ELSE
         DO 269 ICONT=1,NCONT
            IN  = IQ(JCONT+ICONT)
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  269    CONTINUE
         IF(INFR.NE.0) THEN
            JIN = LQ(JVO-INFR)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         IF(INGT.NE.0) THEN
            JIN = LQ(JVO-INGT)
            IQ(JIN) = IBCLR(IQ(JIN),4)
         ENDIF
         ENDIF
*
      ENDIF
*
* SECTION III: X is found at current node (NLEVEL in /GCVOLU/) but not in
*              any of its contents, if any.  If this is a MANY volume,
*              save it as a candidate best-choice, and continue the search
*              by backing up the tree one node and proceed to Section II.
*              If this is an ONLY volume, proceed to Section IV.
*
* *** Point is in current volume/medium, and not in any content
*
  300 IF (GONLY(NLEVEL).EQ.0.) THEN
*
*  **   Lowest level is 'NOT ONLY'
*
         IF (NLMANY.EQ.0) THEN
            CALL GSCVOL
            NLMANY = NLEVEL
         ENDIF
*
*   *   Go up the tree up to a volume with positioned contents
*
  310    INFR   = LINDEX(NLEVEL)
         NLEVEL = NLEVEL -1
         JVO    = LQ(JVOLUM-LVOLUM(NLEVEL))
         NIN    = Q(JVO+3)
         IF (NIN.LT.0) GO TO 310
*
C*****  Code Expanded From Routine:  GTRNSF
C
         IF (GRMAT(10,NLEVEL) .EQ. 0.) THEN
            XC(1) = X(1) - GTRAN(1,NLEVEL)
            XC(2) = X(2) - GTRAN(2,NLEVEL)
            XC(3) = X(3) - GTRAN(3,NLEVEL)
*
         ELSE
            XL1 = X(1) - GTRAN(1,NLEVEL)
            XL2 = X(2) - GTRAN(2,NLEVEL)
            XL3 = X(3) - GTRAN(3,NLEVEL)
            XC(1) = XL1*GRMAT(1,NLEVEL) + XL2*GRMAT(2,NLEVEL) +
     +      XL3* GRMAT(3,NLEVEL)
            XC(2) = XL1*GRMAT(4,NLEVEL) + XL2*GRMAT(5,NLEVEL) +
     +      XL3* GRMAT(6,NLEVEL)
            XC(3) = XL1*GRMAT(7,NLEVEL) + XL2*GRMAT(8,NLEVEL) +
     +      XL3* GRMAT(9,NLEVEL)
 
         ENDIF
C*****  End of Code Expanded From Routine:  GTRNSF
*
         JIN = LQ(JVO-INFR)
         IQ(JIN) = IBSET(IQ(JIN),4)
         NLMIN = MIN(NLEVEL,NLMIN)
         GO TO 200
      ENDIF
*
* SECTION IV: This is the end of the search.
*             (1) Entry at 400:  ISAME = 1     The current node (NLEVEL
*             in /GCVOLU/) is an ONLY volume and there were no contents
*             in the tree below it which could claim X.
*             (2) Entry at 450:  ISAME = 0    Section II has just found
*             another volume which has more claim to X than the current
*             one: either another ONLY or a deeper MANY was found.
* Note: A valid structure is assumed, in which no ONLY volumes overlap.
* If this rule is violated, or if a daughter is not entirely contained
* within the mother volume, the results are unpredictable.
*
  400 ISAME = 1
      GOTO 480
 
  450 ISAME = 0
 
  480 DO 489 NL=NLMIN,NLEVEL-1
         JVO = LQ(JVOLUM-LVOLUM(NL))
         NIN = Q(JVO+3)
         DO 488 IN=1,NIN
            JIN = LQ(JVO-IN)
            IQ(JIN) = IBCLR(IQ(JIN),4)
  488    CONTINUE
  489 CONTINUE
*
      IF (NLMANY.GT.0) THEN
         CALL GFCVOL
         NLEVIN = NLEVEL
      ELSEIF (NLEVEL.GT.NLEVIN) THEN
         INGOTO = LINDEX(NLEVEL)
         NL = NLEVIN
         NLEVIN = NLEVEL
         NLEVEL = NL
      ENDIF
*                                                             END GINVOL
  999 IF(JGSTAT.NE.0) CALL GFSTAT(ISAME)
      END
+DECK,GSSTAK.
*CMZ :  1.30/00 04/05/97  23.58.54  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.23  by  S.Giani
*-- Author :
      SUBROUTINE GSSTAK (IFLAG)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GSSTAK (IFLAG)                                        *
C.    *                                                                *
C.    *   Stores in auxiliary stack JSTAK the particle currently       *
C.    *    described in common /GCKINE/.                               *
C.    *                                                                *
C.    *   On request, creates also an entry in structure JKINE :       *
C.    *    IFLAG =                                                     *
C.    *     0 : No entry in JKINE structure required (user)            *
C.    *     1 : New entry in JVERTX / JKINE structures required (user) *
C.    *    <0 : New entry in JKINE structure at vertex -IFLAG (user)   *
C.    *     2 : Entry in JKINE structure exists already (from GTREVE)  *
C.    *                                                                *
C.    *   Called by : GSKING, GTREVE                                   *
C.    *   Author    : S.Banerjee, F.Bruyant                            *
C.    *   Modifications: PN - put protection against lack of memory.   *
C.    *   - reject Cerenkov photons if mechanism is not activated.     *
C.    *   - save interaction description (MECAT) in stack and NTTARG   *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, TYPING, GCBANK, GCTRAK, GCKINE, GCKING, GCFLAG.
+CDE, GCJLOC, GCMZFO, GCNUM,  GCSTAK, GCVOLU, GCTMED.
+CDE, GCJUMP, IF=USRJMP
*
      INTEGER         NVTX,ITR
      COMMON /VTXKIN/ NVTX,ITR
      REAL    UBUF(1)
      DATA    UBUF/0./
      INTEGER         IFLAG,IER,ISKIP,LP,ITRT,JST,I,MECAT
C.
C.    ------------------------------------------------------------------
*
      IF (IEOTRI.NE.0) RETURN
*
      IF (IPART.LE.0.OR.IPART.GT.NPART) THEN
         PRINT *, ' GSSTAK - Unknown particle code, skip track ', IPART
         GO TO 999
      ENDIF
*
* ***                          protect against lack of memory faults
      IF (IFLAG.NE.0) THEN
         CALL AGNEED(IER)
         IF (IER.NE.0) RETURN
      ENDIF
*
* ***                   create target description for GEANT produced vertices
      Mecat = 0
      If (NGKINE.GT.0 .and. NMEC.GT.0) then
          Mecat = min(LMEC(NMEC),49) + LVOLUM(NLEVEL)*100
          If (ISTOP.EQ.0) Mecat = Mecat+50 ! flag non-stopped particles
          If (ISTAK.GT.0) Mecat = -Mecat   ! flag disconnected vertex
      ENDIF
*
* ***                          Give control to user for track selection
+SELF,IF=-USRJMP.
      CALL GUSKIP(ISKIP)
+SELF,IF= USRJMP.
      CALL JUMPT1(JUSKIP,ISKIP)
+SELF.
      IF (ISKIP.NE.0) GO TO 999
*
* *** Check if an entry in JKINE structure is required
*
      IF (IFLAG.EQ.1) THEN
         CALL GSVERT (VERT,  ITRA, 0, UBUF, 0, NVTX)
         If (NVTX.LE.0) THEN
            Print *,' GSSTAK cannot set Vertex for ',ITRA,Mecat
            Print *,' ****** event simulation abandoned ******'
            IEOTRI=1
            RETURN
         ENDIF
         Q(6+LQ(JVERTX-NVTX))=MECAT
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE IF (IFLAG.LT.0) THEN
         NVTX = -IFLAG
         CALL GSKINE (PVERT, IPART, NVTX, UBUF, 0, ITR)
      ELSE
         IF (IFLAG.EQ.0) THEN
*          Store -ITRA in stack for a track without entry in JKINE
            ITR = -ITRA
         ELSE
            ITR = ITRA
         ENDIF
      ENDIF
*
* *** Store information in stack
*
      IF (JSTAK.EQ.0) THEN
         NDBOOK = NTSTKP*NWSTAK +3
         NDPUSH = NTSTKS*NWSTAK
         CALL MZBOOK (IXCONS,JSTAK,JSTAK,1,'STAK', 0,0,NDBOOK, IOSTAK,3)
         IQ(JSTAK+2) = NTSTKP
      ELSE IF (IQ(JSTAK+1).EQ.IQ(JSTAK+2)) THEN
         CALL AGNEED (IER)
         IF (IER.NE.0) RETURN
         CALL MZPUSH (IXCONS, JSTAK, 0, NDPUSH, 'I')
         IQ(JSTAK+2) = IQ(JSTAK+2) +NTSTKS
      ENDIF
*
*PN:  do not save Cerenkov photons if the mechanism is not activated
      LP   = LQ(JPART-Ipart)
      IF (LP.LE.0) GO TO 999
      ITRT =  Q(6+LP)
      IF (ITRT.EQ.7 .and. ITCKOV.EQ.0) GO TO 999
*
      JST = JSTAK +IQ(JSTAK+1)*NWSTAK +3
      IQ(JSTAK+1) = IQ(JSTAK+1) +1
      IF (IQ(JSTAK+3).EQ.0)  IQ(JSTAK+3) = IQ(JSTAK+1)
      IF (IQ(JSTAK+1).GT.NSTMAX)  NSTMAX = IQ(JSTAK+1)
*
      IQ(JST+1)   = ITR       ! track number(or parent), STACK_ONLY flag
      IQ(JST+2)   = IPART     ! particle type
      IQ(JST+3)   = Mecat     ! its production history
      DO 90 I = 1,3
         Q(JST+3+I) = VERT(I)
         Q(JST+6+I) = PVERT(I)
   90 CONTINUE
      Q(JST+10) = TOFG
      Q(JST+11) = SAFETY
      Q(JST+12) = UPWGHT
*
      NALIVE = NALIVE +1
*                                                             END GSSTAK
  999 END
+DECK,GSVERT
*CMZ :  1.30/00 03/05/97  16.32.36  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GSVERT(V,NTBEAM,NTTARG,UBUF,NWBUF,NVTX)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Creates a new vertex bank                                *
C     *       Vertex is generated from tracks NTBEAM NTTARG            *
C     *       NVTX is the new vertex number                            *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    * Modifications:                                                 *
C.    * PN, 07/Feb/97: allow negative NTbeam and NTtarg                *
C.    ******************************************************************
C.
+CDE,TYPING.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCFLAG
+SEQ,GCPUSH
+SEQ,GCTRAK
+SEQ,GCKINE
+SEQ,GCUNIT
+SEQ,QUEST
      REAL     V(3),UBUF(1)
      INTEGER  LGKINE,NTBEAM,NTTARG,NWBUF,NVTX,NT(2),IER,
     >         JV,JUV,I,J,JK,NVG,NFREE
C.
C.    ------------------------------------------------------------------
C.
      CALL AGNEED (IER)
      IF (IER.NE.0) GO TO 90
 
      NVTX   = NVERTX + 1
      IF (JVERTX.EQ.0)THEN
C        simulated vertex list
         CALL MZBOOK(IXDIV,JVERTX,JVERTX,1,'VERT',NCVERT,NCVERT,2,2,0)
         IQ(JVERTX-5)=0
      ENDIF
      IF (NVTX.GT.IQ(JVERTX-2)) CALL MZPUSH(IXDIV,JVERTX,NPVERT,0,'I')
      IF (NVTX.GT.IQ(JVERTX-2)) THEN
         PRINT *,' GSVERT ERROR: WRONG NVertex ',NVTX
         GOTO 90
      ENDIF
C     one vertex parameters
      CALL MZBOOK(IXDIV,JV,JVERTX,-NVTX,'VERT',1,1,9,3,0)
C     and users buffer
      IF (NWBUF.GT.0) THEN
         CALL MZBOOK(IXDIV,JUV,JV,-1,'VERU',0,0,NWBUF,2,0)
         IQ(JUV-5)=NVTX
         DO 3 I=1,NWBUF
   3     Q(JUV+I)=UBUF(I)
      ENDIF
      DO 4 I=1,3
   4  Q(JV + I) = V(I)
      Q(JV + 4) = TOFG
      Q(JV + 5) = NTBEAM
      Q(JV + 6) = NTTARG
C
      NT(1) = NTBEAM
      NT(2) = NTTARG
      Do i=1,2
         IF (NT(i).GT.0) THEN
            JK   = LGKINE(J,NT(i))
            IF(JK.LE.0) GO TO 90
            NVG  = Q(JK + 7)
            NFREE=IQ(JK-1)-7-NVG
            IF(NFREE.LE.0) CALL MZPUSH(IXDIV,JK,0,max(2,NVG/5),'I')
            Q(JK + NVG + 8) = NVTX
            Q(JK + 7) = NVG + 1
         ENDIF
      EndDO
C
      NVERTX      = NVTX
      IQ(JVERTX+1)= NVERTX
      RETURN
C
C             Error
C
  90  NVTX   = 0
      END
 
+DECK,GSAHIT
*CMZ :          19/07/97  13.08.07  by  Pavel Nevski
*CMZ :  1.30/00 18/04/97  18.05.51  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.20  by  S.Giani
*-- Author :
      SUBROUTINE GSAHIT(ISET,IDET,ITRA,NUMBV,HITS,IHIT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Routines to Communicate with the JHITS data structure       *
C.    *   ---------------------------------------------------------    *
C.    *                                                                *
C.    *   Stores  element  values  for current  hit  into  the  data   *
C.    * structure JHITS.                                               *
C.    * ISET      set number  (can be obtained from  /GCSETS/ filled   *
C.    *           by GFINDS)                                           *
C.    * IDET      detector    number   "           "               "   *
C.    *           "                                                    *
C.    * ITRA      track number producing this hit                      *
C.    * NUMBV     array  of  volume numbers  corresponding  to  list   *
C.    *           NAMESV of GSDET                                      *
C.    * HITS      array of values for current hit elements             *
C.    * IHIT      on return, current hit number.  If =0, hit has not   *
C.    *           been stored.                                         *
C.    *                                                                *
C.    *       JH=LQ(JHITS-ISET)                                        *
C.    *       JHD=LQ(JH-IDET)                                          *
C.    *       IQ(JH+IDET)= pointer to LAST USED word in JHD            *
C.    *         Each hit is packed into JHD in the following format    *
C.    *        --Track number ITRA not packed                          *
C.    *        --Volume numbers packed                                 *
C.    *        --Hits transformed and packed                           *
C.    *                                                                *
C.    *                The Hit data structure JHITS                    *
C.    *                ----------------------------                    *
C.    *                                                                *
C.    *                                            | JHITS             *
C.    *    NSET                  ISET              v                   *
C.    *     ..........................................                 *
C.    *     |                   |  |              |  |                 *
C.    *     ..........................................                 *
C.    *                           |                                    *
C.    *                           | JH                                 *
C.    *      NDET    IDET         v               NDET                 *
C.    *        .....................................                   *
C.    *        |      |  |      |  |               |                   *
C.    *        .....................................                   *
C.    *                |                                               *
C.    *                | JHD                                           *
C.    *                v                                               *
C.    *               .........................................        *
C.    *               |  | 1st hit        | 2nd hit, etc.     |        *
C.    *               .........................................        *
C.    *                         Bank layout                            *
C.    * JH            =  LQ(JHITS-ISET,)  pointer  to  hits for  set   *
C.    *           number ISET                                          *
C.    * JHD           = LQ(JH-IDET),   pointer to  hits of  detector   *
C.    *           IDET                                                 *
C.    *                  of set ISET                                   *
C.    * IQ(JH+IDET)    number of words  used so far for  storing the   *
C.    *           hits                                                 *
C.    *                  of detector IDET                              *
C.    * IQ(JHD+1)       1st word of 1st hit                            *
C.    * IQ(JHD+NWH+1)  1st word of 2nd hit                             *
C.    *                      JS=LQ(JSET-ISET)                          *
C.    *                      JD=LQ(JS-IDET)                            *
C.    *                      NWH=IQ(JD+3)                              *
C.    *   The JHITS structure is filled with the routines GSAHIT and   *
C.    * GSCHIT.   The routine GFHITS can be used to get the hits for   *
C.    * a detector IDET and set ISET.                                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUSTEP                               *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,GCBANK
+CDE,GCUNIT
+CDE,GCFLAG
      COMMON/GCLOCA/NLOCAL(2),JS,JD,JDH,JH,JHD,LOCAL(15)
      DIMENSION NUMBV(1),HITS(1)
      SAVE NMESS
      DATA NMESS/0/
C.
C.    ------------------------------------------------------------------
C.
      IHIT=0
      IF(JSET.LE.0)GO TO 99
      NSET=IQ(JSET-1)
      IF(NSET.LE.0)GO TO 99
      IF(ISET.LE.0)GO TO 99
      IF(ISET.GT.NSET)GO TO 99
      JS=LQ(JSET-ISET)
      NDET=IQ(JS-1)
      IF(NDET.LE.0)GO TO 99
      IF(IDET.LE.0)GO TO 99
      IF(IDET.GT.NDET)GO TO 99
      JD=LQ(JS-IDET)
      JDH=LQ(JD-1)
      IF(JDH.LE.0)GO TO 99
      NW=IQ(JD+1)+IQ(JD+3)+1
      NH=IQ(JD+4)
      NV=IQ(JD+2)
C
C              Create HITS master bank
C
      IF(JHITS.EQ.0)THEN
         CALL MZBOOK(IXDIV,JHITS,JHITS,1,'HITS',NSET,NSET,0,2,0)
         IQ(JHITS-5)=0
      ENDIF
      JH=LQ(JHITS-ISET)
      IF(JH.EQ.0)THEN
         CALL MZBOOK(IXDIV,JH,JHITS,-ISET,'HITS',NDET,NDET,NDET,2,0)
      ENDIF
C
      JHD=LQ(JH-IDET)
      IF(JHD.EQ.0)THEN
C
C            Create Hits bank
C
         NWHI=IQ(JD+7)
         CALL MZBOOK(IXDIV,JHD,JH,-IDET,'SJHD',0,0,NWHI,1,0)
         IQ(JHD-5)=1000*ISET+IDET
         ILAST=0
      ELSE
C
C           Check if enough space. If not increase bank size
C
         NHD=IQ(JHD-1)
         ILAST=IQ(JH+IDET)
         NFREE=NHD-ILAST
         IF(NFREE.LE.NW)THEN
            NWHI2=MAX(100,NW,IQ(JD+7)/2)
*           CALL MZPUSH(IXDIV,JHD,0,NWHI2,'I')
            CALL AgPUSH(Idebug,JHD,0,NHD+NWHI2,Ier)
            IF (Ier.ne.0) Return
            JS  = LQ(JSET-ISET)
            JD  = LQ(JS-IDET)
            JDH = LQ(JD-1)
            JH  = LQ(JHITS-ISET)
         ENDIF
      ENDIF
C
      IQ(JH+IDET)=ILAST+NW
      IHIT=IQ(JH+IDET)/NW
C
C ========>    Store track number,volumes numbers and hits
C
      IQ(JHD+ILAST+1)=ITRA
C
C
C           Store packed volume numbers
C
      NK=ILAST+2
      IF(NV.GT.0)THEN
         K=1
C
         DO 50 I=1,NV
            NB=IQ(JD+2*I+10)
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=NUMBV(I)
               K=1
               IF(I.NE.NV)NK=NK+1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(NUMBV(I),0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  50     CONTINUE
         NK=NK+1
      ENDIF
C
C          Store packed hits
C          Before packing, hits are changed to integers
C          Origin is shifted to have only positive integers
C          Result is multiplied by a constant to get resolution
C
      IF(NH.GT.0)THEN
         K=1
         DO 90 I=1,NH
            NB=IQ(JDH+4*I-2)
            XHIT=(HITS(I)+Q(JDH+4*I-1))*Q(JDH+4*I)
            IF(NB.EQ.0)THEN
               VALMX=2.147483E+9
            ELSE
               VALMX=2.**NB-1.
            ENDIF
            IFLAG=0
            IF(XHIT.LT.0.)THEN
               XHIT=0.
               IFLAG=1
            ELSE IF(XHIT.GT.VALMX)THEN
               XHIT=VALMX
               IFLAG=1
            ENDIF
            IF(IFLAG.NE.0)THEN
               NMESS=NMESS+1
               IF(NMESS.LT.10)THEN
                  WRITE(CHMAIL,1000)IQ(JSET+ISET),IQ(JS+IDET),I,HITS(I)
     +             ,Q(JDH+4*I-1),Q(JDH+4*I)
                  CALL GMAIL(0,0)
               ENDIF
            ENDIF
C
            KHIT=XHIT+0.5
            IF(NB.LE.0)THEN
               IF(K.GT.1)THEN
                   NK=NK+1
               ENDIF
               IQ(JHD+NK)=KHIT
               NK=NK+1
               K=1
            ELSE
               IF(K+NB.GT.33)THEN
                  K=1
                  NK=NK+1
               ENDIF
               CALL MVBITS(KHIT,0,NB,IQ(JHD+NK),K-1)
               K=K+NB
            ENDIF
  90     CONTINUE
      ENDIF
C
 1000 FORMAT(' ***** GSAHIT OVERFLOW WHEN IUSET= ',A4,' IUDET= ',
     +A4,' HITS(',I2,')=',E14.7,' ORIG= ',E14.7,' FACT= ',E14.7)
  99  RETURN
      END
+DECK,GSKINE
*CMZ :  1.30/00 23/03/97  22.06.36  by  Pavel Nevski
*CMZ :  3.21/02 28/03/94  01.30.59  by  S.Giani
*-- Author :
      SUBROUTINE GSKINE(PLAB,IPART,NV,BUF,NWBUF,NT)
C.
C.    ******************************************************************
C.    *                                                                *
C     *       Store kinematics of track NT into data structure         *
C     *       Track is coming from vertex NV                           *
C.    *                                                                *
C.    *    ==>Called by : <USER>, GUKINE,GUSTEP                        *
C.    *       Authors    R.Brun, F.Carena, M.Hansroul  *********       *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,TYPING.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCFLAG
+SEQ,GCPUSH
+SEQ,GCUNIT
+SEQ,QUEST
 
      REAL      PLAB(3),BUF(1),P2,AMASS,E
      INTEGER   LGKINE,IPART,NV,NWBUF,NT,NTI,IER,JV,JPA,JK,JUK,NTG,
     >          I,J,NFREE,JKIN
C.
C.    ------------------------------------------------------------------
C.
      CALL AGNEED (IER)
      IF (IER.NE.0)     GO TO 90
 
      IF (NV.LE.0)      GO TO 10
      IF (JVERTX.LE.0)  GO TO 90
      IF (NV.GT.NVERTX) GO TO 90
      JV = LQ(JVERTX- NV)
      IF (JV.LE.0)      GO TO 90
C
   10 NT     = NTRACK + 1
      IF (JKINE.EQ.0) THEN
         CALL MZBOOK(IXDIV,JKINE,JKINE,1,'KINE',NCKINE,NCKINE,2,2,0)
         IQ(JKINE-5)=0
      ENDIF
      J = LgKINE(JKIN,NT)
      NTI=NT-IQ(JKIN+2)
      IF(NTI.GT.IQ(JKIN-2)) CALL MZPUSH(IXDIV,JKIN,NPKINE,0,'I')
      IF(NTI.GT.IQ(JKIN-2)) THEN
         PRINT *,' GSKINE ERROR: WRONG NTRACK ',NTRACK
         GOTO 90
      ENDIF
C
      IF (JPART.LE.0) GO TO 90
      IF (IPART.GT.IQ(JPART-2)) GO TO 90
      JPA = LQ(JPART- IPART)
      IF (JPA.LE.0) GO TO 90
      P2     = PLAB(1)**2 + PLAB(2)**2 + PLAB(3)**2
      AMASS  = Q(JPA + 7)
      E      = SQRT(P2 + AMASS*AMASS)
C
C            Store kinematics in JKINE
C
      NTRACK = NT
      IQ(JKIN+1)=NTRACK
      CALL MZBOOK(IXDIV,JK,JKIN,-NTI,'KINE',1,1,8,3,0)
      Q(JK + 1) = PLAB(1)
      Q(JK + 2) = PLAB(2)
      Q(JK + 3) = PLAB(3)
      Q(JK + 4) = E
      Q(JK + 5) = IPART
      Q(JK + 6) = NV
C
C            Copy user words
C
      IF(NWBUF.GT.0)THEN
         CALL MZBOOK(IXDIV,JUK,JK,-1,'KINU',0,0,NWBUF,3,0)
         IQ(JUK-5)=NT
C
         DO 15 I=1,NWBUF
            Q(JUK+I)=BUF(I)
   15    CONTINUE
      ENDIF
C
C
C            Connect track NT to vertex NV
C
      IF(NV.GT.0)THEN
         JV = LQ(JVERTX- NV)
         NTG = Q(JV + 7)
         NFREE=IQ(JV-1)-7-NTG
         IF(NFREE.LE.0)CALL MZPUSH(IXDIV,JV,0,max(2,NTG/5),'I')
         Q(JV + NTG + 8) = NT
         Q(JV + 7) = NTG + 1
      ENDIF
C
      GO TO 99
C
C            Error
C
  90  NT = 0
  99  RETURN
      END
 
 
+DECK,GLTRAC.
*CMZ :  1.30/00 03/05/97  16.07.14  by  Pavel Nevski
*CMZ :  3.21/04 13/12/94  15.36.22  by  S.Giani
*-- Author :
      SUBROUTINE GLTRAC
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    SUBR. GLTRAC                                                *
C.    *                                                                *
C.    *   Extracts next track from stack JSTAK and prepares commons    *
C.    *    /GCTRAK/, /GCKINE/ and /GCVOLU/                             *
C.    *                                                                *
C.    *   Called by : GTREVE                                           *
C.    *   Authors   : R.Brun, F.Bruyant                                *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCKINE.
+CDE, GCNUM.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU.
      DIMENSION RNDM(5)
+SELF,IF=-SINGLE.
      DOUBLE PRECISION P2,GETOTD,GEKIND
      DOUBLE PRECISION PXD,PYD,PZD,ONE,HNORM,DAMASS,PP
+SELF.
      PARAMETER (ONE=1)
      COMMON /GCKINE_CONT/ ITRO,TOFO,MECATO
C.
C.    ------------------------------------------------------------------
*
* *** Extract next track from stack JSTAK
*
      IF(ISTORD.EQ.1) THEN
*
* *** User ordering of tracks if requested
         CALL GSTORD
      ENDIF
      ISTAK = IQ(JSTAK+1)
      IQ(JSTAK+1) = ISTAK -1
      JST = JSTAK +NWSTAK*IQ(JSTAK+1) +3
      ITRA   = IQ(JST+1)
      IF (ITRA.LT.0) THEN
         ITRA = -ITRA
      ELSE
*
*        This is a new track. We set to zero the stack number and
*        update the vertex number
         ISTAK = 0
*<       JK=LQ(JKINE-ITRA)
         IVERT=Q(LgKINE(JK,ITRA)+6)
      ENDIF
*PN: extract and save ALL from stack, it may be overwritten by interactions
      ITRO   = IQ(JST+1)
      IPART  = IQ(JST+2)
      MECATO = IQ(JST+3)
      DO 60 I = 1,3
         VERT(I) = Q(JST+3+I)
        PVERT(I) = Q(JST+6+I)
   60 CONTINUE
      TOFO   = Q(JST+10)
      TOFG   = Q(JST+10)
      SAFETY = Q(JST+11)
      UPWGHT = Q(JST+12)
*
* *** Prepare tracking parameters
*
      VECT(1) = VERT(1)
      VECT(2) = VERT(2)
      VECT(3) = VERT(3)
      PXD = PVERT(1)
      PYD = PVERT(2)
      PZD = PVERT(3)
      P2 = PXD**2+PYD**2+PZD**2
      IF(P2.GT.0.) THEN
         PP    = SQRT(P2)
         HNORM = ONE/PP
         VECT(4) = PVERT(1)*HNORM
         VECT(5) = PVERT(2)*HNORM
         VECT(6) = PVERT(3)*HNORM
         VECT(7) = PP
      ELSE
         VECT(4) = 0.
         VECT(5) = 0.
         VECT(6) = 1.
         VECT(7) = 0.
      ENDIF
*
*  ** Reload Particle characteristics, if needed
*
      IF (IPART.NE.IPAOLD) THEN
         JPA = LQ(JPART-IPART)
         DO 90 I = 1,5
            NAPART(I) = IQ(JPA+I)
   90    CONTINUE
         ITRTYP = Q(JPA+6)
         AMASS  = Q(JPA+7)
         CHARGE = Q(JPA+8)
         TLIFE  = Q(JPA+9)
         IUPD   = 0
         IPAOLD = IPART
      ENDIF
*
      DAMASS = AMASS
      GETOTD = SQRT(P2+DAMASS**2)
      GEKIND = GETOTD - DAMASS
      GETOT  = GETOTD
      GEKIN  = GEKIND
*
      IF (ITRTYP.EQ.7) THEN
*
* *** Cerenkov photon. Retrieve polarisation
         JPO = LQ(JSTAK-1)+(ISTAK-1)*3
         POLAR(1) = Q(JPO+1)
         POLAR(2) = Q(JPO+2)
         POLAR(3) = Q(JPO+3)
      ELSE
         CALL GEKBIN
      ENDIF
*
      SLENG  = 0.
      NSTEP  = 0
      NTMSTO = NTMSTO +1
      NTMULT = NTMSTO
      ISTORY = 0
*
*  ** Initialize interaction probabilities
*
      IF (ITRTYP.EQ.1) THEN
*      Gammas
         CALL GRNDM(RNDM,5)
         ZINTPA = -LOG(RNDM(1))
         ZINTCO = -LOG(RNDM(2))
         ZINTPH = -LOG(RNDM(3))
         ZINTPF = -LOG(RNDM(4))
         ZINTRA = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.2) THEN
*       Electrons
         CALL GRNDM(RNDM,3)
         ZINTBR = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
         ZINTAN = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.3) THEN
*       Neutral hadrons
         CALL GRNDM(RNDM,2)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
      ELSE IF (ITRTYP.EQ.4) THEN
*       Charged hadrons
         CALL GRNDM(RNDM,3)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTHA = -LOG(RNDM(2))
         ZINTDR = -LOG(RNDM(3))
      ELSE IF (ITRTYP.EQ.5) THEN
*       Muons
         CALL GRNDM(RNDM,5)
         SUMLIF = -CLIGHT*TLIFE*LOG(RNDM(1))
         ZINTBR = -LOG(RNDM(2))
         ZINTPA = -LOG(RNDM(3))
         ZINTDR = -LOG(RNDM(4))
         ZINTMU = -LOG(RNDM(5))
      ELSE IF (ITRTYP.EQ.7) THEN
*       Cerenkov photons
         CALL GRNDM(RNDM,1)
         ZINTLA = -LOG(RNDM(1))
      ELSE IF (ITRTYP.EQ.8) THEN
*       Ions
         CALL GRNDM(RNDM,2)
         ZINTHA = -LOG(RNDM(1))
         ZINTDR = -LOG(RNDM(2))
      ENDIF
*
*   * Prepare common /GCVOLU/ and structure JGPAR, if needed
*
      IF (NJTMAX.LE.0) THEN
        IF (GONLY(NLEVEL).EQ.0.) NLEVEL=0
        CALL GMEDIA (VECT, NUMED)
      ENDIF
      INFROM = 0
*                                                             END GLTRAC
      END
 
 
+DECK,gpdcay.
*CMZ :  1.30/00 19/04/97  17.50.02  by  Pavel Nevski
*-- Author :    Pavel Nevski
*
      SUBROUTINE GPDCAY  (IPART)
*-
*-    ******************************************************************
*-    *                                                                *
*-    *  Print branching ratios and decay modes for GEANT particles.   *
*-    *                                                                *
*-    *    ==>Called by : <USER>                                       *
*-    *       Author    P.Nevski                                       *
*-    *                                                                *
*-    ******************************************************************
*-
+CDE,TYPING,GCBANK,GCNUM,GCUNIT.
      REAL      BRATIO
      INTEGER   LENOCC,IPART,IP1,IP2,IP,JPA,
     >          MODE,JDK1,JDK2,L1,L,LL,I,JP,M1
      CHARACTER CNAME*20,CMODE*200
*-
*-    ------------------------------------------------------------------
*-
      IF (IPART.EQ.0) THEN
         IP1=1
         IP2=NPART
      ELSE
         IP1=IPART
         IP2=IPART
      ENDIF
*
      DO IP=IP1,IP2
         IF (IP.LE.0)      GOTO 90
         IF (IP.GT.NPART)  GOTO 90
         JPA = LQ(JPART-IP)
         IF (JPA.LE.0)     GOTO 90
         JDK1=LQ(JPA-1) !  PABR bank
         IF (JDK1.LE.0)    GOTO 90
         JDK2=LQ(JPA-2) !  PAMO bank
         IF (JDK2.LE.0)    GOTO 90
*
         CALL UHTOC(IQ(JPA+1),4,CMODE,20)
         L1=LENOCC(CMODE(1:20))
         WRITE(LOUT,1000) IP,CMODE(1:L1)
 1000    FORMAT(I5,1x,A,'  Decay(s):')
*
*    COPY branching ratios & decay modes.
*
         DO I  = 1,6
            CMODE = CMODE(1:L1)//' => '
            LL     = L1+4
            BRATIO = Q(JDK1+I)
            IF (BRATIO.LE.0) GO TO 60
            MODE   = IQ(JDK2+I)
            DO WHILE (MODE.GT.0)
               M1  = MOD(MODE,100)
               IF (M1.LE.0) GOTO 50
               JP  = LQ(JPART-M1)
               IF (JP.LE.0) GO TO 50
               CALL UHTOC(IQ(JP+1),4,CNAME,20)
               L   = LENOCC(CNAME)
               CMODE=CMODE(1:LL)//CNAME(1:L)//' & '
               LL  = LL+L+3
  50           MODE=MODE/100
            ENDDO
            WRITE(LOUT,1001) BRATIO,CMODE(1:LL-3)
 1001       FORMAT(6x,'Branching(%)=',F8.3,' Channel: ',A)
  60     ENDDO
C
  90     CONTINUE
      ENDDO
      END
 
 
 
 
 
 
+DECK,gfdcay.
*CMZ :          01/07/97  10.45.18  by  Pavel Nevski
*CMZ :  1.30/00 19/04/97  17.50.46  by  Pavel Nevski
*CMZ :  3.21/03 02/08/94  18.13.20  by  S.Ravndal
*-- Author :
      SUBROUTINE GFDCAY (IPART,BRATIO,MODE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  Return branching ratios and decay modes for GEANT particles.  *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    P.Nevski                                       *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCPHYS
+SEQ,GCNUM
+SEQ,GCUNIT
      REAL      BRATIO(6)
      INTEGER   MODE(6)
C.
C.    ------------------------------------------------------------------
C.
      CALL VZERO(BRATIO,6)
      CALL VZERO(MODE,6)
      IF (IPART.LE.0)      RETURN
      IF (IPART.GT.NPART)  RETURN
C
C     Particle pointer.
C
      JPA = LQ(JPART-IPART)
      IF (JPA.LE.0)        RETURN
C
C PABR bank
      JDK1=LQ(JPA-1)
      IF (JDK1.LE.0)       RETURN
C PAMO bank
      JDK2=LQ(JPA-2)
      IF (JDK2.LE.0)       RETURN
C
C     COPY branching ratios & decay modes.
C
      DO I=1,6
         BRATIO(I) = Q(JDK1+I)
         MODE(I)   = IQ(JDK2+I)
      ENDDO
C
  99  RETURN
      END
 
+DECK,GFLUCT.
*CMZ :          14/10/97  20.16.21  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.21  by  S.Giani
*-- Author :
      SUBROUTINE GFLUCT(DEMEAN,DE)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   Subroutine to decide which method is used to simulate        *
C.    *   the straggling around the mean energy loss.                  *
C.    *                                                                *
C.    *                                                                *
C.    *   DNMIN:  <---------->1<-------->30<--------->50<--------->    *
C.    *                                                                *
C.    *  STRA=0   :                                                    *
C.    *   LOSS=2  <----------GLANDZ-------------------><--GLANDO-->    *
C.    *   LOSS=1,3<---------------------GLANDZ-------------------->    *
C.    *   LOSS=4              no call to GFLUCT is done                *
C.    *   STRA=1  <-----------PAI---------------------><--GLANDZ-->    *
C.    *   STRA=2  <---PAI----><---ASHO---><----PAI----><--GLANDZ-->    *
C.    *                                                                *
C.    *   DNMIN :  an estimation of the number of collisions           *
C.    *            with energy close to the ionization energy          *
C.    *            (see PHYS333)                                       *
C.    *                                                                *
C.    *   Input  : DEMEAN (mean energy loss)                           *
C.    *   Output : DE   (energy loss in the current step)              *
C.    *                                                                *
C.    *    ==>Called by : GTELEC,GTMUON,GTHADR                         *
C.    *                                                                *
C.    *   Modifications:                                               *
C.    *PN,27/07/97: For Gamma<1.1 PAI fluctuations are scaled as 1/v**2*
C.    *             Brems losses are added to ionization for all models*
C.    ******************************************************************
C.
+CDE, GCBANK, GCJLOC, GCONST
+CDE, GCMATE, GCCUTS, GCMULO
+CDE, GCPHYS, GCKINE, GCTRAK
*
      PARAMETER (DGEV=0.153536 E-3, DNLIM=50)
      PARAMETER (ASHMIN=1,ASHMAX=30)
**
      DE=DEMEAN
      IF (STEP. LE.0) return
      IF (ILOSS.LE.0) return
 
      POTI  = Q(JPROB+9)
      GAMMA = GETOT/AMASS
      BETA  = VECT(7)/GETOT
      XI    = DGEV*CHARGE**2*STEP*DENS*Z/(A*BETA*BETA)
      DNMIN = MIN(XI,DEMEAN)/POTI
*
*PN,27/06/97:  PAI properly tabulated for GAMMA higher than 1.1
      IF (ILOSS.GT.1 .and. DNMIN.GE.DNLIM) THEN
 
         CALL GLANDO(ILOSS,STEP,Z,A,DENS,VECT(7),GETOT,AMASS,DELAND,I)
         DE = DEMEAN + DELAND
 
      else IF (ISTRA.GT.0 .and. DNMIN.LT.DNLIM) THEN
+SELF,IF=ASHO
*        ISTRA = 2 --> PAI + URBAN + ASHO
         IF (DNMIN.GE.ASHMIN.AND.DNMIN.LT.ASHMAX .AND.ISTRA.EQ.2) THEN
             CALL GASHO(VECT(7),AMASS,STEP,DE)
         ELSE
             DE = GSTREN(GAMMA,DCUTE,STEP)
             If (Gamma.LE.1.1) DE=DE*.173554/(BETA*BETA)
         ENDIF
+SELF,IF=-ASHO
         DE = GSTREN(max(GAMMA,1.1),DCUTE,STEP)
         If (Gamma.LE.1.1) DE=DE*.173554/(BETA*BETA)
+SELF.
      ELSE
 
         DEDX  = DEMEAN/STEP
         CALL GLANDZ(Z,STEP,VECT(7),GETOT,DEDX,DE,POTI,Q(JPROB+ 10))
 
      ENDIF
*
*        Add brem losses to ionisation
*        - wrong these are LOSSES, not a measured IONIZATION !!!
*
*      NB = 0
*      IF (ITRTYP.EQ.2) NB=2*NEK1
*      IF (ITRTYP.EQ.5) NB=  NEK1
*      IF (NB.GT.0) THEN
*         JBASE = LQ(JMA-1)+NB+IEKBIN
*         DE = DE +(1.-GEKRAT)*Q(JBASE)+GEKRAT*Q(JBASE+1)
*      ENDIF
*
      END
+DECK,GSMIXT
*CMZ :          02/09/97  18.34.00  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GSMIXT(IMAT,NAMATE,A,Z,DENS,NLMAT,WMAT)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Defines mixture OR COMPOUND IMAT as composed by          *
C.    *       THE BASIC NLMAT materials defined by arrays A,Z and WMAT *
C.    *                                                                *
C.    *       If NLMAT.GT.0 then WMAT contains the PROPORTION BY       *
C.    *       WEIGTHS OF EACH BASIC MATERIAL IN THE MIXTURE.           *
C.    *                                                                *
C.    *       If NLMAT.LT.0 then WMAT contains the number of atoms     *
C.    *       of a given kind into the molecule of the COMPOUND        *
C.    *       In this case, WMAT in output is changed to relative      *
C.    *       weigths.                                                 *
C.    *                                                                *
C.    *       nb : the radiation length is computed according          *
C.    *            the EGS manual slac-210 uc-32 June-78               *
C.    *                           formula  2-6-8 (37)                  *
C.    *                                                                *
C.    *    ==>Called by : <USER>, UGEOM                                *
C.    *       Authors    R.Brun, M.Maire  *********                    *
C.    *                                                                *
C.    *    Modifications:                                              *
C.    *    PN, 2.09.97  - Calculate Abs.Length for protons, not pions  *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCNUM
+SEQ,GCUNIT
+SEQ,GCMZFO
      DIMENSION WMAT(1),A(1),Z(1)
      CHARACTER*(*) NAMATE
      CHARACTER*20 NAME
      DATA ALR2AV , AL183 / 1.39621E-03  ,  5.20948 /
C.
C.    ------------------------------------------------------------------
C.
      IF (IMAT.LE.0)GO TO 99
      IF(JMATE.LE.0)THEN
         CALL MZBOOK(IXCONS,JMATE,JMATE,1,'MATE',NMATE,NMATE,0,3,0)
         IQ(JMATE-5)=0
      ENDIF
      IF(IMAT.GT.NMATE)THEN
         CALL MZPUSH(IXCONS,JMATE,IMAT-NMATE,0,'I')
         NMATE=IMAT
         JMA1=0
      ELSE
         JMA1=LQ(JMATE-IMAT)
         IF(JMA1.GT.0) THEN
            WRITE(CHMAIL,10000)
            CALL GMAIL(1,0)
            CALL GPMATE(IMAT)
            CALL MZDROP(IXCONS,LQ(JMATE-IMAT),' ')
         ENDIF
      ENDIF
      CALL MZBOOK(IXCONS,JMA,JMATE,-IMAT,'MATE',20,20,11,IOMATE,0)
C
      NAME=NAMATE
      NCH=LNBLNK(NAME)
      IF(NCH.GT.0)THEN
         IF(NAME(NCH:NCH).EQ.'$')NAME(NCH:NCH)=' '
      ENDIF
      CALL UCTOH(NAME,IQ(JMA+1),4,20)
C
C             Store mixture parameters
C             and parameter for Pair/Brems and
C             Photoelectric routines
C
      NLM    = IABS(NLMAT)
      IF (NLM.LE.0)GO TO 90
      CALL MZBOOK(IXCONS,JMIXT,JMA,-5,'MAMI',2,2,4*NLM,3,0)
      CALL MZBOOK(IXCONS,JMI1,JMIXT,-1,'MAM1',0,0,10,3,0)
      JMA = LQ(JMATE- IMAT)
      IQ(JMIXT-5)=IMAT
      IQ(JMI1-5)=IMAT
C
C             Compute proportion by weigths in the compound
C
      IF(NLMAT.LT.0) THEN
         AMOL   = 0.
         ZMOL   = 0.
         DO 10 I= 1,NLM
         AMOL   = AMOL + WMAT(I)*A(I)
         ZMOL   = ZMOL + WMAT(I)*Z(I)
   10    CONTINUE
         DO 20 I= 1,NLM
         WMAT(I)= WMAT(I)*A(I) / AMOL
   20    CONTINUE
      ENDIF
C
C             Compute effective mixture parameters
C
      AEFF   = 0.
      ZEFF   = 0.
      RADINV = 0.
      DO 40 I = 1,NLM
         AEFF   = AEFF + WMAT(I)*A(I)
         ZEFF   = ZEFF + WMAT(I)*Z(I)
         ZC     = Z(I)
         ALZ    = LOG(ZC)/3.
         XINV   = ZC*(ZC+GXSI(ZC))*(AL183-ALZ-GFCOUL(ZC))/A(I)
         RADINV = RADINV + WMAT(I)*XINV
         Q(JMIXT+3*NLM+I)=XINV
         Q(JMIXT + 2* NLM + I) = WMAT(I)
         Q(JMIXT + NLM + I) = Z(I)
         Q(JMIXT + I) = A(I)
   40 CONTINUE
      RADINV = ALR2AV * DENS * RADINV
      RADEFF = 1. / RADINV
      CALL GHMIX(A,WMAT,NLM,AHEFF)
      ABSEFF=10000.*AHEFF/(6.022*DENS*GHSIGM(5.,14,AHEFF))
C
      Q(JMA + 6) = AEFF
      Q(JMA + 7) = ZEFF
      Q(JMA + 8) = DENS
      Q(JMA + 9) = RADEFF
      Q(JMA + 10) = ABSEFF
      Q(JMA + 11) = NLM
      Q(JMI1 + 1) = AHEFF
      IF(NLMAT.GT.0)THEN
         Q(JMI1 + 2) = AEFF
         Q(JMI1 + 3) = ZEFF
      ELSE
         Q(JMI1 + 2) = AMOL
         Q(JMI1 + 3) = ZMOL
      ENDIF
C
      IF(JMA1.GT.0) THEN
         CALL GPMATE(-IMAT)
      ENDIF
C
      GO TO 99
C
  90  CHMAIL=' ***** GSMIXT ERROR. MIXTURE WITH NO COMPONENTS'
      CALL GMAIL(0,0)
C
  99  RETURN
10000 FORMAT(' *** GSMIXT ***: Warning, material redefinition:')
      END
+deck,trprfn.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 26/08/95  00.36.09  by  Pavel Nevski
*-- Author :
      SUBROUTINE TRPRFN(X1,P1,H1,X2,P2,H2,CH,XL,R,MVAR,IFLAG,ITRAN,IERR)
************************************************************************
*
*
*     SUBR. TRPRFN(X1,P1,H1,X2,P2,H2,CH,XL,*R*,MVAR,IFLAG,ITRAN,IERR*)
*
*     Origin W.Wittek    EMCSW/81/18
*
*     Finite step length case coded by V.Innocente ( Feb. 88 )
*
*     code improved:                   V.Innocente ( April. 90 )
*                   inline code replaces external function
*     code improved:                   V.Innocente ( January 91 )
*                   effect of energy loss added
*
*_______________________________________________________________________
*
* *** ERROR PROPAGATION ALONG A PARTICLE TRAJECTORY IN A MAGNETIC FIELD
*     ROUTINE ASSUMES THAT IN THE INTERVAL (X1,X2) THE QUANTITIES 1/P
*     AND (HX,HY,HZ) ARE CONSTANT.
*
* *** IFLAG  =  -1   INITIALIZATION, TRANSFORMATION OF ERROR MATRIX FROM
*                    EXTERNAL TO SC VARIABLES
*            =   0   ERROR PROPAGATION FROM X1 TO X2
*            =   1   TRANSFORMATION OF ERROR MATRIX FROM SC TO
*                    EXTERNAL VARIABLES
*
*     ITRAN          USED FOR IFLAG = 0 OR 1 ONLY
*            =   0   TRANSFORMATION MATRIX IS UPDATED ,BUT ERROR MATRIX IS NOT
*                    TRANSFORMED
*           =    1   TRANSF. MATRIX IS UPDATED  AND ERROR MATRIX IS TRANSFORMED
*
*     MVAR           SPECIFIES TYPE OF EXTERNAL VARIABLES
*            =   0   ( 1/P,LAMBDA,PHI,YT, ZT ;   SC   )
*            =   1   ( 1/P,  Y',  Z',  Y,  Z ; SPLINE )
*
* *** X1, P1, H1     X,Y,Z COMPONENTS OF POSITION, MOMENTUM AND MAGNETIC   INPUT
*                    FIELD VECTOR/GRADIENT AT STARTING POINT OF INTERVAL
*     X2, P2, H2     ......  AT END POINT OF INTERVAL                      INPUT
*     CH             CHARGE OF PARTICLE                                    INPUT
*     XL             PATHLENGTH FROM X1 TO X2   ( NEGATIVE IF OPPOSITE
*                    TO ACTUAL MOVEMENT OF PARTICLE )                      INPUT
*     R              ERROR MATRIX  (TRIANGLE)                       INPUT/OUTPUT
*     B              5 * 5 TRANSFORMATION MATRIX FOR ERRORS IN
*                    SC VARIABLES                                         OUTPUT
*
* *** IERR   =  1    ILLEGAL VALUE OF MVAR                                OUTPUT
*               2    MOMENTUM IS ZERO
*               3    H*ALFA/P AT X1 AND X2 DIFFER TOO MUCH
*               4    PARTICLE MOVES IN Z - DIRECTION
*
************************************************************************
*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  X1,P1,H1,X2,P2,H2,R,CH,PS,PC,XL,SPX
+CDE,TRCOM3.
+CDE,GCUNIT.
      DIMENSION X1(3),P1(3),H1(9),X2(3),P2(3),H2(9)
      DIMENSION R(15),PS(3),PC(3)
*
      DIMENSION T1(3),T2(3),U1(3),U2(3),V1(3),V2(3),HN(9)
      DIMENSION AN2(3),DX(3)
      DIMENSION HV1(3),HU1(3)
*
      SAVE INIT,DELHP6,CFACT8
*
      DATA INIT/0/
      DATA DELHP6/300.D0/
*
      DATA CFACT8 / 2.997925 D-4 /
*
*____________________________________________________________________
*
      IERR=0
      IF(IFLAG) 10, 20, 80
*
* *** TRANSFORM ERROR MATRIX FROM EXTERNAL TO INTERNAL VARIABLES;
*
   10 NEW=1
      IF(MVAR.NE.1) GO TO 11
      PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      IF(PA1.EQ.0.) GO TO 902
      PS(1)=1./PA1
      IF(P1(1).EQ.0.) GO TO 904
      PS(2)=P1(2)/P1(1)
      PS(3)=P1(3)/P1(1)
      SPX=1.
      IF(P1(1).LT.0.) SPX=-1.
      CALL TRSPSC(PS,R,PC,R,H1,CH,IERR,SPX)
      GO TO 19
*
   11 IF(MVAR.NE.0) GO TO 901
   19 GO TO 900
*
* *** ERROR PROPAGATION ON A HELIX ASSUMING SC VARIABLES
 
*
   20 PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      PA2=SQRT(P2(1)**2+P2(2)**2+P2(3)**2)
      IF(PA1*PA2.EQ.0.) GO TO 902
C      DPA = PA2 - PA1
      PM1=1./PA1
      PM2=1./PA2
      DPM = PM2 - PM1
*
      DO 201 I=1,3
        T1(I) = P1(I)*PM1
        T2(I) = P2(I)*PM2
201   CONTINUE
*
      SINL=T2(3)
      SINL0=T1(3)
*
      COSL=SQRT(ABS(1.-SINL**2))
      IF(COSL.EQ.0.) GO TO 904
      COSL1=1./COSL
      COSL0=SQRT(ABS(1.-SINL0**2))
*
* *** DEFINE TRANSFORMATION MATRIX BETWEEN X1 AND X2 FOR
* *** NEUTRAL PARTICLE OR FIELDFREE REGION
*
      DO 26 I=1,5
         DO 15 K=1,5
            A(I,K)=0.
   15    CONTINUE
         A(I,I)=1.
   26 CONTINUE
      A(4,3)=XL*COSL
      A(5,2)=XL
*
      IF(CH.EQ.0.) GO TO 45
      HA1=SQRT(H1(1)**2+H1(2)**2+H1(3)**2)
      HA2=SQRT(H2(1)**2+H2(2)**2+H2(3)**2)
      HAM1=HA1*PM1
      HAM2=HA2*PM2
      HAMX=MAX(HAM1,HAM2)
      IF(HAMX.EQ.0.) GO TO 45
*
*
*
* *** CHECK WHETHER H*ALFA/P IS TOO DIFFERENT AT X1 AND X2
*
*
      IF(HA2.NE.0.) THEN
         GAM=(H2(1)*T2(1)+H2(2)*T2(2)+H2(3)*T2(3))/HA2
      ELSE
         GAM=(H1(1)*T1(1)+H1(2)*T1(2)+H1(3)*T1(3))/HA1
      ENDIF
*
      ALFA2=1.-GAM**2
*
      DH2=(H1(1)*PM1-H2(1)*PM2)**2+
     1    (H1(2)*PM1-H2(2)*PM2)**2+
     1    (H1(3)*PM1-H2(3)*PM2)**2
      IF(DH2*ALFA2.GT.DELHP6**2) GO TO 903
*
* *** DEFINE AVERAGE MAGNETIC FIELD AND GRADIENT
*
      PM12=(PM1+PM2)*0.5
      P12=1./(2.*PM12)
      HN(1)=(H1(1)*PM1+H2(1)*PM2)*P12*CH*CFACT8
      HN(2)=(H1(2)*PM1+H2(2)*PM2)*P12*CH*CFACT8
      HN(3)=(H1(3)*PM1+H2(3)*PM2)*P12*CH*CFACT8
CC    HN(4)=(H1(4)*PM1+H2(4)*PM2)*P12*CH*CFACT8
CC    HN(5)=(H1(5)*PM1+H2(5)*PM2)*P12*CH*CFACT8
CC    HN(6)=(H1(6)*PM1+H2(6)*PM2)*P12*CH*CFACT8
CC    HN(7)=(H1(7)*PM1+H2(7)*PM2)*P12*CH*CFACT8
CC    HN(8)=(H1(8)*PM1+H2(8)*PM2)*P12*CH*CFACT8
CC    HN(9)=(H1(9)*PM1+H2(9)*PM2)*P12*CH*CFACT8
*
      HM = SQRT(HN(1)**2+HN(2)**2+HN(3)**2)
      OVER = 1./HM
      HN(1) = OVER*HN(1)
      HN(2) = OVER*HN(2)
      HN(3) = OVER*HN(3)
      PAV = .5*(PA1+PA2)
      Q = - HM/PAV
      THETA = Q*XL
      SINT = SIN(THETA)
      COST = COS(THETA)
      GAMMA=HN(1)*T2(1)+HN(2)*T2(2)+HN(3)*T2(3)
      AN2(1) = HN(2)*T2(3)-HN(3)*T2(2)
      AN2(2) = HN(3)*T2(1)-HN(1)*T2(3)
      AN2(3) = HN(1)*T2(2)-HN(2)*T2(1)
*
      AU = 1./SQRT(T1(1)**2+T1(2)**2)
      U1(1) = -AU*T1(2)
      U1(2) =  AU*T1(1)
      U1(3) =  0.D0
      V1(1) = -T1(3)*U1(2)
      V1(2) =  T1(3)*U1(1)
      V1(3) =  T1(1)*U1(2)-T1(2)*U1(1)
*
      AU = 1./SQRT(T2(1)**2+T2(2)**2)
      U2(1) = -AU*T2(2)
      U2(2) =  AU*T2(1)
      U2(3) =  0.D0
      V2(1) = -T2(3)*U2(2)
      V2(2) =  T2(3)*U2(1)
      V2(3) =  T2(1)*U2(2)-T2(2)*U2(1)
*
      DX(1) = X1(1) - X2(1)
      DX(2) = X1(2) - X2(2)
      DX(3) = X1(3) - X2(3)
*
*
* *** COMPLETE TRANSFORMATION MATRIX BETWEEN ERRORS AT X1 AND X2
* *** FIELD GRADIENT PERPENDICULAR TO TRACK IS PRESENTLY NOT
* *** TAKEN INTO ACCOUNT
*
   30 CONTINUE
      QP  = Q*PAV
      ANV = -(HN(1)*U2(1)+HN(2)*U2(2)            )
      ANU =  (HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3))
      OMCOST = 1.-COST
      TMSINT = THETA-SINT
*
      HU1(1) =            -HN(3)*U1(2)
      HU1(2) = HN(3)*U1(1)
      HU1(3) = HN(1)*U1(2)-HN(2)*U1(1)
*
      HV1(1) = HN(2)*V1(3)-HN(3)*V1(2)
      HV1(2) = HN(3)*V1(1)-HN(1)*V1(3)
      HV1(3) = HN(1)*V1(2)-HN(2)*V1(1)
*
***   1/P
*
      A(1,1) = 1.-DPM*PAV*(1.+(T2(1)*DX(1)+T2(2)*DX(2)+T2(3)*DX(3))/XL)
     +           +2.*DPM*PAV
*
      A(1,2) =  -DPM/THETA*
     1           ( TMSINT*GAMMA*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) +
     2             SINT*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3)) +
     3             OMCOST*(HV1(1)*T2(1)+HV1(2)*T2(2)+HV1(3)*T2(3)) )
*
      A(1,3) =  -COSL0*DPM/THETA*
     1           ( TMSINT*GAMMA*(HN(1)*U1(1)+HN(2)*U1(2)            ) +
     2             SINT*(U1(1)*T2(1)+U1(2)*T2(2)            ) +
     3             OMCOST*(HU1(1)*T2(1)+HU1(2)*T2(2)+HU1(3)*T2(3)) )
*
      A(1,4) =  -DPM/XL*(U1(1)*T2(1)+U1(2)*T2(2)            )
*
      A(1,5) =  -DPM/XL*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3))
*
***   Lambda
*
      A(2,1) = -QP*ANV*(T2(1)*DX(1)+T2(2)*DX(2)+T2(3)*DX(3))
     +         *(1.+DPM*PAV)
*
      A(2,2) = COST*(V1(1)*V2(1)+V1(2)*V2(2)+V1(3)*V2(3)) +
     +         SINT*(HV1(1)*V2(1)+HV1(2)*V2(2)+HV1(3)*V2(3)) +
     1         OMCOST*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3))*
     A                (HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3)) +
     2         ANV*( -SINT*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3)) +
     3         OMCOST*(V1(1)*AN2(1)+V1(2)*AN2(2)+V1(3)*AN2(3)) -
     4         TMSINT*GAMMA*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )
*
      A(2,3) = COST*(U1(1)*V2(1)+U1(2)*V2(2)            ) +
     +         SINT*(HU1(1)*V2(1)+HU1(2)*V2(2)+HU1(3)*V2(3)) +
     1         OMCOST*(HN(1)*U1(1)+HN(2)*U1(2)            )*
     A                (HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3)) +
     2         ANV*( -SINT*(U1(1)*T2(1)+U1(2)*T2(2)            ) +
     3         OMCOST*(U1(1)*AN2(1)+U1(2)*AN2(2)             ) -
     4         TMSINT*GAMMA*(HN(1)*U1(1)+HN(2)*U1(2)            ) )
      A(2,3) = COSL0*A(2,3)
*
      A(2,4) = -Q*ANV*(U1(1)*T2(1)+U1(2)*T2(2)            )
*
      A(2,5) = -Q*ANV*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3))
*
***   Phi
*
      A(3,1) = -QP*ANU*(T2(1)*DX(1)+T2(2)*DX(2)+T2(3)*DX(3))*COSL1
     +         *(1.+DPM*PAV)
*
      A(3,2) = COST*(V1(1)*U2(1)+V1(2)*U2(2)            ) +
     +         SINT*(HV1(1)*U2(1)+HV1(2)*U2(2)             ) +
     1         OMCOST*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3))*
     A                (HN(1)*U2(1)+HN(2)*U2(2)            ) +
     2         ANU*( -SINT*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3)) +
     3         OMCOST*(V1(1)*AN2(1)+V1(2)*AN2(2)+V1(3)*AN2(3)) -
     4         TMSINT*GAMMA*(HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )
      A(3,2) = COSL1*A(3,2)
*
      A(3,3) = COST*(U1(1)*U2(1)+U1(2)*U2(2)            ) +
     +         SINT*(HU1(1)*U2(1)+HU1(2)*U2(2)             ) +
     1         OMCOST*(HN(1)*U1(1)+HN(2)*U1(2)            )*
     A                (HN(1)*U2(1)+HN(2)*U2(2)            ) +
     2         ANU*( -SINT*(U1(1)*T2(1)+U1(2)*T2(2)            ) +
     3         OMCOST*(U1(1)*AN2(1)+U1(2)*AN2(2)             ) -
     4         TMSINT*GAMMA*(HN(1)*U1(1)+HN(2)*U1(2)            ) )
      A(3,3) = COSL1*COSL0*A(3,3)
*
      A(3,4) = -Q*ANU*(U1(1)*T2(1)+U1(2)*T2(2)            )*COSL1
*
      A(3,5) = -Q*ANU*(V1(1)*T2(1)+V1(2)*T2(2)+V1(3)*T2(3))*COSL1
*
***   Yt
*
      A(4,1) = PAV*(U2(1)*DX(1)+U2(2)*DX(2)            )
     +         *(1.+DPM*PAV)
*
      A(4,2) = (   SINT*(V1(1)*U2(1)+V1(2)*U2(2)            ) +
     1           OMCOST*(HV1(1)*U2(1)+HV1(2)*U2(2)             ) +
     2           TMSINT*(HN(1)*U2(1)+HN(2)*U2(2)            )*
     3                  (HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )/Q
*
      A(4,3) = (   SINT*(U1(1)*U2(1)+U1(2)*U2(2)            ) +
     1           OMCOST*(HU1(1)*U2(1)+HU1(2)*U2(2)             ) +
     2           TMSINT*(HN(1)*U2(1)+HN(2)*U2(2)            )*
     3                  (HN(1)*U1(1)+HN(2)*U1(2)            ) )*COSL0/Q
*
      A(4,4) = (U1(1)*U2(1)+U1(2)*U2(2)            )
*
      A(4,5) = (V1(1)*U2(1)+V1(2)*U2(2)            )
*
***   Zt
*
      A(5,1) = PAV*(V2(1)*DX(1)+V2(2)*DX(2)+V2(3)*DX(3))
     +         *(1.+DPM*PAV)
*
      A(5,2) = (   SINT*(V1(1)*V2(1)+V1(2)*V2(2)+V1(3)*V2(3)) +
     1           OMCOST*(HV1(1)*V2(1)+HV1(2)*V2(2)+HV1(3)*V2(3)) +
     2           TMSINT*(HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3))*
     3                  (HN(1)*V1(1)+HN(2)*V1(2)+HN(3)*V1(3)) )/Q
*
      A(5,3) = (   SINT*(U1(1)*V2(1)+U1(2)*V2(2)            ) +
     1           OMCOST*(HU1(1)*V2(1)+HU1(2)*V2(2)+HU1(3)*V2(3)) +
     2           TMSINT*(HN(1)*V2(1)+HN(2)*V2(2)+HN(3)*V2(3))*
     3                  (HN(1)*U1(1)+HN(2)*U1(2)            ) )*COSL0/Q
*
      A(5,4) = (U1(1)*V2(1)+U1(2)*V2(2)            )
*
      A(5,5) = (V1(1)*V2(1)+V1(2)*V2(2)+V1(3)*V2(3))
   45 CONTINUE
*
* *** NEW = 0  TRANSFORMATION MATRIX IS UPDATED
*           1  TRANSFORMATION MATRIX IS INITIALIZED
*
      IF(NEW.EQ.0) GO TO 23
      NEW=0
      DO 25 I=1,5
         DO 24 K=1,5
            B(I,K)=A(I,K)
   24    CONTINUE
   25 CONTINUE
      GO TO 27
   23 CONTINUE
*
      CALL XMM55(A,B,B)
*
   27 CONTINUE
   80 IF(ITRAN.EQ.0) GO TO 90
*
*
      J=0
      DO 22 I=1,5
         DO 21 K=I,5
            J=J+1
            S(J)=R(J)
   21    CONTINUE
   22 CONTINUE
*
*
* *** TRANSFORM ERROR MATRIX
*
      CALL SSMT5T(B,S,S)
*
      NEW=1
 
      J=0
      DO 41 I=1,5
         DO 40 K=I,5
            J=J+1
            R(J)=S(J)
   40    CONTINUE
   41 CONTINUE
*
   90 IF(IFLAG.LE.0) GO TO 900
*
*
* *** TRANSFORM ERROR MATRIX FROM INTERNAL TO EXTERNAL VARIABLES;
*
*
      NEW=1
      IF(MVAR.NE.1) GO TO 91
      PC(1)=PM2
      PC(2)=ASIN(P2(3)*PC(1))
      IF (ABS (P2(1)) .LT. 1.E-30) P2(1) = 1.E-30
      PC(3)=ATAN2(P2(2),P2(1))
      CALL TRSCSP(PC,R,PS,R,H2,CH,IERR,SPX)
      GO TO 900
*
   91 IF(MVAR.NE.0) GO TO 901
      GO TO 900
*
* *** ERROR EXITS
*
  901 IERR=1
      GO TO 999
  902 IERR=2
      GO TO 999
  903 IERR=3
C     IF(INIT.NE.0) GO TO 30
*     WRITE (LOUT, 998) DH2,ALFA2,XL
  998 FORMAT('0',' *** S/R TRPROP   DELTA(H*ALFA/P)',5X
     1,'EXCEEDS TOLERANCE    '/'0',3E12.5//' **********    ',///)
      INIT=1
      GO TO 30
  904 IERR=4
  999 WRITE (LOUT, 1000) IERR
 1000 FORMAT(1H ,' *** S/R ERPROP   IERR =',I5)
*
  900 CONTINUE
      END
 
+deck,trprop.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 26/08/95  00.38.03  by  Pavel Nevski
*-- Author :
C
      SUBROUTINE TRPROP(X1,P1,H1,X2,P2,H2,CH,XL,R,MVAR,IFLAG,ITRAN,IERR)
C
C *** ERROR PROPAGATION ALONG A PARTICLE TRAJECTORY IN A MAGNETIC FIELD
C     ROUTINE ASSUMES THAT IN THE INTERVAL (X1,X2) THE QUANTITIES 1/P
C     AND (HX,HY,HZ) ARE RATHER CONSTANT. DELTA(PHI) MUST NOT BE TOO LARGE
C
C     Authors: A. Haas and W. Wittek
C
C *** IFLAG  =  -1   INITIALIZATION, TRANSFORMATION OF ERROR MATRIX FROM
C                    EXTERNAL TO SC VARIABLES
C            =   0   ERROR PROPAGATION FROM X1 TO X2
C            =   1   TRANSFORMATION OF ERROR MATRIX FROM SC TO
C                    EXTERNAL VARIABLES
C
C     ITRAN          USED FOR IFLAG = 0 OR 1 ONLY
C            =   0   TRANSFORMATION MATRIX IS UPDATED ,BUT ERROR MATRIX IS NOT
C                    TRANSFORMED
C           =    1   TRANSF. MATRIX IS UPDATED  AND ERROR MATRIX IS TRANSFORMED
C
C     MVAR           SPECIFIES TYPE OF EXTERNAL VARIABLES
C            =   0   ( 1/P,LAMBDA,PHI,YT, ZT ;   SC   )
C            =   1   ( 1/P,  Y',  Z',  Y,  Z ; SPLINE )
C
C *** X1, P1, H1     X,Y,Z COMPONENTS OF POSITION, MOMENTUM AND MAGNETIC   INPUT
C                    FIELD VECTOR/GRADIENT AT STARTING POINT OF INTERVAL
C     X2, P2, H2     ......  AT END POINT OF INTERVAL                      INPUT
C     CH             CHARGE OF PARTICLE                                    INPUT
C     XL             PATHLENGTH FROM X1 TO X2   ( NEGATIVE IF OPPOSITE
C                    TO ACTUAL MOVEMENT OF PARTICLE )                      INPUT
C     R              ERROR MATRIX  (TRIANGLE)                       INPUT/OUTPUT
C     B              5 * 5 TRANSFORMATION MATRIX FOR ERRORS IN
C                    SC VARIABLES                                         OUTPUT
C
C *** IERR   =  1    ILLEGAL VALUE OF MVAR                                OUTPUT
C               2    MOMENTUM IS ZERO
C               3    H*ALFA/P AT X1 AND X2 DIFFER TOO MUCH
C                    OR DELTA PHI IS TOO LARGE
C               4    PARTICLE MOVES IN Z - DIRECTION
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  X1,P1,H1,X2,P2,H2,R,CH,PS,PC,XL,SPX
+CDE,TRCOM3.
+CDE,GCUNIT.
      DIMENSION X1(3),P1(3),H1(9),X2(3),P2(3),H2(9)
      DIMENSION R(15),PS(3),PC(3),HN(9)
C
      SAVE INIT,DELHP6,CFACT8
*
      DATA INIT/0/
      DATA DELHP6/300.D0/,DELFI6/0.1D0/
      DATA CFACT8 / 2.997925 D-4 /
C
      IERR=0
      IF(IFLAG) 10, 20, 80
C
C *** TRANSFORM ERROR MATRIX FROM EXTERNAL TO INTERNAL VARIABLES;
C
   10 NEW=1
      IF(MVAR.NE.1) GO TO 11
      PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      IF(PA1.EQ.0.) GO TO 902
      PS(1)=1./PA1
      IF(P1(1).EQ.0.) GO TO 904
      PS(2)=P1(2)/P1(1)
      PS(3)=P1(3)/P1(1)
      SPX=1.
      IF(P1(1).LT.0.) SPX=-1.
      CALL TRSPSC(PS,R,PC,R,H1,CH,IERR,SPX)
      GO TO 19
C
   11 IF(MVAR.NE.0) GO TO 901
   19 GO TO 900
C
C *** ERROR PROPAGATION ON A HELIX ASSUMING SC VARIABLES
 
C
   20 PA1=SQRT(P1(1)**2+P1(2)**2+P1(3)**2)
      PA2=SQRT(P2(1)**2+P2(2)**2+P2(3)**2)
      IF(PA1*PA2.EQ.0.) GO TO 902
      PM1=1./PA1
      PM2=1./PA2
C
      TN(1)=P1(1)+P2(1)
      TN(2)=P1(2)+P2(2)
      TN(3)=P1(3)+P2(3)
      PM12=1./SQRT(TN(1)**2+TN(2)**2+TN(3)**2)
      TN(1)=TN(1)*PM12
      TN(2)=TN(2)*PM12
      TN(3)=TN(3)*PM12
C
      SINL=TN(3)
      COSL=SQRT(ABS(1.-SINL**2))
      IF(COSL.EQ.0.) GO TO 904
      COSL1=1./COSL
      SINP=TN(2)*COSL1
      COSP=TN(1)*COSL1
C
C *** DEFINE TRANSFORMATION MATRIX BETWEEN X1 AND X2 FOR
C *** NEUTRAL PARTICLE OR FIELDFREE REGION
C
      DO 26 I=1,5
         DO 15 K=1,5
            A(I,K)=0.
   15    CONTINUE
         A(I,I)=1.
   26 CONTINUE
      A(4,3)=XL*COSL
      A(5,2)=XL
C
      IF(CH.EQ.0.) GO TO 45
      HA1=SQRT(H1(1)**2+H1(2)**2+H1(3)**2)
      HA2=SQRT(H2(1)**2+H2(2)**2+H2(3)**2)
      HAM1=HA1*PM1
      HAM2=HA2*PM2
      HAMX = MAX(HAM1,HAM2)
      IF(HAMX.EQ.0.) GO TO 45
C
C *** DEFINE AVERAGE MAGNETIC FIELD AND GRADIENT
C
      PM12=(PM1+PM2)*0.5
      P12=1./(2.*PM12)
      HN(1)=(H1(1)*PM1+H2(1)*PM2)*P12*CH*CFACT8
      HN(2)=(H1(2)*PM1+H2(2)*PM2)*P12*CH*CFACT8
      HN(3)=(H1(3)*PM1+H2(3)*PM2)*P12*CH*CFACT8
      HN(4)=(H1(4)*PM1+H2(4)*PM2)*P12*CH*CFACT8
      HN(5)=(H1(5)*PM1+H2(5)*PM2)*P12*CH*CFACT8
      HN(6)=(H1(6)*PM1+H2(6)*PM2)*P12*CH*CFACT8
      HN(7)=(H1(7)*PM1+H2(7)*PM2)*P12*CH*CFACT8
      HN(8)=(H1(8)*PM1+H2(8)*PM2)*P12*CH*CFACT8
      HN(9)=(H1(9)*PM1+H2(9)*PM2)*P12*CH*CFACT8
C
      B0=HN(1)*COSP+HN(2)*SINP
      B2=-HN(1)*SINP+HN(2)*COSP
      B3=-B0*SINL+HN(3)*COSL
      TGL=SINL*COSL1
C
C
C *** CHECK WHETHER H*ALFA/P IS TOO DIFFERENT AT X1 AND X2
C     AND WHETHER CHANGE OF TRACK DIRECTION DUE TO MAG.FIELD IS TOO LARGE
C
C
      IF(HA2.EQ.0.) GO TO 29
 
      GAM=(H2(1)*TN(1)+H2(2)*TN(2)+H2(3)*TN(3))/HA2
      GO TO 28
   29 GAM=(H1(1)*TN(1)+H1(2)*TN(2)+H1(3)*TN(3))/HA1
   28 CONTINUE
      ALFA=SQRT(ABS(1.-GAM**2))
C
      DH2=(H1(1)*PM1-H2(1)*PM2)**2+
     1    (H1(2)*PM1-H2(2)*PM2)**2+
     1    (H1(3)*PM1-H2(3)*PM2)**2
      IF(DH2*ALFA**2.GT.DELHP6**2) GO TO 903
      ALFAQ=-ALFA*CFACT8*(HAM1+HAM2)*0.5
      DFI=ABS(XL*ALFAQ)
      IF(DFI.GT.DELFI6) GO TO 903
C
C *** COMPLETE TRANSFORMATION MATRIX BETWEEN ERRORS AT X1 AND X2
C *** TAKING INTO ACCOUNT  FIELD GRADIENT PERPENDICULAR TO TRACK
C
   30 COSP2=COSP*COSP
      SINP2=SINP*SINP
      COSIP=COSP*SINP
C
      G22=SINP2*HN(9)+COSP2*HN(8)-2.0*COSIP*HN(7)
      G33=SINL*SINL*(COSP2*HN(9)+SINP2*HN(8)+2.0*COSIP*HN(7))
     ++COSL*(COSL*HN(6)-2.0*SINL*(COSP*HN(4)+SINP*HN(5)))
      G23=SINL*(COSIP*(HN(9)-HN(8))+(SINP2-COSP2)*HN(7))
     ++COSL*(COSP*HN(5)-SINP*HN(4))
C
      A(2,1)=XL*B2
      A(2,3)=-B0*XL*PM12
      A(2,4)=(B2*B3*PM12+G22)*XL*PM12
      A(2,5)=(-B2*B2*PM12+G23)*XL*PM12
C
      A(3,1)=-XL*B3*COSL1
      A(3,2)=B0*XL*PM12*COSL1**2
      A(3,3)=1.+TGL*B2*XL*PM12
      A(3,4)=(-B3*B3*PM12-G23)*XL*PM12*COSL1
      A(3,5)=(B3*B2*PM12-G33)*XL*PM12*COSL1
C
      A(4,5)=-B3*TGL*XL*PM12
      A(5,4)=B3*TGL*XL*PM12
C
   45 CONTINUE
C
C *** NEW = 0  TRANSFORMATION MATRIX IS UPDATED
C           1  TRANSFORMATION MATRIX IS INITIALIZED
C
      IF(NEW.EQ.0) GO TO 23
      NEW=0
      DO 25 I=1,5
         DO 24 K=1,5
            B(I,K)=A(I,K)
   24    CONTINUE
   25 CONTINUE
      GO TO 27
   23 CONTINUE
C
      CALL XMM55(A,B,B)
C
   27 CONTINUE
   80 IF(ITRAN.EQ.0) GO TO 90
C
C
      J=0
      DO 22 I=1,5
         DO 21 K=I,5
            J=J+1
            S(J)=R(J)
   21    CONTINUE
   22 CONTINUE
C
C
C *** TRANSFORM ERROR MATRIX
C
      CALL SSMT5T(B,S,S)
C
      NEW=1
 
      J=0
      DO 41 I=1,5
         DO 40 K=I,5
            J=J+1
            R(J)=S(J)
   40    CONTINUE
   41 CONTINUE
C
   90 IF(IFLAG.LE.0) GO TO 900
C
C
C *** TRANSFORM ERROR MATRIX FROM INTERNAL TO EXTERNAL VARIABLES;
C
C
      NEW=1
      IF(MVAR.NE.1) GO TO 91
      PC(1)=PM2
      PC(2)=ASIN(P2(3)*PC(1))
      IF (ABS (P2(1)) .LT. 1.E-30) P2(1) = 1.E-30
      PC(3) = ATAN2 (P2(2),P2(1))
      CALL TRSCSP(PC,R,PS,R,H2,CH,IERR,SPX)
      GO TO 900
C
   91 IF(MVAR.NE.0) GO TO 901
      GO TO 900
C
C *** ERROR EXITS
C
  901 IERR=1
      GO TO 999
  902 IERR=2
      GO TO 999
  903 IERR=3
      IF(INIT.NE.0) GO TO 30
C     WRITE (LOUT, 998) DH2,DFI,ALFA,XL
C 998 FORMAT(1H0,48H *** S/R TRPROP   DELTA(H*ALFA/P)  OR DELTA(PHI),5X
C    1,22HEXCEEDS TOLERANCE     /1H0,4E12.5//16H **********    ,
C    251HATTENTION !   NO FURTHER WARNINGS WILL BE GIVEN    ///)
      INIT=1
      GO TO 30
  904 IERR=4
  999 WRITE (LOUT, 1000) IERR
 1000 FORMAT(1H ,' *** S/R ERPROP   IERR =',I5)
C
  900 RETURN
      END
 
+deck,trscsp.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
C
      SUBROUTINE TRSCSP(PC,RC,PS,RS,H,CH,IERR,SPX)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM   SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C      TO  SPLINE VARIABLES (1/P,Y',Z',Y,Z)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PC(3)     1/P,LAMBDA,PHI                          INPUT
C     PS(3)     1/P,Y',Z'                              OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES        INPUT     (TRIANGLE)
C     RS(15)    ERROR MATRIX IN SPLINE VARIABLES       OUTPUT     (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (Y',YT),(Y',ZT),(Z',YT),(Z',ZT)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RS FOR FIXED X
C
C     IERR  =   1       PARTICLE MOVES PERPENDICULAR TO X-AXIS
C                      ( Y',Z' ARE NOT DEFINED )
C     SPX       SIGN OF X-COMPONENT OF PARTICLE MOMENTUM   OUTPUT
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PC,PS,H,RC,RS,CH,SPX
+CDE,TRCOM3.
      DIMENSION PC(3),PS(3),H(3),RC(15),RS(15)
      DIMENSION UN(3),VN(3)
C
      DATA CFACT8 / 2.997925 D-4 /
C
      IERR=0
      PM=PC(1)
      COSL=COS(PC(2))
      SINP=SIN(PC(3))
      COSP=COS(PC(3))
C
      TN(1)=COSL*COSP
      SPX=1.
      IF(TN(1).LT.0.) SPX=-1.
      IF(TN(1).EQ.0.) GO TO 901
      TN(2)=COSL*SINP
      TN(3)=SIN(PC(2))
C
      T1R=1./TN(1)
      PS(1)=PC(1)
      PS(2)=SINP/COSP
      PS(3)=TN(3)*T1R
C
      UN(1)=-SINP
      UN(2)=COSP
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
C
      J=0
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
      Q=-HAM*CFACT8
C
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)           )*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
 
      T3R=Q*T1R**3
      A(2,4)=-UN(1)*(VN(3)*COSZ           )*T3R
      A(2,5)=-VN(1)*(VN(3)*COSZ           )*T3R
      A(3,4)=UN(1)*(VN(2)*COSZ-UN(2)*SINZ)*T3R
      A(3,5)=VN(1)*(VN(2)*COSZ-UN(2)*SINZ)*T3R
C
    6 T2R=T1R**2
C
      A(1,1)=1.
      A(2,3)=VN(3)*COSL*T2R
      A(3,2)=UN(2)*T2R
      A(3,3)=-VN(2)*COSL*T2R
      A(4,4)=VN(3)*T1R
      A(5,4)=-VN(2)*T1R
      A(5,5)=UN(2)*T1R
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RS(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
C *** ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
      RETURN
      END
 
+deck,trspsc.
*CMZ :          14/11/97  16.33.57  by  Pavel Nevski
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
C
      SUBROUTINE TRSPSC(PS,RS,PC,RC,H,CH,IERR,SPX)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM SPLINE VARIABLES (1/P,Y',Z',Y,Z)
C      TO    SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PS(3)     1/P,Y',Z'                               INPUT
C     PC(3)     1/P,LAMBDA,PHI                         OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RS(15)    ERROR MATRIX IN SPLINE VARIABLES        INPUT      (TRIANGLE)
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES       OUTPUT      (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (LAMBDA,Y),(LAMBDA,Z),(PHI,Y),(PHI,Z)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RS FOR FIXED X
C
C     IERR              NOT USED
C     SPX       SIGN OF X-COMPONENT OF PARTICLE MOMENTUM    INPUT
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PS,PC,H,RC,RS,CH,SPX
+CDE,TRCOM3.
      DIMENSION PS(3),PC(3),H(3),RC(15),RS(15)
      DIMENSION UN(3),VN(3)
C
      DATA CFACT8 / 2.997925 D-4 /
C
      IERR=0
      PM=PS(1)
      TN(1)=1./SQRT(1.+PS(2)**2+PS(3)**2)
      IF(SPX.LT.0.) TN(1)=-TN(1)
      TN(2)=PS(2)*TN(1)
      TN(3)=PS(3)*TN(1)
C
      PC(1)=PS(1)
      PC(2)=ASIN(TN(3))
      IF (ABS (TN(1)) .LT. 1.E-30) TN(1) = 1.E-30
      PC(3) = ATAN2 (TN(2),TN(1))
C
      COSL=SQRT(ABS(1.-TN(3)**2))
      IF (COSL .LT. 1.E-30) COSL = 1.E-30
      COSL1=1./COSL
      UN(1)=-TN(2)*COSL1
      UN(2)=TN(1)*COSL1
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RS(J)
    4    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
 
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
C
      Q=-HAM*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)           )*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(2,4)=-Q*TN(2)*SINZ
      A(2,5)=-Q*TN(3)*SINZ
      A(3,4)=-Q*TN(2)*COSZ*COSL1
      A(3,5)=-Q*TN(3)*COSZ*COSL1
C
    6 A(1,1)=1.
      A(2,2)=TN(1)*VN(2)
      A(2,3)=TN(1)*VN(3)
      A(3,2)=TN(1)*UN(2)*COSL1
      A(4,4)=UN(2)
      A(5,4)=VN(2)
      A(5,5)=VN(3)
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RC(J)=S(J)
   20    CONTINUE
   25 CONTINUE
*
* *** ERROR EXITS
*
      END
 
+deck,trscsd.
*CMZ :  1.00/00 26/08/95  01.41.40  by  Pavel Nevski
*-- Author :
C
      SUBROUTINE TRSCSD(PC,RC,PD,RD,H,CH,IERR,SPU,DJ,DK)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM   SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C      TO         VARIABLES (1/P,V',W',V,W)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PC(3)     1/P,LAMBDA,PHI                          INPUT
C     PD(3)     1/P,V',W'                              OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES        INPUT     (TRIANGLE)
C     RD(15)    ERROR MATRIX IN 1/P,V',W',V,W          OUTPUT     (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (V',YT),(V',ZT),(W',YT),(W',ZT)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RD FOR FIXED U
C     DJ(3)     UNIT VECTOR IN V-DIRECTION
C     DK(3)     UNIT VECTOR IN W-DIRECTION    OF DETECTOR SYSTEM
C
C     IERR  =   1       PARTICLE MOVES PERPENDICULAR TO U-AXIS
C                      ( V',W' ARE NOT DEFINED )
C     SPU       SIGN OF U-COMPONENT OF PARTICLE MOMENTUM   OUTPUT
C
+SELF,IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL  PC,PD,H,RC,RD,CH,DJ,DK,SPU
+SELF.
+SEQ, TRCOM3.
      DIMENSION PC(3),PD(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
+SELF,IF= SINGLE.
      DATA CFACT8 / 2.997925 E-4 /
+SELF,IF=-SINGLE.
      DATA CFACT8 / 2.997925 D-4 /
+SELF.
C
      IERR=0
      PM=PC(1)
      COSL=COS(PC(2))
      SINP=SIN(PC(3))
      COSP=COS(PC(3))
C
      TN(1)=COSL*COSP
      TN(2)=COSL*SINP
      TN(3)=SIN(PC(2))
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      TVW(1)=TN(1)*DI(1)+TN(2)*DI(2)+TN(3)*DI(3)
      SPU=1.
      IF(TVW(1).LT.0.) SPU=-1.
      TVW(2)=TN(1)*DJ(1)+TN(2)*DJ(2)+TN(3)*DJ(3)
      TVW(3)=TN(1)*DK(1)+TN(2)*DK(2)+TN(3)*DK(3)
      IF(TVW(1).EQ.0.) GO TO 901
C
      T1R=1./TVW(1)
      PD(1)=PC(1)
      PD(2)=TVW(2)*T1R
      PD(3)=TVW(3)*T1R
C
      UN(1)=-SINP
      UN(2)=COSP
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
C
      J=0
 
      DO 10 I=1,5
         DO 5 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RC(J)
    5    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
      Q=-HAM*CFACT8
C
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      T3R=Q*T1R**3
      UI=UN(1)*DI(1)+UN(2)*DI(2)+UN(3)*DI(3)
      VI=VN(1)*DI(1)+VN(2)*DI(2)+VN(3)*DI(3)
      A(2,4)=-UI*(VK*COSZ-UK*SINZ)*T3R
      A(2,5)=-VI*(VK*COSZ-UK*SINZ)*T3R
      A(3,4)= UI*(VJ*COSZ-UJ*SINZ)*T3R
      A(3,5)= VI*(VJ*COSZ-UJ*SINZ)*T3R
C
    6 T2R=T1R**2
C
      A(1,1)=1.
      A(2,2)=-UK*T2R
      A(2,3)=VK*COSL*T2R
      A(3,2)=UJ*T2R
      A(3,3)=-VJ*COSL*T2R
      A(4,4)=VK*T1R
      A(4,5)=-UK*T1R
      A(5,4)=-VJ*T1R
      A(5,5)=UJ*T1R
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RD(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
C *** ERROR EXITS
C
  901 IERR=1
  910 CONTINUE
C
      RETURN
      END
*
+DECK,TRSDSC.
*CMZ :  1.00/00 07/10/95  13.25.14  by  Pavel Nevski
*-- Author :   A. Haas and W. Wittek
C
      SUBROUTINE TRSDSC(PD,RD,PC,RC,H,CH,IERR,SPU,DJ,DK)
C
C *** TRANSFORMS ERROR MATRIX
C     FROM        VARIABLES (1/P,V',W',V,W)
C      TO    SC   VARIABLES (1/P,LAMBDA,PHI,YT,ZT)
C
C     Authors: A. Haas and W. Wittek
C
C
C *** PD(3)     1/P,V',W'                               INPUT
C     PC(3)     1/P,LAMBDA,PHI                         OUTPUT
C     H(3)      MAGNETIC FIELD                          INPUT
C     RD(15)    ERROR MATRIX IN 1/P,V',W',V,W           INPUT      (TRIANGLE)
C     RC(15)    ERROR MATRIX IN   SC   VARIABLES       OUTPUT      (TRIANGLE)
C     CH        CHARGE OF PARTICLE                      INPUT
C               CHARGE AND MAGNETIC FIELD ARE NEEDED
C               FOR CORRELATION TERMS (LAMBDA,V),(LAMBDA,W),(PHI,V),(PHI,W)
C               THESE CORRELATION TERMS APPEAR BECAUSE RC IS ASSUMED
C               TO BE THE ERROR MATRIX FOR FIXED S (PATH LENGTH)
C               AND RD FOR FIXED U
C     DJ(3)     UNIT VECTOR IN V-DIRECTION
C     DK(3)     UNIT VECTOR IN W-DIRECTION    OF DETECTOR SYSTEM
C
C     IERR              NOT USED
C     SPU       SIGN OF U-COMPONENT OF PARTICLE MOMENTUM    INPUT
C
+SELF,IF=-SINGLE.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL   PD,PC,H,RC,RD,CH,DJ,DK,SPU
+SELF.
+SEQ, TRCOM3.
      DIMENSION PD(3),PC(3),H(3),RC(15),RD(15),DJ(3),DK(3)
      DIMENSION UN(3),VN(3),DI(3),TVW(3)
C
+SELF,IF= SINGLE.
      DATA CFACT8 / 2.997925 E-4 /
+SELF,IF=-SINGLE.
      DATA CFACT8 / 2.997925 D-4 /
+SELF.
C
      IERR=0
      PM=PD(1)
      TVW(1)=1./SQRT(1.+PD(2)**2+PD(3)**2)
      IF(SPU.LT.0.) TVW(1)=-TVW(1)
      TVW(2)=PD(2)*TVW(1)
      TVW(3)=PD(3)*TVW(1)
C
      DI(1)=DJ(2)*DK(3)-DJ(3)*DK(2)
      DI(2)=DJ(3)*DK(1)-DJ(1)*DK(3)
      DI(3)=DJ(1)*DK(2)-DJ(2)*DK(1)
C
      DO 5 I=1,3
         TN(I)=TVW(1)*DI(I)+TVW(2)*DJ(I)+TVW(3)*DK(I)
    5 CONTINUE
C
      PC(1)=PD(1)
      PC(2)=ASIN(TN(3))
      IF (ABS (TN(1)) .LT. 1.E-30) TN(1) = 1.E-30
      PC(3) = ATAN2 (TN(2),TN(1))
C
      COSL=SQRT(ABS(1.-TN(3)**2))
      IF (COSL .LT. 1.E-30) COSL = 1.E-30
      COSL1=1./COSL
      UN(1)=-TN(2)*COSL1
      UN(2)=TN(1)*COSL1
      UN(3)=0.
C
      VN(1)=-TN(3)*UN(2)
      VN(2)=TN(3)*UN(1)
      VN(3)=COSL
 
C
      UJ=UN(1)*DJ(1)+UN(2)*DJ(2)+UN(3)*DJ(3)
      UK=UN(1)*DK(1)+UN(2)*DK(2)+UN(3)*DK(3)
      VJ=VN(1)*DJ(1)+VN(2)*DJ(2)+VN(3)*DJ(3)
      VK=VN(1)*DK(1)+VN(2)*DK(2)+VN(3)*DK(3)
C
      J=0
      DO 10 I=1,5
         DO 4 K=I,5
            J=J+1
            A(I,K)=0.
            A(K,I)=0.
            S(J)=RD(J)
    4    CONTINUE
   10 CONTINUE
C
      IF(CH.EQ.0.) GO TO 6
      HA=SQRT(H(1)**2+H(2)**2+H(3)**2)
      HAM=HA*PM
      IF(HAM.EQ.0.) GO TO 6
      HM=CH/HA
C
      Q=-HAM*CFACT8
C
      SINZ=-(H(1)*UN(1)+H(2)*UN(2)+H(3)*UN(3))*HM
      COSZ= (H(1)*VN(1)+H(2)*VN(2)+H(3)*VN(3))*HM
      A(2,4)=-Q*TVW(2)*SINZ
      A(2,5)=-Q*TVW(3)*SINZ
      A(3,4)=-Q*TVW(2)*COSZ*COSL1
      A(3,5)=-Q*TVW(3)*COSZ*COSL1
C
    6 A(1,1)=1.
      A(2,2)=TVW(1)*VJ
      A(2,3)=TVW(1)*VK
      A(3,2)=TVW(1)*UJ*COSL1
      A(3,3)=TVW(1)*UK*COSL1
      A(4,4)=UJ
      A(4,5)=UK
      A(5,4)=VJ
      A(5,5)=VK
C
      CALL SSMT5T(A,S,S)
C
      J=0
      DO 25 I=1,5
         DO 20 K=I,5
            J=J+1
            RC(J)=S(J)
   20    CONTINUE
   25 CONTINUE
C
      RETURN
C
C *** ERROR EXITS
C
      END
 
+deck,ssmt5t.
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
      SUBROUTINE SSMT5T(A,S,R)
C *** ------------------------------------------------------            05/07/81
C *** TRANSFORMATION OF SYMMETRIC 5X5 MATRIX S: A*S*AT -> R.
C *** A IS A GENERAL 5X5 MATRIX WHEREAS S,R ARE SYMMETRIC
C *** MATRICES STORED IN TRIANGULAR FORM. FOR:I,J=1,5
C *** R(I,J) = SUM:K=1,5(SUM:L=1,5(A(I,L)*S(L,K)*A(J,K))).
C *** NB: S AND R MAY WELL BE THE SAME MATRIX.
C
C        Author: A. Haas (Freiburg University)
C
C *** ------------------------------------------------------
      DOUBLE PRECISION A,S,R,Q,T1,T2,T3,T4,T5
      DIMENSION A(25),S(15),R(15),Q(15)
      DO 5 I=1,15
         Q(I)=S(I)
    5 CONTINUE
      K=1
      DO 15 J=1,5
         T1=A(J   )
         T2=A(J+ 5)
         T3=A(J+10)
         T4=A(J+15)
         T5=A(J+20)
         DO 10 I=J,5
            R(K)=A(I   )*(Q(1)*T1+Q(2)*T2+Q( 3)*T3+Q( 4)*T4+Q( 5)*T5)
     +          +A(I+ 5)*(Q(2)*T1+Q(6)*T2+Q( 7)*T3+Q( 8)*T4+Q( 9)*T5)
     +          +A(I+10)*(Q(3)*T1+Q(7)*T2+Q(10)*T3+Q(11)*T4+Q(12)*T5)
     +          +A(I+15)*(Q(4)*T1+Q(8)*T2+Q(11)*T3+Q(13)*T4+Q(14)*T5)
     +          +A(I+20)*(Q(5)*T1+Q(9)*T2+Q(12)*T3+Q(14)*T4+Q(15)*T5)
            K=K+1
   10    CONTINUE
   15 CONTINUE
*
      END
 
+deck,xmm55.
*CMZ :  1.00/00 19/03/92  12.19.31  by  Federico Carminati
*-- Author :
      SUBROUTINE XMM55(A,B,C)
C *** ---------------------------------------------                     05/07/81
C *** MULTIPLICATION OF 5X5 MATRICES: A*B -> C.
C *** FOR:I,J=1,5   C(I,J)=SUM:K=1,5(A(I,K)B(K,J))
C *** NB: B AND C MAY WELL BE THE SAME MATRIX
C
C        Author: A. Haas (Freiburg University)
C
C *** ---------------------------------------------
      DOUBLE PRECISION A,B,C,B1J,B2J,B3J,B4J,B5J
      DIMENSION A(25),B(25),C(25)
      DO 10 J5=5,25,5
         B5J=B(J5)
         J4=J5-1
         B4J=B(J4)
         J3=J4-1
         B3J=B(J3)
         J2=J3-1
         B2J=B(J2)
         J1=J2-1
         B1J=B(J1)
         C(J1)=A( 1)*B1J+A( 6)*B2J+A(11)*B3J+A(16)*B4J+A(21)*B5J
         C(J2)=A( 2)*B1J+A( 7)*B2J+A(12)*B3J+A(17)*B4J+A(22)*B5J
         C(J3)=A( 3)*B1J+A( 8)*B2J+A(13)*B3J+A(18)*B4J+A(23)*B5J
         C(J4)=A( 4)*B1J+A( 9)*B2J+A(14)*B3J+A(19)*B4J+A(24)*B5J
         C(J5)=A( 5)*B1J+A(10)*B2J+A(15)*B3J+A(20)*B4J+A(25)*B5J
   10 CONTINUE
*
      END
+DECK,GZEBRA.
*CMZ :          07/12/97  17.29.02  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.19  by  S.Giani
*-- Author :
      SUBROUTINE GZEBRA(NZEB)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Routine to initialise ZEBRA store (//)                   *
C.    *                                                                *
C.    *    ==>Called by : <USER>                                       *
C.    *       Author    R.Brun  *********                              *
C.    *                                                                *
C.    *       Modifications:                                           *
C.    *   PN: Ellastic zebra inspired by V.Perevozchikov               *
C.    ******************************************************************
C.
+CDE,TYPING,GCBANK,GCFLAG.
       INTEGER I1,I2,Itry,LL,KWW,memget,LOCF,NZEB
C.
C.    ------------------------------------------------------------------
C.
       NZEBRA = abs(NZEB)
       NZEBRA = max(NZEBRA,1000000)
       I1     = LOCF   (IQ)
       Do iTry=0,5
          I2  = memget (NZEBRA*4+1000)/4
          If (I2.GT.I1) GO TO 11
          NZEBRA = NZEBRA/2
          PRINT *,'* GZEBRA: requested memory size reduced to ',
     >               Nzebra,' *'
       enddo
       PRINT *,' iTRY,NZEBRA,I1,I2 =', iTRY,NZEBRA,I1,I2
       STOP    ' GZEBRA: FATAL - CAN NOT ALLOCATE MEMORY '
C
  11   LL     = max    (I2-I1,0)
       NZEBRA = LL + NZEBRA
       KWW    = LL + 100
C
       CALL MZSTOR (IXSTOR,'/GCBANK/',' ',FENDQ,LQ,LR1,WS,
     >                                    LQ(KWW+100),LQ(NZEBRA-100))
       IF (IDEBUG.GE.3) CALL MZLOGL(IXSTOR,0)
       I1     = KWBANK
       CALL MZWORK (IXSTOR,LQ(I1),LQ(KWW),5)
       CALL GWORK  (KWBANK-100)
C
      END
 
 
 
 
 
+DECK,GFINDS
*CMZ :          06/12/97  17.19.33  by  Pavel Nevski
*CMZ :  3.21/02 06/07/94  18.26.03  by  S.Giani
*-- Author :
      SUBROUTINE GFINDS
C.
C.    ******************************************************************
C.    *                                                                *
C.    *       Returns the set/volume parameters corresponding to       *
C.    *       the current space point in /GCTRAK/                      *
C.    *       and fill common /GCSETS/                                 *
C.    *                                                                *
C.    *       IHSET  user set identifier                               *
C.    *       IHDET  user detector identifier                          *
C.    *       ISET set number in JSET                                  *
C.    *       IDET   detector number in JS=LQ(JSET-ISET)               *
C.    *       IDTYPE detector type (1,2)                               *
C.    *       NUMBV  detector volume numbers (array of length NVNAME)  *
C.    *       NVNAME number of volume levels                           *
C.    *                                                                *
C.    *    ==>Called by : GTRACK                                       *
C.    *       Author    R.Brun  *********                              *
C.    *       Modified  V.Perev                                        *
C.    *       Jattf corrected by Bagdan Pavlik (Cracow)                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCSETS
+SEQ,GCVOLU
+SEQ,GCTMED
+SELF,IF=DEBUG
      INTEGER        LNAM(15), LNUM(15)
+SELF
      JATTF(JV) = JV + Nint(Q(JV+5)) + 6
C.
C.    ------------------------------------------------------------------
C.
*
+SELF, IF=DEBUG.
      WRITE(CHMAIL,1000)NLEVEL
      CALL GMAIL (0, 0)
      DO 5 I    = 1,NLEVEL
        WRITE(CHMAIL,1001)NAMES(I),NUMBER(I),LVOLUM(I),LINDEX(I)
        CALL GMAIL (0, 0)
        WRITE(CHMAIL,1002)(GTRAN(J,I),J = 1,3),(GRMAT(J,I),J=1,10)
        CALL GMAIL (0, 0)
    5   CONTINUE
 1000 FORMAT (' DEBUG : GFINDS =',I3)
 1001 FORMAT (5(1X,A4,3I3))
 1002 FORMAT (1X,13F9.4)
      NLEV = NLEVEL
      CALL UCOPY (NAMES (1),LNAM(1),NLEV)
      CALL UCOPY (NUMBER(1),LNUM(1),NLEV)
      NLEVEL    = 0
      CALL GLVOLU (NLEV, LNAM, LNUM, IER)
      IF (IER.NE.0)             STOP
+SELF.
*
      IHSET = 0
      IHDET = 0
      ISET  = 0
      IDET  = 0
      IDTYPE = 0
      NVNAME = 0
*
      DO 10 NLEV = NLEVEL,1,-1
         JVO = LQ(JVOLUM-LVOLUM(NLEV))
         JAT = JATTF(JVO)
         IDET = Q(JAT+8)
         IF(IDET.NE.0) THEN
            NL = NLEV
            GO TO 15
         ENDIF
  10  CONTINUE
      GOTO 99
  15  ISET   = Q(JAT+7)
      IDTYPE = Q(JAT+9)
      IHSET  = IQ(JSET+ISET)
      JS     = LQ(JSET-ISET)
      IHDET  = IQ(JS+IDET)
      JD     = LQ(JS-IDET)
      NVNAME = IQ(JD+2)
      DO 40 I=1,NVNAME
            NAME=IQ(JD+2*I+9)
            NUMBV(I)=0
            DO 30 J=1,NLEVEL
               IF(NAMES(J).EQ.NAME)THEN
                  NUMBV(I)=NUMBER(J)
                  GO TO 40
               ENDIF
  30        CONTINUE
  40  CONTINUE
C
   99 END
+DECK,FLUFIN,IF=hadron.
*CMZ :          29/01/98  13.12.38  by  Pavel Nevski
*CMZ :  3.21/02 19/05/94  13.35.12  by  S.Ravndal
*-- Author :
      SUBROUTINE FLUFIN
+CDE,GCBANK.
+CDE,GCCUTS.
+CDE,GCJLOC.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCTMED.
+CDE,GCUNIT.
+CDE,GFKDIS.
*CDE,DIMPAR,FINUCT,PART2T,COMCONT,FHEAVYT,PAPROPT
*CDE,       FINUC, PART2, COMCON, FHEAVY, PAPROP
*KEEP,DIMPAR.
*                                                                     *
*=== dimpar ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      DIMPAR: included in any routine                                *
*                                                                     *
*          Mxxrgn = maximum number of regions                         *
*          Mxxmdf = maximum number of media in Fluka                  *
*          Mxxmde = maximum number of media in Emf                    *
*          Mfstck = stack dimension in Fluka                          *
*          Mestck = stack dimension in Emf                            *
*          Nallwp = number of allowed particles                       *
*          Mpdpdx = number of particle types for which EM dE/dx pro-  *
*                   cesses (ion,pair,bremss) have to be computed      *
*          Icomax = maximum number of materials for compounds (equal  *
*                   to the sum of the number of materials for every   *
*                   compound )                                        *
*          Nstbis = number of stable isotopes recorded in common iso- *
*                   top                                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( MXXRGN = 500  )
      PARAMETER ( MXXMDF = 50   )
      PARAMETER ( MXXMDE = 18   )
      PARAMETER ( MFSTCK = 1000 )
      PARAMETER ( MESTCK = 100  )
      PARAMETER ( NALLWP = 39   )
      PARAMETER ( MPDPDX = 8    )
      PARAMETER ( ICOMAX = 120  )
      PARAMETER ( NSTBIS = 304  )
 
*KEEP,FINUCT.
      DOUBLE PRECISION CXR, CYR, CZR, TKI, PLR, WEI, TV, TVCMS,
     &                 TVRECL, TVHEAV, TVBIND
 
*KEEP,FINUC.
*
*=== finuc ============================================================*
*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990     by Alfredo Ferrari, INFN Milan   *
*     include file: finuc copy                   created 26/11/86 by pa*
*     note: if changed change finuc2 copy also                         *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        np        = number of secondaries                             *
*        kpart(ip) = type of the secondary ip                          *
*        cxr(ip)   = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyr(ip)   = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czr(ip)   = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        tki(ip)   = kinetic energy of secondary ip                    *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXR (MXP), CYR (MXP), CZR (MXP), TKI (MXP),
     &                 PLR (MXP), WEI (MXP), TV, TVCMS, TVRECL, TVHEAV,
     &                 TVBIND, NP0, NP, KPART (MXP)
 
      REAL RNDM(1)
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
*KEEP,PART2T.
      DOUBLE PRECISION AAM, GA, TAU, AAMDSC
 
*KEEP,PART2.
*
*=== part2 ============================================================*
*
*----------------------------------------------------------------------*
*     Include file: part2 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part3 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AAM  (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AAMDSC (IDMAX8), IICH   (IDMAX8), IIBAR  (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)
 
*KEEP,COMCONT.
      DOUBLE PRECISION AOCMBC, CONTNT, SUMACN, CABINX, CABELX,
     &                 ANXNOR, ELXNOR, CONA13, SUMZMF
 
*KEEP,COMCON.
*
*=== comcon ===========================================================*
*
*----------------------------------------------------------------------*
*                                                                      *
*     include file: comcon copy                 created 26/11/86 by pa *
*                                                                      *
*     Last change  on  30-oct-92   by   Alfredo Ferrari, INFN - Milan  *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /comcon/ contains information about compounds                    *
*         icompl(imat) = number of materials in a compound             *
*         matnum(i)    = material numbers (compounds consist of the    *
*                        materials)                                    *
*         aocmbc(i)    = atomic densities in barn**-1 cm**-1           *
*                        (Atoms Over Cm times Barn for Compounds)      *
*         cona13(i)    = A^1/3 of the constituents                     *
*         sumzmf(i)    = cumulative z^2 for multiple scattering        *
*         contnt(i)    = partial densities                             *
*         sumacn(i)    = cumulative atom contents of the compounds     *
*         cabinx(i)    = cumulative at.cont.*inelastic cross section   *
*         cabelx(i)    = cumulative at.cont.*  elastic cross section   *
*         anxnor       = total inelastic cross section                 *
*         elxnor       = total   elastic cross section                 *
*----------------------------------------------------------------------*
*
      COMMON /FKCOMC/ AOCMBC (ICOMAX), CONA13 (ICOMAX), SUMZMF (ICOMAX),
     &                CONTNT (ICOMAX), SUMACN (ICOMAX), CABINX (ICOMAX),
     &                CABELX (ICOMAX), ANXNOR, ELXNOR,  ICOMPL (MXXMDF),
     &                MATNUM (ICOMAX)
 
*KEEP,FHEAVYT.
      DOUBLE PRECISION CXHEAV, CYHEAV, CZHEAV, TKHEAV, PHEAVY,
     &                 WHEAVY, AMHEAV
 
*KEEP,FHEAVY.
*
*=== fheavy ===========================================================*
*
*----------------------------------------------------------------------*
*     Last change on 9 March 1993     by Alfredo Ferrari, INFN Milan   *
*     include file: fheavy copy       created 5/4/90 by A. Ferrari     *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /fheavy/ is the storage for heavy secondaries created in the     *
*              nuclear evaporation                                     *
*        npheav     = number of secondaries                            *
*        kheavy(ip) = type of the secondary ip                         *
*                   ( 3 = deuteron, 4 = 3-H, 5 = 3-He, 6 = 4-He,       *
*                     7-12 = "Heavy" fragment specified by Ibheav and  *
*                     Icheav )                                         *
*        cxheav(ip) = direction cosine of the secondary ip             *
*                     with respect to x-axis                           *
*        cyheav(ip) = direction cosine of the secondary ip             *
*                     with respect to y-axis                           *
*        czheav(ip) = direction cosine of the secondary ip             *
*                     with respect to z-axis                           *
*        tkheav(ip) = kinetic energy of secondary ip                   *
*        pheavy(ip) = momentum of the secondary ip                     *
*        wheavy(ip) = weight of the secondary ip                       *
*        amheav(ip) = atomic masses of the six types of evaporated     *
*                     particles                                        *
*        anheav(kp) = name of the kp-type heavy particle               *
*        icheav(kp) = charge of the kp-type heavy particle             *
*        ibheav(kp) = mass number of the kp-type heavy particle        *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*   !!! There is now the possibility to produce up to 6 "heavy" !!!!   *
*   !!! fragments besides the residual nucleus recorded in      !!!!   *
*   !!! Resnuc: they are identified by indeces 7-12, of course  !!!!   *
*   !!! the corresponding physical properties (Z,A,m..) must be !!!!   *
*   !!! updated every time they are produced                    !!!!   *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*----------------------------------------------------------------------*
*
      PARAMETER ( MXHEAV = 100 )
      CHARACTER*8 ANHEAV
      COMMON / FKHEAV / CXHEAV (MXHEAV), CYHEAV (MXHEAV),
     &                  CZHEAV (MXHEAV), TKHEAV (MXHEAV),
     &                  PHEAVY (MXHEAV), WHEAVY (MXHEAV),
     &                  AMHEAV  ( 12 ) ,
     &                  KHEAVY (MXHEAV), ICHEAV  ( 12 ) ,
     &                  IBHEAV  ( 12 ) , NPHEAV
      COMMON / FKHEAC / ANHEAV  ( 12 )
 
*KEEP,PAPROP.
*
*=== paprop ===========================================================*
*
*----------------------------------------------------------------------*
*     include file: paprop copy                   created 26/11/86 by p*
*     changes: on  16 december 1992 by Alfredo Ferrari                 *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /paprop/ contains particle properties                            *
*        btype  = literal name of the particle                         *
*        am     = particle mass in gev                                 *
*        ichrge = electric charge of the particle                      *
*        iscore = explanations for the scored distribution             *
*        genpar = names of the generalized particles                   *
*        ijdisc = list of the particle types to be discarded           *
*        thalf  = half life of the particle in sec                     *
*        biasdc = decay biasing factors                                *
*        biasin = inelastic interaction biasing factors                *
*        lhadro = flag for hadrons                                     *
*        jspinp = particle spin (in units of 1/2)                      *
*        lbsdcy = logical flag for biased decay: if .true. the biasing *
*                 factor is used as an upper limit to the decay length *
*        lprbsd = logical flag for biased decay: if .true. the biasing *
*                 factor is applied only to primaries                  *
*        lprbsi = logical flag for inelastic interaction biasing: if   *
*                 .true. the biasing factor is applied only to prima-  *
*                 ries                                                 *
*                                                                      *
*----------------------------------------------------------------------*
*
      LOGICAL LHADRO, LBSDCY, LPRBSD, LPRBSI
      CHARACTER*8 BTYPE,GENPAR
      COMMON / FKPAPR / AM  (NALLWP), AMDISC (NALLWP), THALF  (NALLWP),
     &               BIASDC (NALLWP), BIASIN (NALLWP), ICHRGE (NALLWP),
     &               ISCORE     (10), IJDISC (NALLWP), LHADRO (NALLWP),
     &               JSPINP (NALLWP), LBSDCY (NALLWP), LPRBSD, LPRBSI
      COMMON / FKCHPR / BTYPE  (NALLWP), GENPAR (30)
 
*KEEP,PAPROPT.
      DOUBLE PRECISION AM, AMDISC, THALF,BIASDC, BIASIN
*KEND.
 
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
+CDE,AGCHADR.
*
C     geant  message - NDONE positive
C     guhadr message - NREST positive
*
      IF (NDONE.GT.0 .AND. NREST.GT.0)  GO TO 81
      NDONE  = 0
      NREST  = 0
      NP     = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF ((IGF.EQ.1).OR.
     +      (GEKIN.EQ.0..AND.ITRTYP.EQ.3.AND.IPART.NE.25)) THEN
         CALL GHEISH
         IGF = 0
         GOTO 999
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         LMEC(NMEC)=30
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
         GO TO 105
      ENDIF
*
      NREST = NP+NPHEAV
      NDONE = 0
*
   81    ISTOP=1
         NSTAK1 = MIN(MAX(0,NP-NDONE),MXGKIN-NGKINE)
         DO 90  K=NDONE+1,NDONE+NSTAK1
            NREST  = NREST  - 1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NDONE2 = MAX(NDONE+NSTAK1-NP,0)
         NSTAK2 = MIN(MAX(0,NPHEAV-NDONE2),MXGKIN-NGKINE)
*
         DO 100 K=NDONE2+1,NDONE2+NSTAK2
            NREST  = NREST  - 1
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
  105  KCASE=NAMEC(12)
 
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
 
  999 END
 
+DECK,GHEISH,IF=hadron.
*CMZ :          16/12/97  13.31.05  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.38  by  S.Giani
*-- Author :
      SUBROUTINE GHEISH
C
C *** MAIN STEERING FOR HADRON SHOWER DEVELOPMENT ***
C *** NVE 15-JUN-1988 CERN GENEVA ***
C
C CALLED BY : GUHADR (USER ROUTINE)
C ORIGIN : F.CARMINATI, H.FESEFELDT
C                       ROUTINES : CALIM  16-SEP-1987
C                                  SETRES 19-AUG-1985
C                                  INTACT 06-OCT-1987
C
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCCUTS.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTMED.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCUNIT.
C --- GHEISHA COMMONS ---
*KEEP,MXGKGH.
      PARAMETER (MXGKGH=100)
*KEEP,/BLANKP.
      PARAMETER (MXGKPV=MXGKGH)
      COMMON /VECUTY/ PV(10,MXGKPV)
C
*KEEP,/CONSTS.
      COMMON/CONSTS/ PI,TWPI,PIBTW,MP,MPI,MMU,MEL,MKCH,MK0,SMP,SMPI,
     $               SMU,CT,CTKCH,CTK0,
     $               ML0,MSP,MS0,MSM,MX0,MXM,CTL0,CTSP,CTSM,CTX0,CTXM,
     $               RMASS(35),RCHARG(35)
C
                     REAL MP,MPI,MMU,MEL,MKCH,MK0,
     *                    ML0,MSP,MS0,MSM,MX0,MXM
C
*KEEP,/EVENT.
      PARAMETER (MXEVEN=12*MXGKGH)
      COMMON/EVENT / NSIZE,NCUR,NEXT,NTOT,EVE(MXEVEN)
C
*KEEP,/PRNTFL.
      COMMON/PRNTFL/INBCD,NEWBCD,INBIN,NEWBIN,NPEVT,NEVTP,LPRT,NPRT(10)
                    LOGICAL LPRT,NPRT
C
*KEND.
C
C --- "NEVENT" CHANGED TO "KEVENT" IN COMMON /CURPAR/ DUE TO CLASH ---
C --- WITH VARIABLE "NEVENT" IN GEANT COMMON ---
C
      PARAMETER (MXGKCU=MXGKGH)
      COMMON /CURPAR /WEIGHT(10),DDELTN,IFILE,IRUN,NEVT,KEVENT,SHFLAG,
     $                ITHST,ITTOT,ITLST,IFRND,TOFCUT,CMOM(5),CENG(5),
     $                RS,S,ENP(10),NP,NM,NN,NR,NO,NZ,IPA(MXGKCU),
     $                ATNO2,ZNO2
C
C --- "IPART" CHANGED TO "KPART" IN COMMON /RESULT/ DUE TO CLASH ---
C --- WITH VARIABLE "IPART" IN GEANT COMMON ---
C
      COMMON /RESULT/ XEND,YEND,ZEND,RCA,RCE,AMAS,NCH,TOF,PX,PY,PZ,
     $                USERW,INTCT,P,EN,EK,AMASQ,DELTN,ITK,NTK,KPART,IND,
     $                LCALO,ICEL,SINL,COSL,SINP,COSP,
     $                XOLD,YOLD,ZOLD,POLD,PXOLD,PYOLD,PZOLD,
     $                XSCAT,YSCAT,ZSCAT,PSCAT,PXSCAT,PYSCAT,PZSCAT
                      REAL NCH,INTCT
C
C --- "ABSL(21)" CHANGED TO "ABSLTH(21)" IN COMMON /MAT/ DUE TO CLASH ---
C --- WITH VARIABLE "ABSL" IN GEANT COMMON ---
C
      COMMON /MAT/ LMAT,
     $             DEN(21),RADLTH(21),ATNO(21),ZNO(21),ABSLTH(21),
     $             CDEN(21),MDEN(21),X0DEN(21),X1DEN(21),RION(21),
     $             MATID(21),MATID1(21,24),PARMAT(21,10),
     $             IFRAT,IFRAC(21),FRAC1(21,10),DEN1(21,10),
     $             ATNO1(21,10),ZNO1(21,10)
C
      DIMENSION IPELOS(35)
      SAVE IDEOL
C
C --- TRANSFER GEANT CUT-OFFS INTO GHEISHA VALUES ---
      DIMENSION CUTS(5)
      EQUIVALENCE (CUTS(1),CUTGAM)
      DIMENSION RNDM(1)
C
*KEEP,PCODIM.
C --- DIMENSION STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DIMENSION KIPART(48),IKPART(35)
C
*KEEP,PCODAT.
C --- DATA STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DATA KIPART/
     $               1,   3,   4,   2,   5,   6,   8,   7,
     $               9,  12,  10,  13,  16,  14,  15,  11,
     $              35,  18,  20,  21,  22,  26,  27,  33,
     $              17,  19,  23,  24,  25,  28,  29,  34,
     $              35,  35,  35,  35,  35,  35,  35,  35,
     $              35,  35,  35,  35,  30,  31,  32,  35/
C
      DATA IKPART/
     $               1,   4,   2,   3,   5,   6,   8,   7,
     $               9,  11,  16,  10,  12,  14,  15,  13,
     $              25,  18,  26,  19,  20,  21,  27,  28,
     $              29,  22,  23,  30,  31,  45,  46,  47,
     $              24,  32,  48/
C
*KEND.
C
C --- DENOTE STABLE PARTICLES ACCORDING TO GHEISHA CODE ---
C --- STABLE : GAMMA, NEUTRINO, ELECTRON, PROTON AND HEAVY FRAGMENTS ---
C --- WHEN STOPPING THESE PARTICLES ONLY LOOSE THEIR KINETIC ENERGY ---
      DATA IPELOS/
     $             1,   1,   0,   1,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   0,   0,
     $             0,   0,   0,   0,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   1,   1,
     $             0,   0,   1/
C
C --- LOWERBOUND OF KINETIC ENERGY BIN IN N CROSS-SECTION TABLES ---
      DATA TEKLOW /0.0001/
C
C --- KINETIC ENERGY TO SWITCH FROM "CASN" TO "GNSLWD" FOR N CASCADE ---
      DATA SWTEKN /0.05/
C
      DATA IDEOL/0/
C
C --- INITIALIZE RELEVANT GHEISHA VARIABLES IN CASE NOT DONE ALREADY ---
      IF (IFINIT(4) .EQ. 0) CALL GHEINI
C
C --- SET THE INTERACTION MECHANISM TO "HADR" ---
      KCASE=NAMEC(12)
C
C --- SET GHEISHA PRINTING FLAGS ACCORDING TO "DEBUG" STEERING CARD --
      IF (IDEOL .EQ. IDEBUG) GO TO 9000
C
      IF (IDEBUG .NE. 1) GO TO 9001
C
C --- SET SELECTED DEBUGGING FLAGS ---
      DO 9002 LL=1,10
      IF ((ISWIT(LL) .LE. 100) .OR. (ISWIT(LL) .GT. 110)) GO TO 9002
      JJ=ISWIT(LL)-100
      NPRT(JJ)=.TRUE.
 9002 CONTINUE
      GO TO 9000
C
C --- NO DEBUGGING SELECTED ---
 9001 CONTINUE
      DO 9003 LL=1,10
      NPRT(LL)=.FALSE.
 9003 CONTINUE
      IDEOL=IDEBUG
C
 9000 CONTINUE
C
C --- SET THE GHEISHA PARTICLE TYPE TO THE ONE OF GEANT ---
      IF(IPART.GT.48) THEN
         IF(ISTOP.EQ.0) GOTO 9999
         JPA = LQ(JPART-IPART)
         AMAS=Q(JPA+7)
         NCH =Q(JPA+8)
         KPART=-IPART
         GOTO 107
      ENDIF
      NETEST=IKPART(KPART)
      IF ((NETEST .EQ. IPART) .OR. (ISTOP .NE. 0)) GO TO 9004
C
      PRINT 8881,IPART,KPART,ISTOP
 8881 FORMAT(' *GHEISH* IPART,KPART = ',2(I3,1X),' ISTOP = ',I3/
     $ ' *GHEISH* ======> PARTICLE TYPES DO NOT MATCH <=======')
      STOP
C
 9004 CONTINUE
      KPART=KIPART(IPART)
      KKPART=KPART
      AMAS=RMASS(KPART)
      NCH=RCHARG(KPART)
C
C --- TRANSPORT THE TRACK NUMBER TO GHEISHA AND INITIALISE SOME NUMBERS
 107  NTK=ITRA
      INTCT=0.0
      NEXT=1
      NTOT=0
      TOF=0.0
C
C --- FILL RESULT COMMON FOR THIS TRACK WITH GEANT VALUES ---
C --- CALIM CODE ---
      XEND=VECT(1)
      YEND=VECT(2)
      ZEND=VECT(3)
      PX=VECT(4)
      PY=VECT(5)
      PZ=VECT(6)
      USERW=UPWGHT
C --- SETRES CODE ---
      P=VECT(7)
      AMASQ=AMAS*AMAS
      EN=SQRT(AMASQ+P*P)
      EK=ABS(EN-ABS(AMAS))
      ENOLD=EN
C
      SINL=0.0
      COSL=1.0
      SINP=0.0
      COSP=1.0
C
      IF (ABS(P) .LE. 1.0E-10) GO TO 1
      SINL=PZ
      COSL=SQRT(ABS(1.0-SINL**2))
C
 1    CONTINUE
      CALL GRNDM(RNDM,1)
      PHI=RNDM(1)*TWPI
      IF ((PX .EQ. 0.0) .AND. (PY .EQ. 0.0)) GOTO 3
      IF (ABS(PX) .LT. 1.E-10) GOTO 2
      PHI=ATAN2(PY,PX)
      GOTO 3
C
 2    CONTINUE
      IF (PY .GT. 0.0) PHI=PI/2.0
      IF (PY .LE. 0.0) PHI=3.0*PI/2.0
C
 3    CONTINUE
      SINP=SIN(PHI)
      COSP=COS(PHI)
C
C --- SET GHEISHA INDEX FOR THE CURRENT MEDIUM ALWAYS TO 1 ---
      IND=1
C
C --- TRANSFER GLOBAL MATERIAL CONSTANTS FOR CURRENT MEDIUM ---
C --- DETAILED DATA FOR COMPOUNDS IS OBTAINED VIA ROUTINE COMPO ---
      ATNO(IND+1)=A
      ZNO(IND+1)=Z
      DEN(IND+1)=DENS
      RADLTH(IND+1)=RADL
      ABSLTH(IND+1)=ABSL
C
C --- SETUP PARMAT FOR PHYSICS STEERING ---
      PARMAT(IND+1,5)=0.0
      PARMAT(IND+1,8)=IPFIS
      PARMAT(IND+1,9)=0.0
      PARMAT(IND+1,10)=0.0
      JTMN=LQ(JTM)
      IF (JTMN .LE. 0) GO TO 4
      PARMAT(IND+1,5)=Q(JTMN+26)
 4    CONTINUE
C
C --- CHECK WHETHER PARTICLE IS STOPPING OR NOT ---
      IF (ISTOP .EQ. 0) GO TO 5
C
      IF (NPRT(9)) PRINT 1000,KPART
 1000 FORMAT(' *GHEISH* STOPPING GHEISHA PARTICLE ',I3)
      CALL GHSTOP
C --- IN CASE OF DECAY OF PARTICLE OR USER PARTICLE ==> RETURN ---
      IF (LMEC(NMEC) .EQ. 5 .OR. KPART .LT. 0) GO TO 9999
C --- IN CASE OF HAD. INT. WITH GENERATION OF SEC. ==> GO TO 40 ---
      IF (IHADR .NE. 2) GO TO 40
C --- ALSO DEPOSIT REST MASS ENERGY FOR IN-STABLE PARTICLES ---
      IF (IPELOS(KPART) .EQ. 0) DESTEP=DESTEP+ABS(RMASS(KPART))
      GO TO 9999
  5   CONTINUE
C
C --- INDICATE LIGHT (<= PI) AND HEAVY PARTICLES (HISTORICALLY) ---
C --- CALIM CODE ---
      J=2
      TEST=RMASS(7)-0.001
      IF (ABS(AMAS) .LT. TEST) J=1
C
C *** DIVISION INTO VARIOUS INTERACTION CHANNELS DENOTED BY "INT" ***
C THE CONVENTION FOR "INT" IS THE FOLLOWING
C
C INT  = -1 REACTION CROSS SECTIONS NOT YET TABULATED/PROGRAMMED
C      =  0 NO INTERACTION
C      =  1 ELEASTIC SCATTERING
C      =  2 INELASTIC SCATTERING
C      =  3 NUCLEAR FISSION WITH INELEASTIC SCATTERING
C      =  4 NEUTRON CAPTURE
C
C --- INTACT CODE ---
      KK=ABS(Q(JMA+11))
      ALAM1=0.0
      CALL GRNDM(RNDM,1)
      RAT=RNDM(1)*ALAM
      NMEC=NMEC+1
      ATNO2=A
      ZNO2 =Z
C
      DO 6 K=1,KK
      IF (KK .LE. 0) GO TO 6
C
      IF (KK .EQ. 1) GO TO 7
      ATNO2=Q(JMIXT+K)
      ZNO2 =Q(JMIXT+K+KK)
C
 7    CONTINUE
C
C --- TRY FOR ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
      ALAM1=ALAM1+AIEL(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR INELASTIC SCATTERING ---
      INT=2
      LMEC(NMEC)=20
      ALAM1=ALAM1+AIIN(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NUCLEAR FISSION WITH INELASTIC SCATTERING ---
      INT=3
      LMEC(NMEC)=15
      ALAM1=ALAM1+AIFI(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NEUTRON CAPTURE ---
      INT=4
      LMEC(NMEC)=18
      ALAM1=ALAM1+AICA(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
 6    CONTINUE
C --- NO REACTION SELECTED ==> ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
C
C *** TAKE ACTION ACCORDING TO SELECTED REACTION CHANNEL ***
C --- FOLLOWING CODE IS A TRANSLATION OF "CALIM" INTO GEANT JARGON ---
C
 8    CONTINUE
      IF (NPRT(9)) PRINT 1001,INT
 1001 FORMAT(' *GHEISH* INTERACTION TYPE CHOSEN INT = ',I3)
C
C --- IN CASE OF NO INTERACTION OR UNKNOWN CROSS SECTIONS ==> DONE ---
      IF (INT .LE. 0) GO TO 40
C
C --- IN CASE OF NON-ELASTIC SCATTERING AND NO GENERATION OF SEC. ---
C --- PARTICLES DEPOSIT TOTAL PARTICLE ENERGY AND RETURN ---
      IF ((INT .EQ. 1) .OR. (IHADR .NE. 2)) GO TO 9
      ISTOP=2
      DESTEP=DESTEP+EN
      NGKINE=0
      GO TO 9999
C
 9    CONTINUE
      IF (INT .NE. 4) GO TO 10
C
C --- NEUTRON CAPTURE ---
      IF (NPRT(9)) PRINT 2000
 2000 FORMAT(' *GHEISH* ROUTINE CAPTUR WILL BE CALLED')
      ISTOP=1
      CALL CAPTUR(NOPT)
      GO TO 40
C
 10   CONTINUE
      IF (INT .NE. 3) GO TO 11
C --- NUCLEAR FISSION ---
      IF (NPRT(9)) PRINT 2001
 2001 FORMAT(' *GHEISH* ROUTINE FISSIO WILL BE CALLED')
      ISTOP=1
      TKIN=FISSIO(EK)
      GO TO 40
C
 11   CONTINUE
C
C --- ELASTIC AND INELASTIC SCATTERING ---
      PV( 1,MXGKPV)=P*PX
      PV( 2,MXGKPV)=P*PY
      PV( 3,MXGKPV)=P*PZ
      PV( 4,MXGKPV)=EN
      PV( 5,MXGKPV)=AMAS
      PV( 6,MXGKPV)=NCH
      PV( 7,MXGKPV)=TOF
      PV( 8,MXGKPV)=KPART
      PV( 9,MXGKPV)=0.
      PV(10,MXGKPV)=USERW
C
C --- ADDITIONAL PARAMETERS TO SIMULATE FERMI MOTION AND EVAPORATION ---
      DO 111 JENP=1,10
         ENP(JENP)=0.
 111  CONTINUE
      ENP(5)=EK
      ENP(6)=EN
      ENP(7)=P
C
      IF (INT .NE. 1) GO TO 12
C
C *** ELASTIC SCATTERING PROCESSES ***
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C --- NORMAL ELASTIC SCATTERING FOR LIGHT MEDIA ---
      IF (ATNO2 .LT. 1.5) GO TO 35
C
C --- COHERENT ELASTIC SCATTERING FOR HEAVY MEDIA ---
      IF (NPRT(9)) PRINT 2002
 2002 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED')
      CALL COSCAT
      GO TO 40
C
C *** NON-ELASTIC SCATTERING PROCESSES ***
 12   CONTINUE
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C *** USE SOMETIMES NUCLEAR REACTION ROUTINE "NUCREC" FOR LOW ENERGY ***
C *** PROTON AND NEUTRON SCATTERING ***
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=4.5*(EK-0.01)
      IF ((KPART .EQ. 14) .AND. (TEST1 .GT. TEST2)) GO TO 85
      IF ((KPART .EQ. 16) .AND. (TEST1 .GT. TEST2)) GO TO 86
C
C *** FERMI MOTION AND EVAPORATION ***
      TKIN=CINEMA(EK)
      PV( 9,MXGKPV)=TKIN
      ENP(5)=EK+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=FERMI(ENP(5))
      ENP(5)=ENP(5)+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=EXNU(ENP(5))
      ENP(5)=ENP(5)-TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
C
C *** IN CASE OF ENERGY ABOVE CUT-OFF LET THE PARTICLE CASCADE ***
      TEST=ABS(CHARGE)
      IF ((TEST .GT. 1.0E-10) .AND. (ENP(5) .GT. CUTHAD)) GO TO 35
      IF ((TEST .LE. 1.0E-10) .AND. (ENP(5) .GT. CUTNEU)) GO TO 35
C
C --- SECOND CHANCE FOR ANTI-BARYONS DUE TO POSSIBLE ANNIHILATION ---
      IF ((AMAS .GE. 0.0) .OR. (KPART .LE. 14)) GO TO 13
      ANNI=1.3*P
      IF (ANNI .GT. 0.4) ANNI=0.4
      CALL GRNDM(RNDM,1)
      TEST=RNDM(1)
      IF (TEST .GT. ANNI) GO TO 35
C
C *** PARTICLE WITH ENERGY BELOW CUT-OFF ***
C --- ==> ONLY NUCLEAR EVAPORATION AND QUASI-ELASTIC SCATTERING ---
 13   CONTINUE
C
      ISTOP=3
C
      IF (NPRT(9)) PRINT 1002,KPART,EK,EN,P,ENP(5),ENP(6),ENP(7)
 1002 FORMAT(' *GHEISH* ENERGY BELOW CUT-OFF FOR GHEISHA PARTICLE ',I3/
     $ ' EK,EN,P,ENP(5),ENP(6),ENP(7) = ',6(G12.5,1X))
C
      IF ((KPART .NE. 14) .AND. (KPART .NE. 16)) GO TO 14
      IF (KPART .EQ. 16) GO TO 86
C
C --- SLOW PROTON ---
 85   CONTINUE
      IF (NPRT(9)) PRINT 2003,EK,KPART
 2003 FORMAT(' *GHEISH* ROUTINE NUCREC WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL NUCREC(NOPT,2)
C
      IF (NOPT .NE. 0) GO TO 50
C
      IF (NPRT(9)) PRINT 2004,EK,KPART
 2004 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL COSCAT
      GO TO 40
C
C --- SLOW NEUTRON ---
 86   CONTINUE
      IF (NPRT(9)) PRINT 2015
      NUCFLG=0
      CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- OTHER SLOW PARTICLES ---
 14   CONTINUE
      IPA(1)=KPART
C --- DECIDE FOR PROTON OR NEUTRON TARGET ---
      IPA(2)=16
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=ZNO2/ATNO2
      IF (TEST1 .LT. TEST2) IPA(2)=14
      AVERN=0.0
      NFL=1
      IF (IPA(2) .EQ. 16) NFL=2
      IPPP=KPART
      IF (NPRT(9)) PRINT 2005
 2005 FORMAT(' *GHEISH* ROUTINE TWOB WILL BE CALLED')
      CALL TWOB(IPPP,NFL,AVERN)
      GOTO 40
C
C --- INITIALISATION OF CASCADE QUANTITIES ---
 35   CONTINUE
C
C *** CASCADE GENERATION ***
C --- CALCULATE FINAL STATE MULTIPLICITY AND LONGITUDINAL AND ---
C --- TRANSVERSE MOMENTUM DISTRIBUTIONS ---
C
C --- FIXED PARTICLE TYPE TO STEER THE CASCADE ---
      KKPART=KPART
C
C --- NO CASCADE FOR LEPTONS ---
      IF (KKPART .LE. 6) GO TO 9999
C
C *** WHAT TO DO WITH "NEW PARTICLES" FOR GHEISHA ?????? ***
C --- RETURN FOR THE TIME BEING ---
      IF (KKPART .GE. 35) GO TO 9999
C
C --- CASCADE OF HEAVY FRAGMENTS
      IF ((KKPART .GE. 30) .AND. (KKPART .LE. 32)) GO TO 390
C
C --- INITIALIZE THE IPA ARRAY ---
      CALL VZERO(IPA(1),MXGKCU)
C
C --- CASCADE OF OMEGA - AND OMEGA - BAR ---
      IF (KKPART .EQ. 33) GO TO 330
      IF (KKPART .EQ. 34) GO TO 331
C
      NVEPAR=KKPART-17
      IF (NVEPAR .LE. 0) GO TO 15
      GO TO (318,319,320,321,322,323,324,325,326,327,328,329),NVEPAR
C
 15   CONTINUE
      NVEPAR=KKPART-6
      GO TO (307,308,309,310,311,312,313,314,315,316,317,318),NVEPAR
C
C --- PI+ CASCADE ---
 307  CONTINUE
      IF (NPRT(9)) PRINT 2006
 2006 FORMAT(' *GHEISH* ROUTINE CASPIP WILL BE CALLED')
      CALL CASPIP(J,INT,NFL)
      GO TO 40
C
C --- PI0 ==> NO CASCADE ---
 308  CONTINUE
      GO TO 40
C
C --- PI- CASCADE ---
 309  CONTINUE
      IF (NPRT(9)) PRINT 2007
 2007 FORMAT(' *GHEISH* ROUTINE CASPIM WILL BE CALLED')
      CALL CASPIM(J,INT,NFL)
      GO TO 40
C
C --- K+ CASCADE ---
 310  CONTINUE
      IF (NPRT(9)) PRINT 2008
 2008 FORMAT(' *GHEISH* ROUTINE CASKP WILL BE CALLED')
      CALL CASKP(J,INT,NFL)
      GO TO 40
C
C --- K0 CASCADE ---
 311  CONTINUE
      IF (NPRT(9)) PRINT 2009
 2009 FORMAT(' *GHEISH* ROUTINE CASK0 WILL BE CALLED')
      CALL CASK0(J,INT,NFL)
      GO TO 40
C
C --- K0 BAR CASCADE ---
 312  CONTINUE
      IF (NPRT(9)) PRINT 2010
 2010 FORMAT(' *GHEISH* ROUTINE CASK0B WILL BE CALLED')
      CALL CASK0B(J,INT,NFL)
      GO TO 40
C
C --- K- CASCADE ---
 313  CONTINUE
      IF (NPRT(9)) PRINT 2011
 2011 FORMAT(' *GHEISH* ROUTINE CASKM WILL BE CALLED')
      CALL CASKM(J,INT,NFL)
      GO TO 40
C
C --- PROTON CASCADE ---
 314  CONTINUE
      IF (NPRT(9)) PRINT 2012
 2012 FORMAT(' *GHEISH* ROUTINE CASP WILL BE CALLED')
      CALL CASP(J,INT,NFL)
      GO TO 40
C
C --- PROTON BAR CASCADE ---
 315  CONTINUE
      IF (NPRT(9)) PRINT 2013
 2013 FORMAT(' *GHEISH* ROUTINE CASPB WILL BE CALLED')
      CALL CASPB(J,INT,NFL)
      GO TO 40
C
C --- NEUTRON CASCADE ---
 316  CONTINUE
      NUCFLG=0
      IF (EK .GT. SWTEKN) THEN
         CALL CASN(J,INT,NFL)
         IF (NPRT(9)) PRINT 2014
 2014 FORMAT(' *GHEISH* ROUTINE CASN WILL BE CALLED')
      ELSE
         CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
         IF (NPRT(9)) PRINT 2015
 2015 FORMAT(' *GHEISH* ROUTINE GNSLWD WILL BE CALLED')
      ENDIF
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- NEUTRON BAR CASCADE ---
 317  CONTINUE
      IF (NPRT(9)) PRINT 2016
 2016 FORMAT(' *GHEISH* ROUTINE CASNB WILL BE CALLED')
      CALL CASNB(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA CASCADE ---
 318  CONTINUE
      IF (NPRT(9)) PRINT 2017
 2017 FORMAT(' *GHEISH* ROUTINE CASL0 WILL BE CALLED')
      CALL CASL0(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA BAR CASCADE ---
 319  CONTINUE
      IF (NPRT(9)) PRINT 2018
 2018 FORMAT(' *GHEISH* ROUTINE CASAL0 WILL BE CALLED')
      CALL CASAL0(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + CASCADE ---
 320  CONTINUE
      IF (NPRT(9)) PRINT 2019
 2019 FORMAT(' *GHEISH* ROUTINE CASSP WILL BE CALLED')
      CALL CASSP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 ==> NO CASCADE ---
 321  CONTINUE
      GO TO 40
C
C --- SIGMA - CASCADE ---
 322  CONTINUE
      IF (NPRT(9)) PRINT 2020
 2020 FORMAT(' *GHEISH* ROUTINE CASSM WILL BE CALLED')
      CALL CASSM(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + BAR CASCADE ---
 323  CONTINUE
      IF (NPRT(9)) PRINT 2021
 2021 FORMAT(' *GHEISH* ROUTINE CASASP WILL BE CALLED')
      CALL CASASP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 BAR ==> NO CASCADE ---
 324  CONTINUE
      GO TO 40
C
C --- SIGMA - BAR CASCADE ---
 325  CONTINUE
      IF (NPRT(9)) PRINT 2022
 2022 FORMAT(' *GHEISH* ROUTINE CASASM WILL BE CALLED')
      CALL CASASM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 CASCADE ---
 326  CONTINUE
      IF (NPRT(9)) PRINT 2023
 2023 FORMAT(' *GHEISH* ROUTINE CASX0 WILL BE CALLED')
      CALL CASX0(J,INT,NFL)
      GO TO 40
C
C --- XI - CASCADE ---
 327  CONTINUE
      IF (NPRT(9)) PRINT 2024
 2024 FORMAT(' *GHEISH* ROUTINE CASXM WILL BE CALLED')
      CALL CASXM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 BAR CASCADE ---
 328  CONTINUE
      IF (NPRT(9)) PRINT 2025
 2025 FORMAT(' *GHEISH* ROUTINE CASAX0 WILL BE CALLED')
      CALL CASAX0(J,INT,NFL)
      GO TO 40
C
C --- XI - BAR CASCADE ---
 329  CONTINUE
      IF (NPRT(9)) PRINT 2026
 2026 FORMAT(' *GHEISH* ROUTINE CASAXM WILL BE CALLED')
      CALL CASAXM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - CASCADE ---
 330  CONTINUE
      IF (NPRT(9)) PRINT 2027
 2027 FORMAT(' *GHEISH* ROUTINE CASOM WILL BE CALLED')
      CALL CASOM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - BAR CASCADE ---
 331  CONTINUE
      IF (NPRT(9)) PRINT 2028
 2028 FORMAT(' *GHEISH* ROUTINE CASAOM WILL BE CALLED')
      CALL CASAOM(J,INT,NFL)
      GO TO 40
C
C --- HEAVY FRAGMENT CASCADE ---
 390  CONTINUE
      IF (NPRT(9)) PRINT 2090
 2090 FORMAT(' *GHEISH* ROUTINE CASFRG WILL BE CALLED')
      NUCFLG=0
      CALL CASFRG(NUCFLG,INT,NFL)
      IF (NUCFLG .NE. 0) GO TO 50
C
C *** CHECK WHETHER THERE ARE NEW PARTICLES GENERATED ***
 40   CONTINUE
      IF ((NTOT .NE. 0) .OR. (KKPART .NE. KPART)) GO TO 50
C
C --- NO SECONDARIES GENERATED AND PARTICLE IS STILL THE SAME ---
C --- ==> COPY EVERYTHING BACK IN THE CURRENT GEANT STACK ---
      NGKINE=0
      TOFG=TOFG+TOF*0.5E-10
C --- In case of crazy momentum value ==> no change to GEANT stack ---
      IF (P .LT. 0.) GO TO 41
      VECT(4)=PX
      VECT(5)=PY
      VECT(6)=PZ
      VECT(7)=P
      GETOT=EN
      GEKIN=EK
C --- CHECK KINETIC ENERGY ---
      CALL GEKBIN
      EDEP=ABS(ENOLD-EN)
      RMASSI=EN-EK
      IF (NPRT(9) .AND. (EN .GT. ENOLD))
     $ PRINT 8888,EDEP,ENOLD,EN,EK,RMASSI
 8888 FORMAT(' *GHEISH* EDEP,ENOLD,EN,EK,M = ',5(G12.5,1X)/
     $ ' *GHEISH* =======> EDEP WOULD BE NEGATIVE <========')
      IF (ISTOP .EQ. 0) DESTEP=DESTEP+EDEP
C
C --- RE-INITIALIZE THE PROBABILITY FOR HADRONIC INTERACTION ---
 41   CONTINUE
      CALL GRNDM(RNDM,1)
      IF ((RNDM(1) .LE. 0.) .OR. (RNDM(1) .GE. 1.)) GO TO 41
      ZINTHA=-LOG(RNDM(1))
      SLHADR=SLENG
      STEPHA=1.0E10
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1003,NTOT,IPART,KPART,KKPART,NVEDUM
 1003 FORMAT(' *GHEISH* NO SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X)/
     $ ' CURRENT PARTICLE ON THE STACK AGAIN')
      GO TO 9999
C
C *** CURRENT PARTICLE IS NOT THE SAME AS IN THE BEGINNING OR/AND ***
C *** ONE OR MORE SECONDARIES HAVE BEEN GENERATED ***
 50   CONTINUE
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1004,NTOT,IPART,KPART,KKPART,NVEDUM
 1004 FORMAT(' *GHEISH* SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X))
C
C --- INITIAL PARTICLE TYPE HAS BEEN CHANGED ==> PUT NEW TYPE ON ---
C --- THE GEANT TEMPORARY STACK ---
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((KPART .NE. 11) .AND. (KPART .NE. 12)) GO TO 52
      CALL GRNDM(RNDM,1)
      KPART=11.5+RNDM(1)
C
 52   CONTINUE
      ITY=IKPART(KPART)
      LNVE=LQ(JPART-ITY)
      IF (LNVE .LE. 0) PRINT 1234,NTOT,ITY,LNVE
 1234 FORMAT('0*GHEISH* 1234 NTOT,ITY,LNVE = ',3(I10,1X))
      IF (LNVE .LE. 0) STOP
      IF (ISTOP .EQ. 0) ISTOP=1
C
C --- IN CASE THE NEW PARTICLE IS A NEUTRINO ==> FORGET IT ---
      IF (KPART .EQ. 2) GO TO 60
C
C --- PUT PARTICLE ON THE STACK ---
      GKIN(1,1)=PX*P
      GKIN(2,1)=PY*P
      GKIN(3,1)=PZ*P
      GKIN(4,1)=SQRT(P*P+RMASS(KPART)**2)
      GKIN(5,1)=ITY
      TOFD(1)=TOF*0.5E-10
      NGKINE = 1
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
      IF (NPRT(9)) PRINT 1005,ITY,NGKINE
 1005 FORMAT(' *GHEISH* GEANT PART. ',I3,' PUT ONTO STACK AT POS. ',I3)
C
C *** CHECK WHETHER SECONDARIES HAVE BEEN GENERATED AND COPY THEM ***
C *** ALSO ON THE GEANT STACK ***
 60   CONTINUE
C
C --- ALL QUANTITIES ARE TAKEN FROM THE GHEISHA STACK WHERE THE ---
C --- CONVENTION IS THE FOLLOWING ---
C
C EVE(INDEX+ 1)= X
C EVE(INDEX+ 2)= Y
C EVE(INDEX+ 3)= Z
C EVE(INDEX+ 4)= NCAL
C EVE(INDEX+ 5)= NCELL
C EVE(INDEX+ 6)= MASS
C EVE(INDEX+ 7)= CHARGE
C EVE(INDEX+ 8)= TOF
C EVE(INDEX+ 9)= PX
C EVE(INDEX+10)= PY
C EVE(INDEX+11)= PZ
C EVE(INDEX+12)= TYPE
C
      IF (NTOT .LE. 0) GO TO 9999
C
C --- ONE OR MORE SECONDARIES HAVE BEEN GENERATED ---
      DO 61 L=1,NTOT
      INDEX=(L-1)*12
      JND=EVE(INDEX+12)
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((JND .NE. 11) .AND. (JND .NE. 12)) GO TO 63
      CALL GRNDM(RNDM,1)
      JND=11.5+RNDM(1)
C
C --- FORGET ABOUT NEUTRINOS ---
 63   CONTINUE
      IF (JND .EQ. 2) GO TO 61
C
C --- SWITH TO GEANT QUANTITIES ---
      ITY=IKPART(JND)
      JTY=LQ(JPART-ITY)
      IF (JTY .LE. 0) PRINT 1235,NTOT,ITY,JTY
 1235 FORMAT('0*GHEISH* 1235 NTOT,ITY,JTY = ',3(I10,1X))
      IF (JTY .LE. 0) STOP
*     ITRT=Q(JTY+6)
      PLX=EVE(INDEX+9)
      PLY=EVE(INDEX+10)
      PLZ=EVE(INDEX+11)
      ELT=SQRT(PLX*PLX+PLY*PLY+PLZ*PLZ+Q(JTY+7)**2)
C
C --- ADD PARTICLE TO THE STACK IF STACK NOT YET FULL ---
      IF (NGKINE .GE. MXGKIN) THEN
          WRITE(CHMAIL,1236) NTOT, L
 1236     FORMAT(' *** GHEISH: ',I9,' particle produced but only ',
     +           I9,' put on the GEANT stack!')
          CALL GMAIL(1,1)
          GO TO 9999
      ENDIF
      NGKINE=NGKINE+1
      GKIN(1,NGKINE)=PLX
      GKIN(2,NGKINE)=PLY
      GKIN(3,NGKINE)=PLZ
      GKIN(4,NGKINE)=ELT
      GKIN(5,NGKINE)=ITY
      TOFD(NGKINE)=EVE(INDEX+8)*0.5E-10
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
      IF (NPRT(9)) PRINT 1006,ITY,NGKINE,L,(EVE(INDEX+J),J=1,12)
 1006 FORMAT(' *GHEISH* GEANT PART. ',I3,' ALSO PUT ONTO STACK AT',
     $ ' POS. ',I3/
     $ ' EVE(',I2,') = '/12(1H ,12X,G12.5/))
C
 61   CONTINUE
C
 9999 CONTINUE
C --- LIMIT THE VALUE OF NGKINE IN CASE OF OVERFLOW ---
      NGKINE=MIN(NGKINE,MXGKIN)
      END
 
+DECK,GCALOR,IF=GCALOR,If=hadron.
*CMZ :          19/12/97  15.36.36  by  Pavel Nevski
*CMZ :  1.04/08 31/08/95  12.01.02  by  Christian Zeitnitz
*-- Author : Christian Zeitnitz
      SUBROUTINE GCALOR
********************************************************************
*                                                                  *
* PURPOSE: GEANT interface to CALOR                                *
*                                                                  *
* CALLED BY : GUHADR                                               *
*                                                                  *
* INPUT :  particle, material, and probabilities via GEANT common  *
*                                                                  *
* OUTPUT : COMMON GCKING, DESTEP                                   *
*          KCALL  = -1  : Nothing done                             *
*                 =  0  : NMTC has been called                     *
*                 =  1  : MICAP has been called                    *
*                 =  2  : HETC/SKALE has been called               *
*                 =  3  : FLUKA has been called                    *
*                                                                  *
* AUTHOR : C.Zeitnitz (University of Arizona)                      *
*                                                                  *
********************************************************************
C.
C. --- GEANT Commons
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCONST.
+CDE,GCCUTS.
+CDE,GCFLAG.
C --- CALOR - GEANT Interface common
*KEEP,CALGEA.
C***************************************************************
C
C       CALOR-GEANT Interface common
C
C parameters of incident particle :
C                   IPinc   = particle type a la CALOR
C                   Einc    = kinetic energy
C                   Uinc(3) = direction cosines
C material parameters:
C                   NCEL    = number of elements in mixture (NMTC)
C                             GEANT material no. for MICAP
C                   Amed(I) = mass number
C                   Zmed(I) = charge number
C                   Dmed(I) = Atoms/cm**3 * 1E-24
C                   Hden    = Atoms/cm**3 * 1E-24
C                             of H-Atoms in mixture
C
C particle stack:
C            NPHETC           = number of particles
C            Ekinet(1:NPHETC) = kinetic energy of part.
C            IPCAL(1:NPHETC)  = particle type a la CALOR (extended)
C            UCAL(1:NPHETC,3) = direction cosines
C            CALTIM(1:NPHETC) = age of particle (nsec)
C
C            ATARGT = A no. of target nucleus
C            ZTARGT = Z no. of target nucleus
C
C return of residual nucleus information
C            NRECOL  = no. of heavy recoil products
C            Amed(I) = mass number of residual nucleus
C            Zmed(I) = charge number "          "
C            EXmed   = exitation energy of nucleus
C            ERmed(I)= recoil energy of nucleus
C            IntCal  = type of interaction (GEANT NAMEC index)
C return of cross section of hadronic interaction (CALSIG called)
C            SIG =  x-section
C
C set by CALSIG:
C            ICPROC = -1   undefined
C                   =  0   NMTC called for cross-section
C                   =  1   MICAP called for cross-section
C                   =  2   SKALE(NMTC at 3 GeV) called for cross-section
C                   =  3   FLUKA called for cross-section
C            KCALL : same coding as ICPROC, but is only valid after a
C                    call to GCALOR
C       18/8/92  C.Zeitnitz University of Arizona
C****************************************************************
C
      PARAMETER(EMAXP  = 3.495)
      PARAMETER(EMAXPI = 2.495)
C transition upper limit (GeV) NMTC-FLUKA
      PARAMETER(ESKALE = 10.0)
      PARAMETER(MXCP = 300)
C
      COMMON/ CALGEA / IPINC  , EINC       , UINC(3)   ,NCEL        ,
     +                 HDEN   , AMED(100)  , ZMED(100) ,DMED(100)   ,
     +                 NPHETC ,EKINET(MXCP),IPCAL(MXCP),UCAL(MXCP,3),
     +                 INTCAL , EXMED      , ERMED(100),SIG         ,
     +                 CALTIM(MXCP), ICPROC, NRECOL    ,KCALL       ,
     +                 ATARGT , ZTARGT
C
*KEEP,CERRCM.
      LOGICAL CERRF
      COMMON/CERRCM/CERRF,IERRU
*KEEP,CAMASS.
      REAL*4 XMASS(0:11)
      COMMON/CMASS/XMASS
*KEND.
C
C  Avogadro number multiplied by 1.E-24
      PARAMETER(XNAVO = 0.60221367)
C
      DIMENSION NNPART(12)
      LOGICAL INIT,GOFLUK,DOSKAL,FMICAP,SKALEF,NABSOR,FSTOP
      DOUBLE PRECISION DECIN,DMASS
C
      DATA INIT /.TRUE./
      SAVE INIT
C
      IF ( INIT ) THEN
C
C     initialize CALOR
         CALL CALINI
C
         INIT = .FALSE.
C
      ENDIF
      KCALL = -1
C
C get CALOR particle type
      IPINC = -1
      IF(IPART .LE. 48 )  IPINC = IGECAL(IPART)
C
C energy in MeV
 
      EINC   =GEKIN * 1000.0
      UINC(1)=VECT(4)
      UINC(2)=VECT(5)
      UINC(3)=VECT(6)
      KCASE=NAMEC(12)
      NGKINE = 0
      NABSOR = .FALSE.
      FSTOP = .FALSE.
C ----- particle has to be stopped ? -------
      IF(GEKIN.LT.CUTHAD.AND.ITRTYP.EQ.4) THEN
         FSTOP = .TRUE.
         ISTOP = 2
         IF(IPART .EQ. 9) THEN
            NABSOR = .TRUE.
            ISTOP = 1
            EINC = 1.0
            IF(GEKIN.GT.EINC/1000.) DESTEP = DESTEP + GEKIN - EINC/
     +      1000.0
            GEKIN = 0.0
            VECT(7) = 0.0
            KCASE = NAMEC(18)
            NMEC = NMEC + 1
            LMEC(NMEC) = 18
         ELSE
            DESTEP = DESTEP + GEKIN
            GEKIN = 0.0
            VECT(7) = 0.0
            IF(IPART.EQ.8.OR.IPART.EQ.11.OR.IPART.EQ.12) THEN
              CALL GDECAY
              KCASE = NAMEC(5)
              NMEC = NMEC + 1
              LMEC(NMEC) = 5
            ENDIF
            RETURN
         ENDIF
      ELSE IF(GEKIN.LT.CUTNEU.AND.IPART.EQ.13) THEN
         IF(GEKIN.LT.1.E-14) EINC=1.E-11
         ISTOP = 1
         NABSOR = .TRUE.
      ENDIF
      IF(ISTOP.EQ.2.OR.GEKIN.EQ.0.0) RETURN
C
C ------------- check if FLUKA has to be called ---------
C ------------------------------------------------- Goto FLUKA ?
C
      DOSKAL = (IPINC.EQ.0 .OR. IPINC.EQ.1) .AND. GEKIN.GT.EMAXP
      DOSKAL = DOSKAL .OR. (GEKIN .GT. EMAXPI .AND. (IPINC .GT. 1))
      IF(ICPROC.GE.0) THEN
         GOFLUK = ICPROC.EQ.3 .OR. IPINC.EQ.-1
         DOSKAL = DOSKAL .AND. ICPROC.EQ.2
      ELSE
         GOFLUK = IPINC .EQ. -1 .OR. GEKIN .GE. ESKALE
         DOSKAL = DOSKAL .AND. .NOT.GOFLUK
         GOFLUK = GOFLUK .OR. (DOSKAL.AND.SKALEF(IPINC,GEKIN,ESKALE))
         GOFLUK = GOFLUK .AND. .NOT.FSTOP .AND. .NOT.NABSOR
      ENDIF
      ICPROC = -1
C ------------------------------------------- call FLUKA
      IF(GOFLUK) THEN
         CALL FLUFIN
         KCALL = 3
         RETURN
      ENDIF
      CERRF = .FALSE.
      IF(IPINC .EQ. 1 .AND. EINC .LE. 20.0) THEN
C MICAP needs only GEANT material number
         NCEL = NMAT
C --- low energetic neutron -> call micap
         CALL MICAP
         KCALL = 1
      ELSE
         NCEL = 1
         AMED(1) = A
         ZMED(1) = Z
         DMED(1) = DENS/A*XNAVO
         IF(INT(A) .EQ. 1) THEN
            HDEN = DMED(1)
         ELSE
            HDEN = 0.0
         ENDIF
C ------- get material parameter for a mixture---------------------
         KK=MIN1(ABS(Q(JMA+11)),100.)
         NCEL = 1
         IF(KK.GT.1) THEN
            HDEN = 0.0
            NCEL = 0
            AMOL = Q(LQ(JMIXT-1) + 2)
            DO 10 K=1,KK
               IF(NINT(Q(JMIXT+K)).EQ.1) THEN
C                           hydrogen density
                  XMOLCM = DENS/AMOL*XNAVO
                  WI = Q(JMIXT+K+2*KK)*AMOL/Q(JMIXT+K)
                  HDEN = HDEN + XMOLCM * WI
               ELSE
                  NCEL = NCEL + 1
                  AMED(NCEL) = Q(JMIXT+K)
                  ZMED(NCEL) = Q(JMIXT+K+KK)
C                                        molekuls/cm^3
                  XMOLCM = DENS/AMOL*XNAVO
C                                     number of atoms per molecule
                  WI = Q(JMIXT+K+2*KK)*AMOL/AMED(NCEL)
C                                        atoms/cm^3
                  DMED(NCEL) = XMOLCM * WI
               ENDIF
   10       CONTINUE
         ENDIF
         CALL CHETC(DOSKAL)
         KCALL = 0
         IF(DOSKAL) KCALL = 2
      ENDIF
C error ocurred in CALOR ?
      IF(CERRF) THEN
         WRITE(IERRU,'('' NEVT,IPART,Ek,NMED,ISTOP,NABSOR,FSTOP :'',   '
     +   //'          I10,I5,G15.6,2I6,2L6)') IEVENT,IPART,GEKIN,NMAT,
     +   ISTOP,NABSOR,FSTOP
      ENDIF
      ESUM =0.
      EKSUM = 0.
      PX = 0.
      PY = 0.
      PZ = 0.
      NGKINE = 0
      PSUM = 0.
C
      ZINTHA=GARNDM(6)
      SLHADR=SLENG
      STEPHA=BIG
C
      IF(NPHETC.EQ.0.AND.NABSOR) ISTOP = 2
C neutron has been absorbed -> INTCAL=18
      IF(INTCAL.EQ.18) ISTOP = 1
      IF(NPHETC.LE.0) GOTO 160
C
C too many particles in the CALOR array for GEANT
C happens sometimes with deexitation gammas and evaporation neutrons
C simple approach to combine particles and sum up their energies, but
C forget about momentum conservation
C
      IF(NPHETC.GT.MXGKIN) THEN
   20    CONTINUE
         DO 30 I=1,12
            NNPART(I)=0
   30    CONTINUE
         NNTOT = 0
         DO 40 I=1,NPHETC
            IF(IPCAL(I).NE.-1) THEN
               NNPART(IPCAL(I)+1)=NNPART(IPCAL(I)+1)+1
               NNTOT = NNTOT + 1
            ENDIF
   40    CONTINUE
         IF(NNTOT.LE.MXGKIN) GOTO 100
         JMAX=0
         IMAX=0
         DO 50 I=1,12
            IF(JMAX.LT.NNPART(I)) THEN
               JMAX=NNPART(I)
               IPI=I-1
            ENDIF
   50    CONTINUE
         DO 60 I=1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 70
   60    CONTINUE
   70    I1=I
         DO 80 I=I1+1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 90
   80    CONTINUE
   90    I2=I
         ECINI = EKINET(I1)
         DMASS = DBLE(XMASS(IPI))*1.D3
         DECIN = DBLE(ECINI)
         PPI = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         IPJ = IPCAL(I2)
         ECINJ = EKINET(I2)
         DECIN = DBLE(ECINJ)
         PPJ = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         ECIN = SNGL(DBLE(ECINI)+DBLE(ECINJ)+DMASS)
         EKINET(I1) = ECIN
         PP = SNGL(DSQRT(DBLE(ECIN*ECIN) + 2.D0*DBLE(ECIN)*DMASS))
C determine new direction cosines
         UCAL(I1,1) = (PPI*UCAL(I1,1)+PPJ*UCAL(I2,1))/PP
         UCAL(I1,2) = (PPI*UCAL(I1,2)+PPJ*UCAL(I2,2))/PP
         UCAL(I1,3) = (PPI*UCAL(I1,3)+PPJ*UCAL(I2,3))/PP
         USUM = SQRT(UCAL(I1,1)**2+UCAL(I1,2)**2+UCAL(I1,3)**2)
C normalize direction cosines
         IF(USUM.LT.0.0001) THEN
C direction is isotropic distributed
            CALL AZIRN(SINA,COSA)
            COSP = SFLRAF(DUM)
            SINP = SQRT(1.0-COSP*COSP)
            UCAL(I1,1) = SINP * COSA
            UCAL(I1,2) = SINP * SINA
            UCAL(I1,3) = COSP
         ELSE
            UCAL(I1,1) = UCAL(I1,1)/USUM
            UCAL(I1,2) = UCAL(I1,2)/USUM
            UCAL(I1,3) = UCAL(I1,3)/USUM
         ENDIF
C particle I2 vanished
         IPCAL(I2)=-1
         GOTO 20
C end of particle combination
  100    CONTINUE
C sort particles
         I2=NPHETC
         DO 120 I = 1,NPHETC
            IF(I.GE.I2) GOTO 130
            IF(IPCAL(I).EQ.-1) THEN
               DO 110 J = I2,I,-1
                  IF(IPCAL(J).NE.-1) THEN
                     IPCAL(I) = IPCAL(J)
                     EKINET(I) = EKINET(J)
                     UCAL(I,1) = UCAL(J,1)
                     UCAL(I,2) = UCAL(J,2)
                     UCAL(I,3) = UCAL(J,3)
                     I2 = J-1
                     GOTO 120
                  ENDIF
  110          CONTINUE
            ENDIF
  120    CONTINUE
  130    CONTINUE
         NPHETC=MXGKIN
      ENDIF
C
      IF(INTCAL.LT.1.OR.INTCAL.GT.30) INTCAL=12
      KCASE = NAMEC(INTCAL)
      IF(INTCAL.NE.12) THEN
        NMEC = NMEC + 1
        LMEC(NMEC) = INTCAL
      ENDIF
      DO 140 I=1,NPHETC
         IP=IPCAL(I)
         IGPART=ICALGE(IP)
         IF ( IGPART.EQ.0 ) THEN
            PRINT*,'>>> ERROR GCALOR: Particle type ',IP, ' not '
     +      //'implemented in GEANT'
            GOTO 140
         ENDIF
C
C store particle
         ECIN = EKINET(I)/1000.0
         IF(ECIN.LT.1.E-15) GOTO 140
         DECIN = DBLE(ECIN)
         DMASS = DBLE(XMASS(IP))
         PP = SNGL(DSQRT(DECIN*DECIN + 2.0D0*DECIN*DMASS))
         PX = PX + PP*UCAL(I,1)
         PY = PY + PP*UCAL(I,2)
         PZ = PZ + PP*UCAL(I,3)
C generated particle eq incoming
         IF(NPHETC.EQ.1 .AND. IGPART.EQ.IPART) THEN
            VECT(4) = UCAL(I,1)
            VECT(5) = UCAL(I,2)
            VECT(6) = UCAL(I,3)
            VECT(7) = PP
            GEKIN = ECIN
            GETOT = SNGL(DECIN + DMASS)
            TOFG = TOFG + CALTIM(I)
            ISTOP = 0
            IF(NABSOR) ISTOP = 2
            GOTO 160
         ENDIF
C
         NGKINE=NGKINE+1
         GKIN(1,NGKINE) = PP*UCAL(I,1)
         GKIN(2,NGKINE) = PP*UCAL(I,2)
         GKIN(3,NGKINE) = PP*UCAL(I,3)
C the total energy is critical for ECIN below 1.E-8 GeV because of
C single precision of GKIN (normalization when mass is added)!!
C luckely GEANT does use only the momentum components when storing the
C particle on the stack.
         GKIN(4,NGKINE) = SNGL(DECIN+DMASS)
         GKIN(5,NGKINE) = FLOAT(IGPART)
         TOFD(NGKINE)   = CALTIM(I)
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(NGKINE.GE.MXGKIN) GOTO 150
C
  140 CONTINUE
  150 CONTINUE
C particle lost its identity
      ISTOP=1
  160 CONTINUE
C
C
      NGKINE = MIN(NGKINE,MXGKIN)
C
C score kinetic energy of recoil nucleus (given in MeV)
CZ      DESTEP = DESTEP + ERMED * 1.E-3
  170 RETURN
      END
 
+DECK,GFMFIN,If=hadron.
*CMZ :          16/12/97  13.31.05  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.47  by  S.Giani
*-- Author :
      SUBROUTINE GFMFIN
+CDE,GCBANK.
+CDE,GCCUTS.
+CDE,GCJLOC.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCTMED.
+CDE,GCUNIT.
*KEEP,DIMPAR.
*                                                                     *
*=== dimpar ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      DIMPAR: included in any routine                                *
*                                                                     *
*          Mxxrgn = maximum number of regions                         *
*          Mxxmdf = maximum number of media in Fluka                  *
*          Mxxmde = maximum number of media in Emf                    *
*          Mfstck = stack dimension in Fluka                          *
*          Mestck = stack dimension in Emf                            *
*          Nallwp = number of allowed particles                       *
*          Mpdpdx = number of particle types for which EM dE/dx pro-  *
*                   cesses (ion,pair,bremss) have to be computed      *
*          Icomax = maximum number of materials for compounds (equal  *
*                   to the sum of the number of materials for every   *
*                   compound )                                        *
*          Nstbis = number of stable isotopes recorded in common iso- *
*                   top                                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( MXXRGN = 500  )
      PARAMETER ( MXXMDF = 50   )
      PARAMETER ( MXXMDE = 18   )
      PARAMETER ( MFSTCK = 1000 )
      PARAMETER ( MESTCK = 100  )
      PARAMETER ( NALLWP = 39   )
      PARAMETER ( MPDPDX = 8    )
      PARAMETER ( ICOMAX = 120  )
      PARAMETER ( NSTBIS = 304  )
 
*KEEP,FINUCT.
      DOUBLE PRECISION CXR, CYR, CZR, TKI, PLR, WEI, TV, TVCMS,
     &                 TVRECL, TVHEAV, TVBIND
 
*KEEP,FINUC.
*
*=== finuc ============================================================*
*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990     by Alfredo Ferrari, INFN Milan   *
*     include file: finuc copy                   created 26/11/86 by pa*
*     note: if changed change finuc2 copy also                         *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        np        = number of secondaries                             *
*        kpart(ip) = type of the secondary ip                          *
*        cxr(ip)   = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyr(ip)   = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czr(ip)   = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        tki(ip)   = kinetic energy of secondary ip                    *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXR (MXP), CYR (MXP), CZR (MXP), TKI (MXP),
     &                 PLR (MXP), WEI (MXP), TV, TVCMS, TVRECL, TVHEAV,
     &                 TVBIND, NP0, NP, KPART (MXP)
 
*KEND.
      REAL RNDM(1)
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
*KEEP,PART2T.
      DOUBLE PRECISION AAM, GA, TAU, AAMDSC
 
*KEEP,PART2.
*
*=== part2 ============================================================*
*
*----------------------------------------------------------------------*
*     Include file: part2 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part3 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AAM  (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AAMDSC (IDMAX8), IICH   (IDMAX8), IIBAR  (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)
 
*KEEP,COMCONT.
      DOUBLE PRECISION AOCMBC, CONTNT, SUMACN, CABINX, CABELX,
     &                 ANXNOR, ELXNOR, CONA13, SUMZMF
 
*KEEP,COMCON.
*
*=== comcon ===========================================================*
*
*----------------------------------------------------------------------*
*                                                                      *
*     include file: comcon copy                 created 26/11/86 by pa *
*                                                                      *
*     Last change  on  30-oct-92   by   Alfredo Ferrari, INFN - Milan  *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /comcon/ contains information about compounds                    *
*         icompl(imat) = number of materials in a compound             *
*         matnum(i)    = material numbers (compounds consist of the    *
*                        materials)                                    *
*         aocmbc(i)    = atomic densities in barn**-1 cm**-1           *
*                        (Atoms Over Cm times Barn for Compounds)      *
*         cona13(i)    = A^1/3 of the constituents                     *
*         sumzmf(i)    = cumulative z^2 for multiple scattering        *
*         contnt(i)    = partial densities                             *
*         sumacn(i)    = cumulative atom contents of the compounds     *
*         cabinx(i)    = cumulative at.cont.*inelastic cross section   *
*         cabelx(i)    = cumulative at.cont.*  elastic cross section   *
*         anxnor       = total inelastic cross section                 *
*         elxnor       = total   elastic cross section                 *
*----------------------------------------------------------------------*
*
      COMMON /FKCOMC/ AOCMBC (ICOMAX), CONA13 (ICOMAX), SUMZMF (ICOMAX),
     &                CONTNT (ICOMAX), SUMACN (ICOMAX), CABINX (ICOMAX),
     &                CABELX (ICOMAX), ANXNOR, ELXNOR,  ICOMPL (MXXMDF),
     &                MATNUM (ICOMAX)
 
*KEEP,FHEAVYT.
      DOUBLE PRECISION CXHEAV, CYHEAV, CZHEAV, TKHEAV, PHEAVY,
     &                 WHEAVY, AMHEAV
 
*KEEP,FHEAVY.
*
*=== fheavy ===========================================================*
*
*----------------------------------------------------------------------*
*     Last change on 9 March 1993     by Alfredo Ferrari, INFN Milan   *
*     include file: fheavy copy       created 5/4/90 by A. Ferrari     *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /fheavy/ is the storage for heavy secondaries created in the     *
*              nuclear evaporation                                     *
*        npheav     = number of secondaries                            *
*        kheavy(ip) = type of the secondary ip                         *
*                   ( 3 = deuteron, 4 = 3-H, 5 = 3-He, 6 = 4-He,       *
*                     7-12 = "Heavy" fragment specified by Ibheav and  *
*                     Icheav )                                         *
*        cxheav(ip) = direction cosine of the secondary ip             *
*                     with respect to x-axis                           *
*        cyheav(ip) = direction cosine of the secondary ip             *
*                     with respect to y-axis                           *
*        czheav(ip) = direction cosine of the secondary ip             *
*                     with respect to z-axis                           *
*        tkheav(ip) = kinetic energy of secondary ip                   *
*        pheavy(ip) = momentum of the secondary ip                     *
*        wheavy(ip) = weight of the secondary ip                       *
*        amheav(ip) = atomic masses of the six types of evaporated     *
*                     particles                                        *
*        anheav(kp) = name of the kp-type heavy particle               *
*        icheav(kp) = charge of the kp-type heavy particle             *
*        ibheav(kp) = mass number of the kp-type heavy particle        *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*   !!! There is now the possibility to produce up to 6 "heavy" !!!!   *
*   !!! fragments besides the residual nucleus recorded in      !!!!   *
*   !!! Resnuc: they are identified by indeces 7-12, of course  !!!!   *
*   !!! the corresponding physical properties (Z,A,m..) must be !!!!   *
*   !!! updated every time they are produced                    !!!!   *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*----------------------------------------------------------------------*
*
      PARAMETER ( MXHEAV = 100 )
      CHARACTER*8 ANHEAV
      COMMON / FKHEAV / CXHEAV (MXHEAV), CYHEAV (MXHEAV),
     &                  CZHEAV (MXHEAV), TKHEAV (MXHEAV),
     &                  PHEAVY (MXHEAV), WHEAVY (MXHEAV),
     &                  AMHEAV  ( 12 ) ,
     &                  KHEAVY (MXHEAV), ICHEAV  ( 12 ) ,
     &                  IBHEAV  ( 12 ) , NPHEAV
      COMMON / FKHEAC / ANHEAV  ( 12 )
 
*KEEP,PAPROP.
*
*=== paprop ===========================================================*
*
*----------------------------------------------------------------------*
*     include file: paprop copy                   created 26/11/86 by p*
*     changes: on  16 december 1992 by Alfredo Ferrari                 *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /paprop/ contains particle properties                            *
*        btype  = literal name of the particle                         *
*        am     = particle mass in gev                                 *
*        ichrge = electric charge of the particle                      *
*        iscore = explanations for the scored distribution             *
*        genpar = names of the generalized particles                   *
*        ijdisc = list of the particle types to be discarded           *
*        thalf  = half life of the particle in sec                     *
*        biasdc = decay biasing factors                                *
*        biasin = inelastic interaction biasing factors                *
*        lhadro = flag for hadrons                                     *
*        jspinp = particle spin (in units of 1/2)                      *
*        lbsdcy = logical flag for biased decay: if .true. the biasing *
*                 factor is used as an upper limit to the decay length *
*        lprbsd = logical flag for biased decay: if .true. the biasing *
*                 factor is applied only to primaries                  *
*        lprbsi = logical flag for inelastic interaction biasing: if   *
*                 .true. the biasing factor is applied only to prima-  *
*                 ries                                                 *
*                                                                      *
*----------------------------------------------------------------------*
*
      LOGICAL LHADRO, LBSDCY, LPRBSD, LPRBSI
      CHARACTER*8 BTYPE,GENPAR
      COMMON / FKPAPR / AM  (NALLWP), AMDISC (NALLWP), THALF  (NALLWP),
     &               BIASDC (NALLWP), BIASIN (NALLWP), ICHRGE (NALLWP),
     &               ISCORE     (10), IJDISC (NALLWP), LHADRO (NALLWP),
     &               JSPINP (NALLWP), LBSDCY (NALLWP), LPRBSD, LPRBSI
      COMMON / FKCHPR / BTYPE  (NALLWP), GENPAR (30)
 
*KEEP,PAPROPT.
      DOUBLE PRECISION AM, AMDISC, THALF,BIASDC, BIASIN
 
*KEEP,GFKDIS.
*KEND.
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
      NP = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF (IGF.EQ.2.OR.(GEKIN.EQ.0.0.AND.IPART.EQ.13)) THEN
         IF (GEKIN.LT.CUTNEU) THEN
            GEKIN = MAX(GEKIN,1E-14)
* should kinetic energy be deposited?
            ISTOP = 2
            IGF = 0
            GOTO 110
         ENDIF
         CALL GMICAP
         IGF = 0
         GOTO 110
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
      ELSE
         ISTOP=1
         NSTAK1 = MIN(NP,MXGKIN-NGKINE)
         IF(NP.GT.NSTAK1) THEN
            WRITE(CHMAIL,10000) NP-NSTAK1
            CALL GMAIL(0,0)
         ENDIF
         DO 90  K=1,NSTAK1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NSTAK2 = MIN(NPHEAV,MXGKIN-NGKINE)
         IF(NPHEAV.GT.NSTAK2) THEN
            WRITE(CHMAIL,10100) NPHEAV-NSTAK2
            CALL GMAIL(0,0)
         ENDIF
         DO 100 K=1,NSTAK2
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
         KCASE=NAMEC(12)
      END IF
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
10000 FORMAT(' **** FLUFIN: Stack overflow, ',I6,' particles lost')
10100 FORMAT(' **** FLUFIN: Stack overflow, ',I6,
     +' heavy particles lost')
  999 END
+DECK, GTCKOV
*CMZ :          09/02/98  16.15.20  by  Pavel Nevski
*CMZ :  3.21/04 13/12/94  15.17.13  by  S.Giani
*-- Author :
      SUBROUTINE GTCKOV
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   This routine is called to follow the Cherenkov photons       *
C.    *   created during the tracking of charged particles and         *
C.    *   simulate the relevant processes along the way, until either  *
C.    *   the photon is absorbed or exits the detector. Processes      *
C.    *   currently simulated are absorption in-flight, and reflection *
C.    *   /transmission/absorption at a medium boundary. There are two *
C.    *   boundary types: dielectric-metal and dielectric-dielectric.  *
C.    *   For each of these there is a continuum of reflectivity       *
C.    *   and of surface quality from mirror finish to matte. The      *
C.    *   surface model is contained in routine GHSURF.                *
C.    *                                                                *
C.    *   ==>Called by : GTRACK                                        *
C.    *      Authors    F.Carminati, R.Jones ************              *
C.    *                                                                *
C.    *   Modifications:                                               *
C.    *   Nicola.Colonna@ba.infn.it                                    *
C.    *          - more generalized formula for refraction             *
C.    *   PN, 9-feb-98: Let c-photons inter non-transparent media      *
C.    ******************************************************************
C.
+CDE, GCBANK.
+CDE, GCCUTS.
+CDE, GCJLOC.
+SEQ, GCONSP.
+CDE, GCPHYS.
+CDE, GCSTAK.
+CDE, GCTMED.
+CDE, GCTRAK.
+CDE, GCVOLU
+CDE, GCNUM
+CDE, GCVOL1
+CDE, GCUNIT
 
+SELF, IF=-OLD
+SEQ, GCVDMA.
+SELF
*
* ** The following common is in GTMEDI. LSAMVL is set to true if
* ** we did not change volume yet
*
      COMMON/GCCHAN/LSAMVL
      LOGICAL LSAMVL
*
      REAL  R(3),U(3),QQ(3),vin(3),u_v(3)
*     REAL  D(3)
 
      LOGICAL LOLDTR
+SELF, IF=-SINGLE
      PARAMETER (EPSMAC=1.E-6)
+SELF, IF=SINGLE
      PARAMETER (EPSMAC=1.E-11)
+SELF
      PARAMETER (MXPUSH=10)
      SAVE RIN1,EFFIC
C.
C.    ------------------------------------------------------------------
*
* *** Update local pointers if medium has changed
*
      LOLDTR=.FALSE.
      IF(IUPD.EQ.0)THEN
         IUPD  = 1
         JTCKOV = LQ(JTM-3)
         IF(JTCKOV.EQ.0) THEN
*
* *** This Cerenkov photon has crossed into a black medium.
* *** Just absorb it.
            IPROC = 101
            SLABS = 0.
            ISTOP = 2
            STEP  = 0.0001
            DESTEP = VECT(7)
            GOTO 110
         ENDIF
         NPCKOV = Q(JTCKOV+1)
         JABSCO = LQ(JTCKOV-1)
         JEFFIC = LQ(JTCKOV-2)
         JINDEX = LQ(JTCKOV-3)
         JPOLAR = LQ(JSTAK-1)
      ENDIF
      IF(SLENG.LE.0.) THEN
*
* *** Calculate GEKRAT for the particle
         IF(VECT(7).GE.Q(JTCKOV+NPCKOV+1)) THEN
            GEKRAT=1.
            IEKBIN=NPCKOV-1
         ELSEIF(VECT(7).LT.Q(JTCKOV+2)) THEN
*
* *** Particle below energy threshold ?  Short circuit
* *** This should never happen because the photons are generated
* *** only above threshold
*
*            GEKIN = 0.
*            GETOT = 0.
*            VECT(7)= 0.
*            ISTOP = 2
*            NMEC = 1
*            LMEC(1)= 30
*            GO TO 110
 
            GEKRAT=0.
            IEKBIN=1
         ELSE
            JMIN = 1
            JMAX = NPCKOV
   10       JMED = (JMIN+JMAX)/2
            IF(Q(JTCKOV+JMED+1).LT.VECT(7)) THEN
               JMIN = JMED
            ELSE
               JMAX = JMED
            ENDIF
            IF(JMAX-JMIN.GT.1) GO TO 10
            IEKBIN = JMIN
            GEKRAT = (VECT(7) - Q(JTCKOV+IEKBIN+1))/
     +      (Q(JTCKOV+IEKBIN+2)-Q(JTCKOV+IEKBIN+1))
         ENDIF
         GEKRT1=1.-GEKRAT
         RIN1=Q(JINDEX+IEKBIN)*GEKRT1+Q(JINDEX+IEKBIN+1)*GEKRAT
         EFFIC=Q(JEFFIC+IEKBIN)*GEKRT1+Q(JEFFIC+IEKBIN+1)*GEKRAT
         STEPLA=Q(JABSCO+IEKBIN)*GEKRT1+Q(JABSCO+IEKBIN+1)*GEKRAT
      ENDIF
*
* *** Compute current step size
*
      IPROC  = 103
      STEP   = STEMAX
*
*  **   Step limitation due to in flight absorbtion ?
*
      IF (ILABS.GT.0) THEN
         SLABS  = STEPLA*ZINTLA
         IF (SLABS.LT.STEP) THEN
            STEP  = SLABS
            IPROC = 101
         ENDIF
      ENDIF
*
      IF (STEP.LT.0.) STEP = 0.
*
*  **   Step limitation due to geometry ?
*
      STEPT=0.
      IF (STEP.GE.SAFETY) THEN
         CALL GTNEXT
         IF (IGNEXT.NE.0) THEN
*
* **    We are going to cross a boundary, so we need to simulate
* **    boundary effects and to know what is on the other side.
* **    For the moment save the current vector in the geometry tree.
*
+SELF, IF=-OLD
         if(mycoun.gt.1.and.nfmany.gt.0)then
           nlevel=manyle(nfmany)
           do 99 i=1,nlevel
             names(i)=manyna(nfmany,i)
             number(i)=manynu(nfmany,i)
 99        continue
           call glvolu(nlevel,names,number,ier)
           if(ier.ne.0)print *,'Fatal error in GLVOLU'
           ingoto=0
         endif
+SELF
            NLEVL1 = NLEVEL
            DO 20   I=1,NLEVEL
               NAMES1(I) = NAMES(I)
               NUMBR1(I) = NUMBER(I)
               LVOLU1(I) = LVOLUM(I)
   20       CONTINUE
*
* *** This is different from the other tracking routines.
* *** We get to the boundary and then we just jump over it
* *** So, linear transport till we are very near the boundary
*
+SELF,IF=-IBM
            STEP = MAX(SNEXT-PREC,0.)
+SELF,IF=IBM
            STEP = MAX(SNEXT-2.*PREC,0.)
+SELF
            IF(STEP.GT.0.) THEN
               DO 30 I=1,3
                  VECT(I)=VECT(I)+STEP*VECT(I+3)
   30          CONTINUE
            ENDIF
            STEPT=STEP
+SELF,IF=-IBM
            STEP  = SNEXT - STEP + PREC
+SELF,IF=IBM
            STEP  = SNEXT - STEP + 2.*PREC
+SELF
            IPROC = 0
            INWVOL= 2
            NMEC =  1
            LMEC(1)=1
         ENDIF
*
*        Update SAFETY in stack companions, if any
*        This may well not work.
         IF (IQ(JSTAK+3).NE.0) THEN
            DO 40 IST = IQ(JSTAK+3),IQ(JSTAK+1)
               JST = JSTAK +3 +(IST-1)*NWSTAK
               Q(JST+11) = SAFETY
   40       CONTINUE
            IQ(JSTAK+3) = 0
         ENDIF
*
      ELSE
         IQ(JSTAK+3) = 0
      ENDIF
*
* *** Linear transport
*
      VIN(1) = VECT(1)
      VIN(2) = VECT(2)
      VIN(3) = VECT(3)
      IF (INWVOL.EQ.2) THEN
         NBPUSH = 0
   50    DO 60 I = 1,3
            VECTMP  = VECT(I) +STEP*VECT(I+3)
            IF(VECTMP.EQ.VECT(I)) THEN
*
* *** Correct for machine precision
*
               IF(VECT(I+3).NE.0.) THEN
                  VECTMP = VECT(I)+ABS(VECT(I))*SIGN(1.,VECT(I+3))*
     +            EPSMAC
                  IF(NMEC.GT.0) THEN
                     IF(LMEC(NMEC).EQ.104) NMEC=NMEC-1
                  ENDIF
                  NMEC=NMEC+1
                  LMEC(NMEC)=104
+SELF, IF=DEBUG.
                  WRITE(CHMAIL, 10000)
                  CALL GMAIL(0,0)
                  WRITE(CHMAIL, 10100) GEKIN, NUMED, STEP, SNEXT
                  CALL GMAIL(0,0)
10000 FORMAT(' Boundary correction in GTCKOV: ',
     +       '    GEKIN      NUMED       STEP      SNEXT')
10100 FORMAT(31X,E10.3,1X,I10,1X,E10.3,1X,E10.3,1X)
+SELF
               ENDIF
            ENDIF
            VOUT(I) = VECTMP
   60    CONTINUE
         NUMED1=NUMED
         CALL GTMEDI(VOUT,NUMED2)
         LOLDTR=.TRUE.
         IF(NUMED2.LE.0) THEN
            VECT(1) = VOUT(1)
            VECT(2) = VOUT(2)
            VECT(3) = VOUT(3)
            GO TO 110
         ENDIF
         JVO=LQ(JVOLUM-LVOLUM(NLEVEL))
         IF(LSAMVL.AND.Q(JVO+2).NE.12.) THEN
*
* *** In spite of our efforts we have not crossed the boundary
* *** we increase the step size and try again
*
            NBPUSH = NBPUSH + 1
            IF (NBPUSH.LE.MXPUSH) THEN
              STEP = STEP + NBPUSH*PREC
              GOTO 50
            ELSE
              INWVOL = 0
            ENDIF
 
         ENDIF
         IF(NUMED1.EQ.NUMED2) THEN
*
* *** If we are in the same medium, nothing needs to be done!
*
            VECT(1)=VOUT(1)
            VECT(2)=VOUT(2)
            VECT(3)=VOUT(3)
            IPROC=0
         ELSE
            JTM2 = LQ(JTMED-NUMED2)
            IF(IQ(JTM2-2).GE.3) THEN
               JTCKV2 = LQ(JTM2-3)
            ELSE
               JTCKV2 = 0
            ENDIF
            IF(JTCKV2.GT.0) THEN
               NPCKV2 = Q(JTCKV2+1)
               JABSC2 = LQ(JTCKV2-1)
               JEFFI2 = LQ(JTCKV2-2)
               JINDX2 = LQ(JTCKV2-3)
               IF(VECT(7).GE.Q(JTCKV2+NPCKV2+1)) THEN
                  GEKRT2=1.
                  IEKBI2=NPCKV2-1
               ELSEIF(VECT(7).LT.Q(JTCKV2+2)) THEN
                  GEKRT2=0.
                  IEKBI2=1
               ELSE
                  JMIN = 1
                  JMAX = NPCKV2
   64             JMED = (JMIN+JMAX)/2
                  IF(Q(JTCKV2+JMED+1).LT.VECT(7)) THEN
                     JMIN = JMED
                  ELSE
                     JMAX = JMED
                  ENDIF
                  IF(JMAX-JMIN.GT.1) GO TO 64
                  IEKBI2 = JMIN
                  GEKRT2 = (VECT(7) - Q(JTCKV2+IEKBI2+1))/
     +            (Q(JTCKV2+IEKBI2+2)-Q(JTCKV2+IEKBI2+1))
               ENDIF
               GEKRT1=1.-GEKRT2
               ABSCO2=Q(JABSC2+IEKBI2)*GEKRT1+Q(JABSC2+IEKBI2+1)*GEKRT2
               EFFIC2=Q(JEFFI2+IEKBI2)*GEKRT1+Q(JEFFI2+IEKBI2+1)*GEKRT2
               IF(JINDX2.GT.0) THEN
                 RIN2=Q(JINDX2+IEKBI2)*GEKRT1+Q(JINDX2+IEKBI2+1)*GEKRT2
               ELSE
                 RIN2=0.
               ENDIF
               IPROC = 102
            ELSE
* do nothing - let it be absobed there
*              ISTOP  = 2
*              DESTEP = VECT(7)
*              NMEC   = NMEC+1
*              LMEC(NMEC)=30
               VECT(1)=VOUT(1)
               VECT(2)=VOUT(2)
               VECT(3)=VOUT(3)
               GOTO 110
            ENDIF
         ENDIF
      ELSE
         DO 70 I = 1,3
            VECT(I)  = VECT(I) +STEP*VECT(I+3)
   70    CONTINUE
      ENDIF
*
      STEP = STEPT + STEP
      SLENG = SLENG +STEP
*
* *** Update time of flight
*
      TOFG = TOFG +STEP*RIN1/CLIGHT
*
* *** Update interaction probabilities
*
      IF (ILABS.GT.0)    ZINTLA = ZINTLA -STEP/STEPLA
*
      IF (IPROC.EQ.0) GO TO 110
      NMEC = NMEC+1
      LMEC(NMEC) = IPROC
*
*  ** Absorbtion in flight ?
*
      IF (IPROC.EQ.101) THEN
         ISTOP=2
         CALL GRNDM(RNDM,1)
         IF(RNDM.LT.EFFIC) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
            DESTEP=VECT(7)
         ELSE
            DESTEP=0.
         ENDIF
*
*  ** Boundary action?
*
      ELSE IF (IPROC.EQ.102) THEN
         IF(JINDX2.EQ.0) THEN
*
* *** Case dielectric -> metal
*
            CALL GRNDM(RNDM,1)
            IF(RNDM.LT.ABSCO2) THEN
*
* *** Photon is absorbed in the next medium
*
               NMEC=NMEC+1
               LMEC(NMEC)=101
               ISTOP = 2
               CALL GRNDM(RNDM,1)
               IF(RNDM.LT.EFFIC2) THEN
*
* ***  Destep =/= 0 means that the photon has been detected
*
                  DESTEP=VECT(7)
               ELSE
                  DESTEP = 0.
               END IF
               VECT(1) = VOUT(1)
               VECT(2) = VOUT(2)
               VECT(3) = VOUT(3)
               GOTO 110
            ELSE
*
* *** Photon is reflected (no polarization effects)
*
               CALL GLISUR(VECT,VOUT,NUMED1,NUMED2,U,PDOTU,IERR)
               IF (IERR.NE.0) THEN
                  WRITE(CHMAIL,10200) IERR
                  CALL GMAIL(0,0)
                  GO TO 110
               END IF
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   80          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 80
                  ENDIF
               ENDIF
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
               EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL  = 0
            ENDIF
         ELSE
*
*  case dielectric-dielectric:
*
            CALL GLISUR(VECT,VOUT,NUMED1,NUMED2,U,PDOTU,IERR)
            IF (IERR.NE.0) THEN
               WRITE(CHMAIL,10200) IERR
               CALL GMAIL(0,0)
               GO TO 110
            END IF
            EDOTU = POLAR(1)*U(1) + POLAR(2)*U(2) + POLAR(3)*U(3)
            COST1 = -PDOTU
            IF (ABS(COST1).LT.1.) THEN
               SINT1 = SQRT((1-COST1)*(1+COST1))
               SINT2 = SINT1*RIN1/RIN2
            ELSE
               SINT1 = 0.0
               SINT2 = 0.0
            END IF
            IF (SINT2.GE.1) THEN
*
* ***  Simulate total internal reflection
*
               NMEC=NMEC+1
               LMEC(NMEC)=106
*
* ** Restore old volume tree, the photon does not cross the boundary
*
*              CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
               CALL GTMEDI(VIN,N)
               LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
               NBPUSH = 0
   90          NBPUSH = NBPUSH+1
               IF(NBPUSH.GT.MXPUSH) THEN
                  WRITE(CHMAIL,10300) NTMULT,NSTEP
                  CALL GMAIL(0,0)
                  ISTOP=1
                  GOTO 110
               ELSE
                  CALL GINVOL(VECT,ISAME)
                  IF(ISAME.EQ.0) THEN
                     PRECN = NBPUSH*PREC
                     VECT(1) = VECT(1) - PRECN*VECT(4)
                     VECT(2) = VECT(2) - PRECN*VECT(5)
                     VECT(3) = VECT(3) - PRECN*VECT(6)
                     GO TO 90
                  ENDIF
               ENDIF
*
               VECT(4) = +VECT(4) - 2*PDOTU*U(1)
               VECT(5) = +VECT(5) - 2*PDOTU*U(2)
               VECT(6) = +VECT(6) - 2*PDOTU*U(3)
               POLAR(1) = -POLAR(1) + 2*EDOTU*U(1)
               POLAR(2) = -POLAR(2) + 2*EDOTU*U(2)
               POLAR(3) = -POLAR(3) + 2*EDOTU*U(3)
               INWVOL = 0
            ELSE
*
* ***  Calculate amplitude for transmission (Q = P x U)
*
               COST2 = SIGN(1.0,COST1)*SQRT((1-SINT2)*(1+SINT2))
               IF (SINT1.GT.1.E-4) THEN
                  QQ(1) = VECT(5)*U(3) - VECT(6)*U(2)
                  QQ(2) = VECT(6)*U(1) - VECT(4)*U(3)
                  QQ(3) = VECT(4)*U(2) - VECT(5)*U(1)
                  EPERP1 = (POLAR(1)*QQ(1) + POLAR(2)*QQ(2) + POLAR(3)*
     +            QQ(3))
                  ENORM  = SQRT(EPERP1**2+EDOTU**2)
                  EPERP1 = EPERP1/ENORM
                  EPARL1 = EDOTU/ENORM
               ELSE
                  QQ(1) = POLAR(1)
                  QQ(2) = POLAR(2)
                  QQ(3) = POLAR(3)
*
*     Here we follow Jackson's conventions and we set the parallel
*     component = 1 in case of a ray perpendicular to the surface
                  EPERP1 = 0.
                  EPARL1 = 1.
               END IF
               IF(COST1.NE.0.) THEN
                  S1 = RIN1*COST1
                  EPERP2 = 2*S1*EPERP1/(RIN1*COST1+RIN2*COST2)
                  EPARL2 = 2*S1*EPARL1/(RIN2*COST1+RIN1*COST2)
                  E2 = EPERP2**2 + EPARL2**2
                  S2 = RIN2*COST2*E2
                  TCOEF = S2/S1
               ELSE
                  TCOEF = 0.
               ENDIF
               CALL GRNDM(RNDM,1)
               IF (RNDM.GT.TCOEF) THEN
*
* *** Simulate reflection
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=106
*
* *** Restore old volume tree, the photon does not cross the boundary
*
*                 CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
                  CALL GTMEDI(VIN,N)
                  LOLDTR=.FALSE.
*
* *** Reflect, but make sure we are in the old volume before
*
                  NBPUSH = 0
  100             NBPUSH = NBPUSH+1
                  IF(NBPUSH.GT.MXPUSH) THEN
                     WRITE(CHMAIL,10300) NTMULT,NSTEP
                     CALL GMAIL(0,0)
                     ISTOP=1
                     GOTO 110
                  ELSE
                     CALL GINVOL(VECT,ISAME)
                     IF(ISAME.EQ.0) THEN
                        PRECN = NBPUSH*PREC
                        VECT(1) = VECT(1) - PRECN*VECT(4)
                        VECT(2) = VECT(2) - PRECN*VECT(5)
                        VECT(3) = VECT(3) - PRECN*VECT(6)
                        GO TO 100
                     ENDIF
                  ENDIF
*
                  VECT(4) = VECT(4) - 2*PDOTU*U(1)
                  VECT(5) = VECT(5) - 2*PDOTU*U(2)
                  VECT(6) = VECT(6) - 2*PDOTU*U(3)
                  IF(SINT1.GT.1E-4) THEN
                     EPARL2 = RIN2*EPARL2/RIN1-EPARL1
                     EPERP2 = EPERP2-EPERP1
                     E2 = EPERP2**2 + EPARL2**2
                     R(1) = U(1) + PDOTU*VECT(4)
                     R(2) = U(2) + PDOTU*VECT(5)
                     R(3) = U(3) + PDOTU*VECT(6)
                     EABS = SQRT(E2)*SINT1
                     CPARL = EPARL2/EABS
                     CPERP = EPERP2/EABS
                     POLAR(1) = CPARL*R(1) - CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) - CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) - CPERP*QQ(3)
                  ELSEIF(RIN2.GT.RIN1) THEN
*
* *** Case of ray perpendicular to the surface. No change or
* *** an inversion of phase.
                     POLAR(1) = -POLAR(1)
                     POLAR(2) = -POLAR(2)
                     POLAR(3) = -POLAR(3)
                  ENDIF
                  INWVOL = 0
               ELSE
*
* *** Simulate transmission/refraction
*
                  NMEC=NMEC+1
                  LMEC(NMEC)=107
                  VECT(1) = VOUT(1)
                  VECT(2) = VOUT(2)
                  VECT(3) = VOUT(3)
                  GEKRAT = GEKRT2
                  IEKBIN = IEKBI2
                  STEPLA = ABSCO2
                  EFFIC = EFFIC2
                  RIN1 = RIN2
                  IF(SINT1.GT.1E-4) THEN
c                     ALPHA = COST1-COST2*(RIN2/RIN1)
c                     D(1) = VECT(4) + ALPHA*U(1)
c                     D(2) = VECT(5) + ALPHA*U(2)
c                     D(3) = VECT(6) + ALPHA*U(3)
c                     DABS = SQRT(D(1)**2+D(2)**2+D(3)**2)
c                     VECT(4) = D(1)/DABS
c                     VECT(5) = D(2)/DABS
c                     VECT(6) = D(3)/DABS
 
c ... more generalized formula for refraction ...		nc
 
		     costp = - cost2
	             cost_rel=cosd(acosd(cost1)-acosd(cost2))
		     if(u(1).gt.-1.e-5.and.u(1).lt.1.e-5.and.
     +                  u(2).gt.-1.e-5.and.u(2).lt.1.e-5)then
		      vectn3 = cost2
	 	      cy = (cost_rel-vect(6)*cost2)/(1.-vect(6)**2)
		      vectn2 = vect(5)*cy
		      vectn1 = vect(4) * vectn2 / vect(5)
		     else if(u(2).gt.-1.e-5.and.u(2).lt.1.e-5.and.
     +                       u(3).gt.-1.e-5.and.u(3).lt.1.e-5)then
		      vectn1 = costp
		      cz = (cost_rel-vect(4)*costp)/(1.-vect(4)**2)
		      vectn3 = vect(6) * cz
		      vectn2 = vect(5) * vectn3 /vect(6)
		     else
		      u_v(1) = u(2)*vect(6) - u(3)*vect(5)
		      u_v(2) = u(3)*vect(4) - u(1)*vect(6)
		      u_v(3) = u(1)*vect(5) - u(2)*vect(4)
	 	      c1 = u_v(1)*u(2) - u_v(2)*u(1)
	 	      c2 = u_v(3)*u(1) - u(3)*u_v(1)
	 	      c3 = costp * u_v(1)
	 	      c4 = c2/c1
	 	      c5 = c3/c1
	 	      c1p = u_v(1)*vect(5) - u_v(2)*vect(4)
	 	      c2p = u_v(3)*vect(4) - vect(6)*u_v(1)
	 	      c3p = cost_rel * u_v(1)
	 	      c4p = c2p/c1p
	 	      c5p = c3p/c1p
 
		      vectn3 = (c5p - c5) / (c4 - c4p)
	 	      vectn2 = vectn3 * c4 + c5
		      if(vect(4).eq.0.)return
		vectn1 = (cost_rel-vect(5)*vectn2-vect(6)*vectn3)/vect(4)
		     endif
		      vect(4) = vectn1
		      vect(5) = vectn2
		      vect(6) = vectn3
 
c ... end correction					nc
	 	
		     PDOTU = -COST2
                     R(1) = U(1) - PDOTU*VECT(4)
                     R(2) = U(2) - PDOTU*VECT(5)
                     R(3) = U(3) - PDOTU*VECT(6)
                     EABS = SQRT(E2)
                     CPARL = EPARL2/(EABS*SINT2)
                     CPERP = EPERP2/(EABS*SINT1)
                     POLAR(1) = CPARL*R(1) + CPERP*QQ(1)
                     POLAR(2) = CPARL*R(2) + CPERP*QQ(2)
                     POLAR(3) = CPARL*R(3) + CPERP*QQ(3)
                  ENDIF
               END IF
            END IF
         END IF
      ENDIF
*                                                             END GTCKOV
  110 IF(LOLDTR) CALL GLVOLU(NLEVL1,NAMES1,NUMBR1,IERR)
10200  FORMAT(' **** GTCKOV: error from GLISUR = ',I10)
10300  FORMAT(' **** GTCKOV: unable to reflect at NTMULT = ',
     +        I8,' step No. ',I8,' photon abandoned!')
      END
+DECK, GSCKOV.
*CMZ :          09/02/98  16.09.29  by  Pavel Nevski
*CMZ :  3.21/02 21/03/94  17.01.28  by  Rene Brun
*-- Author :
      SUBROUTINE GSCKOV(ITMED, NPCKOV, PPCKOV, ABSCO, EFFIC, RINDEX)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *    Stores the tables for UV photon tracking in medium ITMED    *
C.    *    Please note that it is the user's responsability to         *
C.    *    provide all the coefficients:                               *
C.    *                                                                *
C.    *                                                                *
C.    *       ITMED       Tracking medium number                       *
C.    *       NPCKOV      Number of bins of each table                 *
C.    *       PPCKOV      Value of photon momentum (in GeV)            *
C.    *       ABSCO       Absorbtion coefficents                       *
C.    *                   dielectric: absorbtion length in cm          *
C.    *                   metals    : absorbtion fraction (0<=x<=1)    *
C.    *       EFFIC       Detection efficiency for UV photons          *
C.    *       RINDEX      Refraction index (if=0 metal)                *
C.    *                                                                *
C.    *       Called by : <USER>                                       *
C.    *                                                                *
C.    *       Authors: F.Carminati, R.Jones  ************              *
C.    *                                                                *
C.    *       Modifications:                                           *
C.    *       PN, 9-feb-98:   multiple calls subsitute same banks      *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK.
+SEQ,GCUNIT.
C
      DIMENSION PPCKOV(*), ABSCO(*), EFFIC(*), RINDEX(*)
C.
C.    ------------------------------------------------------------------
C.
      JTM = 0
      IF(ITMED.GT.0) THEN
         IF(JTMED.GT.0) THEN
            IF(IQ(JTMED-2).GE.ITMED) THEN
               JTM = LQ(JTMED-ITMED)
            ENDIF
         ENDIF
      ENDIF
      IF(JTM.LE.0) THEN
         WRITE(CHMAIL,10000)
10000   FORMAT(' **** GSCKOV Tracking medium ',I10,' not defined')
         CALL GMAIL(0,0)
         GO TO 999
      ENDIF
      IF(IQ(JTM-2).LT.3) THEN
         CALL MZPUSH(IXSTOR,JTM,3-IQ(JTM-2),0,' ')
      ENDIF
      JTCKOV=LQ(JTM-3)
      IF (JTCKOV.le.0)
     +   CALL MZBOOK(IXCONS,JTCKOV,JTM, -3,'CKOV',4,4,NPCKOV+1,3,-1)
      JABSCO=LQ(JTCKOV-1)
      IF (JABSCO.le.0)
     +   CALL MZBOOK(IXCONS,JABSCO,JTCKOV,-1,'ABSC',0,0,NPCKOV,3,-1)
      JEFFIC=LQ(JTCKOV-2)
      IF (JEFFIC.le.0)
     +   CALL MZBOOK(IXCONS,JEFFIC,JTCKOV,-2,'EFFI',0,0,NPCKOV,3,-1)
      IF(RINDEX(1).GE.1.) THEN
         JINDEX=LQ(JTCKOV-3)
         IF (JINDEX.le.0)
     +    CALL MZBOOK(IXCONS,JINDEX,JTCKOV,-3,'RIND',0,0,NPCKOV,3,-1)
         JCURIN=LQ(JTCKOV-4)
         IF (JCURIN.le.0)
     +    CALL MZBOOK(IXCONS,JCURIN,JTCKOV,-4,'ABCU',0,0,NPCKOV,3,-1)
      ENDIF
      Q(JTCKOV+1)=NPCKOV
      DO 10 J=1, NPCKOV
         Q(JTCKOV+1+J) = PPCKOV(J)
         Q(JABSCO+  J) = MAX(1E-10,ABSCO(J))
         Q(JEFFIC+  J) = EFFIC(J)
         IF(RINDEX(1).GE.1.) THEN
            Q(JINDEX+ J) = RINDEX(J)
            IF(J.GT.1) THEN
               Q(JCURIN+J)=0.5*((1/RINDEX(J-1)**2)+(1./RINDEX(J)**2))
               Q(JCURIN+J)=Q(JCURIN+J-1)+(PPCKOV(J)-PPCKOV(J-1))*
     +                     Q(JCURIN+J)
            ELSE
               Q(JCURIN+J)=0.
            ENDIF
         ENDIF
   10 CONTINUE
*
  999 END
+DECK,GPHOT
*CMZ :  3.21/02 29/03/94  15.41.22  by  S.Giani
*-- Author :
      SUBROUTINE GPHOT
C.
C.    ******************************************************************
C.    *                                                                *
C.    *  GENERATES PHOTO ELECTRIC MECHANISM                            *
C.    *  Corrected version of L. Urban's routine.                      *
C.    *  Improvements:                                                 *
C.    *    1. Angular distributions of photoelectrons from K-L3 shells *
C.    *    2. Generation of shell decay mode                           *
C.    *    3. Probability of interactioon with a shell = function      *
C.    *       of photon energy                                         *
C.    *                                                                *
C.    *    ==>CALLED BY : GTGAMA                                       *
C.    *       AUTHOR    : J. Chwastowski                               *
C.    *                                                                *
C.    ******************************************************************
C.
+SEQ,GCBANK
+SEQ,GCTRAK
+SEQ,GCPHYS
+SEQ,GCONSP
+SEQ,GCKING
+SEQ,GCCUTS
+SEQ,GCJLOC
+SEQ,GCUNIT
      DIMENSION POT(4),PROB(4),RNA(9)
      EQUIVALENCE (RNA(1),RN01),(RNA(2),RN02),(RNA(3),RN03)
      EQUIVALENCE (RNA(4),RN04),(RNA(5),RN05),(RNA(6),RN06)
      EQUIVALENCE (RNA(7),RN07),(RNA(8),RN08),(RNA(9),RN09)
      EQUIVALENCE (POT(1),POTK),(POT(2),POTL1)
      EQUIVALENCE (POT(3),POTL2),(POT(4),POTL3)
      EQUIVALENCE (PROB(1),PROBK),(PROB(2),PROBL1)
      EQUIVALENCE (PROB(3),PROBL2),(PROB(4),PROBL3)
      SAVE ZINOLD,POT,NSHELL
      DATA ZINOLD / 0.0 /
C.
C.    ------------------------------------------------------------------
C.
      KCASE = NAMEC(8)
C
C             STOP ELECTRON ?
C
C Check if the photoelectric effect was activated. If not deposit
C gamma & return
      IF(IPHOT.NE.1) THEN
         ISTOP = 2
         NGKINE= 0
         DESTEP = DESTEP + VECT(7)
         VECT(7) = 0.
         GEKIN = 0.
         GETOT = 0.
      ELSE
         E=VECT(7)
         CALL GRNDM(RNA,9)
         JPHXS = LQ(JPHOT-1)
         NZ = Q(JPHXS+1)
         IF(NZ.GT.1) THEN
            QS = 0.0
            QS2 = GPHSG1(E)*RN01
            DO 10 I = 1,NZ-1
               QS1 = GPHSGP(I,E)
               QS = QS+QS1
               IF(QS2.LE.QS) THEN
                  K = I
                  GO TO 20
               ENDIF
   10       CONTINUE
            K = NZ
   20       CONTINUE
            JPHFN = LQ(JPHXS-K)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+K)
         ELSE
            JPHFN = LQ(JPHXS-1)
            NUSED = Q(JPHFN+1)*5+1
            JFN = JPHFN+NUSED
            ZINT = Q(JPHXS+1+1)
         ENDIF
C COPY SHELLS POTENTIALS FROM THE ZEBRA STUCTURE
C Check if this atom was used in last entry
         IF(ZINT.NE.ZINOLD) THEN
            NSHELL = Q(JFN+1)
            DO 30 I = 1,NSHELL
               POT(I) = Q(JFN+1+I)
   30       CONTINUE
            ZINOLD = ZINT
         ENDIF
C Check if E-gamma is bigger than the L3 ionization potential.
C This will make GPHOT a little faster.
         ISHELL = 0
         PROB(1) = 0.
         PROB(2) = 0.
         PROB(3) = 0.
         PROB(4) = 0.
         IF(E.GE.POTL3) THEN
C If ZINT < 5 we can have K shell only, so
            IF(ZINT.LT.5) THEN
               IF(E.GT.POTK) THEN
                  PROBK = 1.
                  TK = E-POTK
                  ISHELL = 1
               ENDIF
            ELSE
C The probabilities given below come from crude approximation
C It uses the jump ratios and assumes that they are valid for the whole energy
C range.
               IF(E.LT.POTL2) THEN
                  PROBL3 = 1.0
                  TK = E-POTL3
                  ISHELL = 4
               ELSE
                  E3 = E-POTL3
                  GAMAL3 = E3/EMASS+1.
                  BETAL3 = SQRT(E3*(E3+2.0*EMASS))/(E+EMASS)
                  E2 = E-POTL2
                  GAMAL2 = E2/EMASS+1.
                  BETAL2 = SQRT(E2*(E2+2.0*EMASS))/(E+EMASS)
                  EFRAC = EMASS/E
                  PROBL3 = GAVRL3(GAMAL3,BETAL3,EFRAC)
                  PROBL2 = GAVRL2(GAMAL2,BETAL2,EFRAC)
                  ANOR = 1./(PROBL3+PROBL2)
                  PROBL3 = PROBL3*ANOR
                  PROBL2 = PROBL2*ANOR
                  IF(E.LT.POTL1) THEN
                     IF(RN02.LT.PROBL3) THEN
                        ISHELL = 4
                        TK = E-POTL3
                     ELSE
                        ISHELL = 3
                        TK = E-POTL2
                     ENDIF
                  ELSE
C Parametrization of L1 jump ratio gives constant 1.2
                     PROBL1 = 1.-1./1.2
                     IF(E.LT.POTK) THEN
                        PROBL2 = (1.-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBL1)*PROBL3
                     ELSE
                        PROBK = 125./ZINT+3.5
                        PROBK = 1.-1/PROBK
                        PROBL1 = (1.-PROBK)*PROBL1
                        PROBL2 = (1.-PROBK-PROBL1)*PROBL2
                        PROBL3 = (1.-PROBK-PROBL1)*PROBL3
                     ENDIF
                     IF(POTL3.LE.0.0) PROBL3 = 0.0
                     IF(POTL2.LE.0.0) PROBL2 = 0.0
                     IF(POTL1.LE.0.0) PROBL1 = 0.0
                     ANOR = PROBK+PROBL1+PROBL2+PROBL3
                     IF(ANOR.GT.0.0) THEN
                        ANOR = 1./ANOR
                        PROBK = PROBK*ANOR
                        PROBL1 = PROBL1*ANOR+PROBK
                        PROBL2 = PROBL2*ANOR+PROBL1
                        PROBL3 = PROBL3*ANOR+PROBL2
                        ISHELL = 4
                        TK = E-POTL3
                        IF(RN02.LE.PROBK) THEN
                           ISHELL = 1
                           TK = E-POTK
                        ELSEIF(RN02.LE.PROBL1) THEN
                           ISHELL = 2
                           TK = E-POTL1
                        ELSEIF(RN02.LE.PROBL2) THEN
                           ISHELL = 3
                           TK = E-POTL2
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
            IF(TK.LE.CUTELE) ISHELL = -ISHELL
         ENDIF
         IF(ISHELL.LT.1) THEN
C None of the shells was chosen because of the CUTELE
            ISTOP = 2
            IF(ISHELL.LT.0) THEN
               DESTEP = DESTEP+TK
            ELSEIF(ISHELL.EQ.0) THEN
               DESTEP = DESTEP+VECT(7)
            ENDIF
            NGKINE= 0
            VECT(7) = 0.
            GEKIN = 0.
            GETOT = 0.
         ELSE
C
C             ENERGY AND MOMENTUM OF PHOTOELECTRON
C
            EEL=TK + EMASS
            PEL=SQRT((TK+2.*EMASS)*TK)
            BETA = PEL/EEL
            ISTOP = 1
            NGKINE = 1
            IF(ISHELL.EQ.1) THEN
               COST = GPHAK(BETA)
            ELSEIF(ISHELL.EQ.2) THEN
               COST = GPHAL1(BETA)
            ELSEIF(ISHELL.EQ.3) THEN
               COST = GPHAL2(BETA)
            ELSEIF(ISHELL.EQ.4) THEN
               COST = GPHAL3(BETA)
            ENDIF
            PHI = TWOPI*RN03
            COSPHI = COS(PHI)
            SINPHI = SIN(PHI)
            SINT = SQRT((1.-COST)*(1.+COST))
            GKIN(1,NGKINE) = PEL*SINT*COSPHI
            GKIN(2,NGKINE) = PEL*SINT*SINPHI
            GKIN(3,NGKINE) = PEL*COST
            GKIN(4,NGKINE) = EEL
            GKIN(5,NGKINE) = 3.
            TOFD(NGKINE) = 0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
C
C             ROTATE ELECTRON AND SCATTERED PHOTON INTO GEANT SYSTEM
C
            CALL GVROT(VECT(4),GKIN)
         ENDIF
         IF(ISHELL.NE.0) THEN
            ISHELL = ABS(ISHELL)
            IF(ZINT.GE.5.AND.POT(ISHELL).GT.MIN(CUTGAM,CUTELE)) THEN
C Generate shell decay mode
               IF(RN04.LE.Q(JFN+1+NSHELL+ISHELL)) THEN
                  IF(POT(ISHELL).LE.CUTGAM) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
C Radiative shell decay
                     JS = JFN+1+2*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 40 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 50
                        ENDIF
   40                CONTINUE
   50                CONTINUE
                  ENDIF
               ELSE
                  IF(POT(ISHELL).LE.CUTELE) THEN
                     DESTEP = DESTEP+POT(ISHELL)
                  ELSE
c Nonradiative decay
                     JS = JFN+1+3*NSHELL+ISHELL
                     JS = JPHFN+Q(JS)
                     NPOINT = Q(JS)
                     DO 60 I = 1,NPOINT
                        IF(RN05.LT.Q(JS+I)) THEN
                           TSEC = Q(JS+NPOINT+I)
                           IF(TSEC.GT.CUTELE) THEN
                              EEL=TSEC + EMASS
                              PEL=SQRT((TSEC+2.*EMASS)*TSEC)
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN06
                              COST = 2.*RN07-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = PEL*SINT*COSPHI
                              GKIN(2,NGKINE) = PEL*SINT*SINPHI
                              GKIN(3,NGKINE) = PEL*COST
                              GKIN(4,NGKINE) = EEL
                              GKIN(5,NGKINE) = 3.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+ABS(TSEC)
                           ENDIF
C The following particle forces the energy conservation
                           TSEC = POT(ISHELL)-ABS(TSEC)
                           IF(TSEC.GT.CUTGAM) THEN
                              NGKINE = NGKINE+1
                              PHI = TWOPI*RN08
                              COST = 2.*RN09-1.
                              COSPHI = COS(PHI)
                              SINPHI = SIN(PHI)
                              SINT = SQRT((1.-COST)*(1.+COST))
                              GKIN(1,NGKINE) = TSEC*SINT*COSPHI
                              GKIN(2,NGKINE) = TSEC*SINT*SINPHI
                              GKIN(3,NGKINE) = TSEC*COST
                              GKIN(4,NGKINE) = TSEC
                              GKIN(5,NGKINE) = 1.
                              TOFD(NGKINE) = 0.
                              GPOS(1,NGKINE) = VECT(1)
                              GPOS(2,NGKINE) = VECT(2)
                              GPOS(3,NGKINE) = VECT(3)
                           ELSE
                              DESTEP = DESTEP+TSEC
                           ENDIF
                           GO TO 70
                        ENDIF
   60                CONTINUE
   70                CONTINUE
                  ENDIF
               ENDIF
            ELSE
               DESTEP = DESTEP+POT(ISHELL)
            ENDIF
         ENDIF
      ENDIF
      END
+PATCH,DZDOC. =================================================================
*CMZ :  1.00/01 02/02/96  12.36.40  by  G. Poulard
+DECK,DZE2HT. ----------------------------------------------------------------
*CMZ :  1.30/00 11/02/96  22.08.12  by  Pavel Nevski
*CMZ :  1.00/01 09/12/95  16.20.44  by  Pavel Nevski
*-- Author :    O.Schaile
************************************************************************
*                                                                      *
      SUBROUTINE DZE2HT(LUNIN,LUNUSE, FLAG, UPUP1)
*                                                                      *
*     convert DZEDIT SGML to HTML, plug in links                       *
*                                                                      *
*     flag:       Steering flag:                                       *
*                 0 make all hyperlinks internal only                  *
*                 1 add file name in first up bank                     *
*                 2 add file names in all links                        *
*                 3 as 2 and make 1 file/bank                          *
*     upup1:      Id of Upbank of Upbank of top bank                   *
*                                                                      *
*     output file name(s): BankId//UpId.html                           *
*                                                                      *
*     Author: O.Schaile                                                *
*                                                                      *
************************************************************************
      IMPLICIT NONE
 
      INTEGER       LUNIN,LUNUSE
      CHARACTER*80  CFOUT
      CHARACTER*4   UPUP1
      INTEGER       FLAG
      INTEGER       ML, MS
      PARAMETER     (ML=2000, MS=5000)
      CHARACTER*132 CB(ML), CL
      CHARACTER*8   CSTACK(MS), CLIST(MS)
      CHARACTER*4   BANKID, UPID, UPUPID, DOWNID
      CHARACTER*13  CF
      CHARACTER*4   DZE2US
      INTEGER IPBKID,IPUP,IPLSTA,IPLLAS, ISTAT, IP, IPSTAC,I,J,K,NC
     +        ,INDEXA,INDEXN,INDEXC,LNBLNK, IS, NUP,NCUPID,NCCF,IPLIST
     +        ,LUNOUT, NBANKS, NFILES
      LOGICAL EOF, IGNORE
*---
      IF(UPUP1.EQ.' ')THEN
         UPUP1='NONE'
      ELSE
         UPUP1=DZE2US(UPUP1)
      ENDIF
      EOF=.FALSE.
      IGNORE=.FALSE.
      NUP = 0
      NBANKS=0
      NFILES=0
      LUNOUT=0
 
*     Run through files and find all banks
      IPBKID=0
      IPUP=0
      IPLIST=0
*  10    READ(LUNIN,'(A)',END=50)CL
10    CALL DZDCRD(LUNIN,CL,ISTAT)
      IF(ISTAT.NE.0)GOTO 50
      IF(CL(2:9).EQ.'Bank IDH')THEN
         IPBKID=1
         CB(1)=CL
         BANKID=CL(12:15)
      ELSE IF(CL(2:5).EQ.'Up  ')THEN
         IF(IPBKID.EQ.0)THEN
            WRITE(*,*)'Prescan: Upbank appears before bank'
            GOTO 999
         ENDIF
         UPID=CL(12:15)
         BANKID=DZE2US(BANKID)
         UPID  =DZE2US(UPID)
         IPLIST=IPLIST+1
         IF(IPLIST.GT.MS)THEN
            WRITE(*,*)'Too many banks',IPLIST
            GOTO 999
         ENDIF
         CLIST(IPLIST)=BANKID//UPID
         IPBKID=0
      ENDIF
      GOTO 10
 
 50   CONTINUE
 
      REWIND(LUNIN)
*     LOOP ON BANKS
 
      IPSTAC=0
 100  CONTINUE
      IP=0
      IPBKID=0
      IPUP=0
      IPLSTA=0
      IPLLAS=0
*   110  READ(LUNIN,'(A)',END=150)CL
 110    CALL DZDCRD(LUNIN,CL,ISTAT)
      IF(ISTAT.NE.0)GOTO 150
*     IGNORE ALL CONTROL LINES
      IF(CL(1:4).EQ.'<FIG')IGNORE=.TRUE.
      IF(CL(1:5).EQ.'</FIG')IGNORE=.FALSE.
      IF(IGNORE)GOTO 110
      IF(CL(1:1).EQ.'<')GOTO 110
      IF(CL(1:2).EQ.' |')GOTO 110
      IF(CL(1:11).EQ.' ----------')GOTO 110
*     GET HERE FOR START OF A NEW BANK
 115  CONTINUE
      IF(CL(2:9).EQ.'Bank IDH')THEN
*        ONE FILE/BANK
         IF(FLAG.GE.3)THEN
            IF(LUNOUT.NE.0)THEN
               CLOSE(LUNOUT)
               LUNOUT=0
            ENDIF
         ENDIF
         IF(IPBKID.NE.0)THEN
            NBANKS=NBANKS+1
            IF(IPLSTA.NE.0 .AND. IPLLAS.EQ.0)IPLLAS=IP
            IPSTAC=IPSTAC+1
            IF(IPSTAC.GT.MS)THEN
               WRITE(*,*)'Too many banks'
               GOTO 999
            ENDIF
*
            NCUPID=LNBLNK(UPID)
            BANKID=DZE2US(BANKID)
            UPID  =DZE2US(UPID)
            IF(LUNOUT.LE.0)THEN
               LUNOUT=LUNUSE
               CALL CUTOL(CFOUT)
+SELF,IF=-QMIBM.
               CFOUT=BANKID//UPID//'.html'
               CALL KUOPEN(LUNOUT,CFOUT(1:LNBLNK(CFOUT)),
     +                    'UNKNOWN',ISTAT)
+SELF,IF=QMIBM.
               CFOUT=BANKID//UPID//' html'
               CALL FILEINF(ISTAT,'LRECL',256,'RECFM','V')
               OPEN(LUNOUT,FILE='/'//CFOUT(1:LNBLNK(CFOUT)),
     +         ACCESS='SEQUENTIAL',
     +          STATUS='UNKNOWN',FORM='FORMATTED',IOSTAT=ISTAT)
+SELF.
               NFILES=NFILES+1
               WRITE(LUNOUT,'(A)')'<html>'
               WRITE(LUNOUT,'(A)')'<head>'
               WRITE(LUNOUT,'(A)')'<body>'
               WRITE(LUNOUT,'(A)')'<isindex>'
               WRITE(LUNOUT,'(A)')'</head>'
               WRITE(LUNOUT,'(A)')'<body>'
               WRITE(LUNOUT,'(A)')'<pre>'
            ENDIF
            CSTACK(IPSTAC)=BANKID//UPID
            DO I=1,IP
               NC = LNBLNK(CB(I))
               IF(I.EQ.IPBKID)THEN
                  WRITE(LUNOUT,'(A)')'<hr>'
                  WRITE(LUNOUT,'(A)')'<a name="'
     +            //BANKID//UPID//'"><b>'//
     +            CB(I)(1:NC)//'</b></a>'
               ELSE IF(I.EQ.IPUP .AND. UPID.NE.'NONE')THEN
*                 FIRST FIND UP BANK OF IT
                  IF(IPSTAC.EQ.1 .AND. UPUP1.NE.' ')THEN
                     UPUPID=UPUP1
                  ELSE
                     UPUPID='NONE'
                     IF(IPSTAC.GT.1)THEN
                        DO K=IPSTAC-1,1,-1
                           IF(CSTACK(K)(1:4).EQ.UPID)THEN
                              UPUPID=CSTACK(K)(5:8)
                              GOTO 120
                           ENDIF
                        ENDDO
 120                    CONTINUE
                     ENDIF
                  ENDIF
                  IF((FLAG.GE.1 .AND. NUP .EQ.0) .OR.
     +                FLAG.GE.2) THEN
                     CF=UPID//UPUPID//'.html'
                     CALL CUTOL(CF)
                     NCCF=LNBLNK(CF)
                  ELSE
                     NCCF=0
                  ENDIF
                  NUP=NUP+1
                  NC=MAX(NC,16)
                  IF(NCCF.GT.0)THEN
                     WRITE(LUNOUT,'(A)')' Up        <a href="'//
     +                           CF//'#'//UPID//UPUPID//
     +                      '"><b>'//CB(I)(12:15)//'</b></a>'//
     +                        CB(I)(16:NC)
                  ELSE
                     WRITE(LUNOUT,'(A)')' Up        <a href="'//
     +                                       '#'//upid//upupid//
     +                      '"><b>'//CB(I)(12:15)//'</b></a>'//
     +                        CB(I)(16:NC)
                  ENDIF
               ELSEIF(IPLSTA.NE.0.AND.I.GE.IPLSTA.AND.I.LE.IPLLAS)THEN
                  IS=INDEXC(CB(I),' ')
                  IF(IS.LE.0)GOTO 145
*                 is it an integer, i.e. only numbers or space?
                  DO 126 J=IS,IS+4
                     IF(CB(I)(J:J).NE.' ')THEN
                        IF(INDEXN(CB(I)(J:J)).NE.1)GOTO 130
                     ENDIF
126               CONTINUE
*                  READ(CB(I)(IS:IS+4),'(I5)',ERR=130)K
*                 yes, where does name start?
                  IS = INDEXA(CB(I))
                  IF(IS.LE.0)THEN
                     WRITE (*,*)' Down link has no name ', BANKID, UPID
                     WRITE(*,*) CB(I)
                     IS=10
                  ENDIF
                  DOWNID=CB(I)(IS:IS+3)
                  DOWNID=DZE2US(DOWNID)
                  IF(FLAG.GE.2)THEN
                     CF=DOWNID//BANKID//'.html'
                     CALL CUTOL(CF)
                     NCCF=13
                  ELSE
                     NCCF=0
                  ENDIF
                  IF(NCCF.GT.0)THEN
                     NC=MAX(NC,IS+4)
                     WRITE(LUNOUT,'(A)')CB(I)(1:IS-1)//
     +                           '<a href="'//CF//'#'//
     +                           DOWNID//BANKID//'"><b>'//
     +                           CB(I)(IS:IS+3)//'</b></a>'//
     +                           CB(I)(IS+4:NC)
                  ELSE
*                    is there doc?
                     DO K=1,IPLIST
                        IF(CLIST(K).EQ.DOWNID//BANKID)THEN
                           WRITE(LUNOUT,'(A)')CB(I)(1:IS-1)//
     +                           '<a href="#'//
     +                           DOWNID//BANKID//'"><b>'//
     +                           CB(I)(IS:IS+3)//'</b></a>'//
     +                           CB(I)(IS+4:NC)
                            GOTO 125
                         ENDIF
                     ENDDO
*                    fallen through do loop, no doc there
                     WRITE(LUNOUT,'(A)')CB(I)(1:IS-1)//
     +                           '<a href="nodoc.html"><b>'//
     +                           CB(I)(IS:IS+3)//'</b></a>'//
     +                           CB(I)(IS+4:NC)
                     WRITE(*,'(A)')' No doc for: '
     +               //DOWNID//' '//BANKID//
     +               ' will make a reference to: "nodoc.html"'
 125                 CONTINUE
                  ENDIF
                  GOTO 140
 130              CONTINUE
                  NC=MAX(NC,1)
                  WRITE(LUNOUT,'(A)')CB(I)(1:NC)
 140              CONTINUE
               ELSE
                  NC=MAX(NC,1)
                  WRITE(LUNOUT,'(A)')CB(I)(1:NC)
               ENDIF
 145           CONTINUE
            ENDDO
            IF(EOF) GOTO 900
            IPBKID=0
            IP=0
            IPBKID=0
            IPUP=0
            IPLSTA=0
            IPLLAS=0
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPBKID=IP
         BANKID=CL(12:15)
         CALL CLTOU(BANKID)
      ELSE IF(CL(2:5).EQ.'Up  ')THEN
         IF(IPUP.NE.0)THEN
            WRITE(*,*)'More then 1 Up bank'
            GOTO 999
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPUP=IP
         UPID=CL(12:15)
         CALL CLTOU(UPID)
      ELSE IF(INDEX(CL,'Description of the links') .NE. 0)THEN
         IF(IPLSTA.NE.0)THEN
            WRITE(*,*)'More then 1 Link block start'
            GOTO 999
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPLSTA=IP+1
      ELSE IF(INDEX(CL,'Description of the data') .NE. 0)THEN
         IF(IPLLAS.NE.0)THEN
            WRITE(*,*)'More then 1 Link block end'
            GOTO 999
         ENDIF
         IP=IP+1
         CB(IP)=CL
         IPLLAS=IP-1
      ELSE
         IP=IP+1
         CB(IP)=CL
      ENDIF
      GOTO 110
 150  EOF=.TRUE.
*     DO THE LAST BANK
      CL(2:9)='Bank IDH'
      GOTO 115
 
900   CONTINUE
      WRITE(LUNOUT,'(A)')'</pre>'
      WRITE(LUNOUT,'(A)')'</body>'
      WRITE(LUNOUT,'(A)')'</html>'
      CLOSE(LUNIN)
      CLOSE(LUNOUT)
999   END
 
      CHARACTER*(*) FUNCTION DZE2US(CH)
      CHARACTER*(*) CH
      DO I=1,LEN(CH)
         IF(CH(I:I).EQ.' ')THEN
            DZE2US(I:I)='_'
         ELSE
            DZE2US(I:I)=CH(I:I)
         ENDIF
      ENDDO
      RETURN
      END
+DECK, DZDENT. ----------------------------------------------------------------
*CMZ :  1.30/00 11/02/96  22.08.12  by  Pavel Nevski
*CMZU:  1.00/01 21/01/96  20.40.48  by  Sasha Vanyashin
*CMZ :          09/12/95  16.20.44  by  Pavel Nevski
*-- Author :    M. Goossens DD/US
      SUBROUTINE DZDENT
************************************************************************
*.                                                                     *
*...DZDENT outputs the link,data and status bit information for a bank *
*.                                                                     *
*.  DZDENT is a daugther routine of DZDOCO                             *
*.  It prints the information about the link, status bit and data      *
*.  part of a given bank identifier                                    *
*.                                                                     *
*. BANKS  R : QBKD                                                     *
*. CALLS    : DZDLIN,INDXBC                                            *
*. CALLED   : DZDOCO                                                   *
*. COMMON   : DZDOCC,DZDTAP,MZCN                                       *
*.                                                                     *
*. AUTHOR   : M. Goossens DD/US                                        *
*. VERSION  : 2.03(47)  / 11 Oct 1987                                  *
*.                                                                     *
*. UPDATE   : 21 Mar 1988                                              *
*. BY       : O.Schaile                                                *
*.            Allow return of all described links if B-option is       *
*.            given (rather then only announced one)                   *
*.            Use link in link area (LBQBKD, LQBKD) for all references *
*.            Suppress printing at various places if B-option given    *
*.            3 Dec 88                                                 *
*.            simplify SGML, remove all SGML from this routine         *
*.            21-Nov-95 PN:  Z option supress data description dump    *
*.**********************************************************************
C     SAVE
 
+CDE, BKWRP,TAPES.
+CDE,ZBCDK.         From DZEBRA
+CDE,LINOUT.
      LOGICAL BTEST, LTHERE, RTHERE,BTHERE,DTHERE
*--     General information
      CHARACTER CFORM*4
+SEQ,DOCPARQ,DZDOCOBK.
+SEQ,BKNUPARQ,BKFOPARQ.
+SEQ,BKSTPARQ,BKTGPARQ,BKTGDATQ.
 
      LTHERE=.FALSE.
      RTHERE=.FALSE.
      BTHERE=.FALSE.
      DTHERE=.FALSE.
   10 CONTINUE
 
*--     Loop over the link, status bit and data information
 
      II     = NBHEAQ
      IF (IFLOPT(MPOSBQ).NE.0) THEN
*--         Link description bank option
*--           Number of links announced
          NLLINK = IQ(KQSP+LBQBKD+MONLQ)
          NSLINK = IQ(KQSP+LBQBKD+MONSQ)
          NLLL = MAX(NLLINK,NSLINK)
*--           Get the number ow words required in the bank
          NLPUSH = NLLL + MOLK0Q - IQWND(KQSP+LBQBKD)
*--           If number of link > 0 -- Push bank, otherwise noopt
 
*--- OTTO    allow return of non announced links
 
*--          CALL DZVERI('Before MZPUSH',0,'CFLSU')
         IF (NLLL.GE.0) CALL MZPUSH(0,LBQBKD,0,NLPUSH,'I')
*--      PRINT '('' NLLINK NLPUSH '',2I5)',NLLINK,NLPUSH
*--      CALL DZSHOW('After PUSH',0,L,' ',0,0,0,0)
*--           Local working variables
*--            0th address and max. nb. entries in link description bank
*          MBLK0  = KQSP + LBQBKD + MOLK0Q
          NBLMAX = IQWND(KQSP+LBQBKD) - MOLK0Q
 
          IHLPUT = 0
 
      ENDIF
      ITAG   = IOTAGQ
      IF (IFLOPT(MPOSIQ).NE.0) THEN
         IREP   = 0
      ELSE
         IREP   = 5
      ENDIF
 
      DO 120 I=MBLINQ,MBDATQ
          IF (IFLOPT(MPOSBQ).NE.0.AND.I.NE.MBLINQ)         GO TO 120
          II     = II + IQ(KQSP+LQBKD+I-1)
          INSERT = II + 1
          IREPLO = 0
          INDENT = 0
          IF (I.EQ.MBLINQ .AND. IFLOPT(MPOSBQ).EQ.0) THEN
              IF (IQ(KQSP+LQBKD+I).GT.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     WRITE(LUNUSR,'(''*B.LINK'')')
                     LTHERE=.TRUE.
                 ELSE
                     WRITE(LUNUSR,10102) 'links'
10102                format(T15,' ---------- Description of the ',a,
     +                          ' ----------')
                 ENDIF
             ELSE
C--              No link description
                                                           GO TO 120
             ENDIF
 
          ELSEIF (I.EQ.MBRLIQ) THEN
              IF (IQ(KQSP+LQBKD+I).GT.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     RTHERE=.TRUE.
                     IF(LTHERE)THEN
                        WRITE(LUNUSR,'(''*B/LINK'')')
                        LTHERE=.FALSE.
                     ENDIF
                     WRITE(LUNUSR,'(''*B.RLINK'')')
                 ELSE
                     WRITE(LUNUSR,10102) 'Reference links'
                 ENDIF
             ELSE
C--              No ref link description
                                                           GO TO 120
             ENDIF
 
          ELSEIF (I.EQ.MBBITQ) THEN
            IF (IQ(KQSP+LQBKD+I).GT.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     WRITE(LUNUSR,'(''*B.BI'')')
                     BTHERE=.TRUE.
                     IF(LTHERE)THEN
                        WRITE(LUNUSR,'(''*B/LINK'')')
                        LTHERE=.FALSE.
                     ENDIF
                     IF(RTHERE)THEN
                        WRITE(LUNUSR,'(''*B/RLINK'')')
                        RTHERE=.FALSE.
                     ENDIF
                 ELSE
                     WRITE(LUNUSR,10102) 'status bits'
                 ENDIF
            ELSE
C--               No status bit description
                                                           GO TO 120
            ENDIF
          ELSEIF (I.EQ.MBDATQ) THEN
            IF (IQ(KQSP+LQBKD+I).GT.0 .AND. IFLOPT(MPOSZQ).EQ.0) THEN
                 IF (IFLOPT(MPOSIQ).NE.0) THEN
                     WRITE(LUNUSR,'(''*B.DATA'')')
                     DTHERE=.TRUE.
                     IF(LTHERE)THEN
                        WRITE(LUNUSR,'(''*B/LINK'')')
                        LTHERE=.FALSE.
                     ENDIF
                     IF(RTHERE)THEN
                        WRITE(LUNUSR,'(''*B/RLINK'')')
                        RTHERE=.FALSE.
                     ENDIF
                     IF(BTHERE)THEN
                        WRITE(LUNUSR,'(''*B/BI'')')
                        BTHERE=.FALSE.
                     ENDIF
                 ELSE
                     WRITE(LUNUSR,10102) 'data words'
                 ENDIF
            ELSE
C--            No data description
                                                           GO TO 120
            ENDIF
          ENDIF
   20     IF (INSERT.GT.II+IQ(KQSP+LQBKD+I))               GO TO 100
          JTAG   = IQ(KQSP+LQBKD+INSERT+MBPATQ)
          NWTAG  = IBITS(JTAG,ICHTGQ,NCHTGQ)
          ICHOIC = IBITS(JTAG,ICHBTQ,1)
          IDTAG  = IBITS(JTAG,ICHIDQ,NCHIDQ)
          IREPLV = IBITS(JTAG,IRPLVQ,NRPLVQ)
          IF (IREPLO.LT.IREPLV) THEN
*----           Repetition field descriptor
*--                  Start of higher level
               IF (IFLOPT(MPOSIQ).NE.0) THEN
                  COUT   = '*B.REP '
                  INDENT = 8
               ELSE
                  INDENT = IREPLO*INDENQ
                  COUT   = ' '
                  COUT(INDENT+2:)='--REP level='//
     +                         CHAR(ICHAR('0')+IREPLV)
               ENDIF
 
*1810               IF    (IREPLO.EQ.0)THEN
*1810                  COUT(INDENT+2:)='-- Do I = 1,'
*1810               ELSE IF(IREPLO.EQ.1)THEN
*1810                  COUT(INDENT+2:)='-- Do K = 1,'
*1810               ELSE
*1810                  COUT(INDENT+2:)='-- Do J = 1,'
*1810               ENDIF
              IREPLO = IREPLV
              INUM1  = IQ(KQSP+LQBKD+INSERT+MBIX1Q)
              IF (INUM1.GT.0) THEN
*--               Given as real number
                  WRITE(COUT(ITAG+IREP+INDENT:),'(I8)') INUM1
              ELSEIF (INUM1.EQ.INUINQ) THEN
*--                 Indefinite (variable) number
                  COUT(ITAG+IREP+INDENT:) = 'infinite'
              ELSE
*--                 Information is in form of Hollerith text
                  NWTAG = -INUM1/JFOSEQ
              ENDIF
*--             Skip I self-describing sector
              INSERT = INSERT + NBDSCQ
*--             If not Hollerith self-describing sector -- SKIP
              IF (MOD(IQ(KQSP+LQBKD+INSERT),JFOSEQ).NE.IFOHOQ) THEN
                  IF (NWTAG.GT.0) THEN
*--                     Inconsistency: Tag announced and non present
                      WRITE(LUNUSR,10103)
10103                 format('0?? DZDENT: Inconsistency: ',
     +                'Tag information announced and non present')
                                                           GO TO 130
                  ENDIF
                  IF(IFLOPT(MPOSBQ).EQ.0)THEN
*                     IF (INUM1.NE.0)
                      WRITE(LUNUSR,'(A)') COUT
                  ENDIF
                                                           GO TO 20
              ENDIF
*--             Total number of Hollerith words
              NWHOLL = IQ(KQSP+LQBKD+INSERT)/JFOSEQ
              INSERT = INSERT + 1
*--             When there is tag info
              IF (NWTAG.GT.0) THEN
*--                Numbers given as Hollerith text
                 INLINE=ITAG+IREP+INDENT
                 CALL UHTOC(IQ(KQSP+LQBKD+INSERT),4,
     +                      COUT(INLINE:),NWTAG*4)
                 INSERT = INSERT + NWTAG
                 NWHOLL = NWHOLL - NWTAG
              ENDIF
*--             Is there some text left
              IF (NWHOLL.GT.0) THEN
*--                 More text in the buffer
                  INLINE = INLINE+NWTAG*4
*                  INLINE = IOENTQ + IREP + INDENT
                  IEWORK = 0
                  NOUTF  = NOUTQ - INLINE + 1
                  CALL DZDLIN
              ELSE
                  IF(IFLOPT(MPOSBQ).EQ.0)WRITE(LUNUSR,'(A)') COUT
              ENDIF
 
*------------------ End of loop over Hollerith text
              INDENT = IREPLV*INDENQ
          ELSEIF (IREPLO.GT.IREPLV) THEN
*----           End of repetition field
              IF (IFLOPT(MPOSBQ) .EQ. 0)THEN
*--              Level goes down --> close present level
                  INDENT = IREPLV*INDENQ
                  IF (IFLOPT(MPOSIQ).NE.0) THEN
                     COUT   = '*B/REP '
                  ELSE
                     COUT   = ' '
                     COUT(INDENT+2:)='--REP level='//
     +                       CHAR(ICHAR('0')+IREPLO)//' -- End --'
*1810               COUT(INDENT+2:)='-- End Do -----------------------'
                 ENDIF
                 WRITE (LUNUSR,'(A)') COUT
              ENDIF
              IREPLO = IREPLV
*--             Cross check on EOFS flag
              IF (.NOT.BTEST(JTAG,IBEOSQ)) THEN
                   WRITE (LUNUSR,10101)
*                  WRITE (LUNOUT,10101)
10101              format('0??? DZDENT- Illegal repetition level',
     +                    ' counting (only 1 item allowed')
                                                          GO TO 130
              ELSE
*--                 Skip I self-describing sector
                  INSERT = INSERT + NBEOSQ
              ENDIF
          ELSE
*----           Entry documentation
              INUM1  = IQ(KQSP+LQBKD+INSERT+MBIX1Q)
              INUM2  = IQ(KQSP+LQBKD+INSERT+MBIX2Q)
              IF (INUM1.GT.0) THEN
*--               Get number of characters in INUM1
                  ICH    = INUM1
                  DO 30  IW1=1,8
                      ICH = ICH/10
                      IF (ICH.EQ.0)                        GO TO 40
   30             CONTINUE
                  IW1 = 8
   40         ENDIF
              IF (INUM2.GT.0) THEN
*--               Get number of characters in INUM2
                  ICH    = INUM2
                  DO 50  IW2=1,8
                      ICH = ICH/10
                      IF (ICH.EQ.0)                        GO TO 60
   50             CONTINUE
                  IW2 = 8
   60         ENDIF
*--             Indent for each new repetition level
              COUT   = ' '
              IF (IFLOPT(MPOSIQ).NE.0) THEN
                 COUT='*B.'
                 INLINE=3
                 IW1=IW1-1
              ELSE
                 COUT   = ' '
                 INLINE = INDENT*INDENQ
              ENDIF
              IF (INUM2.EQ.0) THEN
*--                 Case of only one number given
                  IF (INUM1.GE.0) THEN
*--                   Given as real number
                      CFORM  = '(I'//CHAR(ICHAR('1')+IW1)//')'
                      WRITE(COUT(INLINE+1:),CFORM) INUM1
                      INLINE = INLINE + IW1 + 1
                  ELSEIF (INUM1.EQ.INUINQ) THEN
*--                     Indefinite (variable) number
                      INLINE = INLINE + 1
                      COUT(INLINE:) = '*'
                  ENDIF
              ELSE
*--                 Case of two numbers
                  IF (INUM1.GE.0) THEN
*--                   Given as real number
                      CFORM  = '(I'//CHAR(ICHAR('1')+IW1)//')'
                      WRITE(COUT(INLINE+1:),CFORM) INUM1
                      INLINE = INLINE + IW1 + 1
                  ELSEIF (INUM1.EQ.INUINQ) THEN
*--                     Indefinite (variable) number
                      INLINE = INLINE + 1
                      COUT(INLINE:) = '*'
                  ENDIF
                  IF (INUM2.GE.0) THEN
*--                   Given as real number
                      INLINE = INLINE + 1
                      COUT(INLINE:INLINE) = '-'
                      CFORM  = '(I'//CHAR(ICHAR('0')+IW2)//')'
                      WRITE(COUT(INLINE+1:),CFORM) INUM2
                      INLINE = INLINE + IW2
                  ELSEIF (INUM2.EQ.INUINQ) THEN
*--                     Indefinite (variable) number
                      COUT(INLINE+1:INLINE+2) = '-*'
                      INLINE = INLINE + 2
                  ENDIF
              ENDIF
*--             Skip I self-describing sector
              INSERT = INSERT + NBDSCQ
*--             If not Hollerith self-describing sector -- SKIP
              IF (MOD(IQ(KQSP+LQBKD+INSERT),JFOSEQ).NE.IFOHOQ) THEN
*                  WRITE(LUNOUT,'(''0?? DZDENT -- Incomplete data'')')
                  WRITE(LUNUSR,'(''0?? DZDENT -- Incomplete data'')')
                  WRITE(LUNUSR,'(A,A4)')' Previous error occured in',
     +                      IQ(KQSP+LBQBKD+MOIDHQ)
                                                           GO TO 20
              ENDIF
*--             Total number of Hollerith words
              NWHOLL = IQ(KQSP+LQBKD+INSERT)/JFOSEQ
              IITAG  = INSERT + 1
              INSERT = IITAG
              IF (INUM2.EQ.0) THEN
*--                 Case of only one number given
                  IF (INUM1.LE.-JFOSEQ) THEN
*--                     Information is in form of Hollerith text
                      NWN1   = -INUM1/JFOSEQ
                      CALL UHTOC(IQ(KQSP+LQBKD+INSERT+NWTAG),4,
     +                           COUT(INLINE+1:),NWN1*4)
                      INLINE = INDXBC(COUT(:INLINE+NWN1*4),' ')
                      INSERT = INSERT + NWN1
                      NWHOLL = NWHOLL - NWN1
                  ENDIF
              ELSE
*--                 Case of two numbers
                  IF (INUM1.LE.-JFOSEQ) THEN
*--                     Information is in form of Hollerith text
                      NWN1   = -INUM1/JFOSEQ
                      CALL UHTOC(IQ(KQSP+LQBKD+INSERT+NWTAG),4,
     +                           COUT(INLINE+1:),NWN1*4)
                      INLINE = INDXBC(COUT(:INLINE+NWN1*4),' ')
                      INSERT = INSERT + NWN1
                      NWHOLL = NWHOLL - NWN1
                  ENDIF
                  IF (INUM2.LE.-JFOSEQ) THEN
*--                     Information is in form of Hollerith text
                      INLINE = INLINE + 1
                      COUT(INLINE:INLINE) = '-'
                      NWN2   = -INUM2/JFOSEQ
                      CALL UHTOC(IQ(KQSP+LQBKD+INSERT+NWTAG),4,
     +                           COUT(INLINE+1:),NWN2*4)
                      INLINE = INDXBC(COUT(:INLINE+NWN2*4),' ')
                      INSERT = INSERT + NWN2
                      NWHOLL = NWHOLL - NWN2
                  ENDIF
              ENDIF
              INLINE = INDENT + ITAG
 
*--             Special case for the link descriptor bank
 
              IF (IFLOPT(MPOSBQ).EQ.0)                     GO TO 90
*--                Update pointer in input bank and test tag information
                  INSERT = INSERT + NWHOLL
                  LENBKD = IQWND(LBQBKD+KQSP)
                  IF (NWTAG.LE.0)                          GO TO 20
*--                Now cases for link numbers
                  IF (INUM1.LE.0)                          GO TO 20
                  IF (INUM2.LT.INUINQ) THEN
                                                           GO TO 20
                  ELSEIF (INUM2.EQ.INUINQ) THEN
*--                     Undefined --> Fill bank up to end and exit
                      DO 70  IINUM=INUM1,NBLMAX
   70                 IQ(KQSP + LBQBKD + MOLK0Q+IINUM) =
     +                                      IQ(KQSP+LQBKD+IITAG)
                                                           GO TO 120
                  ELSEIF (INUM2.EQ.0) THEN
*--                     Only one number given - Inside allowed offsets?
                      IF(INUM1+MOLK0Q .GT. LENBKD)THEN
                          NLPUSH=INUM1+MOLK0Q - LENBKD
                          CALL MZPUSH(0,LBQBKD,0,NLPUSH,'I')
                      ENDIF
                      IQ(KQSP + LBQBKD + MOLK0Q+INUM1)=
     +                                      IQ(KQSP+LQBKD+IITAG)
                      IF(INUM1 .GT. IHLPUT)IHLPUT = INUM1
                  ELSE
*--                     Range of numbers given - Inside allowed offsets?
                      DO 80  IINUM=MIN(INUM1,NBLMAX),MIN(INUM2,NBLMAX)
   80                 IQ(KQSP + LBQBKD + MOLK0Q+IINUM) =
     +                                     IQ(KQSP+LQBKD+IITAG)
                  ENDIF
                                                           GO TO 20
   90         CONTINUE
*--             When there is tag info  <===========
              IF (NWTAG.GT.0) THEN
*--                 Numbers given as Hollerith text
                  CALL UHTOC(IQ(KQSP+LQBKD+IITAG),4,
     +                       COUT(INLINE:),MIN(NENTIQ-2,NWTAG*4))
*1810
                  IF(INDEX(COUT,'L:').NE.0)THEN
                     IF (IFLOPT(MPOSIQ).NE.0) THEN
                        COUT(1:4)  = '*B.*'
                     ELSE
                        WRITE(LUNUSR,'(A)')' '
                        COUT(1:INDEX(COUT,'L:')-1)='--Label:'
                     ENDIF
                  ENDIF
                  INSERT = INSERT + NWTAG
*--                 Is there some text left
                  NWHOLL = NWHOLL - NWTAG
              ENDIF
*--             Remaining text
              IF (NWHOLL.GT.0) THEN
*--                 Copy text according to output type desired
                  INLINE = IOENTQ + INDENT
                  IF (NWHOLL.EQ.1.AND.IQ(KQSP+LQBKD+INSERT).EQ.IDEMTX)
     +                                                           THEN
*--                     Repetition of the previous line
                      COUT(INLINE:) = '  idem'
                      INSERT = INSERT + 1
                      NWHOLL = 0
                      IF(IFLOPT(MPOSBQ).EQ.0)WRITE(LUNUSR,'(A)') COUT
                  ELSE
                      IEWORK = 0
                      NOUTF  = NOUTQ  - INLINE + 1
*--                     General case with text
                      CALL DZDLIN
                  ENDIF
              ELSE
*--             For tags only
                  IF(IFLOPT(MPOSBQ).EQ.0)WRITE(LUNUSR,'(A)') COUT
*------------------ End of field with text information
              ENDIF
*--------------- Multiple choice present ?
              IF (ICHOIC.NE.0) THEN
*--                 Still more text to read?
                  IF (MOD(IQ(KQSP+LQBKD+INSERT),JFOSEQ).EQ.IFOHOQ) THEN
*--                   Indent for each new repetition level
                      COUT   = ' '
                      INLINE = INDENT + ITAG
*--                     Total number of Hollerith words
                      NWHOLL = IQ(KQSP+LQBKD+INSERT)/JFOSEQ
                      IITAG  = INSERT + 1
                      INSERT = IITAG
*--  ==============     Alternative choice for entry      ==============
                                                           GO TO 90
*--          >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                  ENDIF
              ENDIF
*-------------- End of entry (repetition or information tag) [below 110]
          ENDIF
                                                           GO TO 20
*--         Close the description level if needed
  100     CONTINUE
          IF(IFLOPT(MPOSBQ) .EQ. 0)THEN
              DO 110 IR=IREPLV,1,-1
                  IF (IFLOPT(MPOSIQ).NE.0) THEN
                     COUT   = '*B/REP '
                     INDENT = 10
                  ELSE
                     INDENT = (IR-1)*INDENQ
                     COUT   = ' '
                     COUT(INDENT+2:)='--REP level='//
     +                            CHAR(ICHAR('0')+IR)//' -- End --'
*1810                COUT(INDENT+2:)='-- End Do -----------------------'
                  ENDIF
                  WRITE (LUNUSR,'(A)') COUT
  110         CONTINUE
          ENDIF
          IF(LTHERE)THEN
             WRITE(LUNUSR,'(''*B/LINK'')')
             LTHERE=.FALSE.
          ENDIF
          IF(RTHERE)THEN
             WRITE(LUNUSR,'(''*B/RLINK'')')
             RTHERE=.FALSE.
          ENDIF
          IF(BTHERE)THEN
             WRITE(LUNUSR,'(''*B/BI'')')
             BTHERE=.FALSE.
          ENDIF
          IF(DTHERE)THEN
             WRITE(LUNUSR,'(''*B/DATA'')')
             DTHERE=.FALSE.
          ENDIF
*---------- End of loop over link/status bits/data info (400)
  120 CONTINUE
 
      GOTO 140
 
  130 CONTINUE
 
      WRITE(LUNOUT,'(A,A4)')' Previous error occured in: ',
     +                      IQ(KQSP+LQBKD+1)
 
  140 CONTINUE
 
*--- OTTO tell highest link number
 
      IQ(LBQBKD+KQSP+5) = IHLPUT
      IQUEST(MOQUEQ) = LBQBKD
 
      END
+DECK,DZDDOC. -----------------------------------------------------------------
*CMZ :  1.30/00 14/06/96  12.56.57  by  Pavel Nevski
*CMZU:  1.00/01 21/01/96  23.17.55  by  Sasha Vanyashin
*-- Author :
      SUBROUTINE DZDDOC(IXSTOR,L,CHBANK,CHOPT,IF1,IL1,LUN,CHPF,NKEEPS)
*.
*. INPUT     :  IXSTOR  store index
*.              L       link to bank to be dumped
*.              CHOPT   character option
*.                      'U' suppress list of UNDEFIND
*.                      'K' Keep sequences
*.                      'D' INTEGER statements for data offsets
*.                      'O' Parameter statements for data offsets
*.                      'Z' force hexadecimal (DZSHOW)
*.                      'T' list also pure Character banks 1 word/line
*.                      'C'  list value only (useful for output read by
*.                           another program
*.                      '='  list as IQ(LCHBANK(1)+IOFF)=value
*.                      'R'  try to recover from incomplete doc
*.                      'V'  return data word values into VVAR
*.                      'P'  return path to data word into VVAR
*.                      'I'  return IO char into CHPF
*.                      'E'  examine, check range
*.              IFIRST   first word to dump
*.              ILAST    last word
*.              LUN      output unit
*.              CHPF     prefix when making FORTRAN code (data words)
*.              NKEEPS   # of data words for which offsets
*.                       have been gen
*. OUTPUT    :
*.
*. CALLS     : DZSHOW UOPTC ,MZDROP,RZIN,UCTOH, DZSHOW
*. CALLED    : DZDISP, USER
*.
*. AUTHOR    : O.Schaile
*. VERSION   : 1.00
*. CREATED   : 7-Aug-88
*. LAST MOD  : 18-OCT-92
*.           : 14-jun-96, PN : INDEXN has 1 argument only
*.**********************************************************************
      CHARACTER*(*) CHOPT, CHPF
      CHARACTER*40 CHPFI
      CHARACTER*8  CHBANK
      INTEGER KEYVEC(2), IWHOLL, NLSKIP,IDELAY
      CHARACTER*11 CVAL, CVALSA
      CHARACTER*21 CLOOP
      CHARACTER*1 COPTDZ
      CHARACTER*80 CLINE, CLINSA, CLINDE
      CHARACTER*8 CVAR, CVAR1
      CHARACTER*12 CTEMP
      SAVE LUNINT, IOCH
      PARAMETER (LUNINV=41)
      LOGICAL NEWVAL,KEEPSQ,INHOLL,REPEND, NEWPNT, LRECOV, ENDED
*     pointer stuff
      INTEGER MAXP, IPOINT
      PARAMETER (MAXP=200)
      CHARACTER*8 CVARP, CHREPC
      CHARACTER*8 CPOINT(MAXP)
      INTEGER POINT(MAXP),NPOINT(MAXP), IWDOC,IWDOCO,IWORD, IF11,IL11,
     +        NSTYP, IPCHPF
      CHARACTER*1 CHARIO,CHARIS
      CHARACTER*7 CHARIA
      CHARACTER*32 CVARNM
 
*     for returning values
      INTEGER IENTRY,ITYYY
      INTEGER VVAR(100), NVAL,ITY, MAXVAL
      INTEGER VALINT
      REAL    VALREA
      EQUIVALENCE (VALINT,VALREA)
      CHARACTER*8 CVREQ
      LOGICAL REPATH, NOTFIL
      CHARACTER*13 SPACES
      EXTERNAL SPACES
+SEQ,NONEWL2,IF= NONEWL.
+SEQ,NONEWL1,IF=-NONEWL.
*
+CDE, BKWRP,TAPES.
+CDE,ZBCDK.         From DZEBRA
+SEQ,ZUNIT
+SEQ,DZDPRM
+CDE,LINOUT.
+SEQ,DOCPARQ.
      CHARACTER CQSTAK*13,CQINFO*40
      PARAMETER (NLICHQ=130,NSTCHQ=8,NDVCHQ=8,NBKCHQ=4 )
      CHARACTER CQLINE*(NLICHQ),CQMAP(10)*(NLICHQ)
      CHARACTER CQSTOR*(NSTCHQ),CQDIV*(NDVCHQ),CQID*(NBKCHQ)
      COMMON /DZC1CH/ CQSTOR,CQDIV,CQID,CQMAP,CQSTAK,CQINFO
      EQUIVALENCE (CQLINE,CQMAP)
+SEQ,BKNUPARQ,BKFOPARQ.
+SEQ,BKSTPARQ,BKTGPARQ,BKTGDATQ.
*
      DATA CHARIA/'BIFDHUR'/
      DATA LUNINT/0/
*------
      IENTRY = 1
      ITY    = 0
      IF11=IF1
      IL11=IL1
      IF(INDEX(CHOPT,'K').NE.0 .OR. INDEX(CHOPT,'I').NE.0)THEN
         KEEPSQ=.TRUE.
      ELSE
+SEQ,QSTORE.
         IF(IL11.GT.IQ(KQS+L-1))IL11=IQ(KQS+L-1)
         KEEPSQ=.FALSE.
      ENDIF
      NSTYP=0
      CHARIS=' '
      CHARIO=' '
      IF(INDEX(CHOPT,'D').NE.0)THEN
         IF(INDEX(CHOPT,'R').NE.0)THEN
            CHARIO='R'
         ELSE
            CHARIO='I'
         ENDIF
      ENDIF
      IF(INDEX(CHOPT,'I').NE.0)THEN
         IPCHPF=1
         CHPF=' '
      ELSE
         CALL UCTOH(CHBANK,KEYVEC,4,8)
      ENDIF
      LUC = LUN
      REPATH=.FALSE.
      MAXVAL=0
      GOTO 2
 
      ENTRY DZDGVA(IXSTOR, L, CHOPT,CVREQ,NVAL,VVAR,ITYYY)
      IENTRY = 2
      ITY    = 0
      IF(L.EQ.0)GOTO 990
+SEQ,QSTORE.
      LUC = 6
      IF11=1
      IL11=IQ(KQS+L-1)
      MAXVAL=NVAL
      NVAL=0
      ITY=-1
      IPREP0=0
      IPREP1=0
      IPDRE0=0
      IPDRE1=0
      NOTFIL=.TRUE.
      IF(INDEX(CHOPT,'P').NE.0)THEN
         REPATH=.TRUE.
      ELSE
         REPATH=.FALSE.
      ENDIF
      KEYVEC(1)=IQ(KQS+L-4)
      LUP=LQ(KQS+L+1)
      IF(LUP.NE.0)THEN
         KEYVEC(2)=IQ(KQS+LUP-4)
      ELSE
         CALL UCTOH('NONE',KEYVEC(2),4,4)
      ENDIF
 
2     LUNINT = LUNINV
      LUNSAV = IQPRNT
      IDENTF=0
      IWDOCO=0
      NEXTRA=0
      IMBED2=0
      IOCH = -1
      IPOINT=0
      DO 5 I=1,MAXP
         POINT(I)  = -1
         CPOINT(I) = ' '
5        NPOINT(I) = -1
 
*      IREPC=-2
      IPRKEE=0
      NLSKIP=0
      IDELAY=0
      CLINSA=' '
      LCLINE  = LEN(CLINE)
      IPLINE = 1
      INHOLL = .FALSE.
      IF(INDEX(CHOPT,'R').NE.0)THEN
         LRECOV=.TRUE.
      ELSE
         LRECOV=.FALSE.
      ENDIF
      ENDED =.FALSE.
      REPEND=.FALSE.
      NEWPNT=.FALSE.
      IF(KEEPSQ)THEN
          NBLENG = IL1
      ELSE
         NBLENG = IQ(KQS+L-1)
         KEEPSQ=.FALSE.
*         CALL CLTOU(CHOPT)
         IF(INDEX(CHOPT,'Z').NE.0)THEN
            COPTDZ='Z'
         ELSE
            COPTDZ=' '
         ENDIF
         CALL UCTOH ('$LF/',IILFLF,4,4)
      ENDIF
      IF(INDEX(CHOPT,'C').NE.0 .AND. .NOT.KEEPSQ)THEN
         IQPRNT=LUC
         IW1=IF11
         GOTO 90
      ENDIF
      IF(INDEX(CHOPT,'I').EQ.0)
     +CALL  DZDGDO(0,LQBKD1,KEYVEC,CLINE,IFC,ILC,ICYCLE)
      IF(LQBKD1.EQ.0)THEN
         IF(KEEPSQ  .OR. INDEX(CHOPT,'V').NE.0)THEN
            WRITE(LUC,'(A)')'*   No documentation for '//CHBANK(1:4)
            GOTO 990
         ENDIF
         NDATA = 0
      ELSE
 
         IF(ICYCLE.LT.0)WRITE(LUC,'(A)')
     &  ' **** Requested version not found ****'
         IPDATA = IQ(KQS+LQBKD1+MBHEAQ) + IQ(KQS+LQBKD1+MBGENQ)
     +           +IQ(KQS+LQBKD1+MBLINQ) + IQ(KQS+LQBKD1+MBRLIQ)
     &           +IQ(KQS+LQBKD1+MBBITQ) + 1
         IP1 = 0
         IP2 = 0
         IC1 = 0
         IC2 = 0
         IWORD = 0
         IWORDR=0
         IREPL=0
         IFREPL = 0
         CHREPC=' '
         ILOWRC=0
         IUPERC=0
         LOOPC1=-1
         LOOPC2=-1
         IPFORM=0
         ICFORM=0
         IMFORM=0
         LALILE=0
         IP = KQS+LQBKD1+IPDATA
         IPSAVE=IP
         NDATA = IQ(KQS+LQBKD1+MBDATQ)
      ENDIF
 
      IF(INDEX(CHOPT,'Q').EQ.0 .AND.
     &   INDEX(CHOPT,'V').EQ.0 .AND.
     &  .NOT.KEEPSQ)THEN
         IF(INDEX(CHOPT,'E').EQ.0)THEN
            WRITE(LUC,'(10A)')
     &' -------- Data of Bank/UpBank: ',CHBANK(1:4),'/',CHBANK(5:8),
     &     ' Doc Version: ',CLINE(IFC:ILC), ' ----------'
         ELSE
            WRITE(LUC,'(10A)')
     &   '  Checking data of Bank/UpBank: ',CHBANK(1:4),'/',CHBANK(5:8)
         ENDIF
      ENDIF
 
      IF(NDATA.GT.0)THEN
          IC9 = 10
      ELSE
          IQPRNT = LUC
          IW1 = IF11
          WRITE(LUC,'(A)')
     +    '* Data words not documented for '//CHBANK(1:4)
          IF(KEEPSQ .OR. INDEX(CHOPT,'V').NE.0)THEN
             GOTO 990
          ELSE
             GOTO 90
          ENDIF
      ENDIF
      LDATUM = IP + NDATA
      IWDOC = 0
 
*      IF(.NOT.KEEPSQ) WRITE(LUC,*)' '
*
*     IF11,IL11 first, last word to be doc'td
*     IWORD   current word in data
*     IWORDR   current word in rep section
*     IWDOC   word announced in documentation
*     IWDOCO  remember announced word (for cont lines)
*     IP      pointer in documentation
*     IP1     remember IP for start of rep lev 1
*     IP2     remember IP for start of rep lev 2
*     IC1,IC2 repetition counter 1, 2
*     IT      type of info in doc
*             2 integer
*             5 holl
*     NW      # of words in doc
*     IDENT   ITGREQ describe rep
*             ITGENQ describe seq # of data
*     NEWVAL  if false: cont card
*     INHOLL  holl text in data words started
*     IPFORM  pointer to a key descriptor format (see RZ)
*     LOOPC1  or LOOPC2)loop counters in rep section
*
 
 
   10 CONTINUE
      IF(IP .GE. LDATUM)THEN
          IF(.NOT.KEEPSQ)THEN
              IQPRNT = LUC
               ENDED=.TRUE.
               NEWVAL=.TRUE.
               IP=IPSAVE
          ENDIF
          IF(KEEPSQ)GOTO 990
      ENDIF
      IT = MOD(IQ(IP),16)
      NW = IQ(IP)/16
*      WRITE(*,*)' IT,NW,IP ',IT,NW,IP
      IF(NW .LE. 0)THEN
         WRITE(LUC,'(A,2I9)')' Illegal NW at IPDATA ',NW,IPDATA
         GOTO 990
      ENDIF
 
*     start hollerith sector
 
      IF(IT .EQ. 5)THEN
*         WRITE(*,*)' IDENTF= ',IDENTF
*        try to get rep count name and range
         IF(KEEPSQ .AND. ABS(IDENTF).EQ. ITGREQ)THEN
            NCH=MIN(NW*4,LEN(CLINE))
            CLINE=' '
            CALL UHTOC(IQ(IP+1),4,CLINE,NCH)
            NCH=LNBLNK(CLINE)
            ICOLON=INDEX(CLINE(1:8),':')+1
            CHREPC=CLINE(ICOLON:8)
            IFC=INDEX(CLINE,'[')
            ILC=INDEX(CLINE,']')
            IFC=IFC+1
            ILC=ILC-1
            NC=INDEX(CLINE(IFC:ILC),',')
            IF(NC.EQ.0)NC=INDEX(CLINE(IFC:ILC),':')
            IF(IFC.GT.1 .AND. ILC.GT.IFC+2 .AND. NC.NE.0)THEN
               ILC1=IFC+NC-2
               IFC2=ILC1+2
               CALL DZDCTI(CLINE(IFC:ILC1),ILOWRC)
               CALL DZDCTI(CLINE(IFC2:ILC),IUPERC)
            ENDIF
         ENDIF
         IF(IDENTF .NE. ITGENQ) GOTO 80
 
*        rep count = 0 calc from data word
*         IF(IREPC .EQ. 0)GOTO 80
 
         IF(      IWORD+1 .NE. IWDOC
     +      .AND. IP1+IP2 .EQ. 0
     +      .AND. IWDOC   .NE. IWDOCO )THEN
              IWDOCO = -1
         ENDIF
 
*        rep section ended already?
 
         IF(REPEND)GOTO 80
 
*        look if more words documented then announced
 
         IF(NEXTRA.LT.0 .AND. LRECOV)THEN
            IF(IWDOC.GT.ABS(NEXTRA))THEN
               GOTO 80
            ENDIF
         ENDIF
 
*        is it not continuation card for same item
*        or not a start of rep section
 
         NEWVAL = .FALSE.
*         WRITE(*,*)'IWDOCO ,IWDOC, IWORD', IWDOCO ,IWDOC, IWORD
         IF(IWDOCO .NE. IWDOC .OR. IWDOCO .LE. 0 .OR. NEWPNT)THEN
            IWORD = IWORD+1
            IWORDR = IWORDR+1
            NEWVAL = .TRUE.
         ENDIF
*        remember possible repetition count
         IVALLW = IQ(KQS+L+IWORD)
 
         IF(IWORD .GT. IL11)GOTO 990
         IF(IWORD .LT. IF11)GOTO 80
 
*         look if all words are hollerith
 
         IF(IOCH .LT. 0)THEN
            NIO = JBYT(IQ(KQS+L),19,4)
            NL =  IQ(KQS+L-3)
            IOFFBS = - (NIO + NL + 8 + 1)
            IOCH = JBYT(IQ(KQS+L+IOFFBS),17,16)
            IF(IOCH .EQ. 5 .AND. INDEX(CHOPT,'Z').EQ. 0
     +      .AND. INDEX(CHOPT,'T').EQ. 0)THEN
               IF(.NOT.KEEPSQ)THEN
                   WRITE(LUC,'(1X,2A4,1X,100(15A4/7X))')
     +             (IQ(IP+K),K=1,NW)
                   WRITE(LUC,'(A)')'---- '
               ENDIF
               NEWVAL = .TRUE.
            ENDIF
         ENDIF
 
*        loop here if all words are hollerith
 
   20    CONTINUE
*        empty text buffer at end
          IF(IWORD .GT. IL11)THEN
            IF(IPLINE .GT. 1)THEN
               IF(.NOT.KEEPSQ)
     +          WRITE(LUC,'(14X,A)')CLINE(1:IPLINE-1)
                IPLINE = 1
            ENDIF
            GOTO 990
         ENDIF
 
*        get the printed value from CQLINE of DZSHOW  (Quiet option)
         IF(NEWVAL     .AND.
     &     .NOT.KEEPSQ .OR.
     &     (NEWVAL .AND. INDEX(CHOPT,'V').NE.0 .AND. ITY.EQ.-1)
     &     )THEN
             IF(IC9 .GE. 9 .OR. NEWPNT)THEN
                CALL DZSHOW(' ',IXSTOR, L,COPTDZ//'Q',1,0,IWORD,IWORD+8)
                IC9 = 1
             ELSE
                IC9 = IC9+1
             ENDIF
             IBV1 = IC9*12
             IBV2 = IBV1+10
             CVAL = CQLINE(IBV1:IBV2)
             CVALSA=CVAL
         ELSE
             CVAL = '          '
         ENDIF
*        collect text on CLINE
         IF(IOCH .EQ. 5            .AND.
     +      INDEX(CHOPT,'Z').EQ.0  .AND.
     +      INDEX(CHOPT,'T').EQ. 0 )THEN
            IF(IPLINE .GE. LCLINE)THEN
               IF(.NOT.KEEPSQ)
     +         WRITE(LUC,'(14X,A)')CLINE(1:IPLINE-1)
               IPLINE = 1
            ENDIF
            CLINE(IPLINE:IPLINE+3)=CVAL(8:11)
            IPLINE = IPLINE+4
            IF(INHOLL)THEN
               IWORD = IWORD+1
               GOTO 20
            ELSE
               INHOLL = .TRUE.
               CVAL = ' '
            ENDIF
         ELSE
 
*        output other then pure text, empty text buffer
 
             IF(IPLINE .GT. 1)THEN
                IF(.NOT.KEEPSQ .AND.INDEX(CHOPT,'V').EQ.0)
     &          WRITE(LUC,'(14X,A)')CLINE(1:IPLINE-1)
                IPLINE= 1
             ENDIF
             INHOLL = .FALSE.
         ENDIF
 
         CALL UHTOC(IQ(IP+1),4,CVAR,8)
 
*        return value?
 
         IF(INDEX(CHOPT,'V').NE.0)THEN
            IF(CVAR.EQ.CVREQ)THEN
*              find data type
               IF(ITY.LT.0)THEN
                  IF     (INDEX(CVAL,'"').NE.0)THEN
                     ITY=5
                  ELSE IF(INDEX(CVAL,'.').NE.0)THEN
                     ITY=3
                  ELSE
                     ITY=2
                  ENDIF
               ENDIF
*              return path only?
               IF(REPATH)THEN
                  IF(NOTFIL)THEN
                     NOTFIL=.FALSE.
                     NVAL=NVAL+1
                     IF(IREPL.LE.1)THEN
                        VVAR(NVAL)=IWORD-IPREP0
                     ELSE
                        VVAR(NVAL)=IWORD-IPREP1
                     ENDIF
                  ENDIF
               ELSE
                  IF(ITY.EQ.5)THEN
                     WRITE(*,*)'Holleriths not yet supported'
                     ITY=5
                     GOTO 80
                  ENDIF
                  NVAL=NVAL+1
                  VVAR(NVAL)=IQ(KQS+L+IWORD)
               ENDIF
            ENDIF
            IF(NVAL.EQ.MAXVAL)THEN
               IF(MAXVAL.GT.1)WRITE(*,*)
     &         'Max number of values reached', MAXVAL
                GOTO 990
            ELSE
               GOTO 80
            ENDIF
         ENDIF
 
         CVAR1 = CVAR
         CALL CLTOU(CVAR1)
 
*        conVert it by ZITOH?
 
         IF     (CVAR1(1:2).EQ.'Z:')THEN
            CALL ZITOH(IQ(KQS+L+IWORD),IWHOLL,1)
            CVAL=' '
            CALL UHTOC(IWHOLL,4,CVAL,4)
*        format of a Key descriptor
         ELSE IF(CVAR1(1:2).EQ.'F:')THEN
            IF(IPFORM.EQ.0)IPFORM=KQS+L+IWORD
            DO 15 I=1,10
               IFM=JBYT(IQ(KQS+L+IWORD),(I-1)*3+1,3)
               IF     (IFM.EQ.1)THEN
                  CVAL(I:I)='I'
                  IMFORM=IMFORM+1
               ELSE IF(IFM.EQ.3)THEN
                  CVAL(I:I)='H'
                  IMFORM=IMFORM+1
                ELSE
                  CVAL(I:I)=' '
               ENDIF
               CVAL(11:11)=' '
15          CONTINUE
         ELSE IF(CVAR1(1:2).EQ.'K:')THEN
            ICFORM=ICFORM+1
            IF(ICFORM.GT.IMFORM)ICFORM=1
            IFC2=ICFORM/10
            IFC1=MOD(ICFORM,10)
            IF(IFC1.EQ.0)THEN
               IFC1=10
               IFC2=IFC2-1
            ENDIF
            IFM=JBYT(IQ(IPFORM+IFC2),(IFC1-1)*3+1,3)
            IF(IFM.EQ.3)THEN
               CALL ZITOH(IQ(KQS+L+IWORD),IWHOLL,1)
               CVAL=' '
               CALL UHTOC(IWHOLL,4,CVAL,4)
            ENDIF
         ELSE IF(CVAR1(1:2).EQ.'B:')THEN
             WRITE(CVAL,'(Z9)')IQ(KQS+L+IWORD)
             CVALSA=CVAL
         ELSE IF(CVAR1(1:2).EQ.'D:')THEN
             CALL RZDATE(IQ(KQS+L+IWORD),IDATX,ITIMX,1)
             WRITE(CVAL(1:6),'(I6)')MOD(IDATX,1000000)
             WRITE(CVAL(8:11),'(I4)')MOD(ITIMX,10000)
             CVAL(7:7)='/'
         ENDIF
*     pointer stuff
 
*     look if a label is reached
 
      IF(NEWPNT .OR. .NOT. NEWVAL)THEN
        NEWPNT=.FALSE.
      ELSE
       IF(IPOINT.GT.0)THEN
         DO I=1,IPOINT
            IF(IWORD.EQ.POINT(I) .AND. NPOINT(I).NE.0)THEN
*           skip in doc until label is found
               IF(ENDED)ENDED=.FALSE.
               IPP=IPSAVE
               NWP=-1
21             IPP=IPP+NWP+1
               IF(IPP.GE.LDATUM)THEN
                  WRITE(*,*)'No label found for : ',CPOINT(I)
                  GOTO 26
               ENDIF
               ITP = MOD(IQ(IPP),16)
               NWP = IQ(IPP)/16
               IF(ITP.NE.5)GOTO 21
               CALL UHTOC(IQ(IPP+1),4,CVARP,8)
               CALL CLTOU(CVARP)
               IF(CVARP(1:2).NE.'L:')GOTO 21
 
               IF(CVARP(3:).EQ.CPOINT(I)(3:))THEN
*                 remember for later in case identical lines are skipped
                  WRITE(CLINDE,'(2A4,13X,14A4)')
     +            (IQ(IPP+K),K=1,NWP)
                  IDELAY=1
                  IP=IPP+NWP+1
                  NEWPNT=.TRUE.
*                 end a possible infinite repetition
                  IF(IFREPL.EQ.0)THEN
                     IWORD=IWORD-1
                  ELSE
                     IWORD=IWORD-1
                     IFREPL=0
                  ENDIF
*                  WRITE(*,*)'Label found',IWORD,' ',CPOINT(I)
                  IWDOCO=-1
                  GOTO 10
               ELSE
                  GOTO 21
               ENDIF
            ENDIF
         ENDDO
         IF(ENDED)THEN
            IW1=IWORD
            GOTO 90
         ENDIF
       ENDIF
      ENDIF
 
*     is the pointer bit coded in cont card?
      IF(INDEX(CVALSA,'.').NE.0)THEN
         IF(Q(KQS+L+IWORD).GT.0. .AND. Q(KQS+L+IWORD).LT.1000000.)THEN
            IBVAL=Q(KQS+L+IWORD)
         ELSE
            IBVAL=0
         ENDIF
      ELSE
         IBVAL=IQ(KQS+L+IWORD)
      ENDIF
      IF(.NOT.NEWVAL)THEN
         IF(CVAR1(2:4).EQ.':BI')THEN
            READ(CVAR1(5:6),'(I2)',ERR=40  )I1BIT
            IF(I1BIT.GT.31)GOTO 24
            READ(CVAR1(7:8),'(I2)',ERR=24  )I2BIT
            IF(I2BIT.GT.31)GOTO 24
            IF(I2BIT.LT.I1BIT)GOTO 24
            IBVAL = JBYT(IQ(KQS+L+IWORD),I1BIT+1,I2BIT-I1BIT+1)
            IF(INDEX(CHOPT,'Z').NE.0)THEN
               WRITE(CVAL,'(Z11)')IBVAL
            ELSE
               WRITE(CVAL,'(I11)')IBVAL
            ENDIF
*           get the name
            IF(NW.LT.3)THEN
               CTEMP='XXXXXX'
            ELSE
               NCH=MIN(NW-2,2)*4
               IF(NCH.GT.6)NCH=6
               CALL UHTOC(IQ(IP+3),4,CTEMP,NCH)
*              embedded space
               IPSP=INDEX(CTEMP,' ')
               IF(IPSP.NE.0)CTEMP(IPSP:)=' '
            ENDIF
            CVAR1(3:8)=CTEMP
         ENDIF
      ENDIF
 
24    CONTINUE
 
*     if it is a pointer or rep count of it, remember its value
 
      IF(CVAR1(1:2).EQ.'P:' .OR. CVAR1(1:2).EQ.'N:')THEN
*        already there?
         IF(IPOINT.GT.0)THEN
            DO I=1,IPOINT
               IF(CPOINT(I).EQ.CVAR1)THEN
*                  IF(CVAR1(1:2).EQ.'P:')THEN
*                     IF(POINT(I).GE.0)THEN
*                        IF(POINT(I) .LT. IQ(KQS+L+IWORD))
*     &                  POINT(I)=IQ(KQS+L+IWORD)
*                        WRITE(*,*)'Ambigous pointer: ', CPOINT(I)
*                     ELSE
*                        POINT(I)=IBVAL
*                        GOTO  25
*                     ENDIF
*                  ELSE
                  IF(CVAR1(1:2).EQ.'N:')THEN
                     IF(NPOINT(I).GE.0)THEN
                        WRITE(*,*)'Ambigous rep count: ', CPOINT(I)
                     ELSE
*                       may be a simple expression of the value
                        CALL DZDGRC(IQ(IP),2,IBVAL,IREPC,NEXTRA,
     &                  IDUMMY,0,NDUMMY)
                        IF(IREPC.GT.0)IBVAL=IREPC
                        NPOINT(I)=IBVAL
                        GOTO  25
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
         IPOINT=IPOINT+1
         IF(IPOINT.GT.MAXP)THEN
            WRITE(*,*)'Too many pointers:',IPOINT
         ELSE
            CPOINT(IPOINT)=CVAR1
            IF(CVAR1(1:2).EQ.'P:')THEN
               POINT (IPOINT)=IBVAL
*              does it point to same as previous
               IF(IPOINT.GT.1)THEN
                  DO I=1,IPOINT-1
                     IF(POINT(I).EQ.POINT(IPOINT)
     &               .AND. POINT(I).NE.0)THEN
                        POINT(I)=-1
                       WRITE(*,*)'Pointer: ',CPOINT(I),
     &                  ' overwritten by: ',CPOINT(IPOINT)
                     ENDIF
                  ENDDO
               ENDIF
            ELSE
*              may be a simple expression of the value
               CALL DZDGRC(IQ(IP),2,IBVAL,IREPC,NEXTRA,
     &         IDUMMY,0,NDUMMY)
               IF(IREPC.GT.0)IBVAL=IREPC
               NPOINT (IPOINT)=IBVAL
            ENDIF
         ENDIF
25       CONTINUE
      ENDIF
 
26    CONTINUE
 
*     pointer stuff end
 
*       if cont line then look if its mask, bitvalue or choice
         LENMSK=0
         IF(.NOT.NEWVAL)THEN
*            wildchar mask
             IF(CVAR(1:8) .EQ. 'WILDCHAR' .OR.
     &          CVAR(1:4) .EQ. 'MASK')THEN
                IF(KEEPSQ)GOTO 80
*               get the mask
                IF(NW.LT.3)THEN
*                  no mask provided
                   GOTO 80
                ELSE
                   CVAR1 = ' '
                   CTEMP=' '
                   NCH=MIN(NW-2,2)*4
                   IF(NCH.GT.11)NCH=11
                   CALL UHTOC(IQ(IP+3),4,CTEMP,NCH)
*                  embedded space
                   NCH=INDEX(CTEMP,' ')-1
                   IF(NCH.LE.0)NCH=11
                   LENMSK=NCH
                   CTEMP(NCH+1:)=' '
*                  look if it matches
                   DO 28 I=11,1,-1
*                     mask ended?
                      IF(NCH.LE.0)THEN
                         IF(CVALSA(I:I).EQ. ' ')THEN
                            GOTO 29
                         ELSE
                            GOTO 80
                         ENDIF
                      ENDIF
*                     value ended, is rest of mask *?
                      IF(CVALSA(I:I).EQ. ' ')THEN
                         DO 27 J=NCH,1,-1
                           IF(CTEMP(J:J).NE.'*')GOTO 80
27                       CONTINUE
                         GOTO 29
                      ENDIF
                      IF(CTEMP(NCH:NCH).EQ.'*')GOTO 28
                      IF(CTEMP(NCH:NCH).NE.CVALSA(I:I))GOTO 80
28                 NCH=NCH-1
29                 CONTINUE
*                  all matched, does it still fit on line?
                   NCH=(NW-2)*4
                   IF(NCH+LALILE-LENMSK.GT.80)GOTO 50
 
                   CLINE=' '
                   CALL UHTOC(IQ(IP+3),4,CLINE,NCH)
                   NCH=LENOCC(CLINE)
                   LALILE=LALILE+NCH-LENMSK
                   WRITE(LUC,'(A'//NONEWL//')')CLINE(LENMSK+1:NCH)
                   LENMSK=0
                   GOTO 80
                ENDIF
            ENDIF
 
*            choice
             IF(CVAR(1:6) .EQ. 'BITVAL')THEN
                 IF(KEEPSQ)GOTO 80
                 READ(CVAR(7:8),'(I2)')IBIT
                 IF(IAND(IQ(KQS+L+IWORD),ISHFT(1,IBIT)).EQ.0)THEN
                     GOTO 80
                 ELSE
                     CVAR1 = ' '
                     GOTO 50
                 ENDIF
             ENDIF
*            choice starts with C, and
*            contains only numbers or  _  + -
*
             IF(CVAR(1:1).EQ.'C')THEN
                 ILC = INDXBC(CVAR,' ')
                 IF(ILC.LE.1)GOTO 40
                 IFNUM = 2
                 DO 30   K=2,ILC
                     IF(INDXNC(CVAR(K:K)) .NE. 0
     +               .AND.      CVAR(K:K) .NE. '_'
     +               .AND.      CVAR(K:K) .NE. '-'
     +               .AND.      CVAR(K:K) .NE. '+')GOTO 40
                     IF(CVAR(K:K) .EQ. '_')IFNUM=K+1
   30            CONTINUE
                 IF(IFNUM.GT.ILC)GOTO 40
                 IF(KEEPSQ)GOTO 80
                 READ(CVAR(IFNUM:ILC),'(I8)')IVAL
                 IF(INDEX(CVALSA,'.').NE.0)THEN
                    IBVAL=Q(KQS+L+IWORD)
                 ELSE
                    IBVAL=IQ(KQS+L+IWORD)
                 ENDIF
                 IF(IBVAL .NE. IVAL)THEN
                     GOTO 80
                 ELSE
                     CVAR1 = ' '
                     GOTO 50
                 ENDIF
             ENDIF
             IF(CVAR(1:4).EQ.'BITS')THEN
                 READ(CVAR(5:6),'(I2)',ERR=40  )I1BIT
                 IF(I1BIT.GT.31)GOTO 40
                 READ(CVAR(7:8),'(I2)',ERR=40  )I2BIT
                 IF(I2BIT.GT.31)GOTO 40
                 IF(I2BIT.LT.I1BIT)GOTO 40
                 IBVAL = JBYT(IQ(KQS+L+IWORD),I1BIT+1,I2BIT-I1BIT+1)
                 IF(INDEX(CHOPT,'Z').NE.0)THEN
                     WRITE(CVAL,'(Z11)')IBVAL
                 ELSE
                     WRITE(CVAL,'(I11)')IBVAL
                 ENDIF
             ENDIF
         ENDIF
   40    CONTINUE
*
   50    CONTINUE
         IF(IWORD .LT. IF11)GOTO 80
         IF(CVAR .EQ. 'UNDEFIND' .AND. INDEX(CHOPT,'U').NE. 0)GOTO 80
         IF(KEEPSQ)THEN
*           generate FORTRAN code
            IF(NEWVAL .AND. CVAR.NE.'UNDEFIND')THEN
               ILC = INDXBC(CVAR,' ')
*              suppress D:, P: etc
               IFNCOL=MAX(1,INDEX(CVAR(1:ILC),':')+1)
*              get IO-char
               NCH=MIN((NW-2)*4,60)
               CLINE=' '
               CALL UHTOC(IQ(IP+3),4,CLINE,NCH)
               ICOLON=INDEX(CLINE,'IO:')
               IF(ICOLON.NE.0)THEN
*                 skip space
                  ICOLON=ICOLON+2+INDEXC(CLINE(ICOLON:),' ')
                  CHARIO=CLINE(ICOLON:ICOLON)
                  IF(CHARIO.EQ.'U')CHARIO='B'
                  IF(CHARIO.EQ.'R')CHARIO='F'
                  IOLCHA=ICOLON+INDEX(CLINE(ICOLON:),' ')-1
               ENDIF
               IF(INDEX(CHOPT,'I').NE.0)THEN
                  IF(ICOLON.NE.0)THEN
                     IF(INDEX(CHARIA,CHARIO).EQ.0)THEN
                        WRITE(*,*)'Illegal IO-char: ',CHARIO
                        CHPF=' '
                        GOTO 995
                     ENDIF
                     IF(CHARIO.EQ.CHARIS)THEN
                        NSTYP=NSTYP+1
                     ELSE
                        IF(NSTYP.NE.0)THEN
                           CALL DZDFIO(CHPF,IPCHPF,NSTYP,CHARIS)
                           IF(IPCHPF.LE.0)GOTO 995
                        ENDIF
                        NSTYP=1
                     ENDIF
                  ELSE
                     IF(NSTYP.GT.0)THEN
                        NSTYP=NSTYP+1
                     ELSE
                        WRITE(*,*)'No IO-char given yet'
                     ENDIF
                  ENDIF
*                 end of get IO-char
               ELSE
*                 if parameter statements required force Integers
                  IF(INDEX(CHOPT,'p').NE.0) CHARIO='I'
*                 data word offsets, assignments
                  ISKC=INDEXN(CHOPT)
*                 skip first ISKCC characters in data word name
                  IF(ISKC.NE.0)THEN
                     CALL DZDCTI(CHOPT(ISKC:ISKC),ISKCC)
                     IFNCOL=MIN(IFNCOL+ISKCC,ILC)
                  ENDIF
*                 prepare pre or postfix
                  ILPF = MIN(LNBLNK(CHPF),LEN(CHPFI))
                  IF(ILPF.GT.0)THEN
                     CHPFI(1:ILPF)=CHPF(1:ILPF)
                  ELSE
                     IF(INDEX(CHOPT,'=').NE.0)THEN
                        IF(IREPL.GT.0)THEN
                           CHPFI='(I)= Q(NOFF+'
                           IF(CHARIO.EQ.'I')CHPFI(5:5)='I'
                           ILPF=12
                        ELSE
                           CHPFI='= Q(NOFF+'
                           IF(CHARIO.EQ.'I')CHPFI(2:2)='I'
                           ILPF=9
                        ENDIF
                     ELSE IF((INDEX(CHOPT,'C').NE.0 .OR.
     +               INDEX(CHOPT,'H').NE.0)
     +               .AND.IREPL.GT.0)THEN
                        IF(CHREPC.EQ.' ')THEN
                           CHPFI='(MW)'
                        ELSE
                           CHPFI='('//CHREPC(1:2)//')'
                        ENDIF
                        ILPF=4
                     ENDIF
                  ENDIF
                  IF(ILPF.GT.0)THEN
                     IF(INDEX(CHOPT,'Z').EQ.0 .AND.
     +                  INDEX(CHOPT,'=').EQ.0 .AND.
     +                  INDEX(CHPFI,'(').EQ.0)THEN
                        CVARNM(1:ILPF)=CHPFI(1:ILPF)
                        CVARNM(ILPF+1:)=CVAR(IFNCOL:ILC)
                     ELSE
                        CVARNM(1:ILC-IFNCOL+1)=CVAR(IFNCOL:ILC)
                        CVARNM(ILC-IFNCOL+2:)=CHPFI(1:ILPF)
                     ENDIF
                     ILC=ILC-IFNCOL+1+ILPF
                  ELSE
                     CVARNM=CVAR(IFNCOL:ILC)
                     ILC=ILC-IFNCOL+1
                  ENDIF
                  WRITE(CVAR1,'(I8)')IWORDR
*  PN: compilation problem on sp2
*                 IFC = INDEXN(CVAR1,' ')
                  IFC = INDEXN(CVAR1)
                  IF(INDEX(CHOPT,'=').NE.0)THEN
*                    data assignments
                     IF(NKEEPS.EQ.0)THEN
                        ILC1 = INDXBC(CHBANK(1:4),' ')
                        IF(IPRKEE.LE.0)THEN
                           IPRKEE=IPRKEE+1
                           WRITE(LUC,'(A)')
     +                    'C +KEEP,'//'DAASS'//CHBANK(1:ILC1)
                        ENDIF
                     ENDIF
                     CALL DZDPLN(LUC,
     +               CVARNM(1:ILC)//CVAR1(IFC:8)//')',2)
                  ELSE IF(INDEX(CHOPT,'D').NE.0)THEN
*                    declarations, commons
                     IF(NKEEPS.EQ.0)THEN
                        ILC1 = INDXBC(CHBANK(1:4),' ')
                        IF(IPRKEE.LE.0)THEN
                           IPRKEE=IPRKEE+1
                           WRITE(LUC,'(A)')
     +                     'C +KEEP,'//'DAOFF'//CHBANK(1:ILC1)
                        ENDIF
                        IF(INDEX(CHOPT,'C').NE.0)THEN
*                          commons
                           IF(CHPFI(1:1).EQ.'(' .AND.
     +                     CHPFI(ILPF:ILPF).EQ.')')THEN
*                             parameter statement for dimension
                              CALL DZDPLN(LUC,'INTEGER ',2)
                              CHPFI(1:1)=' '
                              CALL DZDPLN(LUC,CHPFI(1:ILPF-1),1)
                              CHPFI(1:1)='('
                              CALL DZDPLN(LUC,'PARAMETER (',2)
                              CALL DZDPLN(LUC,CHPFI(2:ILPF-1)//'=',1)
                              IF(IUPERC.GT.0)THEN
                                 WRITE(CTEMP,'(I12)')IUPERC
                                 IFC=INDEXC(CTEMP,' ')
                                 CALL DZDPLN(LUC,CTEMP(IFC:)//')',1)
                              ELSE
                                 CALL DZDPLN(LUC,'??)',1)
                              ENDIF
                           ENDIF
                           CALL DZDPLN(LUC,
     +                     'COMMON/CO'//CHBANK(1:ILC1)//'/',2)
                           CALL DZDPLN(LUC,
     +                     ' '//CVARNM(1:ILC),1)
                           ILC=0
                        ENDIF
                        IF(INDEX(CHOPT,'H').NE.0)THEN
*                          hbname
                           CALL DZDPLN(LUC,
     +                     'CALL HBNAME (ID'//CHBANK(1:ILC1)//
     +                     ','''//CHBANK(1:ILC1)//''',',2)
*                          if its an array fill dimension first
                           IF(CHPFI(1:1).EQ.'(' .AND.
     +                     CHPFI(ILPF:ILPF).EQ.')')THEN
                              CALL DZDPLN(LUC,
     +                        CHPFI(2:ILPF-1)//','''//CHPFI(2:ILPF-1),1)
                              IF(IUPERC.GT.0)THEN
                                 WRITE(CTEMP,'(I12)')ILOWRC
                                 IFC=INDEXC(CTEMP,' ')
                                 CALL DZDPLN(LUC,'['//CTEMP(IFC:),1)
                                 WRITE(CTEMP,'(I12)')IUPERC
                                 IFC=INDEXC(CTEMP,' ')
                                 CALL DZDPLN(LUC,
     +                           ','//CTEMP(IFC:)//']',1)
                              ELSE
                                 CALL DZDPLN(LUC,'[0,??]',1)
                              ENDIF
                           ELSE
                              CALL DZDPLN(LUC,
     +                        CVARNM(1:ILC)//',''',1)
                              CALL DZDPLN(LUC,CVARNM(1:ILC),1)
                              ILC=0
                           ENDIF
                        ENDIF
                     ENDIF
                     IF(INDEX(CHOPT,'C').EQ.0 .AND.
     +                  INDEX(CHOPT,'H').EQ.0)THEN
                        IF(CHARIO.NE.CHARIS)THEN
                           IF(CHARIO.EQ.'F')THEN
                              CALL DZDPLN(LUC,'REAL ',2)
                           ELSE
                              CALL DZDPLN(LUC,'INTEGER ',2)
                           ENDIF
                           CALL DZDPLN(LUC,
     +                     ' '//CVARNM(1:ILC),1)
                           ILC=0
                        ENDIF
                     ENDIF
                     IF(ILC.GT.0)THEN
                        CALL DZDPLN(LUC,
     +                  ','//CVARNM(1:ILC),1)
                     ENDIF
                     IF(INDEX(CHOPT,'H').NE.0)THEN
                        IF(ICOLON.GT.1)THEN
                           CALL DZDPLN(LUC,':'//CLINE(ICOLON:IOLCHA),1)
                        ENDIF
                     ENDIF
                  ELSE
*                    PARAMETER statements
                     IF(NKEEPS.EQ.0)THEN
                        CALL DZDPLN(LUC,'PARAMETER(',2)
                     ELSE
                        CALL DZDPLN(LUC,',',1)
                     ENDIF
                     CALL DZDPLN(LUC,
     +               CVARNM(1:ILC)//'='//CVAR1(IFC:8)
     +               ,1)
                  ENDIF
                  NKEEPS = NKEEPS+1
                  CHARIS=CHARIO
               ENDIF
            ENDIF
         ELSE
            MC1 = MIN(NW,17)
            MC=MC1
            DO 60   K=3,MC1
               IF(IQ(IP+K).EQ.IILFLF)THEN
                 MC=K-1
                 GOTO 70
               ENDIF
   60       CONTINUE
   70       CONTINUE
*           examine/check value against range
            IF(INDEX(CHOPT,'E').NE.0)THEN
*              get [ , ]
               NCH=MIN((NW-2)*4,LEN(CLINE))
               CLINE=' '
               CALL UHTOC(IQ(IP+3),4,CLINE,NCH)
               IFC=INDEX(CLINE,'[')
               ILC=INDEX(CLINE,']')
               IFC=IFC+1
               ILC=ILC-1
               NC=INDEX(CLINE(IFC:ILC),',')
               IF(NC.EQ.0)NC=INDEX(CLINE(IFC:ILC),':')
               IF(IFC.EQ.1 .OR. ILC.LE.0 .OR. NC.EQ.0)THEN
                  WRITE(LUC,'(A,I6)')
     +            'No range defined for word:',IWORD
                   GOTO 80
               ENDIF
               ILC1=IFC+NC-2
               IFC2=ILC1+2
               IOUT=0
               IF(INDEX( CVAL,'.').EQ.0)THEN
*                 INTEGER
                  IF(CLINE(IFC:IFC).NE.'*')THEN
                     CALL DZDCTI(CLINE(IFC:ILC1),IVAL1)
                     IF(IQ(KQS+L+IWORD).LT.IVAL1)THEN
                        IOUT=1
                     ELSE IF(CLINE(IFC2:IFC2).NE.'*')THEN
                        CALL DZDCTI(CLINE(IFC2:ILC),IVAL2)
                        IF(IQ(KQS+L+IWORD).GT.IVAL2)IOUT=1
                     ENDIF
                  ENDIF
                  IF(IOUT.GT.0)THEN
                     WRITE(LUC,'(A,I10,A,I6,A,2(I10,A))')
     +               CVAR1,IQ(KQS+L+IWORD),' at:',IWORD,
     +               ' out of range [', IVAL1,',' ,IVAL2,']'
                  ENDIF
               ELSE
                  IF(CLINE(IFC:IFC).NE.'*')THEN
                     CALL IZCTOR(CLINE(IFC:ILC1),VAL1)
                     IF(Q(KQS+L+IWORD).LT.VAL1)THEN
                        IOUT=1
                     ELSE IF(CLINE(IFC2:IFC2).NE.'*')THEN
                        CALL IZCTOR(CLINE(IFC2:ILC),VAL2)
                        IF(Q(KQS+L+IWORD).GT.VAL2)IOUT=1
                     ENDIF
                  ENDIF
                  IF(IOUT.GT.0)THEN
                     WRITE(LUC,'(A,E10.4,A,I6,A,2(E10.4,A))')
     +               CVAR1,Q(KQS+L+IWORD),' at:',IWORD,
     +               ' out of range [', VAL1,',' ,VAL2,']'
                  ENDIF
               ENDIF
*           print the value
            ELSE IF(INDEX(CHOPT,'=').EQ.0)THEN
*               fill in a possible index
                CLOOP=CVAR1
                IF(LOOPC1.GT.0)THEN
                   CLOOP(9:9)='('
                   CLOOP(21:21)=')'
                   WRITE(CLOOP(10:14),'(I5)')LOOPC1
                   IF(LOOPC2.GT.0)THEN
                      CLOOP(15:15)=','
                      WRITE(CLOOP(16:20),'(I5)')LOOPC2
                   ENDIF
                   CLOOP=SPACES(CLOOP,0)
                ENDIF
*               indent
                NCLOOP=LENOCC(CLOOP)
                IF(NCLOOP.LE.12)THEN
                     NCLOOP=12
                ELSE IF(NCLOOP.LE.16)THEN
                     NCLOOP=16
                ENDIF
                CLINE=' '
                WRITE(CLINE,'(1X,I5)')IWORD
 
                CLINE(9:9+NCLOOP-1)=CLOOP(1:NCLOOP)
                CLINE(9+NCLOOP:9+NCLOOP+10)=CVAL
                MC=(MC-2)*4
                MC=MIN(MC,LEN(CLINE)-21-NCLOOP)
                CALL UHTOC(IQ(IP+3),4,CLINE(22+NCLOOP-LENMSK:),MC)
*               remove leading part if its MASK
                IF(LENMSK.GT.0)CLINE(1:22+NCLOOP-1)=' '
                IF(CLINE (9+NCLOOP-1:MC+35).NE.
     &             CLINSA(9+NCLOOP-1:MC+35))THEN
                   IF(NLSKIP.GT.0)THEN
                      WRITE(LUC,'(/26X,A,I5,A)')'---',NLSKIP,
     &                ' lines with same value skipped ---'
*                      IF(IDELAY.LE.0)WRITE(LUC,'(A)')' '
                      NLSKIP=0
                   ENDIF
                   IF(IDELAY.GT.0)THEN
                      WRITE(LUC,'(/11X,A)')CLINDE
                      IDELAY=IDELAY-1
                   ENDIF
                   LALILE=LENOCC(CLINE)
                   WRITE(LUC,'(/A'//NONEWL//')')CLINE(1:LALILE)
*             only if bank has more then 100 words
                   IF(NBLENG.GT.100)CLINSA(1:MC+35)=CLINE(1:MC+35)
                ELSE
                   NLSKIP=NLSKIP+1
                ENDIF
             ELSE
                IF(INDEX( CVAL,'.').EQ.0)THEN
                   WRITE(LUC,'(6X,A,A4,A,A8,A,A11)')
     +             'IQ(L',CHBANK(1:4), '+', CVAR1, ') = ', CVAL
                ELSE
                   WRITE(LUC,'(6X,A,A4,A,A8,A,A11)')
     +             'Q(L',CHBANK(1:4), '+', CVAR1, ') = ', CVAL
                ENDIF
             ENDIF
         ENDIF
         GOTO 80
      ENDIF
 
*     end of hollerith sector
 
      IF(IT .NE. 2)THEN
         WRITE(LUC,'(/A,2I9)')' Unexpected IT,NW ',IT,NW
         WRITE(LUC,'(1X,100Z8)')(IQ(IP+K),K=1,NW)
         GOTO 80
      ENDIF
 
*     start of integer sector
*     i.e. word # documented or rep level change
 
*     WRITE(*,'(1X,Z8,100I8)')(IQ(IP+K),K=1,NW)
      ICHOIC = IQ(IP+1)
*      IBIT13 = JBYT(ICHOIC,1,3)
      IDENTF = JBYT(ICHOIC,11,5)
      IF(KEEPSQ )THEN
         IF(IREPL.NE.JBYT(ICHOIC,16,3))THEN
            IF(INDEX(CHOPT,'C').NE.0)NKEEPS=0
            IF(INDEX(CHOPT,'H').NE.0)THEN
               IF(NKEEPS.GT.0)CALL DZDPLN(LUC,''')',1)
               NKEEPS=0
            ENDIF
         ENDIF
      ENDIF
 
      IREPL=JBYT(ICHOIC,16,3)
*      IESEQ  = JBYT(ICHOIC,19,1)
*      WRITE(*,*)' IBIT13, IDENTF, IREPL, IESEQ',
*     &               IBIT13, IDENTF, IREPL, IESEQ
*     remember sequence number of data word documented
      IWDOCO = IWDOC
      IF(IDENTF .EQ. ITGENQ)THEN
*        remember start of rep section in doc
         IF(IC1.GT.0 .AND. IP1 .EQ. 0)IP1 =IP
         IF(IC2.GT.0 .AND. IP2 .EQ. 0)IP2 =IP
         IWDOC = IQ(IP+2)
         GOTO 80
      ENDIF
 
*     repetition level
 
      IF(IDENTF .EQ. ITGREQ)THEN
          IF(REPEND)THEN
             REPEND=.FALSE.
          ELSE
             IF(KEEPSQ)IWORDR=0
          ENDIF
*         end of infinite rep loop (IFREPL=1), check if doc is uptodate
 
          IF(IFREPL.NE.0 .AND. NEXTRA.EQ.0 .AND. LRECOV
     &     .AND. IMBED2.EQ.0 .AND. NW.EQ.1 .AND. IREPL.EQ.0)THEN
             NTRIAL=0
             NDREST=IQ(L+KQS-1)-IWORIF
             NNREP=FLOAT(NDREST)/FLOAT(IWDOC)+0.5
74           NDEXT=NDREST-IWDOC*NNREP
             IF(NDEXT.NE.0 .AND. NNREP.GT.0)THEN
                NEXTRA=NDEXT/NNREP
                IF(NNREP*NEXTRA.EQ.NDEXT)THEN
                   IF(INDEX(CHOPT,'Q').EQ.0)
     &             CALL DZDPRW(LUC,NEXTRA+IWDOC)
                ELSE
                   IF(NTRIAL.EQ.0)THEN
                      NNREP=NNREP+1
                      NTRIAL=1
                      GOTO 74
                   ELSEIF(NTRIAL.EQ.1)THEN
                      NNREP=NNREP-2
                      NTRIAL=-1
                      GOTO 74
                   ELSE
                      NEXTRA=0
                   ENDIF
                ENDIF
             ELSE
                NEXTRA=0
             ENDIF
             IF(NEXTRA.LT.0)THEN
                 WRITE(LUC,'(/A,I5,A)')
     &           ' Ignore last',-NEXTRA,' words'
                 IWORD=IWORD+NEXTRA
                 IWORDR=IWORDR+NEXTRA
*                force new retrieval of formatted values
                 IC9=10
                 NEXTRA=-(NEXTRA+IWDOC)
             ENDIF
             IF(NEXTRA.EQ.0 .AND. NDEXT.NE.0)THEN
                   CALL DZDPRW(LUC,-1000000)
             ENDIF
          ENDIF
*     look if enough data words are documented for this section
          IF(NEXTRA.GT.0 .AND. LRECOV)THEN
             DO 75 II=IWORD+1,IWORD+NEXTRA
                CALL DZSHOW(' ',IXSTOR, L,COPTDZ//'Q',1,0,II,II)
                CVAL = CQLINE(12:22)
                IF(INDEX(CHOPT,'C').EQ.0)THEN
                   IF(INDEX(CHOPT,'Q').EQ.0)
     &             WRITE(LUC,'(/1X,I5,16X,A11,A)') II, CVAL,
     &            '  not documented'
                ELSE
                   WRITE(LUC,'(A11)')CVAL
                ENDIF
   75        CONTINUE
             IWORD=IWORD+NEXTRA
             IWORDR=IWORDR+NEXTRA
*            force new retrieval of formatted values
             IC9=10
          ENDIF
 
*
76        IWDOC = -1
 
*     end of rep level
 
          IF(NW .EQ. 1)THEN
 
             IF(IREPL .EQ. 1)THEN
*               end rep lev 2
                IF(REPATH)THEN
                   IF(IP.NE.IPDRE1)THEN
                      IF(IPRL1.LE.0)THEN
                         NVAL=-1
                         GOTO 990
                      ENDIF
                      VVAR(IPRL2)=IWORD-IPREP1
                      IPRL2=0
                      IPDRE1=IP
                      IF(NOTFIL)THEN
                         NVAL=NVAL+1
                         VVAR(NVAL)=0
                      ENDIF
                   ENDIF
                   IPREP1=IWORD
                ENDIF
                IC2 = IC2 -1
                LOOPC2=LOOPC2+1
*                IREPC=-2
                IF(IC2 .GT. 0)THEN
                    IP = IP2
                    IDENTF = ITGENQ
                    GOTO 10
                ENDIF
                LOOPC2=-1
                NEXTRA=0
                GOTO 80
             ELSE
                IF(IREPL .EQ. 0)THEN
                   IF(REPATH)THEN
*                     all done
                      IF(IP.NE.IPDRE0)THEN
                         IF(IPRL1.LE.0)THEN
                            NVAL=-1
                            GOTO 990
                         ENDIF
                         VVAR(IPRL1)=IWORD-IPREP0
                         IPDRE0=IP
                         IPRL1=0
                         IF(NOTFIL)THEN
                            NVAL=NVAL+1
                            VVAR(NVAL)=0
                         ENDIF
                      ENDIF
                      IF(.NOT.NOTFIL)GOTO 990
                      IPREP0=IWORD
                   ENDIF
                   IC1=IC1-1
                   LOOPC1=LOOPC1+1
*                   IREPC=-2
                   IF(IC1 .GT. 0)THEN
                      IF(KEEPSQ)GOTO 990
                      IP = IP1
                      IDENTF = ITGENQ
                      GOTO 10
                   ENDIF
                   LOOPC1=-1
                   NEXTRA=0
                   IMBED2=0
                   GOTO 80
                ELSE
                   WRITE(LUC,'(/A,I9)')' Illegal end of rep at',IP
                   GOTO 990
                ENDIF
             ENDIF
          ENDIF
 
* start of rep
 
          IREPC = IQ(IP+2)
 
*         return path?
 
          IF(REPATH)THEN
             NVAL=NVAL+1
*            offset from previous to start of rep
             VVAR(NVAL)= - (IWORD-IPREP0)
*            remember start of section
             IF(IREPL.EQ.2)THEN
                IPREP1=IWORD
             ELSE
                IPREP0=IWORD
             ENDIF
             NVAL=NVAL+1
             VVAR(NVAL)=4
             NVAL=NVAL+1
             VVAR(NVAL)=IREPC
             MGEVAL=MAXVAL-NVAL
          ELSE
             MGEVAL=0
          ENDIF
 
          IF(IREPC.LT.0 .AND. .NOT. KEEPSQ)THEN
*            was it given in previous data word?
             ITP = MOD(IQ(IP+NW+1),16)
             NWP = IQ(IP+NW+1)/16
             NCOP=MIN(15,NWP)*4
             IF(ITP.EQ.5)THEN
                CLINE=' '
                CALL UHTOC(IQ(IP+NW+2),4,CLINE,NCOP)
                IF(CLINE(1:2).EQ.'N:'.AND.IPOINT.GT.0)THEN
                   DO I=1,IPOINT
                      NCH=LENOCC(CPOINT(I))
                      IF(CPOINT(I)(1:NCH).EQ.CLINE(1:NCH))THEN
                         IREPC=NPOINT(I)
                         IF(LENOCC(CLINE).GT.NCH)THEN
                            IVALRC=IREPC
                            IF(REPATH)THEN
                               CALL DZDGR1
     &                         (CLINE(NCH+1:),IVALRC,IREPC,NEX,
     &                          VVAR(NVAL+1),MGEVAL,NGEVAL)
                            ELSE
                               CALL DZDGR1
     &                         (CLINE(NCH+1:),IVALRC,IREPC,NEX,
     &                          IDUMMY,0,NDUMMY)
                            ENDIF
                         ENDIF
                         GOTO 77
                      ENDIF
                   ENDDO
                ENDIF
             ENDIF
 
*            try to get rep count from variable
 
             IF(REPATH)THEN
                CALL DZDGRC(IQ(IP+NW+1),0,IVALLW,IREPC,NEXTRA,
     &          VVAR(NVAL+1),MGEVAL,NGEVAL)
                IF(NGEVAL.LE.0)THEN
                   VVAR(NVAL)=1000000
                ELSE
                   VVAR(NVAL-1)=VVAR(NVAL-1)+NGEVAL
                   NVAL=NVAL+NGEVAL
                ENDIF
             ELSE
                CALL DZDGRC(IQ(IP+NW+1),0,IVALLW,IREPC,NEXTRA,
     &          IDUMMY,0,NDUMMY)
             ENDIF
 
             IF(NEXTRA.LT.0 .AND.INDEX(CHOPT,'Q').EQ.0 .AND. LRECOV)
     &       CALL DZDPRW(LUC,NEXTRA)
             IF(NEXTRA.GT.0 .AND. LRECOV)THEN
                IF(INDEX(CHOPT,'Q').EQ.0)WRITE(*,*)
     &          ' WARNING: Assume EXTRA',NEXTRA,' words not documented'
             ENDIF
 
             IF(IREPC.EQ.0)THEN
                REPEND=.TRUE.
             ENDIF
          ENDIF
77        CONTINUE
 
          IF(REPATH)THEN
             NVAL=NVAL+1
             IF(IREPL.EQ.1)THEN
                IPRL1=NVAL
             ELSE
                IPRL2=NVAL
             ENDIF
          ENDIF
 
          IF(IREPL.EQ.1)THEN
             IP1 = 0
             LOOPC1=1
             IC1 = IREPC
*             IC1 = IQ(IP+2)
             IF(IC1 .LT. 0)THEN
                IF(IFREPL .EQ. 0)THEN
                   IF(KEEPSQ)THEN
                      IC1 = 1
                   ELSE
*                    variable (infinite)rep
                      IFREPL =1
                      IC1 = 10000000
                   ENDIF
                   IDENTF = -ITGREQ
                   IF(NEWPNT)THEN
                      IWORIF=IWORD+1
                   ELSE
                      IWORIF=IWORD
                   ENDIF
                ELSE
                   WRITE(LUC,'(/A,I9)')
     &             ' Illegal var Rep count at ',IP
                   GOTO 990
                ENDIF
             ENDIF
             GOTO 80
          ELSE
             IF(IREPL.EQ.2)THEN
                IP2 = 0
                LOOPC2=1
                IC2 = IREPC
*               flag imbedded rep level 2
                IMBED2=1
*                IC2 = IQ(IP+2)
                IF(IC2 .LT. 0)THEN
                   WRITE(LUC,'(/A,I9)')
     &             ' Illegal var Rep count at ',IP
                   GOTO 990
                ENDIF
             ELSE
                WRITE(LUC,'(/A,I9)')' Repl>2 at ',IP
                GOTO 990
             ENDIF
          ENDIF
      ENDIF
 
   80 CONTINUE
      IP = IP+NW+1
      IF(IWORD.LT.IL11 .OR. IP.LT.LDATUM)THEN
          GOTO 10
      ELSE
          GOTO 990
      ENDIF
 
   90 CONTINUE
      IF(NLSKIP.GT.0)THEN
         WRITE(LUC,'(/A,I5,A)')'       ---',NLSKIP,
     &   ' identical lines skipped ---'
         NLSKIP=0
      ELSE
         WRITE(LUC,'(/A)')' '
      ENDIF
      DO 100 IWORD=IW1,IL11
      CALL DZSHOW(' ',IXSTOR, L,COPTDZ//'Q',1,0,IWORD,IWORD)
      CVAL = CQLINE(12:22)
      IF(INDEX(CHOPT,'C').EQ.0)THEN
          WRITE(LUC,'(1X,I5,16X,A11)') IWORD, CVAL
      ELSE
          WRITE(LUC,'(A11)')CVAL
      ENDIF
  100 CONTINUE
 
  990 CONTINUE
      IF( .NOT. KEEPSQ)THEN
         IF(NLSKIP.GT.0)THEN
            WRITE(LUC,'(/A,I5,A)')'       ---',NLSKIP,
     &      ' identical lines skipped ---'
            NLSKIP=0
         ELSE
            WRITE(LUC,'(/A)')
     &     '-----------------------------------------------------------'
         ENDIF
      ENDIF
  995 CONTINUE
      IF(INDEX(CHOPT,'I').NE.0 .AND. NSTYP.GT.0)THEN
          CALL DZDFIO(CHPF,IPCHPF,NSTYP,CHARIS)
      ENDIF
      IF(KEEPSQ .AND. INDEX(CHOPT,'H').NE.0 .AND. NKEEPS.GT.0)THEN
         CALL DZDPLN(LUC,''')',1)
      ENDIF
      IF(LQBKD1.NE.0 .AND.INDEX(CHOPT,'I').EQ.0)THEN
         CALL MZDROP(0,LQBKD1,'L')
         LQBKD1=0
      ENDIF
      IQPRNT =LUNSAV
      IF (IENTRY.EQ.2) ITYYY=ITY
      END
 
+DECK,DZIOPH. -----------------------------------------------------------------
*CMZ :  1.30/00 11/02/96  22.08.12  by  Pavel Nevski
*CMZU:  1.00/01 22/01/96  00.49.05  by  Sasha Vanyashin
*-- Author :
+SEQ,DEBUGVF1,IF=DEBUGON,IF=VFORT.
      SUBROUTINE DZIOPH (IFIRST,ILAST)
      SAVE KFOTYP
+CDE,MQSYS,QEQU,MZIOC,ZBCDK,ZUNIT.
+CDE,DZC1,BKFOPARQ.
 
      CHARACTER CHROUT*(*),CHSTAK*6,KFOTYP(0:11)*1
+SELF,IF=QMCRY,QMCDC.
      CHARACTER CDWORD*36
+SELF,IF=-QMCRY,IF=-QMCDC.
      CHARACTER CDWORD*20
+SELF.
      DOUBLE PRECISION DWORD
      INTEGER                IWORD
      REAL                         RWORD
      EQUIVALENCE     (DWORD,IWORD,RWORD)
      PARAMETER (CHROUT = 'DZIOPH')
      DATA KFOTYP /'U','B','I','F','D','H','*','S','*','N','*','L'/
 
+SEQ,DEBUGVF2,IF=DEBUGON,IF=VFORT.
*SEQ, Q$JBIT.
 
      CHSTAK          = CQSTAK(MCQSIQ:)
      CQSTAK(MCQSIQ:) = CHROUT
 
      CALL ZPAGE(IQPRNT,MIN((ILAST-IFIRST)/10+2,5))
      CQLINE = ' --------  DATA part of bank  --------'
      IF (IFLOPT(MPOSQQ).EQ.0) CALL DZTEXT(0,CDUMMQ,1)
 
      WRITE (CQLINE,'(1X,I7,'' /'',120X)') IFIRST
      INLINE =11
 
      JDATA  = 0
      JFOCUR = 0
      NWPRNT = 0
 
 
   10 ITYPE  = MFO(JFOCUR+1)
      IF (ITYPE.EQ.7)                                      GO TO 40
      NWSEC = MFO(JFOCUR+2)
      IF   (NWSEC)           20, 30, 60
 
   20 NWSEC = ILAST - JDATA
                                                           GO TO 60
 
   30 JDATA = JDATA + 1
      IWORD = IQ(KQS+LS+JDATA)
      NWSEC = IWORD
      IF (JDATA.GE.IFIRST) THEN
+SELF,IF=QMCRY,QMCDC.
          WRITE(CQLINE(INLINE:INLINE+19),'('' *'',A1,''('',I15,'')'')')
     +     KFOTYP(MIN(ITYPE,6)),NWSEC
+SELF,IF=-QMCRY,IF=-QMCDC.
          WRITE(CQLINE(INLINE:INLINE+11),'('' *'',A1,''('', I7,'')'')')
     +     KFOTYP(MIN(ITYPE,6)),NWSEC
+SELF.
          NWPRNT = NWPRNT + 1
      ENDIF
                                                           GO TO 50
 
   40 JDATA = JDATA + 1
      IWORD = IQ(KQS+LS+JDATA)
      ITYPE = MOD (IWORD,16)
      NWSEC = IWORD/16
      IF (JDATA.GE.IFIRST) THEN
+SELF,IF=QMCRY,QMCDC.
         WRITE(CQLINE(INLINE:INLINE+19),'('' *S('',A1,'','',I13,'')'')')
+SELF,IF=-QMCRY,IF=-QMCDC.
         WRITE(CQLINE(INLINE:INLINE+11),'('' *S('',A1,'','', I5,'')'')')
+SELF.
     +     KFOTYP(MIN(ITYPE,6)),NWSEC
          NWPRNT = NWPRNT + 1
      ENDIF
 
   50 IF (JDATA.GE.IFIRST) THEN
+SELF,IF=QMCRY,QMCDC.
          IF (MOD(NWPRNT,6).EQ.0)  THEN
+SELF,IF=-QMCRY,IF=-QMCDC.
          IF (MOD(NWPRNT,10).EQ.0)  THEN
+SELF.
              IF (IFLOPT(MPOSQQ).NE.0)                    GO TO 999
              CALL DZTEXT(0,CDUMMQ,1)
              WRITE (CQLINE,'(1X,I7,'' /'',120X)') NWPRNT+IFIRST
              INLINE =11
          ELSE
+SELF,IF=QMCRY,QMCDC.
              INLINE = INLINE + 20
+SELF,IF=-QMCRY,IF=-QMCDC.
              INLINE = INLINE + 12
+SELF.
          ENDIF
      ENDIF
 
      IF (ITYPE.GE.8) THEN
          ITYPE      = 0
          NWSEC      = ILAST - JDATA
          IQUEST(11) = -ITYPE
      ELSEIF (NWSEC.EQ.0) THEN
          ITYPE      = 0
                                                           GO TO 900
      ELSEIF (NWSEC.LT.0) THEN
          ITYPE      = 0
          NWSEC      = ILAST - JDATA
          IQUEST(11) = -ITYPE-32
      ENDIF
 
 
   60 IDBLE  = 0
      DO 100 I=MAX(JDATA+1,IFIRST),MIN(JDATA+NWSEC,ILAST)
          IWORD = IQ(KQS+LS+I)
          IF (IDBLE.EQ.1)           THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(A,'')'')') CDWORD(18:)
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(A,'')'')') CDWORD(10:)
+SELF.
              IDBLE  = 0
          ELSEIF (ITYPE.EQ.IFOHOQ)  THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(7X,''"'',A12)') IWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(7X,''"'',A4)')  IWORD
+SELF.
          ELSEIF (ITYPE.EQ.IFOINQ)  THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(I20)')          IWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(I12)')          IWORD
+SELF.
          ELSEIF (ITYPE.EQ.IFOFLQ)  THEN
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(G20.14)')       RWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              if (Rword.EQ.0.0) then
                 CQLINE(INLINE:INLINE+11)='  0.0  '
              else if (abs(Rword).LT.1.e-3.or.abs(Rword).GT.1.e8) then
                 WRITE(CQLINE(INLINE:INLINE+11),'(G12.4)')     RWORD
              else if (abs(Rword).LT.1) then
                 WRITE(CQLINE(INLINE:INLINE+11),'(F12.8)')     RWORD
              else
                 WRITE(CQLINE(INLINE:INLINE+15),'(G16.9)')     RWORD
                 CQLINE(INLINE+12:INLINE+15)=' '
              endif
+SELF.
          ELSEIF (ITYPE.EQ.IFODOQ)  THEN
              CALL UCOPY(Q(KQS+LS+I),DWORD,2)
+SELF,IF=QMCRY,QMCDC.
              WRITE(CDWORD,'(D36.29)') DWORD
              WRITE(CQLINE(INLINE:INLINE+19),'('' D('',A)') CDWORD(:17)
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CDWORD,'(D20.13)') DWORD
              WRITE(CQLINE(INLINE:INLINE+11),'('' D('',A)') CDWORD(:9)
+SELF.
              IDBLE  = 1
          ELSE
+SELF,IF=QMCRY,QMCDC.
              WRITE(CQLINE(INLINE:INLINE+19),'(''  Z '',Z16)') IWORD
+SELF,IF=-QMCRY,IF=-QMCDC.
              WRITE(CQLINE(INLINE:INLINE+11),'(''  Z '',Z8)')  IWORD
+SELF.
          ENDIF
          NWPRNT = NWPRNT + 1
 
+SELF,IF=QMCRY,QMCDC.
          IF (MOD(NWPRNT,6).EQ.0)  THEN
+SELF,IF=-QMCRY,IF=-QMCDC.
          IF (MOD(NWPRNT,10).EQ.0)  THEN
+SELF.
              IF (IFLOPT(MPOSQQ).NE.0)                    GO TO 999
              CALL DZTEXT(0,CDUMMQ,1)
              WRITE (CQLINE,'(1X,I7,'' /'',120X)') NWPRNT+IFIRST
              INLINE =11
          ELSE
+SELF,IF=QMCRY,QMCDC.
              INLINE = INLINE + 20
+SELF,IF=-QMCRY,IF=-QMCDC.
              INLINE = INLINE + 12
+SELF.
          ENDIF
 
  100 CONTINUE
 
 
      JDATA = JDATA + NWSEC
 
      IF (JDATA.GE.ILAST)                                  GO TO 900
 
      IF (JDATA.LT.ILAST)   THEN
          JFOCUR = JFOCUR + 2
          IF (JFOCUR.LT.JFOEND)                            GO TO 10
          JFOCUR = JFOREP
                                                           GO TO 10
      ENDIF
 
 
  900 IF (INLINE.NE.11.AND.IFLOPT(MPOSQQ).EQ.0) CALL DZTEXT(0,CDUMMQ,1)
 
  999 CQSTAK(MCQSIQ:) = CHSTAK
      END
 
+DECK,dzdpsc.
*CMZ :  1.30/00 14/02/96  21.04.12  by  Pavel Nevski
*-- Author :    Otto Schaile  14/02/96
******************************************************************************
*                                                                            *
      SUBROUTINE DZDPSC(ISTORE,LEV,CF)
*                                                                            *
* draw bank tree below LEV in store ISTORE in PostScript format into file CF *
******************************************************************************
      INTEGER LEV
      INTEGER LUNTRE, IRET
      PARAMETER (LUNTRE=65)
      CHARACTER*(*) CF
      CALL KUOPEN(LUNTRE,CF,'UNKNOWN',IRET)
      CALL IOPWK(2,LUNTRE,-111)
      CALL IDAWK(1)
      CALL IACWK(2)
      CALL RZCDIR('//RZDOC',' ')
      CALL DZDDTR(ISTORE,LEV,0,0,0,2,-111,'MPR')
      CALL IUWK(0,1)
      CALL IDAWK(2)
      CALL IACWK(1)
      CALL ICLWK(2)
      END
 
+DECK,dzdhtm.
*CMZ :  1.30/00 28/05/96  23.54.26  by  Unknown
*-- Author :    Otto Schaile   14/02/96
*******************************************************************
*                                                                 *
      SUBROUTINE DZDHTM(ISTORE,L,CFLAG)
*                                                                 *
*     walk through a d/s at L and write doc in html               *
*     CFLAG  'S' one bank only                                    *
*            'T' bank tree (default)                              *
*            'N' no data words                                    *
*            'P' plain text (no hyperlinks)                       *
*                                                                 *
*******************************************************************
C+SEQ,ZUNIT.
+SEQ,ZEBQ
+SEQ,MZCA
+SEQ,MZCB
C++CDE,ZBCDK.         From DZEBRA
C++SEQ,DZDPRM
C++SEQ,DZDOCC.
      CHARACTER*(*) CFLAG
      CHARACTER*16 CLTOP
      INTEGER L,LN,LGO,LRET,LDOWN, IFC,ILC, IHNONE, LUN
      PARAMETER (LUN=65)
      CHARACTER*8 ANCHOR
      CHARACTER*80 CGET
      CHARACTER*4 CLINK
      CHARACTER*5 CSUFFI
      CHARACTER*16 CLDOWN
      CHARACTER*16 DZE2US
      INTEGER KEYVEC(2)
*---
      CALL MZSDIV(ISTORE,-7)
      CALL UCTOH('NONE',IHNONE,4,4)
      IF(INDEX(CFLAG,'P').EQ. 0)THEN
         CSUFFI='.html'
      ELSE
         CSUFFI='.txt'
      ENDIF
      WRITE(CLTOP,'(A4,I7.7,A)')IQ(KQS+L-4),L,CSUFFI
      CLTOP=DZE2US(CLTOP)
      OPEN(LUN,FILE=CLTOP,STATUS='UNKNOWN')
*      CALL KUOPEN(LUN,CLTOP,'UNKNOWN',IRET)
      IF(LQ(KQS+L+1).EQ.0)THEN
         CLTOP=' '
      ELSE
         WRITE(CLTOP,'(A4,I7.7,A)')
     +   IQ(KQS+LQ(KQS+L+1)-4),LQ(KQS+L+1),CSUFFI
         CLTOP=DZE2US(CLTOP)
      ENDIF
      IF(INDEX(CFLAG,'P').EQ. 0)THEN
         WRITE(LUN,'(A)')'<html>'
         WRITE(LUN,'(A)')'<head>'
         WRITE(LUN,'(A)')'<body>'
         WRITE(LUN,'(A)')'<isindex>'
         WRITE(LUN,'(A)')'</head>'
         WRITE(LUN,'(A)')'<body>'
         WRITE(LUN,'(A)')'<pre>'
         ENDIF
      LRET=-L
 20   CONTINUE
      LGO=LRET
      CALL DZDWTR(ISTORE,LGO,LRET)
      IF(LRET.NE.0)THEN
*         WRITE(*,'(A,A4,I10)')'Found ',IQ(KQS+LRET-4),LRET
         KEYVEC(1)=IQ(KQS+LRET-4)
         IF(LQ(KQS+LRET+1).GT.1)THEN
            KEYVEC(2)=IQ(KQS+LQ(KQS+LRET+1)-4)
         ELSE
            KEYVEC(2)=IHNONE
         ENDIF
         I1000=100000
         LQBKD=0
         CALL RZIN(0,LQBKD,2,KEYVEC,I1000,'D')
         IF (LQBKD .EQ. 0)THEN
            NLT = 0
            NLU = 0
            WRITE(*,'(A,A4)')'No doc for bank ',KEYVEC(1)
         ELSE
            IP0=KQSP+LQBKD+1
 
            CALL DZDGGI(IQ(IP0),'CL',' ',CGET,IFC,ILC)
            WRITE(ANCHOR,'(I8.8)')LRET
            IF(INDEX(CFLAG,'P').EQ. 0)
     +      WRITE(LUN,'(A)')'<a name="L'//ANCHOR//'"><b>'
            IF(ILC.GT.0)WRITE(LUN,'(A)')
     +      'Bank IDH '//CGET(1:4)//' '//CGET(5:ILC)
            IF(INDEX(CFLAG,'P').EQ. 0)
     +      WRITE(LUN,'(A)')'</b></a>'
            CALL DZDGGI(IQ(IP0),'AU',' ',CGET,IFC,ILC)
            IF(ILC.GT.0)WRITE(LUN,'(A,A,A)')'Author(s) ',CGET(IFC:ILC)
            CALL DZDGGI(IQ(IP0),'VE',' ',CGET,IFC,ILC)
            IF(ILC.GT.0)WRITE(LUN,'(A,A,A)')'Version  ',CGET(IFC:ILC)
            NID=IQ(KQS+LRET-5)
            WRITE(LUN,'(A,I6)')'NumId     ',NID
            NL=IQ(KQS+LRET-3)
            NS=IQ(KQS+LRET-2)
            WRITE(LUN,'(A,I6)')'Str Links ',NS
            NR=NL-NS
            WRITE(LUN,'(A,I6)')'Ref Links ',NR
            ND=IQ(KQS+LRET-1)
            WRITE(LUN,'(A,I6)')'NData     ',ND
            NIO = JBYT(IQ(KQS+LRET),19,4)
            IOFFBS = - (NIO + NL + 8 + 1)
            CALL DZDIOC(IQ(KQS+LRET+IOFFBS),CGET,ILC)
            IF(ILC.GT.0)WRITE(LUN,'(A,A,A)')'IO-Char   ',CGET(1:ILC)
 
            WRITE(LUN,'(A)')'----------  System links ----------'
            CALL UHTOC(KEYVEC(2),4,CLINK,4)
            IF(CLINK.NE.'NONE')THEN
               IF(INDEX(CFLAG,'P').EQ. 0)THEN
                  WRITE(ANCHOR,'(I8.8)')LQ(KQS+LRET+1)
*                 is it very first bank
                  IF(LRET.EQ.L)THEN
                     NCH=LNBLNK(CLTOP)
                     WRITE(LUN,'(A,A)')'Up-Link   '//
     +               '<a href="'//CLTOP(1:NCH)//'#L'//ANCHOR//'"><b>'//
     +               CLINK//'</b></a>'
                  ELSE
                     WRITE(LUN,'(A,A)')'Up-Link   '//
     +               '<a href="#L'//ANCHOR//'"><b>'//
     +               CLINK//'</b></a>'
 
                  ENDIF
               ELSE
                  WRITE(LUN,'(A,A)')'Up-Link   '//CLINK
               ENDIF
*              handle Origin link eventually
            ELSE
               WRITE(LUN,'(A,A)')'Up-Link   '//CLINK
            ENDIF
            LN=LQ(KQS+LRET)
            IF(LN.NE.0)THEN
               CALL UHTOC(IQ(KQS+LN-4),4,CLINK,4)
               IF(INDEX(CFLAG,'P').EQ. 0)THEN
                  WRITE(ANCHOR,'(I8.8)')LN
                  WRITE(LUN,'(A,A)')'Next-Link '//
     +            '<a href="#L'//ANCHOR//'"><b>'//
     +            CLINK//'</b></a>'
               ELSE
                   WRITE(LUN,'(A,A)')'Next-Link '//CLINK
               ENDIF
            ENDIF
            IF(NS.GT.0)THEN
               WRITE(LUN,'(A)')'--------- Struct links ----------'
               DO I=1,NS
                  LDOWN=LQ(KQS+LRET-I)
                  IF(LDOWN.NE.0)THEN
                     CALL UHTOC(IQ(KQS+LDOWN-4),4,CLINK,4)
                     CALL DZDGGI(IQ(IP0),'LI',CLINK,CGET,IFC,ILC)
                     IF(INDEX(CFLAG,'P').EQ. 0)THEN
                        WRITE(ANCHOR,'(I8.8)')LDOWN
                        IF(INDEX(CFLAG,'S').NE.0)THEN
                           WRITE(CLDOWN,'(A4,I7.7,A5)')
     +                     CLINK,LDOWN,'.html'
                           CLDOWN=DZE2US(CLDOWN)
                           WRITE(LUN,'(I6,A)')I,
     +                     ' <a href="'//CLDOWN//'#L'//
     +                     ANCHOR//'"><b>'//
     +                     CLINK//'</b></a> '//CGET(1:ILC)
                        ELSE
                           WRITE(LUN,'(I6,A)')I,
     +                     ' <a href="#L'//
     +                     ANCHOR//'"><b>'//
     +                     CLINK//'</b></a> '//CGET(1:ILC)
                        ENDIF
                     ELSE
                        WRITE(LUN,'(I6,A)')I,CLINK//' '//CGET(1:ILC)
                     ENDIF
                  ENDIF
               ENDDO
            ENDIF
            IF(ND.GT.0 .AND. INDEX(CFLAG,'N').EQ. 0)THEN
               CALL DZDDWD(ISTORE,LRET,' ',1,ND,LUN)
            ENDIF
            CALL MZDROP(0,LQBKD,' ')
            LQBKD=0
         ENDIF
         IF(INDEX(CFLAG,'S').EQ.0)GOTO 20
      ENDIF
      IF(INDEX(CFLAG,'P').EQ. 0)THEN
         WRITE(LUN,'(A)')'</pre>'
         WRITE(LUN,'(A)')'</body>'
         WRITE(LUN,'(A)')'</html>'
      ENDIF
  999 CONTINUE
      RETURN
      END
 
 
+DECK,dzdwtr.
*CMZ :  1.30/00 14/02/96  21.11.15  by  Pavel Nevski
*-- Author :    Otto Schaile   14/02/96
**************************************************************************
*                                                                        *
       SUBROUTINE DZDWTR(ISTORE,L,LRET)
*                                                                        *
*     walk through a d/s at L, return link to the next bank in LRET      *
**************************************************************************
+SEQ,ZEBQ
+SEQ,MZCA
+SEQ,MZCB
      INTEGER L,LIN,LRET,JB
      INTEGER LORIG, LUP, LFROM
      SAVE    LORIG, LUP, LFROM
*---
      CALL MZSDIV(ISTORE,-7)
*     init links and return
      IF(L.LT.0)THEN
         LRET=-L
         LORIG = LRET
         LUP = LRET
         LFROM = LQ(KQS+LRET+1)
         GOTO 90
      ENDIF
*
      LIN=L
      JB = LUP - LORIG + 1
   10 CONTINUE
      NS = IQ(KQS+LUP -2)
      IF(JB .LE. NS)THEN
*        go down
         LD1 = LQ(KQS+ LIN - JB)
*        look if this link is used
         IF(LD1 .EQ. 0)THEN
            JB = JB + 1
            GOTO 10
         ENDIF
         LUP = LD1
         LORIG = LD1
         LRET = LD1
         GOTO 90
      ENDIF
 
*     look if its part of linear structure
 
      LN = LQ(KQS+LIN)
      IF(LN .NE. 0)THEN
         LUP = LN
         LORIG = LN
         LRET = LN
         GOTO 90
      ENDIF
 
*     look if it is end of a linear structure
*     i.e. origin and up link are in different banks
 
   50 CONTINUE
      LUP = LQ(KQS+LIN+1)
      LORIG = LQ(KQS+LIN+2)
*     look if back at top bank or if it would move above top bank
      IF(LUP .LE. 1 .OR. LUP .EQ. LFROM) THEN
         LRET=0
         GOTO 99
      ENDIF
      NSU = IQ(KQS+LUP-2)
      IF(LORIG .GE. LUP .OR. LORIG .LT. LUP-NSU)THEN
*        its different, step back
         LIN = LORIG
         GOTO 50
      ENDIF
*     go up
      LRET = LUP
   90 CONTINUE
      JB = LUP - LORIG + 1
      IF(JB.NE.1) THEN
         LIN=LRET
         GOTO 10
      ENDIF
   99 CONTINUE
      END
+DECK, ZFATAL.
*CMZ :  1.30/00 01/04/97  18.15.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   16/03/97
      SUBROUTINE ZFATAL
 
C-    FATAL PROGRAM TERMINATION
 
+CDE, ZMACH, ZSTATE, ZUNIT, MQSYS.
C--------------    END CDE                             --------------
+SEQ, ZFATALCH.
+SEQ, ZFATALRE.
 
      IF (NQERR.GT.0)              GO TO 71
      NQERR = NQERR+1
      LUN   = IQTYPE
      IF (LUN.NE.0)                GO TO 22
 
   21 LUN  = IQLOG
   22 IF (NQTRAC.EQ.0)             GO TO 31
 
C----              PRINT ZEBRA TRACE-BACK
 
+SELF, IF=QPRINT, IF=-QTRHOLL, A6M.
      JT = NQTRAC - 1
      WRITE (LUN,9024) MQTRAC(JT+1)
 9024 FORMAT (1X/' !!!!! ZFATAL called from ',A6)
      GO TO 28
 
   25 WRITE (LUN,9025) MQTRAC(JT+1)
 9025 FORMAT (14X,'called from ',A6)
   28 JT = JT - 1
+SELF, IF=QPRINT, IF=QTRHOLL, IF=-A6M.
      JT = NQTRAC - 2
      WRITE (LUN,9024) MQTRAC(JT+1),MQTRAC(JT+2)
 9024 FORMAT (1X/' !!!!! ZFATAL called from ',2A4)
      GO TO 28
 
   25 WRITE (LUN,9025) MQTRAC(JT+1),MQTRAC(JT+2)
 9025 FORMAT (14X,'called from ',2A4)
   28 JT = JT - 2
+SELF, IF=QPRINT.
      IF (JT.GE.0)                 GO TO 25
      IF (NQFATA.EQ.0)             GO TO 49
      GO TO 41
+SELF.
 
C--                EXTERNAL CALL TO ZFATAL
 
   31 IF (NQFATA.NE.0)             GO TO 41
+SELF, IF=QPRINT.
      WRITE (LUN,9031)
 9031 FORMAT (1X/' !!!!! ZFATAL reached.')
+SELF.
      GO TO 49
 
C--                ZEBRA INTERNAL CALL TO ZFATAL
 
   41 CONTINUE
+SELF, IF=QPRINT, IF=QTRHOLL, IF=A6M.
      WRITE (LUN,9041) IQUEST(10),NQCASE
 9041 FORMAT (1X/' !!!!! ZFATAL reached from ',A6,'  for Case=',I3/1X)
+SELF, IF=QPRINT, IF=QTRHOLL, IF=-A6M.
      WRITE (LUN,9041) IQUEST(9),IQUEST(10),NQCASE
 9041 FORMAT (1X/' !!!!! ZFATAL reached from ',2A4,'  for Case=',I3/1X)
+SELF, IF=QPRINT, IF=-QTRHOLL.
      WRITE (LUN,9041) IQUEST(9),IQUEST(10),NQCASE
 9041 FORMAT (1X/' !!!!! ZFATAL reached from ',2A4,'  for Case=',I3/1X)
+SELF, IF=QPRINT.
 
      JPOS = IQBITW - 7
 
      DO 47  JW=11,10+NQFATA
      IT = IQUEST(JW)
      J  = JBYT (IT,JPOS,8)
      IF (J.EQ.0)                  GO TO 44
      IF (J.EQ.255)                GO TO 44
 
      WRITE (LUN,9043,ERR=47)  JW,IT,IT,IT
      GO TO 47
 
   44 WRITE (LUN,9044,ERR=47)  JW,IT,IT
+SELF, IF=QPRINT, IF=-HEX.
 9043 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,O22,1X,A6)
 9044 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,O22)
+SELF, IF=QPRINT, IF=HEX.
 9043 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,Z16,1X,A6)
 9044 FORMAT (10X,'IQUEST(',I2,') = ',I9,1X,Z16)
+SELF.
   47 CONTINUE
 
   49 WRITE (LUN,9049) JQSTOR,JQDIVI
 9049 FORMAT (1X/10X,'Current Store number =',I3,'  (JQDIVI=',I2,')')
 
      IF (IQVID(2).EQ.0)           GO TO 59
 
      WRITE (LUN,9051) IQVID
      WRITE (LUN,9052) (J,IQVREM(1,J),IQVREM(2,J),J=1,6)
 
 9051 FORMAT (1X/10X,'Automatic Verification Identifiers :'
     F/10X,'Current :',2X,2I11)
 9052 FORMAT (10X,'Stacked, J =',I2,' :',I6,I11,5(/22X,I2,' :',I6,I11))
 
   59 IF (LUN.NE.IQLOG)            GO TO 21
 
*PN: trying to do something, at least provide an extended diagnostoc
      CALL ZABEND (NQCASE,LQSYSR(KQT+1))
*     print *,' ==> NQCASE,NQERR after ZABEND =',NQCASE,NQERR
      IF (NQCASE.EQ.0) RETURN
*
      NQCASE = 0
      NQFATA = 0
 
 
C----              RECOVERY LOOP
 
   71 NQERR = NQERR + 1
      IF (NQERR.GE.4)              GO TO 79
      WRITE (IQLOG,9071)
      IF (IQTYPE.EQ.0)             GO TO 79
      IF (IQTYPE.EQ.IQLOG)         GO TO 79
      WRITE (IQTYPE,9071)
 9071 FORMAT (1X/' !!!!! break for re-entry to ZFATAL !!!!!')
   79 CONTINUE
*
* PN: regain control as in arithmetic trap
      CALL TRACEQ
+SELF, QTOABEND.
      CALL ABEND
+SELF.
* PN: never reached, for reference only
      CALL ZPHASE(0)
      END
 
+DECK,banks,T=TEXT.
*CMZ :          11/03/98  13.44.29  by  Pavel Nevski
*CMZ :  1.30/00 31/03/97  20.55.48  by  Pavel Nevski
*-- Author :    Pavel Nevski
+BANK,DETM.--------------------    DETM    ------------------------------
*B..DETM  main detector description
*B.AU    Pavel Nevski
*B.VE    1.00
*B.ST    /GCBANK/
*B.DV    Constant
*B.IO    -H
*B.UP    NONE
*B.DATA
*B.REP   100
*B.1     cset  - subsystem name
*B/REP
*B/DATA
*B/
+BANK,DOCU.--------------------    DOCU    ------------------------------
*B..DOCU    documentation system
*B.AU    Pavel Nevski
*B.VE    1.00
*B.ST    /GCBANK/
*B.DV    Constant
*B.IO    -I
*B.UP    DETM   -1
*B.DATA
*B.1   PNOW     - current print level
*B.2   PRIN     - system print level
*B.3   DEBU     - GEANT debug level
*B.4   GEOM     - geometry version
*B.5   HIST     - system histogram flag
*B.6   GRAP     - system graphics level
*B.7   SIMU     - store GEANT hits flag
*B.8   DIGI     - digitisation flag
*B.9   RECO     - reconstruction flag
*B.10  MFLD     - magnetic field flag
*B.11  ANAL     - user analysis level
*B.12  BACK     - pile-up bunch select.
*B.13  resa     - reserve
*B.14  resb     - reserve
*B.15  resc     - reserve
*B/DATA
*B/
+BANK,DETM.--------------------    DETM    ------------------------------
*B..DETM   system documention
*B.AU    Otto Schaile
*B.VE    1.00
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    300
*B.IO    1H 19I / *S
*B.UP    DOCU   -1
*B.DATA
*B.1  name      - bank name
*B.2  NwDesc    - full number of words in description
*B.3  NwHead    - number of words in the header
*B.4  nothing
*B.5  nothing
*B.6  nothing
*B.7  nothing
*B.8  nothing
*B.9  nothing
*B.10 nothing
*B.11 NwGen     - number of word in generic description
*B.12 NwLink    - number of word in link description
*B.13 nothing
*B.14 nothing
*B.15 NwData    - number of word in data description
*B.16 nothing
*B.17 nothing
*B.18 nothing
*B.19 nothing
*B.20 nothing
*B.REP   FOREVER
*B.21 part      - new part
*B.REP    BITS0031 ! previous word = rep count
*B.22 content   - some content
*B/REP
*B/REP
*B/DATA
*B/
+BANK,RUNG.--------------------    RUNG    ------------------------------
*B..RUNG    GEANT run header
*B.AU    Rene Brun
*B.VE    1.00
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    30
*B.IO    20I 8F -I
*B.UP    NONE
*B.DATA
*B.1      IDRUN     - Geant RUN number
*B.REP 9
*B.2      USER      - Reserved for User Application
*B/REP
*B.11     InitDate  - creation date for INIT structures
*B.12     InitTime  - creation time for INIT structures
*B.13     KineDate  - creation date for KINE structures
*B.14     KineTime  - creation time for KINE structures
*B.15     HitsDate  - creation date for HITS structures
*B.16     HitsTime  - creation time for HITS structures
*B.17     DigiDate  - creation date for Digi structures
*B.18     DigiTime  - creation time for Digi structures
*B.19     NRNDM(1)  - 1st seed of GRNDM at the end of the last event
*B.20     NRNDM(2)  - 2nd seed of GRNDM at the end of the last event
*B.21     InitGeVe  - Geant version number when INIT created
*B.22     InitZeVe  - Zebra version number when INIT created
*B.23     KineGeVe  - Geant version number when KINE created
*B.24     KineZeVe  - Zebra version number when KINE created
*B.25     HitsGeVe  - Geant version number when HITS created
*B.26     HItsZeVe  - Zebra version number when HITS created
*B.27     DigiGeVe  - Geant version number when DIGI created
*B.28     DidiZeVe  - Zebra version number when DIGI created
*B.29     Ievent    - event number at the end of the last event
*B.30     reserve   - not used
*B/DATA
*B/
 
+BANK,HEAD.--------------------    HEAD    ------------------------------
*B..HEAD   event header
*B.AU    R. Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.NL    1
*B.NS    1
*B.ND    10
*B.IO    -I
*B.UP    NONE
*B.LINK
*B/LINK
*B.DATA
*B.1     IdRun    - Run number
*B.2     IdEvt    - Event number
*B.3     Nrndm(1) - first random number seed at event start
*B.4     Nrndm(2) - second random number seed at event start
*B.REP   7
*B.5     user     - reserved for user application
*B/REP
*B/DATA
*B/
 
+BANK,PART.--------------------    PART    ------------------------------
*B..PART Particle data set
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.NL    100
*B.NS    100
*B.IO    -F
*B.UP    NONE
*B.LINK
*B.REP    100
*B.1     PART
*B/REP
*B/LINK
*B/
 
+BANK,PART.--------------------    PART    ------------------------------
*B..PART single particle data
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.NL    2
*B.NS    2
*B.ND    9
*B.IO    5H -F
*B.UP    PART   -5
*B.LINK
*B.1     PABR
*B.2     PAMO
*B/LINK
*B.DATA
*B.REP   5
*B.1     name - particle name (char*20)
*B/REP
*B.6     ITRTYP - type of tracking routine (g/e/n/h/m/n/i/c)
*B.7     AMASS  - particle mass (in GeV)
*B.8     CHARGE - particle charge
*B.9     TLIFE  - life time (in seconds)
*B.REP   Nuser
*B.10    USER   - user words
*B/REP
*B/DATA
*B/
+BANK,PABR.--------------------    PABR    ------------------------------
*B..PABR Branching ratio
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    6
*B.IO    -F
*B.UP    PART   -1
*B.DATA
*B.REP    6
*B.1     i-th branching ratio
*B/REP
*B/DATA
*B/
 
+BANK,PAMO.--------------------    PAMO    ------------------------------
*B..PAMO decay mode
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    6
*B.IO    -I
*B.UP    PART   -2
*B.DATA
*B.REP    6
*B.1     i-th decay mode
*B/REP
*B/DATA
*B/
 
 
+BANK,SETS.--------------------    SETS    ------------------------------
*B..SETS   subsytem  sets
*B.AU    R. Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.NL    2 - per subsystem
*B.NS    2
*B.ND    2
*B.IO    -H
*B.UP    NONE
*B.LINK
*B.1     SETS   - pointer to hits set
*B.2     SAME   - same for digi
*B/LINK
*B.DATA
*B.REP
*B.1     Cset  - set name = subsystem name + H or D
*B/REP
*B/DATA
*B/
 
+BANK,SETS.--------------------    SETS    ------------------------------
*B..SETS    Detectors
*B.AU    R. Brun
*B.VE    3.01
*B.IO    -H
*B.UP    SETS   -1
*B.LINK
*B.1     SEJD   -  pointer to GEANT detector description
*B/LINK
*B.DATA
*B.REP
*B.1     Cdet   -  detector name
*B/REP
*B/DATA
*B/
 
+BANK,SEJD.--------------------    SEJD    ------------------------------
*B..SEJD    GEANT detector parameters
*B.AU    R. Brun
*B.VE    3.01
*B.NL    4
*B.NS    4
*B.ND    100
*B.IO    '10I / 1H 1I'
*B.UP    SETS   -1
*B.LINK
*B.1     SJDH   -  GEANT standard hit parameters
*B.2     SJDD   -  GEANT standard digitisation parameters
*B.3     SJDU   -  USER general hit/digi descriptor
*B/LINK
*B.DATA
*B.1     Nwv      Number of words to store packed volume numbers
*B.2     Nv       Number of volume descriptors (real+pseudo)
*B.3     Nwh      Number of words per packed hit part
*B.4     Nh       Number of (cumulative) elements per hit
*B.5     Nwd      Number of words per packed digit part
*B.6     Nd       Number of (cumulative) elements per digitisation
*B.7     NWHI     primary size of the hit bank
*B.8     NWDI     primary size of the digitisation bank
*B.9     Npath    Number of paths through the JVOLUM tree
*B.10    Idm      For aliases only, IDET of mother detector
*B.REP   Nv times:
*B.11    NameVol  Name of a volume descriptor
*B.12    NbitVol  Number of bits for packing its number
*B/REP
*B/DATA
*B/
 
+BANK,SJDH.--------------------    SJDH    ------------------------------
*B..SJDH    Hit parameters (GSDETH)
*B.AU    R. Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    4      -  per hit element
*B.IO    / 1H 1I 2F
*B.UP    SEJD   -1
*B.DATA
*B.REP   Nh times:
*B.1     NameHit  Name of a hit descriptor
*B.2     NbitHit  Number of bits for its packing
*B.3     origin   positive displacement for packing
*B.4     factor   scale to convert to integer
*B/REP
*B/DATA
*B/
 
+BANK,SJDD.--------------------    SJDD    ------------------------------
*B..SJDD    Digit parameters (GSDETD)
*B.AU    R. Brun
*B.VE    3.01
*B.ND    2      - per digi element
*B.IO    / 1H 1I
*B.UP    SEJD   -2
*B.DATA
*B.REP   Nd times:
*B.1     NameDig  Name of a digit descriptor
*B.2     NbitDig  Number of bits for its packing
*B/REP
*B/DATA
*B/
 
+BANK,SJDU.--------------------    SJDU    ------------------------------
*B..SJDU    User Hit/Digit description
*B.AU    Pavel Nevski
*B.VE    1.00
*B.ND    200
*B.IO    -F
*B.UP    SEJD   -3
*B.DATA
*B.1     Iadr1   displacement for hit description part    = 10
*B.2     N:Nha   Number of all hit descriptors (both in non- and cum. parts)
*B.3     Iadr2   displacement for volume description part=10+10*Nh
*B.4     N:Nva   Number of all volume descriptors (branching or not)
*B.5     Iadr3   displacement for the free space   = 10+10*Nh+3*Nv
*B.6     Nvb     number of real volume branchings for NUMBV
*B.7     Goption Hit option: 1 - single step, 4 - Calorimetry
*B.8     Serial  Valid serial number for this subset
*B.9     IdType  USER detector number
*B.10    Iprin   current print flag both for HITS and DIGI
*B.REP   N:NHA
*B.11    hit     encoded hit name
*B.12    option  encoded hit option (R-rounding,S-single step)
*B.13    Nb      number of bit requested
*B.14    Fmin    hit low limit
*B.15    Fmax    hit upper limit
*B.16    Origin  Geant hit origin (-Fmin)
*B.17    Factor  Geant packing factor
*B.18    Nbit    number of bit allocated
*B.19    Iext    address of the Geant user step routine
*B.20    Ifun    hit function code (1-18 at present)
*B/REP
*B.REP   N:Nva
*B.21    Ivol    Volume of branching (pointer in JVOLUM)
*B.22    Ncopy   number of branchings
*B.23    Nb      number of bit needed
*B/REP
*B/DATA
*B/
 
+BANK,SAME.--------------------    SETS    ------------------------------
*B..SAME   same for digits
*B.NL    1
*B.ND    1
*B.UP    SETS   -1
*B/
 
+BANK,TMED.--------------------    TMED    ------------------------------
*B..TMED   standart tracking parameters
*B.AU    R. Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.IO    -F
*B.UP    NONE
*B.LINK
*B.REP
*B.1     TMED   - pointer to individual tracking medium
*B/REP
*B/LINK
*B.DATA
*B.1     CUTGAM - tracking cut for photons
*B.2     CUTELE - tracking cut for electrons
*B.3     CUTNEU - tracking cut for neutral hadrons
*B.4     CUTHAD - tracking cut for charged hadrons
*B.5     CUTMUO - tracking cut for muons
*B.6     BCUTE  - cut for electron bremsstrahlung
*B.7     BCUTM  - cut for muon and hadron bremsstrahlung
*B.8     DCUTE  - cut for delta-ray production by electrons
*B.9     DCUTM  - cut for delta-ray production by muons
*B.10    PPCUTM - energy cut for direct pair prod by muons
*B.11    IPAIR  - pair production flag
*B.12    ICOMP  - compton effect flag
*B.13    IPHOT  - photoabsorbtion flag
*B.14    IPFIS  -
*B.15    IDRAY  - delta ray production flag
*B.16    IANNI  - annigilation flag
*B.17    IBREM  - bremsstrahlung
*B.18    IHADR  -
*B.19    IMUNU  -
*B.20    IDCAY  - unstable particle decay flag
*B.21    ILOSS
*B.22    IMULS
*B.23      -    - undefined
*B.24      -    - undefined
*B.25      -    - undefined
*B.26    GHEISA
*B.27    MODEL
*B.28    RKB
*B.29    C
*B.30      -    - undefined
*B.31    ILABS  -
*B.32    ISYNC  - synchrotron radiation flag
*B.33    ISTRA  - de/dx model selection
*B.34      -    -
*B.35      -    -
*B.36      -    -
*B.37      -    -
*B.38      -    -
*B.39      -    -
*B.40      -    -
*B/DATA
*B/
 
+BANK,TCUT.--------------------    TCUT    ------------------------------
*B..TCUT     tracking parameters
*B.AU    R. Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    40
*B.IO    -F
*B.UP    TMED
*B.DATA
*B.1     CUTGAM - tracking cut for photons
*B.2     CUTELE - tracking cut for electrons
*B.3     CUTNEU - tracking cut for neutral hadrons
*B.4     CUTHAD - tracking cut for charged hadrons
*B.5     CUTMUO - tracking cut for muons
*B.6     BCUTE  - cut for electron bremsstrahlung
*B.7     BCUTM  - cut for muon and hadron bremsstrahlung
*B.8     DCUTE  - cut for delta-ray production by electrons
*B.9     DCUTM  - cut for delta-ray production by muons
*B.10    PPCUTM - energy cut for direct pair prod by muons
*B.11    IPAIR  - pair production flag
*B.12    ICOMP  - compton effect flag
*B.13    IPHOT  - photoabsorbtion flag
*B.14    IPFIS  -
*B.15    IDRAY  - delta ray production flag
*B.16    IANNI  - annigilation flag
*B.17    IBREM  - bremsstrahlung
*B.18    IHADR  -
*B.19    IMUNU  -
*B.20    IDCAY  - unstable particle decay flag
*B.21    ILOSS  -
*B.22    IMULS  -
*B.23      -    - undefined
*B.24      -    - undefined
*B.25      -    - undefined
*B.26    GHEISA -
*B.27    MODEL  -
*B.28    RKB    -
*B.29    C      -
*B.30      -    - undefined
*B.31    ILABS  -
*B.32    ISYNC  - synchrotron radiation flag
*B.33    ISTRA  - de/dx model selection
*B.34      -    -
*B.35      -    -
*B.36      -    -
*B.37      -    -
*B.38      -    -
*B.39      -    -
*B.40      -    -
*B/DATA
*B/
 
+BANK,MATE.--------------------    MATE    ------------------------------
*B..MATE  Materials
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.NL    100
*B.NS    100
*B.ND    0
*B.IO    -F
*B.UP    NONE
*B.LINK
*B.REP    100
*B.1     MATE
*B/REP
*B/LINK
*B/
 
+BANK,MATE.--------------------    MATE    ------------------------------
*B..MATE    Material description
*B.AU
*B.VE    1.00
*B.ST    /GCBANK/
*B.DV    Constant
*B.NL    20
*B.NS    20
*B.ND    11
*B.IO    5H -F
*B.UP    MATE   -1
*B.LINK
*B.REP    20
*B/REP
*B/LINK
*B.DATA
*B.REP    5
*B.1    matnam  - Material Name
*B/REP
*B.6      A     - Atomic weight
*B.7      Z     - Atomic number
*B.8      DENS  - density in g/cm-3
*B.9      RADL  - radiation length in cm
*B.10     ABSL  - absorption length in cm (ignored by GEANT)
*B.11     NLMAT - number of components for mixtures
*B/DATA
*B/
 
+BANK,TMED.--------------------    TMED    ------------------------------
*B..TMED   tracking medium parameters
*B.AU    R. Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.IO    5H -F
*B.UP    TMED
*B.NX    JTMN - private copy of tracking parameters
*B.DATA
*B.1     name1  - traking medium name
*B.2     name2  - same
*B.3     name3  - same
*B.4     name4  - same
*B.5     name5  - same
*B.6     Imate  - material number
*B.7     ISVOL  - sensetive volume flag
*B.8     IFIELD - Magnetic field flag
*B.9     FIELDM - Maximum field value
*B.10    TmaxFD - Max. angular deviation in field
*B.11    SteMax - Maximum step permitted
*B.12    DeeMax - Maximum fractional energy loss
*B.13    Epsil  - boundary crossing precision
*B.14    StMin  - min of the max.step imposed by E-loss,ms etc
*B.REP
*B.15    user   - user words
*B/REP
*B/DATA
*B/
 
+BANK,VERT.--------------------    VERT    ------------------------------
*B..VERT    simulated vertex list
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.NL    5
*B.NS    5
*B.ND    1
*B.IO    -I
*B.UP    NONE
*B.NX    VERT
*B.LINK
*B.REP    5
*B.1     VERT    - one vertex
*B/REP
*B/LINK
*B.DATA
*B.1     NVERTX  - number of vertices
*B.2     NVROFF  - offset in vertex number
*B/DATA
*B/
+BANK,VERT.--------------------    VERT    ------------------------------
*B..VERT    one vertex parameters
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.NL    1
*B.NS    1
*B.ND    9
*B.IO    -F
*B.UP    VERT   -1
*B.LINK
*B.1     VERU
*B/LINK
*B.DATA
*B.1     Vx     - vertex position in x
*B.2     Vy     - vertex position in y
*B.3     Vz     - vertex position in z
*B.4     ToF    - Time of flight
*B.5     NtBeam - first track which has produced the vertex
*B.6     NtTarg - second track which has produced the vertex
*B.7     NoTrac - number of tracks in the vertex
*B.REP   NoTrac
*B.8     Itrack - produced track number
*B/REP
*B/DATA
*B/
 
+BANK,VERU.--------------------    VERU    ------------------------------
*B..VERU    some vertex parameters
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.ND    2
*B.IO    -F
*B.UP    VERT   -1
*B.DATA
*B.1     one    - yet unknown vertex parameters
*B.2     two    - yet unknown vertex parameters
*B/DATA
*B/
 
+BANK,KINE.--------------------    KINE    ------------------------------
*B..KINE    list of tracks
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.NL    50
*B.NS    50
*B.ND    1
*B.IO    -I
*B.UP    NONE
*B.NX    KINE
*B.LINK
*B.REP   forever
*B.1     KINE   - link to a single track
*B/REP
*B/LINK
*B.DATA
*B.1     NTRACK - number of simulated tracks
*B.2     NTROFF - offset in track number
*B/DATA
*B/
 
+BANK,KINE.--------------------    KINE    ------------------------------
*B..KINE   single track parameters
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.NL    1
*B.NS    1
*B.IO    -F
*B.UP    KINE   -1
*B.LINK
*B.1     KINU
*B/LINK
*B.DATA
*B.1     Px    - track momentum in x
*B.2     Py    - track momentum in y
*B.3     Pz    - track momentum in z
*B.4     Energy - track total energy (Gev)
*B.5     Ipart  - GEANT particle code
*B.6     IoVert - vertex origin
*B.7     NoVert - number of vertices
*B.REP   NoVert
*B.8     IVert  - vertex number
*B/REP
*B/DATA
*B/
 
+BANK,KINU.--------------------    KINU    ------------------------------
*B..KINU    additional track parameters
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.ND    2
*B.IO    -F
*B.UP    KINE   -1
*B.DATA
*B.1     one    - yet unknown track parameter
*B.2     two    - yet unknown track parameter
*B/DATA
*B/
 
+BANK,HITS.--------------------    HITS    ------------------------------
*B..HITS GEANT hit bank
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.IO    -I
*B.UP    NONE
*B.NX    HITS
*B.LINK
*B.REP   Nset
*B.1     HITS - set hit banks
*B/REP
*B/LINK
*B/
 
+BANK,HITS.--------------------    HITS    ------------------------------
*B..HITS Set hit sets
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.IO    -I
*B.UP    HITS   -1
*B.LINK
*B.REP   Ndet
*B.1     SJHD
*B/REP
*B/LINK
*B.DATA
*B.REP   Ndet
*B.1     Nlast  - number of words in detector hit bank
*B/REP
*B/DATA
*B/
 
+BANK,SJHD.--------------------    SJHD    ------------------------------
*B..SJHD   Detector hits
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.IO    -B
*B.UP    HITS   -1
*B.DATA
*B.REP   Nword
*B.1     hit    - packed hit data, use AgFHIT1 routine
*B/REP
*B/DATA
*B/
 
+BANK,DIGI.--------------------    DIGI    ------------------------------
*B..DIGI GEANT digi bank
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.IO    -I
*B.UP    NONE
*B.NX    DIGI
*B.LINK
*B.REP   Nset
*B.1     DIGI - set of digi sets
*B/REP
*B/LINK
*B/
 
+BANK,DIGI.--------------------    DIGI    ------------------------------
*B..DIGI Set of digi sets
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.IO    -I
*B.UP    DIGI   -1
*B.LINK
*B.REP   Ndet
*B.1     SJDX
*B/REP
*B/LINK
*B.DATA
*B.REP   Ndet
*B.1     Nlast  - number of words in detector digi bank
*B/REP
*B/DATA
*B/
 
+BANK,SJDX.--------------------    SJDX    ------------------------------
*B..SJDX Detector digits
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    QDIV2
*B.IO    -B
*B.UP    DIGI   -1
*B.DATA
*B.REP   Nword
*B.1     hit    - packed digi data, use AgFDIG1 routine
*B/REP
*B/DATA
*B/
 
+BANK,ROTM.--------------------    ROTM    ------------------------------
*B..ROTM  Rotation structure
*B.AU    Rene Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    0
*B.IO    -F
*B.UP    NONE
*B.LINK
*B.REP
*B.1     ROTM
*B/REP
*B/LINK
*B/
 
+BANK,ROTM.--------------------    ROTM    ------------------------------
*B..ROTM rotation matrix
*B.AU    R.Brun
*B.VE    3.01
*B.ST    /GCBANK/
*B.DV    Constant
*B.ND    16
*B.IO    -F
*B.UP    ROTM   -1
*B.DATA
*B.1      scx        - sin(ThetaX)*cos(PhiX)
*B.2      ssx        - sin(ThetaX)*sin(PhiX)
*B.3      cx         - cos(ThetaX)
*B.4      scy        - sin(ThetaY)*cos(PhiY)
*B.5      ssy        - sin(ThetaY)*sin(PhiY)
*B.6      cy         - cos(ThetaY)
*B.7      scz        - sin(ThetaZ)*cos(PhiZ)
*B.8      ssz        - sin(ThetaZ)*sin(PhiZ)
*B.9      cz         - cos(ThetaZ)
*B.10     flag       - rotation flag (yes/no)
*B.11     ThetaX     - polar angle of the X axis
*B.12     PhiX       - azimuth of the X axis
*B.13     ThetaY     - polar angle of the Y axis
*B.14     PhiY       - azimuth of the Y axis
*B.15     ThetaZ     - polar angle of the Z axis
*B.16     PhiZ       - azimuth of the Z axis
*B/DATA
*B/
 
+BANK,RUNT.--------------------    RUNT    ------------------------------
*B..RUNT     Run Tree Bank
*B.AU        R. DeWolf
*B.NL        1
*B.NS        1
*B.ND        5
*B.UP        NONE
*B.IO        -I
*B.LINK
*B.1         GENR     GENZ Run Information Bank
*B/LINK
*B.DATA
*B.1         JOSYS1   Format flag
*B.2         JOSYS2   Member system word = 100000*NG+NM
*B.3         JOSYS3   Modularity system word = 100000*NW+NT
*B.4         JOCJID   Current Job identifier (up to the user/experiment)
*B.5         JOCRUN   Run number
*B/DATA
*B/
 
+BANK,GENR.--------------------    GENR    ------------------------------
*B..GENR     GENZ Run Information Bank
*B.AU        R. DeWolf
*B.ND        13
*B.UP        RUNT
*B.IO        7I 2H -I
*B.DATA
*B.1         JOSYS1   Format flag
*B.2         JOSYS2   Member system word = 100000*NG+NM
*B.3         JOSYS3   Modularity system word = 100000*NW+NT
*B.4         JOGJID   Generator run Job ID
*B.5         JOGRRU   Generator run number
*B.6         JOTIME   Time (hhmmss)
*B.7         JODATE   Date (yymmdd)
*B.8         JOMACH   Machine (Hollerith)
*B.9         JOGRNA   Generator (Hollerith)
*B.10        JOGVER   Generator version
*B.11        JOGEND   Generator date (yymmdd)
*B.12        JOGZVR   GENZ version * 10000
*B.13        JOZBVR   Zebra version * 10000
*B/DATA
*B/
 
+BANK,EVNT.--------------------    EVNT    ------------------------------
*B..EVNT     Event Tree Bank
*B.AU        R. DeWolf
*B.NL        2
*B.NS        2
*B.ND        6
*B.UP        NONE
*B.IO        -I
*B.LINK
*B.1         PASS     bank containing history of this data-structure
*B.2         GENE     GENZ event bank linear structure
*B/LINK
*B.DATA
*B.1         JOSYS1   Format flag
*B.2         JOSYS2   Member system word = 100000*NG+NM
*B.3         JOSYS3   Modularity system word = 100000*NW+NT
*B.4         JOCJID   Current Job identifier
*B.5         JOCRUN   Run number (For real data = DAQ run number)
*B.6         JOCEVT   Event (gate) number
*B/DATA
*B/
 
*B..PASS     Pass Record Bank
*B.AU        R. DeWolf
*B.NX        PASS
*B.UP        EVNT
*B.IO        -I
*B.DATA
*B.1         JOSYS1   Format flag
*B.2         JOSYS2   Member system word = 100000*NG+NM NGEN
*B.3         JOSYS3   Modularity system word = 100000*NW+NT (=300003)
*B.REP    NPASS  Number of Job Pass
*B.4      JOPJID Pass Job ID ( = CJID for latest PASS bank)
*B.5      JOGJID Generator Job ID.( = CJID if generated but not if read in)
*B.6      JOEVID ZEBRA IDN of event read in or generated
*B/REP
*B/DATA
*B/
 
+BANK,GENE.--------------------    GENE    ------------------------------
*B..GENE     GENZ Event Bank
*B.AU        R. DeWolf
*B.NL        1
*B.NS        1
*B.ND        12
*B.IO        5I 1H 4F 1I -F
*B.NX        GENE
*B.UP        EVNT
*B.LINK
*B.1         GENP     GENZ parton/particle bank
*B/LINK
*B.DATA
*B.1         JOSYS1   Format flag = 1
*B.2         JOSYS2   Member system word = 100000*NG+NM = 0
*B.3         JOSYS3   Modularity system word = 100000*NW+NT = 0
*B.4         JOGRUN   Generator run number
*B.5         JOGEVT   Generator event number
*B.6         JOGNAM   Generator name
*B.7         JOVRTX   Interaction vertex position in metres
*B.8         JOVRTY     idem
*B.9         JOVRTZ     idem
*B.10        JOVRTT   Interaction vertex time in seconds
*B.11        JOWTFL   Interaction weight flag
*B.12        JOWEIG   Interaction weight
*B/DATA
*B/
 
+BANK,GENP.--------------------    GENP    ------------------------------
*B..GENP     GENZ parton/particle data
*B.AU        R. DeWolf
*B.NL        1
*B.NS        1
*B.UP        GENE
*B.IO        3I / 5I 8F
*B.DATA
*B.1         JOSYS1   Format flag
*B.2         JOSYS2   Member system word = 100000*NG+NM (N particles)
*B.3         JOSYS3   Modularity system word = 100000*NW+NT;
*B.REP     JOSYS2  number of particles
*B.4       JOSTAT   Status flag
*B.5       JOPDGC   PDG particle code
*B.6       JOMOT1   First mother
*B.7       JOMOT2 Second mother. If -ve, mothers give a range: MOT1-MOT2
*B.8       JODAU1 First daughter. If<0, reference to GEANT trk. Number -ITRA
*B.9       JOPXPX x-Momentum of particle in GeV/c
*B.10      JOPYPY     idem in y
*B.11      JOPZPZ     idem in z
*B.12      JOMASS   Mass in GeV/c/c. Not necessarily the on-shell mass.
*B.13      JOTIME   Start time of particle relative to the interaction (sec)
*B.14      JOVERTX    particle origin in x
*B.15      JOVERTY    idem in y
*B.16      JOVERTZ    idem in z
*B/REP
*B/DATA
*B/
 
+BANK,RECB.--------------------    RECB    ------------------------------
*B..RECB    Reconstructed Event
*B.IO    -I
*B.UP    NONE
*B.LINK
*B.1     SECT  - Reconstruction level 1
*B.2     TRIG  - Trigger level 1 & 2
*B/LINK
*B.DATA
*B.REP
*B.1     NYD   - Future reconstruction flags
*B/REP
*B/DATA
*B/
 
+BANK,SECT.--------------------    SECT    ------------------------------
*B..SECT    Reconstruction Phase 1
*B.IO    -F
*B.UP    RECB   -1
*B.NX    SECT
*B.LINK
*B.1     INNE - Inner detector reconstruction
*B.2     CALO - General calorimeter unpacking
*B.3     ECAL - E.m. calo reconstruction
*B.4     HCAL - Had calo reconstruction
*B.5     EMIS - missing energy calo reconstruction
*B/LINK
*B.DATA
*B.REP
*B.1     NYD  - Phase one summary data etc
*B/REP
*B/DATA
*B/
 
+BANK,INNE.-------------------    INNE    ------------------------------
*B..INNE    inner detector reconstruction
*B.IO    -F
*B.UP    SECT   -1
*B.NX    INNE
*B.LINK
*B.1     XKAL - different recnstruction packages
*B/LINK
*B.DATA
*B.REP
*B.1     NYD  - ID summary data etc
*B/REP
*B/DATA
*B/
 
 
+BANK,RAWH.--------------------    RAWH    ------------------------------
*B..RAWH    RD13 event header
*B.AU    Giuseppe Mornacci, RD13 note 109
*B.VE    1.00
*B.IO    -I
*B.UP    RECB   -1
*B.NX    RAWH
*B.DATA
*B.1     Marker   - Event Marker (12345678Hex = 305419896)
*B.2     Size     - Event structure size
*B.3     type     - SOR=3, SOB=1, EVENT=5, EOB=2, EOR=4
*B.4     BlockID  - Block ID: (DEADFACE = -559023410) or detector
*B.5     Run      - Run number
*B.6     Spill    - spill number in run
*B.7     Event    - Event number in run
*B.8     Evspill  - Event number in spill
*B.9     UEHptr   - User Header Pointer (always 11)
*B.10    CNTptr   - Contents List Pointer
*B.11    error    - Error code
*B.12    LUEH     - User Event Header size
*B.REP   LUEH
*B.13    UEH      - User Event Header
*B/REP
*B/DATA
*B/
 
+BANK,DETE.--------------------    DETE    ------------------------------
*B..DETE    DETECTOR Header
*B.AU    Giuseppe Mornacci
*B.VE    1.00
*B.IO    -I
*B.UP    RAWH   -1
*B.NX    DETE
*B.DATA
*B.1     Marker   - Event Marker (12345678Hex = 305419896)
*B.2     Size     - block structure size
*B.3     type     - Event type: SOR=3, SOB=1, EVENT=5, EOB=2, EOR=4
*B.4     detector - detector code
*B.5     Run      - Run number
*B.6     Spill    - spill number in run
*B.7     Event    - Event number in run
*B.8     Evspill  - Event number in spill
*B.9     UEHptr   - User Header Pointer
*B.10    CNTptr   - Content Space Pointer
*B.11    error    - error code
*B.12    LUEH     - User Event Header size
*B.REP   LUEH
*B.13    UEH      - User Event Header
*B/REP
*B/DATA
*B/
 
+BANK,STAK.--------------------    STAK    ------------------------------
*B..STAK    Geant temporary stack
*B.AU    R.Brun
*B.VE    3.21
*B.ST    /GCBANK/
*B.DV    Constant
*B.IO    3I / 3I 9F
*B.UP    NONE
*B.DATA
*B.1     Ntrack  - number of tracks in stack
*B.2     Nslots  - number of allocated slots
*B.3     Nsafety - safety update flag
*B.REP   FOREVER
*B.4     ITR     - ITRA of particle (>0) or of its ancestor (<0)
*B.5     IPART   - Particle type (geant)
*B.6     zero    - reserve
*B.7     Vertx   - x of production point
*B.8     Verty   - idem y
*B.9     Vertz   - idem z
*B.10    Pvertx  - Px at production point
*B.11    Pverty  - idem Py
*B.12    Pvertz  - idem Pz
*B.13    TOFG    - TOF at production point
*B.14    SAFETY  - distance to next boundary
*B.15    UPWGHT  - users word
*B/REP
*B/DATA
*B/
 
+BANK,CODE.--------------------    CODE    ------------------------------
*B..CODE EGZ generator header
*B.AU    Unknown STAR hero
*B.VE    1.00
*B.ND    10
*B.IO    2H -F
*B.UP    NONE
*B.NX    RUN
*B.DATA
*B.1   cname1 - event generator name
*B.2   cname2 - same
*B.3   evtver - event genrator version
*B.4   zproj  - Z of projectile
*B.5   aproj  - A of projectile
*B.6   ztarg  - Z of target nuclei
*B.7   atarg  - A of target nuclei
*B.8   sqrts  - sqrt of CMS energy
*B.9   bmin   - min impact parameter
*B.10  bmax   - max impact parameter
*B/DATA
*B/
 
+BANK,RUN .--------------------    RUN     ------------------------------
*B..RUN  EGZ run bank (empty)
*B.AU    Unknown STAR hero
*B.VE    1.00
*B.IO    -I
*B.UP    NONE
*B/
 
+BANK,EVEN.--------------------    EVEN    ------------------------------
*B..EVEN EGZ event bank
*B.AU    Unknown STAR hero
*B.VE    1.00
*B.ST    /GCBANK/
*B.IO    6I 1F / 1I 4F 1I
*B.UP    NONE
*B.DATA
*B.1   nptls  - number of particle generated
*B.2   nptarg - number of protons in target nuclei
*B.3   nntarg - number of neutrons in target nuclei
*B.4   npproj - number of protons in projectile
*B.5   nnproj - number of neutrons in projectile
*B.6   ntry   - number of previous unsuccesful retries
*B.7   bimevt - impact parameter
*B.REP FOREVER
*B.8   IdPtl  - event generator particle ID
*B.9   PlabX  - Px in lab.system
*B.10  PlabY  - Py in lab.system
*B.11  PlabZ  - Pz in lab.system
*B.12  Energy - energy in lab.system
*B.13  IoPtl  - unknown code
*B/REP
*B/DATA
*B/
 
 
 
 
+DECK,RZINK
*CMZ :  1.30/00 15/04/97  17.42.11  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZINK(KEYU,ICYCLE,CHOPT)
*
************************************************************************
*
*         To find and decode KEYU,ICYCLE
* Input:
*   KEYU    Keyword vector of the information to be read
*   ICYCLE  Cycle number of the key to be read
*           ICYCLE > highest cycle number means read the highest cycle
*           ICYCLE = 0 means read the lowest cycle
*   CHOPT   Character variable specifying the options selected.
*           data structure
*             default
*                   Same as 'D' below
*             'A'   Read continuation of the previously read data structure
*                   with identifier KEYU,ICYCLE
*                   Given that option implies that the record was written with
*                   the same option by a call to RZOUT.
*             'C'   Provide   information   about   the   cycle   numbers
*                   associated with KEY.
*                   The  total number  of  cycles  and the  cycle  number
*                   identifiers of the 19 highest  cycles are returned in
*                   IQUEST(50) and IQUEST(51..89) respectively
*             'D'   Read the  Data structure  with the  (key,cycle)  pair
*                   specified.
*             'N'   Read the neighbouring. keys (i.e. those preceding and
*                   following KEY).
*                   The  key-vectors of  the previous  and  next key  are
*                   available   respectively   as   IQUEST(31..35)    and
*                   IQUEST(41..45), see below.
*             'R'   Read data into existing bank at LSUP,JBIAS
*             'S'   KEYU(1) contains the key serial number
*                   IQUEST(20)= serial number of the key in directory
*                   IQUEST(21..20+NWKEY)=KEY(1....NWKEY)
*
* Called by RZIN,RZVIN
*
*  Author  : R.Brun DD/US/PD
*  Written : 09.05.86
*  Last mod: 11.09.89
*          : 04.03.94 S.Banerjee (Change in cycle structure)
*          : 15.04.97 P.Nevski   accept both selection KEY versions
************************************************************************
+SEQ,RZCL,RZCLUN,RZCOUT,RZK,RZCKEY,RZCYCLE.
      CHARACTER*(*) CHOPT
      DIMENSION KEYU(*)
      EQUIVALENCE (IOPTA,IQUEST(91)), (IOPTC,IQUEST(92))
     +,    (IOPTD,IQUEST(93)), (IOPTN,IQUEST(94)), (IOPTR,IQUEST(95))
     +,    (IOPTS,IQUEST(96))
*
*-----------------------------------------------------------------------
*
+SEQ,Q$JBIT.
*
      IQUEST(1)=0
      CALL UOPTC(CHOPT,'ACDNRS',IQUEST(91))
*
*           Search KEY and CYCLE
*
      LK=IQ(KQSP+LCDIR+KLK)
      NKEYS=IQ(KQSP+LCDIR+KNKEYS)
      NWKEY=IQ(KQSP+LCDIR+KNWKEY)
      IQUEST(7)=NKEYS
      IQUEST(8)=NWKEY
      IF(NKEYS.EQ.0)GO TO 90
*
      IF(IOPTS.NE.0)THEN
         IK1=KEYU(1)
         IK2=IK1
         IF(IK1.GT.NKEYS.OR.IK1.LE.0)THEN
            IQUEST(1)=1
            IQUEST(2)=IK1
            RETURN
         ENDIF
      ELSE
         IK1=1
         IK2=NKEYS
         DO 5 I=1,NWKEY
            IKDES=(I-1)/10
            IKBIT1=3*I-30*IKDES-2
            IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).LT.3)THEN
               KEY(I)=KEYU(I)
            ELSE
               CALL ZHTOI(KEYU(I),KEY(I),1)
            ENDIF
   5     CONTINUE
      ENDIF
      DO 30 I=IK1,IK2
         LKC=LK+(NWKEY+1)*(I-1)
         IF(IOPTS.EQ.0)THEN
            DO 10 K=1,NWKEY
               IF(IQ(KQSP+LCDIR+LKC+K).NE.KEY(K))GO TO 30
  10        CONTINUE
         ELSE
            DO 15 K=1,NWKEY
               IF(K.LT.10)THEN
                  IKDES=(K-1)/10
                  IKBIT1=3*K-30*IKDES-2
                  IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).LT.3)THEN
                     IQUEST(20+K)=IQ(KQSP+LCDIR+LKC+K)
                  ELSE
                     CALL ZITOH(IQ(KQSP+LCDIR+LKC+K),IQUEST(20+K),1)
                  ENDIF
               ENDIF
  15        CONTINUE
         ENDIF
         IQUEST(20)=I
         LCYC=IQ(KQSP+LCDIR+LKC)
         IF (KVSCYC.NE.0) THEN
            II=I
            IF (IQUEST(99).GE.96) II=IQ(KQSP+LCDIR+LKC+1)
            IF (IQ(KQSP+LCDIR+LCYC+KKYCYC).NE.II) THEN
               IQUEST(1) = 11
               GO TO 99
            ENDIF
         ENDIF
         NC=0
  20     NC=NC+1
         ICY = JBYT(IQ(KQSP+LCDIR+LCYC+KCNCYC),21,12)
         IF(ICY.EQ.ICYCLE)GO TO 50
         IF(NC.EQ.1.AND.ICYCLE.GT.ICY)GO TO 50
         IF (KVSCYC.EQ.0) THEN
            LCOLD = JBYT(IQ(KQSP+LCDIR+LCYC+KPPCYC),1,16)
         ELSE
            LCOLD = IQ(KQSP+LCDIR+LCYC+KPPCYC)
         ENDIF
         IF(LCOLD.EQ.0.AND.LCOLD.NE.LCYC.AND.ICYCLE.EQ.0)GO TO 50
         LCYC=LCOLD
         IF(LCYC.NE.0)GO TO 20
         GO TO 90
  30  CONTINUE
      GO TO 90
*
*           Cycle has been found
*           Read record descriptor
*
  50  IF (KVSCYC.EQ.0) THEN
         IR1   = JBYT(IQ(KQSP+LCDIR+LCYC+KFRCYC),17,16)
         IR2   = JBYT(IQ(KQSP+LCDIR+LCYC+KSRCYC),17,16)
         IP1   = JBYT(IQ(KQSP+LCDIR+LCYC+KORCYC), 1,16)
         NW    = JBYT(IQ(KQSP+LCDIR+LCYC+KNWCYC), 1,20)
      ELSE
         IR1   = IQ(KQSP+LCDIR+LCYC+KFRCYC)
         IR2   = IQ(KQSP+LCDIR+LCYC+KSRCYC)
         IP1   = JBYT(IQ(KQSP+LCDIR+LCYC+KORCYC), 1,20)
         NW    = IQ(KQSP+LCDIR+LCYC+KNWCYC)
      ENDIF
      N1    = NW
      IQUEST(2)=1
      IF(IR2.NE.0)IQUEST(2)=(NW-N1-1)/LREC+2
      IQUEST(3)=IR1
      IQUEST(4)=IP1
      IQUEST(5)=IR2
      IQUEST(6)=ICY
      IQUEST(12)=NW
      IQUEST(14)=IQ(KQSP+LCDIR+LCYC+1)
      IQUEST(15)=LCYC
C
C           C option given
C
      IF(IOPTC.NE.0)THEN
         IQUEST(50)=0
         LC1=LCYC
  51     IQUEST(50)=IQUEST(50)+1
         IF (KVSCYC.EQ.0) THEN
            LCOLD = JBYT(IQ(KQSP+LCDIR+LC1+KPPCYC),1,16)
         ELSE
            LCOLD = IQ(KQSP+LCDIR+LC1+KPPCYC)
         ENDIF
         IF(IQUEST(50).LE.19)THEN
            NC=IQUEST(50)
            IQUEST(50+NC)=JBYT(IQ(KQSP+LCDIR+LC1+KCNCYC),21,12)
            IQUEST(70+NC)=IQ(KQSP+LCDIR+LC1+KFLCYC)
         ENDIF
         IF(LCOLD.NE.0.AND.LCOLD.NE.LC1)THEN
            LC1=LCOLD
            GO TO 51
         ENDIF
      ENDIF
C
C           N option given. return neighbours
C
      IF(IOPTN.NE.0)THEN
         IF(I.EQ.1)THEN
            IQUEST(30)=0
         ELSE
            IQUEST(30)=NWKEY
            DO 52 J=1,NWKEY
               IF(J.LT.10)THEN
                  LKCJ=LK+(NWKEY+1)*(I-2)
                  IQUEST(30+J)=IQ(KQSP+LCDIR+LKCJ+J)
                  IKDES=(J-1)/10
                  IKBIT1=3*J-30*IKDES-2
                  IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).GE.3)THEN
                     CALL ZITOH(IQUEST(30+J),IQUEST(30+J),1)
                  ENDIF
               ENDIF
  52        CONTINUE
         ENDIF
         IF(I.EQ.NKEYS)THEN
            IQUEST(40)=0
         ELSE
            IQUEST(40)=NWKEY
            DO 53 J=1,NWKEY
               IF(J.LT.10)THEN
                  LKCJ=LK+(NWKEY+1)*I
                  IQUEST(40+J)=IQ(KQSP+LCDIR+LKCJ+J)
                  IKDES=(J-1)/10
                  IKBIT1=3*J-30*IKDES-2
                  IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).GE.3)THEN
                     CALL ZITOH(IQUEST(40+J),IQUEST(40+J),1)
                  ENDIF
               ENDIF
  53        CONTINUE
         ENDIF
      ENDIF
      GO TO 99
*
*           Error
*
  90  IQUEST(1)=1
      IF(IOPTN.NE.0)THEN
         IF(NKEYS.GT.0)THEN
            IQUEST(30)=NWKEY
            IQUEST(40)=NWKEY
            DO 91 J=1,NWKEY
               IF(J.GE.10)GO TO 91
               LKCJ=LK+(NWKEY+1)*(NKEYS-1)
               IQUEST(30+J)=IQ(KQSP+LCDIR+LK+J)
               IQUEST(40+J)=IQ(KQSP+LCDIR+LKCJ+J)
               IKDES=(J-1)/10
               IKBIT1=3*J-30*IKDES-2
               IF(JBYT(IQ(KQSP+LCDIR+KKDES+IKDES),IKBIT1,3).GE.3)THEN
                  CALL ZITOH(IQUEST(30+J),IQUEST(30+J),1)
                  CALL ZITOH(IQUEST(40+J),IQUEST(40+J),1)
               ENDIF
  91        CONTINUE
         ENDIF
      ENDIF
*
  99  RETURN
      END
+DECK, MZPUSH.
*CMZ :  1.30/00 18/03/97  19.04.33  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZPUSH (IXDIV,LORGP,INCNLP,INCNDP,CHOPT)
 
C-    Change the size of a bank, user called
 
+CDE, ZBCD, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCL, MZCN, MZCT.
C--------------    End CDE                             --------------
      DIMENSION    IXDIV(9),LORGP(9),INCNLP(9),INCNDP(9)
      CHARACTER    *(*) CHOPT
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZPU, 4HSH   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZPUSH /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZPUSH  ')
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT, Q$SBYT.
 
+SEQ, QTRACE.
 
      IF (IXDIV(1).EQ.-7)          GO TO 12
      CALL MZSDIV (IXDIV,0)
 
   12 CALL MZCHNB (LORGP)
      LORG  = LORGP(1)
      INCNL = INCNLP(1)
      INCND = INCNDP(1)
 
      CALL UOPTC (CHOPT,'RI',IQUEST)
      IFLAG = MIN (2, IQUEST(1)+2*IQUEST(2))
 
C-         IFLAG = 0  general
C-                 1  R-educe
C-                 2  I-solated
 
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.NE.0)
     +WRITE (IQLOG,9809) LORG,INCNL,INCND,IFLAG
 9809 FORMAT (1X/' DEVZE MZPUSH,  Entry for LORG,INCNL,INCND,IFLAG= '
     F,5I8)
+SELF, IF=QDEBUG.
      IF (IQVSTA.NE.0)       CALL ZVAUTX
+SELF.
      IF ((INCNL.EQ.0) .AND. (INCND.EQ.0))  GO TO 999
      LQSYSR(KQT+1) = LORG
 
C--                Find division
 
      JQDIVI = MZFDIV (-7, LORG)
      IF (JQDIVI.EQ.0)             GO TO 91
 
C--                Set bank parameters
 
+SELF,             IF=QDEBUG.
      CALL MZCHLS (-7,LORG)
      IF (IQFOUL.NE.0)             GO TO 91
      NL    = IQNL
      NS    = IQNS
      ND    = IQND
      NQNIO = IQNIO
      NQID  = IQID
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9831) JQDIVI,IQLS,IQID,IQNL,IQNS,IQND
 9831 FORMAT (16X,'JQDIVI,IQLS,IQID,IQNL,IQNS,IQND=',I3,I7,1X,A4,4I8)
+SELF,             IF=-QDEBUG.
      NQID  = IQ(KQS+LORG-4)
      NL    = IQ(KQS+LORG-3)
      NS    = IQ(KQS+LORG-2)
      ND    = IQ(KQS+LORG-1)
      NQNIO = JBYT (IQ(KQS+LORG),19,4)
+SELF.
      NQNL = NL + INCNL
      NQNS = MIN (NS,NQNL)
      NQND = ND + INCND
      IF (NS.EQ.NL)  NQNS = NQNL
+SELF, IF=QDEBPRI.
      IF (NQLOGL.GE.2)
     + WRITE (IQLOG,9032) JQSTOR,JQDIVI,LORG,NQID,INCNL,INCND,CHOPT
 9032 FORMAT (' MZPUSH-  Store/Div',2I3,' L/ID/INCNL/INCND/OPT=',
     FI9,1X,A4,2I7,1X,A)
+SELF.
      IF (JBIT(IQ(KQS+LORG),IQDROP).NE.0)   GO TO 92
 
C--                Check for bad parameters
 
      IF (NQND+NQNL.GE.LQSTA(KQT+21)) GO TO 93
      IF (NQND.LT.0)               GO TO 93
      IF (NQNL.GT.64000)           GO TO 93
      IF (NQNS.LT.0)               GO TO 93
 
      NLC = MIN (NL,NQNL)
      NSC = MIN (NS,NQNS)
      NDC = MIN (ND,NQND)
 
C--                Check giving up non-zero structural links
 
      IF (NQNS.GE.NS)              GO TO 36
      L  = LORG - NS - 1
      LD = LORG - NQNS
   34 L  = L + 1
      IF (L.GE.LD)                 GO TO 36
      LNZ = LQ(KQS+L)
   35 IF (LNZ.EQ.0)                GO TO 34
      IF (LQ(KQS+LNZ+2).NE.L)         GO TO 34
      IF (JBIT(IQ(KQS+LNZ),IQDROP).EQ.0)   GO TO 94
      LNZ = LQ(KQS+LNZ)
      GO TO 35
 
C--                Ready I/O characteristic
 
   36 LN = LORG - NL - NQNIO - 1
      CALL UCOPY (LQ(KQS+LN),NQIOCH,NQNIO+1)
      IF (NQNIO.NE.0)  NQIOSV(1)=0
      NQIOCH(1) = MSBYT (NQNL+NQNIO+12,NQIOCH(1),1,16)
 
C--                Re-enter after garbage collection, if any
 
   41 LE = LORG + ND + 9
 
C------            Check for short-cuts
 
      INCTT = INCNL + INCND
      INCMX = MAX (INCNL,INCND)
      INCMI = MIN (INCNL,INCND)
      CALL MZRESV
      IF (JQMODE.NE.0)             GO TO 45
 
C--                Last bank in forward division
 
      IF (LE.NE.LQEND(KQT+JQDIVI))    GO TO 51
      IF (INCNL.GE.0)              GO TO 42
      IF (IFLAG.NE.1)              GO TO 42
      IF ((NQRESV.GE.INCTT).AND.(NQRESV.LT.INCND))  GO TO 42
 
      LNN = LN - INCNL
      CALL UCOPY (NQIOCH,LQ(KQS+LNN),NQNIO+1)
      IQ(KQS+LORG-3) = NQNL
      IQ(KQS+LORG-2) = NQNS
 
      NWD = -INCNL
      CALL MZPUDX (LN,NWD)
      INCNL = 0
      INCTT = INCND
      LN    = LNN
      NL    = NQNL
 
   42 NQRESV = NQRESV - INCTT
      IF (NQRESV.LT.0)             GO TO 49
      NDELTA = INCNL
      LNEW   = LORG + NDELTA
      LQEND(KQT+JQDIVI) = LQEND(KQT+JQDIVI) + INCTT
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)  WRITE (IQLOG,9848) NDELTA,LNEW
+SELF.
      IF (NDELTA.EQ.0)  THEN
          IQ(KQS+LNEW-1) = NQND
          IF (IFLAG.NE.0)          GO TO 81
          IF (INCMI.GE.0)          GO TO 81
          GO TO 71
        ELSE
          CALL UCOPY2 (LQ(KQS+LORG-NLC),LQ(KQS+LNEW-NLC),NLC+NDC+9)
          IF (INCNL.GT.0)  CALL VZERO (LQ(KQS+LNEW-NQNL),INCNL)
          LQ(KQS+LN)     = NQIOCH(1)
          IQ(KQS+LNEW-3) = NQNL
          IQ(KQS+LNEW-2) = NQNS
          IQ(KQS+LNEW-1) = NQND
          GO TO 61
        ENDIF
 
C--                First bank in reverse division
 
   45 IF (LN.NE.LQSTA(KQT+JQDIVI))    GO TO 51
      IF (INCND.GE.0)              GO TO 47
      IF (IFLAG.NE.1)              GO TO 47
      IF ((NQRESV.GE.INCTT).AND.(NQRESV.LT.INCNL))  GO TO 47
      IQ(KQS+LORG-1) = NQND
 
      L   = LE + INCND
      NWD = -INCND
      CALL MZPUDX (L,NWD)
      INCND = 0
      INCTT = INCNL
      ND    = NQND
 
   47 NQRESV = NQRESV - INCTT
      IF (NQRESV.LT.0)             GO TO 49
      LNN    = LN - INCTT
      NDELTA = -INCND
      LQSTA(KQT+JQDIVI) = LNN
 
      LNEW  = LORG + NDELTA
 
      IF (NDELTA.NE.0)  CALL UCOPY2 (LQ(KQS+LORG-NLC)
     +,                              LQ(KQS+LNEW-NLC), NLC+NDC+9)
 
      IF (INCNL.GT.0)  CALL VZERO (LQ(KQS+LNEW-NQNL),INCNL)
      CALL UCOPY (NQIOCH,LQ(KQS+LNN),NQNIO+1)
 
      IQ(KQS+LNEW-3) = NQNL
      IQ(KQS+LNEW-2) = NQNS
      IQ(KQS+LNEW-1) = NQND
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)  WRITE (IQLOG,9848) NDELTA,LNEW
 9848 FORMAT (' DEVZE MZPUSH,  Edge bank with NDELTA,LNEW=',2I8)
+SELF.
 
      IF (NDELTA.NE.0)             GO TO 61
      IF (IFLAG.NE.0)              GO TO 81
      IF (INCMI.GE.0)              GO TO 81
      GO TO 71
 
C--                Garbage collection
*     IQUEST(1)=0
   49 CALL MZGAR1
      IF (IQUEST(1).EQ.0 .and. IQUEST(11).LT.0) then
         print *,' ***** error in mzpush after mzgar1, iquest(1,11)=',
     >            iquest(1),iquest(11)
         IQUEST(1)=-1
         return
      ENDIF
*
      LORG = LQSYSR(KQT+1)
      LN   = LORG - NL - NQNIO - 1
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9849)
 9849 FORMAT (1X/' DEVZE MZPUSH,  Garbage collected for edge bank')
+SELF.
      GO TO 41
 
C----              Reduction only
 
   51 IF (INCMX.GT.0)              GO TO 56
      IF (INCNL.EQ.0)              GO TO 52
 
C--                Link part
 
      LNN = LN - INCNL
      CALL UCOPY (NQIOCH,LQ(KQS+LNN),NQNIO+1)
      IQ(KQS+LORG-3)= NQNL
      IQ(KQS+LORG-2)= NQNS
 
      CALL MZPUDX (LN,-INCNL)
 
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9851) INCNL
 9851 FORMAT (' DEVZE MZPUSH,  In-situ links with INCNL=',I8)
+SELF.
      IF (INCND.EQ.0)              GO TO 54
 
C--                Data part
 
   52 IQ(KQS+LORG-1) = NQND
      LD  = LE + INCND
      NWD = -INCND
      CALL MZPUDX (LD,NWD)
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9852) INCND
 9852 FORMAT (' DEVZE MZPUSH,  In-situ data with INCND=',I8)
+SELF.
 
   54 LNEW   = LORG
      NDELTA = 0
      IF (IFLAG.NE.0)              GO TO 999
      GO TO 71
 
C------            Lift replacement bank
 
   56 J = 64*(32*NQNIO + NQNIO + 1) + 1
      NQIOCH(1) = MSBYT (J,NQIOCH(1),1,16)
 
      NQBIA = 2
      CALL MZLIFT (-7,LNEW,0,63,NQID,-1)
      LORG   = LQSYSR(KQT+1)
      NDELTA = LNEW - LORG
 
      CALL UCOPY (LQ(KQS+LORG-NLC),LQ(KQS+LNEW-NLC),NLC+4)
      CALL UCOPY (IQ(KQS+LORG),    IQ(KQS+LNEW),    NDC+1)
      IQ(KQS+LORG) = MSBIT1 (IQ(KQS+LORG),IQDROP)
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9857) LORG,LNEW
 9857 FORMAT (' DEVZE MZPUSH,  Push by copy LORG -> LNEW=',2I8)
+SELF.
 
C------            Up-date immediate links only
 
   61 IF (IFLAG.LT.2)              GO TO 71
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9861)
 9861 FORMAT (' DEVZE MZPUSH,  Update immediate links only')
+SELF.
 
C----              Update according to k-link in pushed bank
 
      K = LQ(KQS+LNEW+2)
      IF (K.EQ.0)                  GO TO 62
      IF (LQ(KQS+K).NE.LORG)          GO TO 95
      LQ(KQS+K) = LNEW
 
C----              Update according to link 0
 
   62 K = LNEW
      L = LQ(KQS+K)
      IF (L.EQ.0)                  GO TO 65
      IF (L.EQ.LORG)               GO TO 64
      LQ(KQS+L+2) = K
   63 K = L
      L = LQ(KQS+K)
      IF (L.EQ.0)                  GO TO 65
      IF (L.NE.LORG)               GO TO 63
   64 LQ(KQS+K) = LNEW
 
C----              Update k- and up-link in vertically dependent banks
 
   65 K = LNEW - NSC - 1
 
C--                          each link
   66 K = K + 1
      IF (K.GE.LNEW)               GO TO 81
      L = LQ(KQS+K)
      IF (L.EQ.0)                  GO TO 66
      IF (LQ(KQS+L+2).NE.K-NDELTA)    GO TO 66
      LQ(KQS+L+2) = K
 
C--                          and its linear structure
 
      LF = L
   68 LQ(KQS+L+1) = LNEW
      L = LQ(KQS+L)
      IF (L.EQ.LF)                 GO TO 66
      IF (L.NE.0)                  GO TO 68
      GO TO 66
 
C------            Global update of links
 
   71 MQDVGA = 0
      MQDVWI = 0
      JQSTMV = -1
+SELF, IF=QDEBPRI.
      IF (NQLOGL.GE.1)
     + WRITE (IQLOG,9071) JQSTOR,JQDIVI,LORG,NQID
 9071 FORMAT (' MZPUSH-  Store/Div',2I3,' Relocation pass for L/ID ='
     F,I9,1X,A4)
+SELF,             IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9871)
 9871 FORMAT (' DEVZE MZPUSH,  Update by relocation pass')
+SELF.
 
      CALL MZTABM
 
      LMT  = LQMTA - 8
   74 LMT  = LMT + 8
      IF (LQ(LMT).NE.JQDIVI)       GO TO 74
      LQ(LMT+1) = 2
 
      CALL MZTABX
      LQMTE = LQMTLU
 
      LQ(LQTA-1) = LORG - NL - NQNIO - 1
      LQ(LQTA)   = LORG - NLC
      LQ(LQTA+1) = LORG + NDC + 9
      LQ(LQTA+2) = NDELTA
      LQ(LQTA+3) = 0
      LQ(LQTA+4) = LORG + ND + 9
 
      LQTE  = LQTA + 4
 
      CALL MZRELX
 
      NQDPSH(KQT+JQDIVI) = NQDPSH(KQT+JQDIVI) + 1
 
C------            Finished, reset LORG, clear new data words
 
   81 LORGP(1) = LNEW
      IF (INCND.GT.0)  CALL VZERO (IQ(KQS+LNEW+ND+1),INCND)
+SEQ, QTRACE99.
      RETURN
 
C----              Error conditions
 
   95 NQCASE = 3
      NQFATA = 1
      IQUEST(19) = K
      GO TO 92
 
   94 NQCASE = 1
      NQFATA = 2
      IQUEST(19) = L - LORG
      IQUEST(20) = LQ(KQS+L)
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 7
      IQUEST(12) = NQID
      IQUEST(13) = NS
      IQUEST(14) = NL
      IQUEST(15) = ND
      IQUEST(16) = NQNIO
      IQUEST(17) = INCNL
      IQUEST(18) = INCND
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 1
      IQUEST(11) = LORG
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK, ZTELL.
*CMZ :          17/10/97  12.42.42  by  Pavel Nevski
*CMZ :  1.30/00 19/03/97  22.28.33  by  Pavel Nevski
*-- Author :
      SUBROUTINE ZTELL (IDP,JFLP)
+CDE,QUEST.
C-    Signal trouble situation,
C-    called from the garbage collector if not enough space
C-    may be user called with IDP > 100
      write (*,101) IDP,JFLP
 101  format(1x,20('*'),' ZEBRA problem, ZTELL called with ',2i6,
     >       1x,20('*'))
      If (IDP.eq.19 .and. JFLP.eq.0) write(*,102)
 102  format(22x,'probably there is no more space on output file')
      END
 
 
 
 
 
+DECK, MZGAR1,IF=test.
*CMZ :  1.30/00 16/03/97  22.41.45  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZGAR1
 
C-    Garbage collect division JQDIVI for not enough space
C-    System called
 
+CDE, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCN, MZCT.
C--------------    End CDE                             --------------
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZGA, 4HR1   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZGAR1 /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZGAR1  ')
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT.
 
 
+SEQ, QTRACE.
+SELF, IF=QDEBUG.
      IQVREM(1,1) = IQVID(1)
      IQVREM(2,1) = IQVID(2)
+SELF.
 
C----              Construct Memory Occupation table
 
      MQDVGA = 0
      MQDVWI = 0
 
      IF (JQDIVI.LT.3)             GO TO 24
      MQDVGA = MSBIT1 (0,JQDIVI)
      JQDVM2 = JQDIVI - JQMODE
      IF (JQDVM2.EQ.JQDVSY-1)  JQDVM2=JQDVLL
      JQDVM1 = 2
      JQSTMV = JQSTOR
      IQTNMV = 0
      IF (JQSHAR.EQ.0)             GO TO 29
      MQDVGA = MSBIT1 (MQDVGA,JQSHAR)
      GO TO 29
 
   24 MQDVGA = 3
      JQSTMV = -1
   29 NQDVMV = 0
      NRESAV = NQRESV
+SELF, IF=QDEBPRI, IF=-QTRHOLL, A6M.
      IF (NQLOGL.GE.1)  WRITE (IQLOG,9028) MQTRAC(NQTRAC-1),
     +                      JQSTOR,JQDIVI,NQRESV
 9028 FORMAT (' MZGAR1-  Auto Garbage Collection called from ',A6,
     F' for Store/Div',2I3,' Free',I7)
+SELF, IF=QDEBPRI, IF=QTRHOLL, IF=-A6M.
      IF (NQLOGL.GE.1)  WRITE (IQLOG,9028) MQTRAC(NQTRAC-3),
     +                      MQTRAC(NQTRAC-2),JQSTOR,JQDIVI,NQRESV
 9028 FORMAT (' MZGAR1-  Auto Garbage Collection called from ',2A4,
     F' for Store/Div',2I3,' Free',I7)
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9829) JQDIVI,JQSHAR,NQRESV
 9829 FORMAT (1X/' DEVZE MZGAR1 entered,  JQDIVI,JQSHAR,NQRESV= ',3I8)
+SELF.
      CALL MZTABM
 
C--                Construct Link Relocation table
 
      CALL MZTABR
      NQRESV = NQRESV + NQFREE
      IF (NQRESV.GE.0)             GO TO 51
      IF (IQPART.NE.0)             GO TO 51
      IF (JQDIVI.LT.3)             GO TO 72
 
C----              Shift division if not enough space
 
      NRESV1 = LQSTA(KQT+2) - LQEND(KQT+1) - NQMINR
      NRESV1 = MIN (NRESV1,LQEND(KQT+2)-LQ2END)
 
C--                Forward division
 
      IF (JQMODE.NE.0)             GO TO 34
      IF (JQSHAR.NE.0)  THEN
          NPOSSH = NQDMAX(KQT+JQDIVI) + NQDMAX(KQT+JQDIVN)
     +             -(LQEND(KQT+JQDIVN) - LQSTA(KQT+JQDIVI))
          GO TO 36
        ELSE
          NPOSSH = LQSTA(KQT+JQDIVI) + NQDMAX(KQT+JQDIVI)
     +             - LQSTA(KQT+JQDIVN)
          GO TO 36
        ENDIF
 
C--                Reverse division
 
   34 IF (JQSHAR.NE.0)  THEN
          NPOSSH = NQDMAX(KQT+JQDIVI) + NQDMAX(KQT+JQDIVN)
     +             -(LQEND(KQT+JQDIVI) - LQSTA(KQT+JQDIVN))
        ELSE
          NPOSSH = LQEND(KQT+JQDIVN)
     +             - (LQEND(KQT+JQDIVI) - NQDMAX(KQT+JQDIVI))
        ENDIF
 
   36 NSH = (LQEND(KQT+JQDIVI)-LQSTA(KQT+JQDIVI)) / 8
      NSH = MAX (NSH,24) - NQRESV
      NSH = MIN (NSH, NPOSSH, NRESV1)
 
      IF (NSH+NQRESV.LT.0)         GO TO 72
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9836) JQDIVI,JQSHAR,NQRESV
     +,           NRESV1,NPOSSH,NSH
     +,           JQGAPM,JQGAPR
 9836 FORMAT (' DEVZE MZGAR1,  JQDIVI,JQSHAR,NQRESV=    ',3I8/
     F16X,'NRESV1,NPOSSH,NSH=',3I8/
     F16X,'JQGAPM,JQGAPR=    ',2I8)
+SELF.
      NQRESV = NQRESV + NSH
      NQDVMV = - NSH
      CALL MZTABS
 
C----              Relocate + memory move
 
   51 NWIN = NQRESV - NRESAV
+SELF, IF=QDEBPRI.
      IF (NQLOGL.GE.1)  WRITE (IQLOG,9051) NWIN,NQDVMV
 9051 FORMAT (10X,'Wins',I7,' words, Shift by',I7)
+SELF.
      CALL MZTABX
      CALL MZTABF
      IF   (NQNOOP)          68, 53, 67
   53 CALL MZGSTA (NQDGAF(KQT+1))
      CALL MZRELX
   67 CALL MZMOVE
   68 IF (NQRESV.LT.0)             GO TO 71
+SEQ, QTRACE99.
      RETURN
 
C--------          Not enough space
 
   71 IF (IQPART.NE.0)             GO TO 29
   72 IQUEST(11) = NQRESV
      IQUEST(12) = JQSTOR
      IQUEST(13) = JQDIVI
 
*     WRITE (IQLOG,9072) NQRESV
 9072 FORMAT (10X,'Not enough space, Free',I7)
 
      IF (NQPERM.NE.0)             GO TO 999
      IF (JQKIND.EQ.1)             CALL ZTELL (99,1)
 
C------            Error conditions
 
      NQCASE = 1
      NQFATA = 1
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK,zfatam.
*CMZ :  1.30/00 19/03/97  21.37.20  by  Pavel Nevski
*-- Author :    Pavel Nevski   16/03/97
      subroutine ZFATAM  (message)
      character  message*(*)
+CDE,MZCA.
+CDE,ZFATALCH.
+CDE,ZFATALRE.
      print *,' ********** ZFATAM message: ',message,' **********'
      end
+DECK,RZREAD
*CMZ :          08/08/97  16.00.05  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZREAD(V,N,IPC,IFORM)
*
************************************************************************
*
*           Read N words from input buffer into V
*
* Called by RZIN,RZINS,RZVIN
*
*  Author  : R.Brun, B.Holl
*  Written : 07.05.86
*  Last mod: 17.05.93 Change test on IFOCON(1) to .LT.0
*        PN: 08.08.97 When exchange format does not conside with native,
*            (-FQXISN selected), if last copied record comes from LROUT,
*            current IRIN value was not saved.
*
************************************************************************
+SEQ,ZUNIT,IF=-FQXISN.
+SEQ,RZCL,RZCLUN,RZCOUT,RZK.
+SEQ,MZIOC.
      DIMENSION V(*)
*
*-----------------------------------------------------------------------
*
*           Find first record
*
      NL1=LREC-IP1+1
      IF(IPC.LE.NL1)THEN
         IRS=IR1
         IS1=IP1+IPC-1
      ELSE
         NBEF=(IPC-NL1-1)/LREC
         IRS=IR2+NBEF
         IS1 =IPC-NL1-NBEF*LREC
      ENDIF
*
      LRIN=LQ(KQSP+LTOP-7)
      IF(LRIN.EQ.0)THEN
         CALL MZBOOK(JQPDVS,LRIN,LTOP,-7,'RZIN',0,0,LREC+1,2,-1)
         IQ(KQSP+LRIN-5)=IQ(KQSP+LTOP-5)
         IQ(KQSP+LTOP+KIRIN)=0
         IRIN=0
      ELSE
         IRIN=IQ(KQSP+LTOP+KIRIN)
      ENDIF
      LROUT=LQ(KQSP+LTOP-6)
      IF(LROUT.EQ.0)THEN
         IROUT=0
      ELSE
         IROUT=IQ(KQSP+LTOP+KIROUT)
      ENDIF
      IF(IRS.NE.IRIN)THEN
         IF(IRS.NE.IROUT)THEN
            CALL RZIODO(LUN,LREC,IRS,IQ(KQSP+LRIN+1),1)
            IF(IQUEST(1).NE.0)GO TO 90
            IRIN=IRS
            IQ(KQSP+LTOP+KIRIN)=IRIN
         ENDIF
      ENDIF
*
*           Read record into array V
*
+SELF,IF=-FQXISN.
      IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
         NWFOTT = N
         NWFODN = 0
         IF(IFORM.GT.0)THEN
            MFO(1) = IFORM
            MFO(2) = -1
            JFOEND = 2
         ENDIF
      ENDIF
+SELF.
      NLEFT=LREC-IS1+1
      IF(N.LE.NLEFT)THEN
         NP1=N
      ELSE
         NP1=NLEFT
      ENDIF
      IF(IRS.NE.IROUT)THEN
+SELF,IF=-FQXISN.
         IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
            NWFOAV=NP1
            CALL FZICV(IQ(KQSP+LRIN+IS1),V)
            IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
            IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LRIN+IS1+NP1-1)
            IQUEST(1)=0
         ELSE
+SELF.
            CALL UCOPY(IQ(KQSP+LRIN+IS1),V,NP1)
+SELF,IF=-FQXISN.
         ENDIF
+SELF.
      ELSE
+SELF,IF=-FQXISN.
         IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
            NWFOAV=NP1
            CALL FZICV(IQ(KQSP+LROUT+IS1),V)
            IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
            IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LROUT+IS1+NP1-1)
            IQUEST(1)=0
         ELSE
+SELF.
            CALL UCOPY(IQ(KQSP+LROUT+IS1),V,NP1)
+SELF,IF=-FQXISN.
         ENDIF
+SELF.
      ENDIF
      IF(NP1.LT.N)THEN
         NR=(N-NP1-1)/LREC+1
         IF(IRS.EQ.IR1)THEN
            IRS=IR2
         ELSE
            IRS=IRS+1
         ENDIF
         DO 60 I=1,NR
            IRin=IRS+I-1
            IF(I.NE.NR)THEN
+SELF,IF=-FQXISN.
               IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
                  CALL RZIODO(LUN,LREC,IRin,IQ(KQSP+LRIN+1),1)
                  IF(IQUEST(1).NE.0)GO TO 90
                  IQ(KQSP+LTOP+KIRIN)=IRIN
                  IF(NWFOAV.LT.0)THEN
                     CALL UCOPY2(IQ(KQSP+LRIN+1),IQ(KQSP+LRIN+2),LREC)
                     IQ(KQSP+LRIN+1)=IDOUB1
                     NWFOAV=LREC
                     CALL FZICV(IQ(KQSP+LRIN+1),V)
                     CALL UCOPY2(IQ(KQSP+LRIN+2),IQ(KQSP+LRIN+1),LREC)
                  ELSE
                     NWFOAV=LREC
                     CALL FZICV(IQ(KQSP+LRIN+1),V)
                  ENDIF
                  IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
                  IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LROUT+LREC)
                  IQUEST(1)=0
               ELSE
+SELF.
                  CALL RZIODO(LUN,LREC,IRin,V(NP1+1),1)
                  IF(IQUEST(1).NE.0)GO TO 90
+SELF,IF=-FQXISN.
               ENDIF
+SELF.
               NP1=NP1+LREC
            ELSE
               NL=N-NP1
               IF(IRIN.NE.IROUT)THEN
                  CALL RZIODO(LUN,LREC,IRIN,IQ(KQSP+LRIN+1),1)
                  IF(IQUEST(1).NE.0)GO TO 90
                  IQ(KQSP+LTOP+KIRIN)=IRIN
+SELF,IF=-FQXISN.
                  IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
                     IF(NWFOAV.LT.0)THEN
                       CALL UCOPY2(IQ(KQSP+LRIN+1),IQ(KQSP+LRIN+2),LREC)
                       IQ(KQSP+LRIN+1)=IDOUB1
                       NWFOAV=NL
                       CALL FZICV(IQ(KQSP+LRIN+1),V)
                       CALL UCOPY2(IQ(KQSP+LRIN+2),IQ(KQSP+LRIN+1),LREC)
                     ELSE
                       NWFOAV=NL
                       CALL FZICV(IQ(KQSP+LRIN+1),V)
                     ENDIF
                     IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
                     IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LRIN+NL)
                     IQUEST(1)=0
                  ELSE
+SELF.
                     CALL UCOPY(IQ(KQSP+LRIN+1),V(NP1+1),NL)
+SELF,IF=-FQXISN.
                  ENDIF
+SELF.
               ELSE
+SELF,IF=-FQXISN.
                 IF(IMODEX.GT.0.AND.IFORM.NE.1)THEN
                   IF(NWFOAV.LT.0)THEN
                     CALL UCOPY2(IQ(KQSP+LROUT+1),IQ(KQSP+LROUT+2),LREC)
                     IQ(KQSP+LROUT+1)=IDOUB1
                     NWFOAV=NL
                     CALL FZICV(IQ(KQSP+LROUT+1),V)
                     CALL UCOPY2(IQ(KQSP+LROUT+2),IQ(KQSP+LROUT+1),LREC)
                   ELSE
                     NWFOAV=NL
                     CALL FZICV(IQ(KQSP+LROUT+1),V)
                   ENDIF
                   IF(NWFOAV.GT.0.OR.IFOCON(1).LT.0)GO TO 95
                   IF(NWFOAV.LT.0)IDOUB1=IQ(KQSP+LROUT+NL)
                   IQUEST(1)=0
                 ELSE
+SELF.
                     CALL UCOPY(IQ(KQSP+LROUT+1),V(NP1+1),NL)
+SELF,IF=-FQXISN.
                  ENDIF
+SELF.
               ENDIF
            ENDIF
  60     CONTINUE
      ENDIF
  90  CONTINUE
+SELF,IF=QMVAX.
      IF(IRELAT.NE.0)UNLOCK(UNIT=LUN)
+SELF,IF=-FQXISN.
      GO TO 99
  95  IQUEST(1) =4
      IQUEST(11)=NWFOTT
      IQUEST(12)=NWFORE
      IQUEST(13)=NWFOAV
      IQUEST(14)=NWFODN
      IF(JBYT(IQ(KQSP+LTOP),15,3)-3.GE.-2) WRITE(IQLOG,1000)
 1000 FORMAT(' RZREAD. Error during conversion into native format')
+SELF.
  99  RETURN
      END
+DECK, MZLINK.
*CMZ :          20/11/97  23.58.03  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZLINK (IXSTOR,CHNAME,LAREA,LREF,LREFL)
 
C-    Set permanent link area, user called
 
+CDE, ZBCD, ZSTATE, ZUNIT.
+CDE, MQSYS.
C--------------    End CDE                             --------------
      DIMENSION    LAREA(9),LREF(9),LREFL(9),NAME(2)
      CHARACTER    *(*) CHNAME
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZLI, 4HNK   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZLINK /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZLINK  ')
+SELF.
 
+SEQ, Q$JBIT, Q$LOCF.
 
+SEQ, QTRACE.
 
+SEQ, QSTORE.
+SELF, IF=QDEBUG.
      IF (IQVSTA.NE.0)       CALL ZVAUTX
+SELF.
 
C--                Check enough space in system link-area table
 
      LSYS  = LQSYSS(KQT+1)
      NWTAB = IQ(KQS+LSYS+1)
      IF (NWTAB+5.GT.IQ(KQS+LSYS-1))  THEN
          JQDIVI = JQDVSY
          CALL MZPUSH (-7,LSYS,0,100,'I')
          LQSYSS(KQT+1) = LSYS
        ENDIF
 
C--                Construct table entry
 
      LSTO = LSYS + NWTAB
+SELF, MZLINK24.
      LOCAR = LOCF (LAREA(1)) - LQSTOR
      LOCR  = LOCF (LREF(1))  - LQSTOR
      LOCRL = LOCF (LREFL(1)) - LQSTOR
+SELF.
      NS = LOCR    - LOCAR
      NL = LOCRL+1 - LOCAR
      IF (NL.EQ.1)  THEN
          NS = NS + 1
          NL = NS
        ENDIF
 
      LOCARE = LOCAR + NL
      MODAR  = NS
 
      NAME(1) = IQBLAN
      NAME(2) = IQBLAN
      N = MIN (8, LEN(CHNAME))
      IF (N.NE.0)  CALL UCTOH (CHNAME,NAME,4,N)
 
      IQ(KQS+LSTO+1) = LOCAR
      IQ(KQS+LSTO+2) = LOCARE
      IQ(KQS+LSTO+3) = MODAR
      IQ(KQS+LSTO+4) = NAME(1)
      IQ(KQS+LSTO+5) = NAME(2)
 
C--                Range of possible values for an origin-link
 
      IQTABV(KQT+13) = MIN (IQTABV(KQT+13), LOCAR)
      IQTABV(KQT+14) = MAX (IQTABV(KQT+14), LOCARE)
 
+SELF, IF=QPRINT.
      IF (NQLOGL.GE.0)
     +WRITE (IQLOG,9039) NAME,JQSTOR,NL,NS
 9039 FORMAT (1X/' MZLINK.  Initialize Link Area  ',2A4,'  for Store'
     F,I3,' NL/NS=',2I6)
 
+SELF, IF=QDEBUG.
 
C----              Check valid parameters
 
      IF (LOCR .LT.LOCAR)          GO TO 91
      IF (LOCRL.LT.LOCAR)          GO TO 91
      IF (NL.LT.NS)                GO TO 91
 
C------            Check overlap with existing stores
 
      KLA = KQS + LOCAR
      KLE = KQS + LOCARE
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9841) 4*LQSTOR, 4*LQATAB, 4*LQBTIS, 4*KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
 9841 FORMAT (1X/' DEVZE MZLINK.  ',17X,'LQSTOR',17X,'LQATAB',
     F17X,'LQBTIS',20X,'KLA'
+SELF, IF=QDEVZE, IF=-HEX.
     F/10X,'4* OCT',4O23/13X,'OCT',4O23/13X,'DEC',4I23)
+SELF, IF=QDEVZE, IF=HEX.
     F/10X,'4* HEX',4Z23/13X,'HEX',4Z23/13X,'DEC',4I23)
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)  WRITE (IQLOG,9842) KLA,KLE
 9842 FORMAT (16X,' KLA/KLE=',2I10)
+SELF, IF=QDEBUG.
 
      DO 47  JSTO=1,NQSTOR+1
      IF (NQALLO(JSTO).NE.0)       GO TO 47
      JT  = NQOFFT(JSTO)
      JS  = NQOFFS(JSTO)
      JSA = JS  - IQTABV(JT+2) + 1
      JSE = JS  + LQSTA(JT+21) + 1
      JTA = JT  + LQBTIS       + 1
      JTE = JTA + NQTSYS
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9843) JTA,JTE,  JSA,JSE
 9843 FORMAT (16X,' JTA/JTE=',2I10,'  JSA/JSE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JTA .AND. KLA.LT.JTE)    GO TO 92
      IF (KLE.GT.JSA .AND. KLA.LT.JSE)    THEN
         IF (NQLOGL.GE.0) WRITE (IQLOG,9139) CHNAME,JSTO
 9139    FORMAT (' Link area ',a,' overlaps with store #',i3)
      ENDIF
 
C--                Check overlap with existing link areas
 
      L = JS+ LQSYSS(JT+1)
      N = IQ(L+1)
      IF (N.LT.12)                 GO TO 47
 
      DO 44  J=12,N,5
      JLA = JS + IQ(L+J)
      JLE = JS + IQ(L+J+1)
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9844) JLA,JLE
 9844 FORMAT (16X,' JLA/JLE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JLA .AND. KLA.LT.JLE)    GO TO 94
   44 CONTINUE
   47 CONTINUE
+SELF.
 
   61 IQ(KQS+LSYS+1) = NWTAB + 5
      CALL VZERO (LAREA,NL)
+SEQ, QTRACE99.
      RETURN
 
C------            Error conditions
 
   94 NQCASE = 1
      NQFATA = 3
      IQUEST(21) = IQ(L+J+3)
      IQUEST(22) = IQ(L+J+4)
      IQUEST(23) = JLA + LQSTOR
 
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 3
      IQUEST(18) = JSTO - 1
      IQUEST(19) = NQPNAM(JT+1)
      IQUEST(20) = NQPNAM(JT+2)
 
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 7
      IQUEST(11) = NAME(1)
      IQUEST(12) = NAME(2)
      IQUEST(13) = LOCAR + LQSTOR
      IQUEST(14) = LOCR  + LQSTOR
      IQUEST(15) = LOCRL + LQSTOR
      IQUEST(16) = NS
      IQUEST(17) = NL
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZLINT.
*CMZ :          21/11/97  17.09.55  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZLINT (IXSTOR,CHNAME,LAREA,LREF,LREFL)
 
C-    Set permanent link area, user called
 
+CDE, ZBCD, ZSTATE, ZUNIT.
+CDE, MQSYS.
C--------------    End CDE                             --------------
      DIMENSION    LAREA(9),LREF(9),LREFL(9),NAME(2)
      CHARACTER    *(*) CHNAME
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZLI, 4HNT   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZLINT /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZLINT  ')
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT, Q$LOCF.
 
 
+SEQ, QTRACE.
 
+SEQ, QSTORE.
+SELF, IF=QDEBUG.
      IF (IQVSTA.NE.0)       CALL ZVAUTX
+SELF.
 
      LSYS  = LQSYSS(KQT+1)
      NWTAB = IQ(KQS+LSYS+1)
+SELF, MZLINT14.
      LOCAR = LOCF (LAREA(1)) - LQSTOR
+SELF.
      JDES = LAREA(2)
      IF (JDES.LT.11)              GO TO 21
      IF (JDES.GE.NWTAB)           GO TO 21
      LSTO = LSYS + JDES
      IF (IQ(KQS+LSTO+1).NE.LOCAR)    GO TO 21
      NL = IQ(KQS+LSTO+2) - LOCAR
+SELF, IF=QDEBPRI.
      IF (NQLOGL.LT.2)             GO TO 19
      WRITE (IQLOG,9018) IQ(KQS+LSTO+4),IQ(KQS+LSTO+5),JQSTOR
 9018 FORMAT (1X/' MZLINT-  Re-Init of Link Area ',2A4,'  for Store',I3)
+SELF.
 
C--                Set link area active
 
   19 LAREA(1) = 7
      CALL VZERO (LAREA(3),NL-2)
+SEQ, QTRACE99.
      RETURN
 
C------            Initialize for the first time
 
   21 IF (NWTAB+5.GT.IQ(KQS+LSYS-1))  THEN
          JQDIVI = JQDVSY
          CALL MZPUSH (-7,LSYS,0,100,'I')
          LQSYSS(KQT+1) = LSYS
        ENDIF
 
      LSTO = LSYS + NWTAB
+SELF, MZLINT24.
      LOCR  = LOCF (LREF(1))  - LQSTOR
      LOCRL = LOCF (LREFL(1)) - LQSTOR
+SELF.
      NS = LOCR    - LOCAR
      NL = LOCRL+1 - LOCAR
      IF (NL.EQ.1)  THEN
          NS = NS + 1
          NL = NS
        ENDIF
 
      LOCARE = LOCAR + NL
      MODAR  = MSBIT1 (NS,31)
 
      NAME(1) = IQBLAN
      NAME(2) = IQBLAN
      N = MIN (8, LEN(CHNAME))
      IF (N.NE.0)  CALL UCTOH (CHNAME,NAME,4,N)
 
      IQ(KQS+LSTO+1) = LOCAR
      IQ(KQS+LSTO+2) = LOCARE
      IQ(KQS+LSTO+3) = MODAR
      IQ(KQS+LSTO+4) = NAME(1)
      IQ(KQS+LSTO+5) = NAME(2)
 
C--                Range of possible values for an origin-link
 
      IQTABV(KQT+13) = MIN (IQTABV(KQT+13), LOCAR+2)
      IQTABV(KQT+14) = MAX (IQTABV(KQT+14), LOCARE)
 
      NSM2 = NS - 2
      NLM2 = NL - 2
+SELF, IF=QPRINT.
      IF (NQLOGL.GE.1)
     +WRITE (IQLOG,9039) NAME,JQSTOR,NLM2,NSM2
 9039 FORMAT (1X/' MZLINT.  Initialize Link Area  ',2A4,'  for Store'
     F,I3,' NL/NS=',2I6)
 
+SELF, IF=QDEBUG.
 
C----              Check valid parameters
 
      IF (LOCR .LT.LOCAR)          GO TO 91
      IF (LOCRL.LT.LOCAR)          GO TO 91
      IF (NL.LT.NS)                GO TO 91
 
C------            Check overlap with existing stores
 
      KLA = KQS + LOCAR
      KLE = KQS + LOCARE
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)
     +WRITE (IQLOG,9841) 4*LQSTOR, 4*LQATAB, 4*LQBTIS, 4*KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
     +,           LQSTOR,LQATAB, LQBTIS,KLA
 9841 FORMAT (1X/' DEVZE MZLINT.  ',17X,'LQSTOR',17X,'LQATAB',
     F17X,'LQBTIS',20X,'KLA'
+SELF, IF=QDEVZE, IF=-HEX.
     F/10X,'4* OCT',4O23/13X,'OCT',4O23/13X,'DEC',4I23)
+SELF, IF=QDEVZE, IF=HEX.
     F/10X,'4* HEX',4Z23/13X,'HEX',4Z23/13X,'DEC',4I23)
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9842) KLA,KLE
 9842 FORMAT (16X,' KLA/KLE=',2I10)
+SELF, IF=QDEBUG.
 
      DO 47  JSTO=1,NQSTOR+1
      IF (NQALLO(JSTO).NE.0)       GO TO 47
      JT  = NQOFFT(JSTO)
      JS  = NQOFFS(JSTO)
      JSA = JS  - IQTABV(JT+2) + 1
      JSE = JS  + LQSTA(JT+21) + 1
      JTA = JT  + LQBTIS       + 1
      JTE = JTA + NQTSYS
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9843) JTA,JTE,  JSA,JSE
 9843 FORMAT (16X,' JTA/JTE=',2I10,'  JSA/JSE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JTA .AND. KLA.LT.JTE)    GO TO 92
      IF (KLE.GT.JSA .AND. KLA.LT.JSE)    THEN
         IF (NQLOGL.GE.0) WRITE (IQLOG,9139) CHNAME,JSTO
 9139    FORMAT (' Link area ',a,' overlaps with store #',i3)
      ENDIF
 
C--                Check overlap with existing link areas
 
      L = JS+ LQSYSS(JT+1)
      N = IQ(L+1)
      IF (N.LT.12)                 GO TO 47
 
      DO 44  J=12,N,5
      JLA = JS + IQ(L+J)
      JLE = JS + IQ(L+J+1)
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.7)   WRITE (IQLOG,9844) JLA,JLE
 9844 FORMAT (16X,' JLA/JLE=',2I10)
+SELF, IF=QDEBUG.
 
      IF (KLE.GT.JLA .AND. KLA.LT.JLE)    GO TO 94
   44 CONTINUE
   47 CONTINUE
+SELF.
 
C--                Success, register new link area
 
      LAREA(2) = NWTAB
      IQ(KQS+LSYS+1) = NWTAB + 5
      GO TO 19
 
C------            Error conditions
 
   94 NQCASE = 1
      NQFATA = 4
      IQUEST(21) = IQ(L+J+3)
      IQUEST(22) = IQ(L+J+4)
      IQUEST(23) = JLA + LQSTOR
      IQUEST(24) = LAREA(2)
 
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 3
      IQUEST(18) = JSTO - 1
      IQUEST(19) = NQPNAM(JT+1)
      IQUEST(20) = NQPNAM(JT+2)
 
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 7
      IQUEST(11) = NAME(1)
      IQUEST(12) = NAME(2)
      IQUEST(13) = LOCAR + LQSTOR
      IQUEST(14) = LOCR  + LQSTOR
      IQUEST(15) = LOCRL + LQSTOR
      IQUEST(16) = NSM2
      IQUEST(17) = NLM2
+SEQ, QTOFATAL.
*     prevent warning only
      L = MSBIT0 (NS,31)
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZSTOR.
*CMZ :          13/12/97  06.42.18  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZSTOR (IXSTOR,CHNAME,CHOPT
     +,                  IFENCE,LV,LLR,LLD,LIMIT,LAST)
 
C-    Initialize new Zebra store region, user called
 
+CDE, ZBCD, ZMACH, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCWK.
C--------------    End CDE                             --------------
      DIMENSION    IXSTOR(9),IFENCE(9)
      DIMENSION    LV(9),LLR(9),LLD(9),LIMIT(9),LAST(9)
      DIMENSION    MMSYSL(5), NAMELA(2), NAMESY(2)
      CHARACTER    *(*) CHNAME,CHOPT
+SELF, IF=QMVDS.
      SAVE         MMSYSL, NAMELA, NAMESY, NAMWSP, NAMEDV
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZST, 4HOR   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZSTOR /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZSTOR  ')
+SELF, IF=QHOLL.
      DATA  MMSYSL / 4HSYSL,0,0,101,2/
      DATA  NAMELA / 4Hsyst, 4Hem   /
      DATA  NAMESY / 4Hsyst, 4Hem   /
      DATA  NAMWSP / 4Hqwsp /
      DATA  NAMEDV / 4HQDIV /
+SELF, IF=-QHOLL.
      DATA  MMSYSL / 0,0,0,101,2/
+SELF.
 
+SEQ, Q$JBIT, Q$SBIT, Q$SHIFT, Q$LOCF.
 
 
C--                Clear Zebra tables on first entry
 
      IF (NQSTOR.NE.-1)            GO TO 13
      CALL VZERO (NQOFFT,32)
      LQATAB = LOCF (IQTABV(1)) - 1
      LQASTO = LOCF (LQ(1)) - 1
      LQBTIS = LQATAB - LQASTO
      LQWKTB = LOCF(IQWKTB(1)) - LQASTO
      LQWKFZ = LOCF(IQWKFZ(1)) - LQASTO
      NQTSYS = LOCF(IQDN2(20)) - LQATAB
      NQWKTB = NQWKTT
 
C-      KQFT=342 relies on LQFSTA(1) to be LQSTA(1+342) in /MZCC/
      KQFT = 342
+SELF, IF=QPRINT.
      IF (NQLOGD.GE.-1)
     +WRITE (IQLOG,9011) LQATAB,LQATAB
 9011 FORMAT (1X/' MZSTOR.  ZEBRA table base TAB(0) in /MZCC/ at adr'
+SELF, IF=QPRINT, IF=-HEX.
     F,I12,1X,O11,' OCT')
+SELF, IF=QPRINT, IF=HEX, IF=-B64.
     F,I12,1X,Z11,' HEX')
+SELF, IF=QPRINT, IF=HEX, IF=B64.
     F,I12,1X,Z16,' HEX')
+SELF.
   13 CONTINUE
+SELF, IF=-QHOLL.
      CALL UCTOH ('SYSL',    MMSYSL, 4,4)
      CALL UCTOH ('system  ',NAMELA, 4,8)
      CALL UCTOH ('system  ',NAMESY, 4,8)
      CALL UCTOH ('qwsp'    ,NAMWSP, 4,4)
      CALL UCTOH ('QDIV'    ,NAMEDV, 4,4)
+SELF.
 
+SEQ, QTRACE.
 
      CALL UOPTC (CHOPT,'Q:',IQUEST)
      LOGQ   = IQUEST(1)
      IFLSPL = IQUEST(2)
 
      JQSTOR = NQSTOR + 1
      CALL VZERO (KQT,27)
 
C--                Calculate store off-set
 
      LQSTOR = LOCF(LV(1)) - 1
      KQS    = LQSTOR - LQASTO
 
      NFEND  = (LQSTOR+1) - LOCF(IFENCE(1))
      NQFEND = NFEND
 
C--                Printing name of store
 
      NQSNAM(1) = IQBLAN
      NQSNAM(2) = IQBLAN
      N = MIN (8, LEN(CHNAME))
      IF (N.NE.0)  CALL UCTOH (CHNAME,NQSNAM,4,N)
 
C--                Set log level
 
      NQLOGL = NQLOGD
      IF (LOGQ.NE.0)  NQLOGL=-2
 
C--                Permanent links et al.
 
      NQSTRU = LOCF(LLR(1)) - (LQSTOR+1)
      NQREF  = LOCF(LLD(1)) - (LQSTOR+1)
      NQLINK = NQREF
      LQ2END = LOCF(LIMIT(1)) - LQSTOR
      NDATAT = LOCF(LAST(1))  - LQSTOR
 
C--                Calculate table off-set
 
      NDATA = NDATAT
      LOCT  = LQATAB
      IF (JQSTOR.NE.0)  THEN
          NDATA = NDATA  - NQTSYS
          NQSNAM(6) = NDATA
          LOCT  = LQSTOR + NDATA
          KQT   = LOCT   - LQATAB
          NDATA = NDATA - 4
          CALL VFILL (LQ(KQS+NDATA),10,IQNIL)
        ENDIF
 
+SELF, IF=QPRINT.
      IF (NQLOGL.GE.-1)
     +WRITE (IQLOG,9021) JQSTOR,NQSNAM(1),NQSNAM(2)
     +,                  LQSTOR,LOCT,LQSTOR,LOCT,KQS,KQT,KQS,KQT
     +,                  NQSTRU,NQREF,LQ2END,NDATAT,NFEND
 9021 FORMAT (1X/' MZSTOR.  Initialize Store',I3,'  in ',2A4,
     F/10X,'with Store/Table at absolute adrs',2I12
+SELF, IF=QPRINT, IF=-HEX.
     F/40X,'OCT',2(1X,O11)/40X,'OCT',2(1X,O11)
+SELF, IF=QPRINT, IF=HEX, IF=-B64.
     F/40X,'HEX',2(1X,Z11)/40X,'HEX',2(1X,Z11)
+SELF, IF=QPRINT, IF=HEX, IF=B64.
     F/30X,'HEX',2(1X,Z16)/30X,'HEX',2(1X,Z16)
+SELF, IF=QPRINT.
     F/30X,'relative adrs',2I12
     F/10X,'with',I6,' Str. in',I6,' Links in',I7,' Low words in'
     F,I8,' words.'
     F/10X,'This store has a fence of',I5,' words.')
+SELF.
 
C--                Set minimum sizes
 
      NSYS   =  400
      NQMINR =   40
      NWF    = 2000
      IF (JQSTOR.EQ.0)  NQMINR=164
 
C--                Check parameters valid
 
      IF (NQSTRU.LT.0)               GO TO 91
      IF (NQREF .LT.NQSTRU)          GO TO 91
      IF (NDATAT.LT.NQLINK+NWF)      GO TO 91
      IF (LQ2END.LT.NQLINK+NQMINR)   GO TO 91
      IF (NFEND .LT.1)               GO TO 92
      IF (NFEND .GE.1001)            GO TO 92
      IF (IFLSPL.EQ.1)  THEN
          IF (JQSTOR.EQ.0)           GO TO 96
          GO TO 39
        ENDIF
 
+SELF,             IF=-QSINGLST, IF=QDEBUG.
C--                Check overlapping stores
 
      IF (JQSTOR.EQ.0)             GO TO 41
      KSA = KQS - NQFEND
      KSE = KQS + NDATAT
 
      DO 36  JSTO=1,JQSTOR
      JT  = NQOFFT(JSTO)
      JS  = NQOFFS(JSTO)
      JSA = JS  - IQTABV(JT+2)
      JSE = JS  + LQSTA(JT+21)
      JTA = JT  + LQBTIS
      JTE = JTA + NQTSYS
 
      IF (KSE.GT.JTA .AND. KSA.LT.JTE     .or.
     >    KSE.GT.JSA .AND. KSA.LT.JSE)    THEN
         IF (NQLOGL.GE.0) WRITE (IQLOG,9139)
     >                    CHNAME,NQPNAM(JT+1), NQPNAM(JT+2)
 9139    FORMAT (' store ',a,' overlaps with store ',2a4)
      ENDIF
 
   36 CONTINUE
+SELF.
   39 IF (JQSTOR.GE.16)            GO TO 93
 
C----              Initialize divisions 1 + 2 + system
 
   41 NQOFFT(JQSTOR+1) = KQT
      NQOFFS(JQSTOR+1) = KQS
      NQALLO(JQSTOR+1) = IFLSPL
      CALL VZERO (IQTABV(KQT+1),NQTSYS)
      CALL VBLANK (IQDN1(KQT+1), 40)
      NQSTOR = NQSTOR + 1
 
      LQ(KQS+NDATA-1) = IQNIL
      LQ(KQS+NDATA)   = IQNIL
 
      NDATA = NDATA - 2
      LQSTA(KQT+21) = NDATA
 
      JQDVLL = 2
      JQDVSY = 20
      LQSTA(KQT+20)  = NDATA
      LQEND(KQT+20)  = NDATA
      NQDMAX(KQT+20) = NDATA
      IQMODE(KQT+20) = 1
      IQKIND(KQT+20) = ISHFTL (1, 23)
      IQRNO(KQT+20)  = 9437183
      IQDN1(KQT+20)  = NAMESY(1)
      IQDN2(KQT+20)  = NAMESY(2)
 
      LQSTA(KQT+2)  = NDATA - NSYS
      LQEND(KQT+2)  = LQSTA(KQT+2)
      NQDMAX(KQT+2) = NDATA
      IQMODE(KQT+2) = 1
      IQKIND(KQT+2) = MSBIT1 (2, 21)
      IQRCU(KQT+2)  = 3
      IQRTO(KQT+2)  = ISHFTL (3,20)
      IQRNO(KQT+2)  = 9437183
      IQDN1(KQT+2)  = NAMEDV
      IQDN2(KQT+2)  = IQNUM(3)
 
      LQSTA(KQT+1)  = NQLINK + 1
      LQEND(KQT+1)  = LQSTA(KQT+1)
      NQDMAX(KQT+1) = NDATA
      IQKIND(KQT+1) = MSBIT1 (1, 21)
      IQRCU(KQT+1)  = 3
      IQRTO(KQT+1)  = ISHFTL (3,20)
      IQRNO(KQT+1)  = 9437183
      IQDN1(KQT+1)  = NAMEDV
      IQDN2(KQT+1)  = IQNUM(2)
 
      CALL UCOPY (IQCUR,IQTABV(KQT+1),16)
      CALL VFILL (IFENCE,NFEND,IQNIL)
      IF (NQLINK.NE.0)  CALL VZERO (LV,NQLINK)
 
C--                Return IXSTOR
 
      IF (JQSTOR.EQ.0)  THEN
          IF (IXSTOR(1).EQ.0)      GO TO 71
        ENDIF
      IDN = ISHFTL (JQSTOR,26)
      IXSTOR(1) = IDN
 
C----              Create system link table bank
 
   71 JQDIVI = JQDVSY
      CALL MZLIFT (-7,LSYS,0,2,MMSYSL,0)
      LQSYSS(KQT+1) = LSYS
 
      NALL   = LOCF(IQTDUM(1)) - LOCF(LQSYSS(1))
      NSTR   = LOCF(LQSYSR(1)) - LOCF(LQSYSS(1))
 
      LOCAR  = LOCF (LQSYSS(KQT+1)) - LQSTOR
      LOCARE = LOCAR + NALL
 
C--                Working space
 
      IQ(KQS+LSYS+1) = 11
      IQ(KQS+LSYS+2) = 1
      IQ(KQS+LSYS+3) = 1 + NQLINK
      IQ(KQS+LSYS+4) = NQSTRU
      IQ(KQS+LSYS+5) = NAMWSP
      IQ(KQS+LSYS+6) = IQBLAN
 
C--                System link area
 
      IQ(KQS+LSYS+7) = LOCAR
      IQ(KQS+LSYS+8) = LOCARE
      IQ(KQS+LSYS+9) = NSTR
      IQ(KQS+LSYS+10)= NAMELA(1)
      IQ(KQS+LSYS+11)= NAMELA(2)
 
C--                Range of possible values for an origin-link
 
      IQTABV(KQT+13) = MIN (1, LOCAR)
      IQTABV(KQT+14) = MAX (LQSTA(KQT+21), LOCARE)
 
+SEQ, QTRACE99.
      RETURN
 
C------            Error conditions
 
   96 NQCASE = NQCASE + 3
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 9
      IQUEST(11) = NQSNAM(1)
      IQUEST(12) = NQSNAM(2)
      IQUEST(13) = NFEND
      IQUEST(14) = NQSTRU
      IQUEST(15) = NQLINK
      IQUEST(16) = LQ2END
      IQUEST(17) = NDATAT
      IQUEST(18) = NQMINR
      IQUEST(19) = NWF
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZRELB.
*CMZ :          01/12/97  23.30.19  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZRELB
 
C-    Relocator for links in banks
 
+CDE, ZSTATE, ZUNIT.
+CDE, MQSYS, MZCN, MZCT.
C--------------    End CDE                             --------------
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZRE, 4HLB   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZRELB /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZRELB  ')
+SELF.
 
+SEQ, Q$JBIT.
 
 
+SEQ, QTRACE.
 
      LFIXLO = LQ(LQTA-1)
      LFIXRE = LQ(LQTA)
      LFIXHI = LQ(LQTE)
      JHIGO  = (LQTE-LQTA) / 4
      NENTR  = JHIGO - 1
 
      IF (NENTR.EQ.0)  THEN
          LADTB1 = LQ(LQTA+1)
          NRLTB2 = LQ(LQTA+2)
          IFLTB3 = LQ(LQTA+3)
        ENDIF
 
      LMRNX  = LQMTA
   12 LMR    = LMRNX
      IF (LMR.GE.LQMTE)            GO TO  999
      LMRNX  = LMRNX + 8
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)
     +WRITE (IQLOG,9813) (LQ(J+LMR-1),J=1,8)
 9813 FORMAT (1X/' DEVZE MZRELB.  DIV, ACT,   NSH, LF, LL, LTA, LTB'
     F,', NFREE'/14X,2I5,6I7)
+SELF.
 
      IACT   = LQ(LMR+1)
      IF (IACT.LE.0)               GO TO 12
      IF (IACT.EQ.4)               GO TO 12
      LSTOP  = LQ(LMR+4)
      IF (IACT.EQ.3)               GO TO 14
      LN     = LQ(LMR+3)
      LDEAD  = LSTOP
      GO TO 19
 
   14 LSEC   = LQRTA + LQ(LMR+5) - 4
 
C------            Next bank,  check if dead group
 
   16 LSEC   = LSEC + 4
      LNX    = LQ(LSEC)
      LDEAD  = LQ(LSEC+1)
 
   17 LN = LNX
      IF (LN.GE.LSTOP)             GO TO 12
      IF (LN.EQ.LDEAD)             GO TO 16
 
C--                Next bank,  alive
 
   19 CONTINUE
 
+SELF, IF=QDEBUG.
      CALL MZCHLN (-7,LN)
      IF (IQFOUL.NE.0)             GO TO 91
      LNX = IQNX
      IF (IQND.LT.0)               GO TO 17
      LS  = IQLS
      LO  = LS + 2
      LX  = LS + 3
      L2  = LS - IQNS
      L1  = LS - IQNL
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9819) LN, IQID,IQNL,IQNS,IQND
 9819 FORMAT (1X/' DEVZE MZRELB.  Do bank at LN =',I7
     F,'  ID,NL,NS,ND= ',A4,3I7)
+SELF, IF=-QDEBUG.
      NST = JBYT (LQ(KQS+LN),1,16) - 11
      IF (NST.LT.0)  THEN
          LNX = LN + NST + 11
          GO TO 17
        ELSE
          LS  = LN + NST
          LO  = LS + 2
          LX  = LS + 3
          L2  = LS - IQ(KQS+LS-2)
          L1  = LS - IQ(KQS+LS-3)
          LNX = LS + IQ(KQS+LS-1) + 9
        ENDIF
+SELF.
      IF   (NENTR)           66, 46, 26
 
C--------------    2 OR MORE RELOCATION INTERVALS       -------------
 
C----              Next link
 
   23 IF (L1.EQ.LO) GO TO 25
   24 LQ(KQS+L1)= 0
 
   25 L1 = L1 + 1
      IF (L1.EQ.LX)                GO TO 17
   26 LFIRST= LQ(KQS+L1)
   27 LINK  = LQ(KQS+L1)
      IF (LINK.EQ.0)               GO TO 25
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9827) LINK,L1
 9827 FORMAT (16X,'Link =',I7,' from L1 =',I7)
+SELF.
      IF (IQFLIO.EQ.0)  THEN
          IF (LINK.LT.LFIXLO)      GO TO 25
          IF (LINK.GE.LFIXHI)      GO TO 25
          IF (LINK.LT.LFIXRE)      GO TO 23
        ELSE
          IF (LINK.LT.LFIXRE)      GO TO 24
          IF (LINK.GE.LFIXHI)      GO TO 24
        ENDIF
 
C--                Binary search in relocator table
 
      JLOW = 0
      JHI  = JHIGO
 
   29 JEX = (JHI+JLOW) / 2
      IF (JEX.EQ.JLOW)             GO TO 31
      IF (LINK.GE.LQ(LQTA+4*JEX))  GO TO 30
      JHI  = JEX
      GO TO 29
 
   30 JLOW = JEX
      GO TO 29
 
C--                Relocate
 
   31 JTB = LQTA + 4*JLOW
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)
     +WRITE (IQLOG,9831) JLOW, (LQ(JTB+J-1),J=1,4)
 9831 FORMAT (50X,'Entry',I5,',',4I7)
+SELF.
      IF (LINK.GE.LQ(JTB+1))             GO TO 33
      LQ(KQS+L1) = LINK + LQ(JTB+2)
      GO TO 25
 
C----              Link into dead area
 
   33 IF   (LQ(JTB+3))       25, 24, 34
 
C--                Bridge structural link
 
   34 IF (L1.LT.L2)                GO TO 24
      IF (LS+1-L1)           36, 24, 35
   35 CONTINUE
 
+SELF, IF=QDEBUG.
      CALL MZCHLS (-7,LINK)
      IF (IQFOUL.NE.0)             GO TO 92
+SELF.
      LINK = LQ(KQS+LINK)
      LQ(KQS+L1) = LINK
      IF (LINK.NE.LFIRST)          GO TO 27
      GO TO 24
 
C--                Reverse bridging of s-link
 
   36 LINK = LQ(KQS+LINK+2)
      LQ(KQS+L1) = LINK
      GO TO 27
 
C--------------    1 RELOCATION INTERVAL ONLY           -------------
 
C----              Next link
 
   43 IF (L1.EQ.LO) GO TO 45
   44 LQ(KQS+L1)= 0
 
   45 L1 = L1 + 1
      IF (L1.EQ.LX)                GO TO 17
   46 LFIRST= LQ(KQS+L1)
   47 LINK  = LQ(KQS+L1)
      IF (LINK.EQ.0)               GO TO 45
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9827) LINK,L1
+SELF.
      IF (IQFLIO.EQ.0)  THEN
          IF (LINK.LT.LFIXLO)      GO TO 45
          IF (LINK.GE.LFIXHI)      GO TO 45
          IF (LINK.LT.LFIXRE)      GO TO 43
          IF (LINK.GE.LADTB1)      GO TO 53
        ELSE
          IF (LINK.LT.LFIXRE)      GO TO 44
          IF (LINK.GE.LADTB1)      GO TO 44
        ENDIF
 
C--                Relocate
 
      LQ(KQS+L1) = LINK + NRLTB2
      GO TO 45
 
C----              Link into dead area
 
   53 IF   (IFLTB3)           45, 44, 54
 
C--                Bridge structural link
 
   54 IF (L1.LT.L2)                GO TO 44
      IF (LS+1-L1)           56, 44, 55
   55 CONTINUE
 
+SELF, IF=QDEBUG.
      CALL MZCHLS (-7,LINK)
      IF (IQFOUL.NE.0)             GO TO 92
+SELF.
      LINK = LQ(KQS+LINK)
      LQ(KQS+L1) = LINK
      IF (LINK.NE.LFIRST)          GO TO 47
      GO TO 44
 
C--                Reverse bridging of s-link
 
   56 LINK = LQ(KQS+LINK+2)
      LQ(KQS+L1) = LINK
      GO TO 47
 
C--------------    NO RELOCATION INTERVAL               -------------
 
C----              Next link
 
   64 LQ(KQS+L1)= 0
 
   65 L1 = L1 + 1
      IF (L1.EQ.LX)                GO TO 17
   66 LINK  = LQ(KQS+L1)
      IF (LINK.EQ.0)               GO TO 65
 
+SELF, IF=QDEVZE.
      IF (NQDEVZ.GE.11)   WRITE (IQLOG,9827) LINK,L1
+SELF.
      IF (LINK.LT.LFIXLO)          GO TO 65
      IF (LINK.GE.LFIXHI)          GO TO 65
      GO TO 64
 
C------            Error conditions
+SELF,  IF=QDEBUG.
   92 NQCASE = 1
      NQFATA = 2
      LN     = LS
      IQUEST(12) = L1
      IQUEST(13) = LINK
   91 NQCASE = NQCASE + 1
      NQFATA = NQFATA + 1
      IQUEST(11) = LN
      IF (IQFLIO.NE.0)             GO TO 98
+SEQ, QTOFATAL.
 
   98 IQUEST(9) = NQCASE
      IQUEST(10)= NQFATA
      NQCASE = 0
      NQFATA = 0
      IQFLIO = -7
+SELF.
+SEQ, QTRACE99.
      RETURN
      END
+SEQ, QCARDL.      ==================================================
+DECK, MZPAW.
*CMZ :          06/12/97  11.36.55  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZPAW (NWORDS,CHOPT)
 
C-    Initialize the store /PAWC/ of at least 10000 words;
 
      COMMON /PAWC/  NWPAW,IXPAWC,IHBOOK,IXHIGZ,IXKU,IFENCE(5)
     +,              LMAIN, IPAW(9989)
C--------------------------------------------------------------------
      CHARACTER*(*) CHOPT
 
      NW   = abs (NWORDS)
      NW   = max (NW,100000)
      I1   = LOCF(IPAW)
      I2   = memget (NW*4+1000)/4
      LL   = max    (I2-I1,0)
      NW   = NW + LL
      KWW  = LL + 100
C
      CALL MZSTOR (IXPAWC,'/PAWC/',' ',IFENCE,LMAIN,IPAW,IPAW,
     +                                 IPAW(KWW+100),IPAW(NW-100))
      CALL MZWORK (IXPAWC,IPAW(9989),IPAW(KWW),5)
      CALL MZWORK (IXPAWC,IPAW(50),IPAW(5000),0)
c
      NWPAW  = NW
      IHBOOK = 0
      IXHIGZ = 0
      IXKU   = 0
      RETURN
      END
+DECK,mzchnb.
*CMZ :          05/12/97  19.43.57  by  Pavel Nevski
*-- Author :    Pavel Nevski   05/12/97
 
      SUBROUTINE MZCHNB (LIX)
      END
+DECK, MZWORK.
*CMZ :          06/12/97  11.43.18  by  Pavel Nevski
*-- Author :
      SUBROUTINE MZWORK (IXSTOR,DFIRST,DLAST,IFLAGP)
 
C-    Allocate working space, user called
 
C-    IFLAG = -1  reset wsp empty
C-             0  new wsp
C-             1  vary both limits, keep common links
C-             2  vary  only DLAST  limit, keep links and common data
C-             3  reset only DFIRST limit, zero all links
C-             4  vary  only DFIRST limit, keep common links
C-            >5  allocate reserve between WS and DIV1
+CDE, ZMACH, ZSTATE, ZUNIT.
+CDE, MQSYS.
      COMMON /MZCDN/ LQRSTA(20),LQREND(20)
C--------------    End CDE                             --------------
      INTEGER      DFIRST(9), DLAST(9), IFLAGP(9)
+SELF, IF=QTRHOLL, IF=-A6M.
      DIMENSION    NAMESR(2)
      DATA  NAMESR / 4HMZWO, 4HRK   /
+SELF, IF=QTRHOLL, IF=A6M.
      DATA  NAMESR / 6HMZWORK /
+SELF, IF=-QTRHOLL.
      CHARACTER    NAMESR*8
      PARAMETER   (NAMESR = 'MZWORK  ')
+SELF.
 
+SEQ, Q$JBIT, Q$LOCF.
+SEQ, QTRACE.
+SEQ, QSTORE.
 
      IFLAG = IFLAGP(1)
      JSTO  = JBYT (IXSTOR,27,4)
      IF (JSTO.GT.NQSTOR) GO TO 91
 
C----              Reset empty working space
 
      NEWL  = NQREF
      NEWD  = NQREF
      IF (IFLAG.LT.0)              GO TO 71
      NEWL  = LOCF (DFIRST(1)) - (LQSTOR+1)
      NEWD  = LOCF (DLAST(1))  -  LQSTOR
 
      IF (IFLAG.GE.5)              then
         LQRSTA(JSTO+1)=NEWL
         LQREND(JSTO+1)=NEWD
         GO TO 999
      endif
 
      IF (IFLAG.GE.3)  NEWD = LQSTA(1) - 1
      IF (IFLAG.EQ.2)  NEWL = NQLINK
 
C----              Check valid parameters
 
      IF (NEWL.LT.NQREF)           GO TO 92
      IF (NEWD.LT.NEWL)            GO TO 93
      IF (IFLAG.GE.3)              GO TO 31
      IF (LQRSTA(JSTO+1).EQ.0) then
         IF (NEWD.GE.LQEND(KQT+2)) GO TO 94
      ELSE
         IF (NEWD.GE.LQRSTA(JSTO+1)) GO TO 94
      ENDIF
 
C--                Check garbage collection
 
      NQRESV = LQSTA(KQT+2) - NQMINR - NEWD
      IF (NQRESV.GT.0)             GO TO 31
      print *,' negative NQRESV force garbage collection = ',NQRESV
      LQEND(KQT+1) = LQSTA(KQT+1)
      JQDIVI = 2
      CALL MZRESV
      CALL MZGAR1
      NQRESV = LQSTA(KQT+2) - NQMINR - NEWD
      IF (NQRESV.LE.0)             GO TO 94
 
C--                Clear new links
 
   31 LA = NQREF
      IF (IFLAG.EQ.1)  LA = NQLINK
      IF (IFLAG.EQ.2)  LA = NQLINK
      IF (IFLAG.EQ.4)  LA = NQLINK
      N  = NEWL - LA
      IF (N.GT.0)  CALL VZERO (LQ(KQS+LA+1),N)
 
C----              Set new limits
 
   71 NQLINK  = NEWL
      IQTABV(KQT+5) = NQLINK
      IF (IFLAG.LT.3)  THEN
          IF (NEWD.GE.LQSTA(KQT+1)) Then
             LQSTA(KQT+1) = LQREND(JSTO+1)
             IF (LQSTA(KQT+1).EQ.0)  LQSTA(KQT+1) = NEWD + 1
             LQEND(KQT+1) = LQSTA(KQT+1)
          endif
        ENDIF
 
      IF (NQLOGL.GE.2) WRITE (IQLOG,9071) JQSTOR,IFLAG,NQLINK,NEWD
 9071 FORMAT (' MZWORK-  Store',I3,' Flag=',I2,' Last Link/Data',2I7)
 
+SEQ, QTRACE99.
      RETURN
 
C------            Error conditions
 
   94 NQCASE = 1
   93 NQCASE = NQCASE + 1
   92 NQCASE = NQCASE + 1
   91 NQCASE = NQCASE + 1
      NQFATA = 4
      IQUEST(11) = NQREF
      IQUEST(12) = NEWL
      IQUEST(13) = NEWD
      IQUEST(14) = IFLAG
+SEQ, QTOFATAL.
      END
+SEQ, QCARDL.      ==================================================
+DECK,RZMAKE.
*CMZ :          12/01/98  20.43.08  by  Pavel Nevski
*-- Author :
      SUBROUTINE RZMAKE(LUNIN,CHDIR,NWKEY,CHFORM,CHTAG,NRECP,CHOPT)
*
************************************************************************
*
*           Routine to create a new RZ file
*           To use an already existing file CALL RZFILE
* Input:
*   LUNP    Logical unit number associated with  the RZ file.   A FORTRAN
*           OPEN statement must precede the call to RZFILE.
*           Starting address of the memory area which will contain the RZ
*           information ('M' option)
*   CHDIR   Character variable specifying  the name of the  top directory
*           to be associated with unit LUN.
*   NWKEY   Number of words associated to a key (maximum 5)
*   CHFORM  Character variable describing each element  of the key vector
*           'B' Bit string but not zero
*           'H' Hollerith (4 characters)
*           'I' Integer (nonzero)
*           Ex: CHFORM='IIH' for NWKEY=3 and the 2 first keys are integer
*               and the third one is Hollerith
*   CHTAG   Character array defined as CHARACTER*8 CHTAG(NWKEY).
*           Each  element of  the  array allows  the  description of  the
*           corresponding element in the key vector with a tag of up to 8
*           characters.
*   NRECP   Number of physical records for primary allocation
*   CHOPT   Character variable specifying the selected options.
*           medium
*             default
*                   Disk
*             'M'   Memory
*                   In this  case the user  must have allocated  at least
*                   NRECP*LUNP words of memory starting at address LUN.
*           mode
*             default
*                   Native mode
*             'X'   Exchange mode
*           other
*             'F'   Format NRECP records (unless 'M')
*             'C'   C I/O (unless 'M')
*                   LRECL (words) taken from IQUEST(10)
*             'O'   OLD format for Cycle information (default is NEW)
*
* Called by <USER>
*
*  Author  : R.Brun DD/US/PD
*  Written : 01.04.86
*  Last mod: 14.09.93 No longer force exchange mode for LINUX
*          : 09.03.94 S.Banerjee (Change in cycle structure)
*          : 30.01.95 J.Shiers. Permit nrecp>65000 for new format
*          : 10.12.97 P.Nevski  Default is NEW
************************************************************************
*
+SEQ,ZUNIT.
+SEQ,ZSTATE.
+SEQ,RZCL,RZDIR,RZCLUN,RZK,RZCYCLE.
+SELF,IF=QMVAX.
      CHARACTER*16 CHORG
+SELF
      CHARACTER    CHOPT*(*),CHDIR*(*),CHFORM*(*)
      CHARACTER*16 CHTOP
      CHARACTER*(*)  CHTAG(*)
      DIMENSION    IOPTV(6),IHDIR(2)
      EQUIVALENCE (IOPTM,IOPTV(1)), (IOPTX,IOPTV(2))
     +,           (IOPTF,IOPTV(3)), (IOPTC,IOPTV(4))
     +,           (IOPTN,IOPTV(5)), (IOPTO,IOPTV(6))
*
*-----------------------------------------------------------------------
*
+SEQ,Q$JBIT.
      IQUEST(1)=0
      LOGLV = MIN(NQLOGD,4)
      LOGLV = MAX(LOGLV,-3)
      LUNP  = LUNIN
*
      CALL UOPTC(CHOPT,'MXFCNO',IOPTV)
+SELF,IF=-QCFIO.
      IF(IOPTC.NE.0) THEN
         WRITE(IQPRNT,*) 'RZMAKE. option C ignored - valid only ',
     +      'for MSDOS, Unix and VMS systems'
         IOPTC = 0
      ENDIF
+SELF.
      IOPTN =1-IOPTO
      IMODEX=IOPTX
      IMODEC=IOPTC
      IF(IOPTC.NE.0) LUNP = IQUEST(11)
+SELF,IF=FQXISN.
      IMODEX=1
+SELF,IF=QMLNX.
C     RZfile maked always with Exchange mode for LINUX
*     IMODEX=1
+SELF.
      IRELAT=0
*
*                Check NWKEY and NRECP
*
      IF(NWKEY.LE.0.OR.NWKEY.GT.KNMAX)THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9010)
 9010    FORMAT(' RZMAKE. NWKEY input value is invalid')
         IQUEST(1) =1
         IQUEST(11)=NWKEY
         GO TO 99
      ENDIF
      IF(NRECP.LT.2.OR.(NRECP.GT.65000.AND.IOPTN.EQ.0))THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9011)
 9011    FORMAT(' RZMAKE. NRECP input value is invalid')
         IQUEST(1) =1
         IQUEST(11)=NRECP
         GO TO 99
      ENDIF
*
*          Save existing material (if any)
*
      CALL RZSAVE
*
*            Find record length (as specified in the OPEN statement)
*
*          A, Memory option. LUN contains the buffer address
*                            and the value of LUNP is the block length
*
      IF(IOPTM.NE.0)THEN
         LRECP=LUNP
         IF(LRECP.LT.100.OR.LRECP.GT.10000)LRECP=1024
      ELSE
*
*          B, Standard option DISK. Use information as specified
*             in the Fortran OPEN statement
*
          IF(IOPTC.EQ.0) THEN
+SELF,IF=-QMVAX,IF=-QMVDS.
            INQUIRE(UNIT=LUNP,RECL=LRECB)
+SELF,IF=QMVDS.
            LRECB=4096
+SELF,IF=QMVAX.
            INQUIRE(UNIT=LUNP,RECL=LRECB,ORGANIZATION=CHORG)
            IF(CHORG.EQ.'RELATIVE')IRELAT=1
+SELF.
*
+SELF,IF=RZBYTES.
            LRECP=LRECB/4
+SELF,IF=-RZBYTES.
            LRECP=LRECB
+SELF,IF=QMCRY,QMCV64.
            IF(IOPTX.EQ.0) THEN
               LRECP=LRECB/8
            ELSE
               LRECP=LRECB/4
            ENDIF
+SELF.
         ELSE
*
*     Take LRECL from IQUEST(10) in case of C I/O option
*
            LRECP = IQUEST(10)
         ENDIF
      ENDIF
*
      LUN = LUNP
      IZRECL = LRECP
      IF(LUN.LE.0.AND.IOPTM.EQ.0)THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9012)
 9012    FORMAT(' RZMAKE. LUN input value is invalid')
         IQUEST(1) =1
         IQUEST(11)=LUN
         GO TO 99
      ENDIF
      IF(LRECP.LT.50)THEN
         IF(LOGLV.GE.-2) WRITE(IQLOG,9013)
 9013    FORMAT(' RZMAKE. LRECP input value less than 50')
         IQUEST(1) =1
         IQUEST(11)=LRECP
         GO TO 99
      ENDIF
      IF(LOGLV.GE.0) WRITE(IQLOG,9014) LUNP,LRECP,CHOPT
 9014 FORMAT(' RZMAKE. Unit ',I6,' Initializing with LREC=',I6,
     +', OPT= ',A)
      CALL MZSDIV (0,-7)
*
*           Check if LUN not already defined
*
      LRZ=LQRS
  10  IF(LRZ.NE.0)THEN
         IF(IQ(KQSP+LRZ-5).EQ.LUN)THEN
            IF(LOGLV.GE.-2) WRITE(IQLOG,9015)
 9015       FORMAT(' RZMAKE. Logical unit number already in use')
            IQUEST(1) =1
            IQUEST(11)=LUN
            GO TO 99
         ELSE
            LRZ=LQ(KQSP+LRZ)
            GO TO 10
         ENDIF
      ENDIF
*
*            First call to RZMAKE, create link area
*
      IF(LQRS.EQ.0)THEN
         CALL MZLINK(JQPDVS,'RZCL',LTOP,LTOP,LFROM)
         CALL MZBOOK(JQPDVS,LRZ0,LQRS,1,'RZ0 ',2,2,36,2,0)
         IQ(KQSP+LRZ0-5)=0
         ISAVE = 1
         NHPWD = 0
         CALL VBLANK(IHPWD,2)
      ENDIF
      NCHD  = LEN(CHDIR)
      IF(NCHD.GT.16)NCHD=16
      CHTOP = CHDIR(1:NCHD)
*
*            Create control bank
*
      IDTIME=0
      CALL RZDATE(IDTIME,IDATE,ITIME,2)
      KTAGS = KKDES+(NWKEY-1)/10+1
      NREC  = NRECP
      LREC  = LRECP
      NWREC = (NREC-1)/32 +1
      NW    = 50+NWREC
      NRD   = (NW-1)/LREC +1
      NWL   = NRD*LREC
      LD    = KTAGS+2*NWKEY
      LB    = LD+NRD+1
      LS    = LB+3+NWREC
      LK    = LS
      LF    = LS
*
      CALL MZBOOK (JQPDVS,LTOP,LQRS,1,'RZ  ',10,9,NWL,2,0)
*
*            Disk or memory
*
      IF(IOPTM.EQ.0)THEN
         IQ(KQSP+LTOP-5) = LUN
*
*            C I/O?
         IF(IOPTC.NE.0) CALL SBIT1(IQ(KQSP+LTOP),5)
      ELSE
         NMEM=IQ(KQSP+LRZ0)+1
         IQ(KQSP+LRZ0)=NMEM
         IQ(KQSP+LTOP-5)=-NMEM
         IF(2*NMEM.GT.IQ(KQSP+LRZ0-1))THEN
            CALL MZPUSH(JQPDVS,LRZ0,0,10,'I')
         ENDIF
         IQ(KQSP+LRZ0+2*NMEM-1)=LOCF(LUNP)-LOCF(IQ(1))+1
         IQ(KQSP+LRZ0+2*NMEM  )=LRECP
         LUN=-NMEM
      ENDIF
*
*            Pre-format file
*
      IF((IOPTF.NE.0).AND.(IOPTM.EQ.0))THEN
         DO 100 I=2,NRECP
  100    CALL RZIODO(LUN,LREC,I,IQ(KQSP+LTOP+1),2)
         IF(IQUEST(1).NE.0)THEN
            IF(LOGLV.GE.-1) WRITE(IQLOG,1000) I-1
 1000       FORMAT(' RZMAKE. Could only pre-format',I6,' records')
            IQUEST(1)=0
         ENDIF
      ENDIF
*
*            Write empty record for locks
*
      CALL RZIODO(LUN,LREC,1,IQ(KQSP+LTOP+1),2)
      IF(IQUEST(1).NE.0) GO TO 99
*
*            Build top-directory parameters
*
      CALL SBIT1(IQ(KQSP+LTOP),2)
      CALL VBLANK(IQ(KQSP+LTOP+1),4)
      CALL UCTOH(CHDIR,IQ(KQSP+LTOP+1),4,NCHD)
      CALL ZHTOI(IQ(KQSP+LTOP+1),IQ(KQSP+LTOP+1),4)
+SELF,IF=QMVAX.
*
*             Set ORGANIZATION type
*
      IF(IRELAT.NE.0)CALL SBIT1(IQ(KQSP+LTOP),4)
+SELF.
*
      NHPWD = 0
      CALL VBLANK(IHPWD,2)
      CALL UCOPY(IHPWD,IQ(KQSP+LTOP+KPW1),2)
      IQ(KQSP+LTOP+KPW1+2) = NCHD
      IF(IMODEX.GT.0)THEN
         CALL SBIT1(IQ(KQSP+LTOP+KPW1+2),12)
      ENDIF
      IQ(KQSP+LTOP+KDATEC) = IDTIME
      IQ(KQSP+LTOP+KDATEM) = IDTIME
      IQ(KQSP+LTOP+KQUOTA) = NREC
      IQ(KQSP+LTOP+KRUSED) = NRD
      IQ(KQSP+LTOP+KWUSED) = NWL
      IF (IOPTN.NE.0) THEN
        WRITE(IQLOG,7001) CHDIR
 7001   FORMAT(10x,'RZMAKE. new RZ format selected for ',a)
*     +        10x,'This file will not be readable with versions',
*     +            ' of RZ prior to release 94B')
        IQ(KQSP+LTOP+KRZVER) = 1
      ELSE
        WRITE(IQLOG,7007)
 7007 FORMAT(10x,'RZMAKE. OLD RZ format selected for ',a/,
     +       10x,'This file will have the limit on the number of',
     +           ' blocks < 64 K')
        IQ(KQSP+LTOP+KRZVER) = 0
      ENDIF
      IQ(KQSP+LTOP+KIP1)   = 2
      IQ(KQSP+LTOP+KNFREE) = NWL-LF
      IQ(KQSP+LTOP+KLD)    = LD
      IQ(KQSP+LTOP+KLB)    = LB
      IQ(KQSP+LTOP+KLS)    = LS
      IQ(KQSP+LTOP+KLK)    = LK
      IQ(KQSP+LTOP+KLF)    = LF
      IQ(KQSP+LTOP+KLC)    = NWL+1
      IQ(KQSP+LTOP+KLE)    = NWL
      IQ(KQSP+LTOP+KNWKEY) = NWKEY
      IQ(KQSP+LTOP+LD)     = NRD
      IQ(KQSP+LTOP+LB)     = NWREC
      IQ(KQSP+LTOP+LB+1)   = LREC
      IQ(KQSP+LTOP+LB+2)   = IDTIME
*
      NCHF=LEN(CHFORM)
      NCH =LEN(CHTAG(1))
      IF(NCH.GT.8)NCH=8
      DO 20 I=1,NWKEY
         IF(NCH.LT.8)CALL VBLANK(IHDIR,2)
         CALL UCTOH(CHTAG(I),IHDIR,4,NCH)
         CALL UCOPY(IHDIR,IQ(KQSP+LTOP+KTAGS+2*(I-1)),2)
         IFORM=2
         IF(I.LE.NCHF)THEN
            IF(CHFORM(I:I).EQ.'B')IFORM=1
            IF(CHFORM(I:I).EQ.'H')IFORM=3
            IF(CHFORM(I:I).EQ.'A')IFORM=4
         ENDIF
         IKDES=(I-1)/10
         IKBIT1=3*I-30*IKDES-2
         CALL SBYT(IFORM,IQ(KQSP+LTOP+KKDES+IKDES),IKBIT1,3)
  20  CONTINUE
      CALL ZHTOI(IQ(KQSP+LTOP+KTAGS),IQ(KQSP+LTOP+KTAGS),2*NWKEY)
      DO 30 I=1,NRD
         IQ(KQSP+LTOP+LD+I)=I+1
         CALL SBIT1(IQ(KQSP+LTOP+LB+3),I+1)
  30  CONTINUE
*
*            Store default LOG level
*
      LOGL = LOGLV + 3
      CALL SBYT(LOGL,IQ(KQSP+LTOP),15,3)
      CALL RZVCYC(LTOP)
*
*            Allocate free records
*
      CALL MZBOOK(JQPDVS,LFREE,LTOP,-2,'RZFR',0,0,3,2,0)
      IQ(KQSP+LFREE-5)=LUN
      IQ(KQSP+LFREE+1)=1
      IQ(KQSP+LFREE+2)=NRD+2
      IQ(KQSP+LFREE+3)=NREC
*
*            Allocate space for used records
*
      CALL MZBOOK(JQPDVS,LUSED,LTOP,-3,'RZUS',0,0,21,2,0)
*
      IQ(KQSP+LUSED-5)=LUN
      LRIN  = 0
      LPURG = 0
      LROUT = 0
      LCDIR = LTOP
      NLCDIR= 1
      NLNDIR= 1
      NLPAT = 1
      CHCDIR(1)=CHTOP
      CHNDIR(1)=CHTOP
      IQUEST(1)=0
*
  99  RETURN
      END
+PATCH,MAIN. ==================================================================
*CMZ :  1.00/01 27/10/94  01.44.00  by  Pavel Nevski
+DECK,agmain,T=GEANT.  ------------------------------------------------------
*CMZ :          12/03/98  16.11.16  by  Pavel Nevski
*-- Author :    Pavel Nevski
*****************************************************************************
*                                                                           *
      subroutine        A G M A I N
*                                                                           *
*****************************************************************************
+CDE,TYPING,GCFLAG,GCTIME.
*
      INTEGER           NWGEAN, NWGEA, NWPAW, NWPA
      PARAMETER        (NWGEAN= 8 000 000,    NWPAW=2 000 000)
      CHARACTER*240     BATCHF,PAWLOGF,PROG,COMD,ARG,VERSION,FATCAT
      INTEGER           AgIPAW,IwTYP
      COMMON /AgCIPAW/  AgIPAW,IwTYP
      INTEGER           LENOCC,ICDECI,Iprin,I,J,K,L,N,Nr/0/,Iv/0/,Na/0/,Irc
      CHARACTER*320     CHARGS
      COMMON /PCARGS/   CHARGS
      EXTERNAL          PAEXIT,UGLAST,AgPAWE
      INTEGER           ICSDEBUG
      COMMON /CSDEBUG/  ICSDEBUG
      LOGICAL           S,G
 
*     ON REAL UNDERFLOW IGNORE
*
*     CALL TIMEST  (1.E9)  ! set time limit for interactive (does not work)
      NWGEA = NWGEAN
      NWPA  = NWPAW
      CALL GETARG(0,PROG)
      I = 1
      N = LENOCC (PROG)
      DO J=1,N   { IF (PROG(J:J).EQ.'/') I=J+1; }
      VERSION = '       '
*     VERSION = PROG(I:N)
      FATCAT = ' '
*
      do J=1,999
      {  CALL GETARG(J,comd);  Call CUTOL(comd)
         L=LENOCC(comd);       if (L<=0) Break
         if comd(1:2)=='-h'
         { print *, ' usage: '//prog(i:n)     _
                 // ' [ -V version]'          _
                 // ' [ -w HIGZ_UNIT ]'       _
                 // ' [ -l login_kumac]'      _
                 // ' [ -b batch_kumac]'      _
                 // ' [ -D debug_level]'      _
                 // ' [ -P PAWC_size(Mw)]'    _
                 // ' [ -G GCBANK_size(Mw)]'  _
                 // ' [ -f fatmen_catalog  ]' _
                 // ' [ -n(o login_kumac)]'   _
           ; return
         }
         if comd(1:1)='-'
         { Na+=1;  Nr=1;  Arg=' ';  CALL GETARG(J+1,Arg);
           K=Lenocc(arg);   If (K>0) Nr=ICDECI(arg,1,K);
           If (comd(1:2)='-v') { if (LenOCC(arg)>0) VERSION = arg; Iv=1 }
           If (comd(1:2)='-d') { IDEBUG = Nr;  ICSDEBUG=Index(Arg,'c')  }
           If (comd(1:2)='-g') NWGEA   = max(0,Nr)*1000000
           If (comd(1:2)='-p') NWPA    = max(0,Nr)*1000000
           If (comd(1:2)='-f') FATCAT  = Arg
      }  }
      CALL CUTOL(VERSION)
      S = Version.ne.'gstar'
      G = Version.ne.'staf'
*
      write (*,1001) PROG(I:N),NWGEA,NWPA
1001  format(1x,54('*')/' * Starting ',a8,
     >       ' NwGEANT=',i9,' NwPAW=',i8,' *'/ 1x,54('*'))
*
      IPRIN = -3
      IF (IDEBUG>2) IPRIN=-1
*                                        initialise packages
      CALL MZEBRA  (IPRIN)
      CALL GZEBRA  (NWGEA)                      ! store 0 - geant
      CALL MZPAW   (NWPA)                       ! store 1 - pawc
 
      CALL PAWINT1 (PROG(I:N),BATCHF,PAWLOGF)
      CALL PAWINT2 (0,'+?',AgPAWE,IWTYP)  ! type of PAW, HBOOK, command
      CALL FMLOGL (-3)
      IF (LENOCC(FATCAT)>0) CALL FMSTRT(62,63,%L(FATCAT),Irc)
 
      if (G) CALL GINTRI            ! Geant MENUs and COMMANDs
*
      IF (IWTYP.EQ.999) THEN        ! motif zebra browser
         CALL PMINIT                ! Paw-Motif
         CALL GBROWS                ! Geant Browser
         CALL KUINIM (PROG)         ! Kuip-Motif
      ELSE
         CALL ZBRDEF                ! zebra-browser (p.248)
      ENDIF
*
      CALL PAWINT3                  ! HIGZ,HPLOT,COMIS,SIGMA, commons
      if (G) CALL GXCS              ! declare GEANT routines to COMIS
      if (G) CALL UGINIT (PROG)     ! user MENUs
      if (G) CALL GDINIT            ! Initialise Drawing pkg
      CALL TIMEL  (TIMINT)
 
      if (G) { Call AgVERSION; CALL KUEXEC('ROOT /GEANT') }
      if (S) { call staf_start }
****>
      CALL KUEXEC  ('SET/PROMPT '''//PROG(I:N)//' >''')
*
      NOLOG = LENOCC(PAWLOGF).le.0
      CALL PAWINT4 (PAWLOGF)
      BATCH = LENOCC(BATCHF).gt.0
      IF (BATCH) CALL PAWINT4(BATCHF)
*
      Call AgPAWQ
****>
      if (S) call staf_stop
      WRITE(*,'(/1x,a)') 'Exiting from '//PROG(I:N)
      if (G) Call UGLAST
      CALL PAEXIT
      :return:
      END
 
      subroutine  AgPAWQ
      COMMON /AgCIPAW/  AgIPAW,IwTyp
      AgIPAW = AgIPAW + 1
 
      if (IwTYP.EQ.999) then
        Call KuWham ('PAW++')
      else
        call KuWhag
      endif
      entry       AgPAWE
      end
*
 
 
+DECK,agversion,t=geant. -----------------------------------------------------------
*CMZ :          02/12/97  23.37.03  by  Pavel Nevski
*CMZ :  1.30/00 13/05/97  14.57.05  by  Pavel Nevski
*-- Author :    Pavel Nevski   10/07/96
      SUBROUTINE AGVERSION
character*36 cmon/'JanFebMarAprMayJunJulAugSepOctNovDec'/
+CDE,GCUNIT,AGCVERS,VIDQQ.
+SEQ,DATEQQ,TIMEQQ,VERSQQ.
     QFTITLCH=VIDQQ(5:60)
     id=mod(IDATQQ,100);  im=3*mod(IDATQQ/100,100);  iy=IDATQQ/10000;
 <w>;(' ********************************************************************')
 <w>;(' *                                                                  *')
 <w>;(' *        A D V A N C E D   G E A N T   I N T E R F A C E           *')
 <w>;(' *                                                                  *')
*<w>;(' *                      04-Sep-97 hot news:                         *')
 <w> id,cmon(im-2:im),iy; (' *',22x,i2.2,'-',a3,'-',i2.2,' hot news:',25x,'*')
 <w>;(' *                                                                  *')
*<w>;(' * 20-Jul-97, MAJOR update! Remove all sl files prior to this date  *')
*<w>;(' *                                                                  *')
+IF,GCALOR.
 <w>;(' * GCALOR avalable for calorimeter simulations on command: HADR 6   *')
*<w>;(' *        It needs bertaf.dat and xsneut95.dat from /cern/95a/lib   *')
+ENDIF.
 <w>;(' * Kuip command "ON ERROR GOTO label" will now react on:            *')
 <w>;(' *      - End_of_DATA on P stream, Write_Error on O stream          *')
 <w>;(' *      - time_left less than defined by GTIME command argument     *')
*<w>;(' * On GHIST command some standard histogram handling is introduced  *')
*<w>;(' *        with automatic histogram dump when EXITing AGI.           *')
*<w>;(' * Binning refined: - for BIT option all 2**Nbit values are used,   *')
*<w>;(' *                    unknown elements are supposed to be integer   *')
*<w>;(' *                  - for BIN option the interval is centered       *')
*<w>;(' * To get robust tracking in MANY volumes use ISWIT(10) value > 0   *')
*<w>;(' * Electron physics (Bremsstraghlung, Pair production) updated      *')
*<w>;(' * Print control is now fully consistent with SLUG-DICE-ATRECON     *')
 <w>;(' * Explicit NCOPY parameter is now allowed in the POSITION operator *')
*<w>;(' * Protection against errenious hit limits (bug in GFIPAR on SUN)   *')
*<w>;(' * RbGET counting request now returns again the correct number      *')
*<w>;(' *       of banks in a chain, as it is described in SOFT-NO-002     *')
 <w>;(' * USE operator has an OPERation NEXT, allowing bank chain scanning *')
 <w>;(' * "-b filename" option now available for batch mode.               *')
 <w>;(' * CERNLIB 97a release is now the default library version.          *')
 <w>;(' * Be aware that it requires the FILL attribute to be 0, otherwise  *')
 <w>;(' * edges drawn in black/white obscure most of the GEANT drawings !  *')
 <w>;(' *                                                                  *')
 <w>;(' * Absorption length calculation for mixtures corrected in GEANT.   *')
 <w>;(' * CMZ KEEP sequences (car-format) are recognised as REPLACE macros *')
 <w>;(' *                                                                  *')
 <w>;(' * GEANT memory may be increased at the program invocation time -   *')
 <w>;(' * start with -h option to get more information how to use switches *')
 <w>;(' *                                                                  *')
 <w>;(' *           FOR MORE DETAILS PLEASE USE HELP FACILITY              *')
 <w>;(' *                                                                  *')
 <w>;(' * To get complete description of AGI commands in printable format  *')
 <w>;(' *              do:  MANUAL AGUSER MAN.TEX LATEX                    *')
 <w>;(' ********************************************************************')
      end
 
 
+DECK,uginit,T=geant. ---------------------------------------------------------
*CMZ :          30/12/97  11.59.38  by  Pavel Nevski
*CMZ :  1.30/00 17/04/97  20.55.24  by  Pavel Nevski
*-- Author :    Pavel Nevski   27/11/94
*****************************************************************************
*                                                                           *
             Subroutine   U G I N I T (C)
*                                                                           *
*            GEANT Initialization Sequence                                  *
*****************************************************************************
+CDE,TYPING,GCBANK,GCPHYS,GCTRAK,SCLINK,AGECOM,AGCKINE.
     CHARACTER C*1
     Integer  p/0/
     EXTERNAL CSRMSL,AGDROP
*
     CALL GINIT                   "  GEANT common blocks                "
     CALL GZINIT                  "  GEANT core divisions, link areas,  "
     CALL AGZINI                  "  specific ZEBRA initialization      "
*    CALL GFFGO                   !  READ data cards within GEANt
     CALL GPART                   "  Define standard particles          "
     CALL GMATE                   "  Initialize standard materials      "
     Call CSEXT ('CSRMSL,AGDROP,p',CSRMSL,AGDROP,p,p,p,p,p,p,p,p)
+SELF,IF=-HPUX.
     Call CSFILE('0.csl')         "  Make all AGI routines callable     "
+SELF.
     DPHYS1      = 0              "  oshibku oshibkoi vybivaiut         "
     %Standalone = 1              "  standalone version, not batch      "
     %IGRAP      = -1             "  no default graphic, on request only"
     IGAUTO      = 0              "  defaults GEANT tracking  off       "
     CrunType    = ' '            "  no default actions defined         "
     NkineMax    =  64 000        "  ZEBRA limit on KINE bank           "
     NhitsMax    = 100 000 000    "  a reasonable limit on hit bank     "
*    Call GUINTI                     gsuser menu - called by geant      "
     Call AGXINIT                 "  aguser menu - called here          "
     %Module=' ';  call Agstand
     Call AgDummy
*
END
 
 
+DECK,uglast,T=geant. ----------------------------------------------------------
*CMZ :          21/11/97  17.47.13  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  22.56.51  by  Pavel Nevski
*-- Author :    Pavel Nevski   27/11/94
*********************************************************************
                Subroutine   U G L A S T
*********************************************************************
+CDE,TYPING,GCUNIT,GCFLAG,AGCKINE.
    Integer      ICYCLE
    Character*10 CTOP
 
    IF IUHIST>0
    { CTOP='//'//CDHIST;  <w> CTOP,CFHIST;
      (' Saving Histograms from ',a,' to ',a)
      CALL  RZCDIR(CTOP,' ');
      CALL  HCDIR('//PAWC','  ');    CALL HCDIR(CTOP,' ');
      CALL  HROUT(0,ICYCLE,'NT');    Call HREND(CTOP)
      If (Idebug>0) Call HLDIR('//PAWC','TSIA')
      CLOSE (IUHIST);    IUHIST=0
    }
    * Call RZCLOS(' ','A')
    If (Ioutp!=0) Call FZENDO(23,'TX')
    Call GLAST
    " STOP "
    END
 
 
+DECK,agxinit,T=kuip.
*CMZ :          16/03/98  03.12.22  by  Pavel Nevski
*CMZ :  1.30/00 19/04/97  15.44.40  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/04/96
******************************************************************************
*               A G X I N I T    C D F
******************************************************************************
>Name AGXINIT
>Menu AGUSER
>guidance
Advanced Geant Interface menu
*-----------------------------------------------------------------------------
>Command ACTIONS
>parameters
+
Option 'program actions allowed'   C    D='*'
>Guidance
This command can be used to overwrite the default program actions,
derived from the nature of input data.
 
List of program actions, allowed in the run, is :
 K - convertion GENZ banks to KINE
 S - Geant simulations
 D - Hit digitization
 R - reconstruction
 T - test beam data analysis.
 O - automatic output at the end of TRIG command
 * - all above is allowed
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GCLOSE
>Parameters
+
Option 'call GPHYSI after geometry closing' C
>Guidance
Close GEANT geometry building phase. Should be done before any graphics
and/or simulations are started, otherwise ZEBRA memory problems may arise.
If any parameter is given, GPHYSI is also called to calculate cross-sections.
In DEBUG OFF mode the output of GPHYSI is rederected into LUN 99.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GDROP
>Parameters
+
Option 'bank drop choice' C D='*'
>Guidance
Drops a selected bank tree or a set of bank trees according to the
following list:
 P - Particle structure PART
 A - material structure MATE
 M - medium structure TMED
 - - drops all three above mentioned structures
 
 V - Volume structures VOLUM and GPAR, Rotation matrices
 S - sets, hits and digits SETS, HITS and DIGI
 D - detector description bank DETM
 R - event raw data RAWD and reconstruction bank RECB
 E - the whole short-range event division
 * - drops all listed above except for the first three.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GDUMP
>Parameters
PATH   'Path to the selected sub-branch of banks' C D='/DETM'
+
OPTION 'Dump option (F,H,C,U or 1)'                   C D=' '
>guidance
Dumps the content of a selected sub-branch of ZEBRA banks,
addressed by the PATH.
 
Possible options are:
 F - dump in a file instead of the terminal. The bank name is used as
     the file name with .sgml extension
 H - convert the dump file in HTML formated set of files with
     appropriate hyperlinks beween them.
     Each bank in the structure is described in a separate file
     with the name of the bank and its top level bank as the filename
     and with .html extension.
 C - dump only numbers without variable names and comments. This may
     be usefull for an output intended to be read by another program.
 U - dump also banks which have no documenation (normally they are skipped),
 1 - dump also long banks (more than 1000 word - normally they are skipped).
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command MODE
>Parameters
Detector 'detector subsystem name' C D='ALL'
+
Flag  'control flag name' C
* R='PRIN,DEBU,GEOM,HIST,GRAP,SIMU,DIGI,RECO,MFLD,ANAL,BACK'
Value 'flag value'        I
>Guidance
For a given detector subsystem (or for ALL of them) sets a control flag value.
Possible flags and their default values are:
       PNOW  (0)             - print level for current event
       PRIN  (0)             - normal print level
       DEBU  (0)             - debug print level
       GEOM  (1)             - geometry version
       HIST  (1)             - system histogram flag
       GRAP  (1)             - system graphics level
       SIMU  (1)             - store GEANT hits flag
       DIGI  (1)             - digitisation flag
       RECO  (1)             - reconstruction flag
       MFLD  (1)             - magnetic field flag
       ANAL  (0)             - user analysis level
       BACK  (0)             - number of pile-up bunchs to select
                               (relative to the trigger one)
 
To change default values use GSFLAG command.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command DETP
>Parameters
Detector 'detector subsystem name' C
+
NAME  'name of the selected bank or of a variable in the bank' C
Value 'value of the selector or new value of the variable    ' R
>Guidance
When a USE operator is called for a bank for the first time,
it checks weither the bank name and the value of its selector
coincides with the one mentioned in a DETP command for the same detector.
If this is the case, corresponding variables in the bank are replaced
by the new value.
 
Only one DETP command per detector is kept in the program,
the next command with the same detector name overwrites the previous one.
On the other hand, any number of banks and their variable
can be changed by a single command (which can be expended
to several lines following KUIP rules.
When data are read from P stream, they are stripped out of
old DETP commands.
 
 Typing rules for  DETP parameters are the following:
 - the bank selector may be given in () or with a = sign.
 - variable to change should have a trailing = sign.
 - the new value should be separated by a blank.
 - command is not case sensitive.
 
 Example:
 DETP CALO cgeo(1).rmin= 200
 DETP CALO cgeo= 1 rmin= 200
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GVERTEX
>Parameters
X_vertex  'x of the generated vertex' R D=0
Y_vertex  'y of the generated vertex' R D=0
Z_vertex  'z of the generated vertex' R D=0
>Guidance
Defines an average vertex position for standalone particle generation.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GSPREAD
>Parameters
X_sigma  'x-spread of the generated vertex' R D=0
Y_sigma  'y-spread of the generated vertex' R D=0
Z_sigma  'z-spread of the generated vertex' R D=0
>Guidance
Defines the vertex spread for standalone particle generation.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GSFLAG
>Parameters
Flag  'AGI control flag' C D='PRIN' R='PRIN,PNOW,GRAP,HIST,SIMU,MFLD'
+
Value 'flag value      ' I D=1
>Guidance
Sets default value for control flags. These flags will be used to
provide a default value for all new detectors DETE (MODE) bank.
 
Flags mentioned here are only a subset of all flags,
available in the MODE command.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GFLAG
>Parameters
Flag  'AGI control flag' C D='PRIN' R='PRIN,PNOW,GRAP,HIST,SIMU,MFLD'
+
Value 'flag value      ' I D=1
>Guidance
Sets default value for control flags - same as GSFLAG
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GDEBUG
>Parameters
Flag 'hard debug level'  I  D=1
+
Itest 'random number print flag'  I  D=0
>Guidance
Set geant IDEBUG flag to value more than 1 for hard debugging
and ITEST flag for random number printouts.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GAUTO
>Parameters
Option 'automatic tracking parameter computation'  C  D='ON' R='ON,OFF,0,1'
>Guidance
Set or reset flag for automatic tracking medium parameter computation by GEANT.
Equivalent to the standard GEANT AUTO flag (which also works now).
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GPRINT
>Parameters
NAME   'Object Name' C
+
SET    'Set(subsystem) name'        C  D='*'
DET    '(sensitive) detector name'  C  D='*'
>Guidance
Prints selected GEANT object (hits, digits, sets,
KINE tracks, Vertices, Particles, Materials, Media,
Volumes, Rotation matrices)
using its name rather than the numeric ID.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GPHITS
>Parameters
+
CSET  'subsystem (set) name' C D='*'
CDET  'User detector name'   C D='*'
>Guidance
Prints hits using CALL AGPDIGI(cset+H,cdet).
Unlike the internal GEANT numbering, volume numbering starts from 1.
Pseudo-divisions are decoded into their original real values.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GPDIGI
>Parameters
+
CSET  'subsystem (set) name' C D='*'
CDET  'User detector name'   C D='*'
>Guidance
Prints digits using CALL AGPDIGI(cset+D,cdet).
Unlike the internal GEANT numbering, volume numbering starts from 1.
Pseudo-divisions are decoded into their original real values.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GSTOP
>Parameters
ABANDON 'electron stopping mode' I D=0
>Guidance
Low energy electrons and positrons, which have no chance to
reach the volume boundary, may be stopped using 2 different criteria.
There is no description currently available how it is done.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GKINE
>Parameters
NTRACK  'Number of tracks per event, -1 for tape input ' I D=1  R=-10:10000
ID      'Particle ID or number of events to skip on input'  I   R=0:100000
+
PTLOW   'Lower limit of pT'          R         R=0.:100000.
PTHIGH  'Upper limit of pT'          R         R=0.:100000.
YLOW    'Lower limit of rapidity'    R         R=-10.:10.
YHIGH   'Upper limit of rapidity'    R         R=-10.:10.
PHILOW  'Lower limit of Phi'         R         R=-10.:10.
PHIHIGH 'Upper limit of Phi'         R         R=-10.:10.
ZLOW    'Lower limit of Z of Vertex' R
ZHIGH   'Upper limit of Z of vertex' R
option  'choise of Geant or PDG particle ID' C D='G'  R='G,P,E'
>Guidance
Generates particles with flat phase space distribution
(instead of input events from a file) or to provide a particle filter
parameters for external generator input.
 
 Parameters are number of tracks per event, Geant particle ID for
particle in-line generation. Following optional parameters are
lower and upper bounds of pT, rapidity and azimouth anlge intervals.
If no parameters are given, a single muon will be generated per event,
distributed uniformly in the interval 0<pT<10 GeV, -10<y<10, 0<phi<2pi.
 
 To switch to PDG particle ID instead of the GEANT one, the options P or
E can be used.
 
  If NTRACK equal -1 events are read from P input stream instead of
been generated. In this case the second parameter is the initial
event number.
Other parameters are use as a filter to select particles fed into
simulations.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GMOMENTUM
>Parameters
NTRACK  'Number of tracks per event, -1 for tape input ' I D=1  R=-10:10000
ID      'Geant Particle ID, first event for tape input'  I D=5  R=0:1000
+
PxLOW   'Lower limit of pT'          R         R=-10000:10000
PxHIGH  'Upper limit of pT'          R         R=-10000:10000
PyLOW   'Lower limit of rapidity'    R         R=-10000:10000
PyHIGH  'Upper limit of rapidity'    R         R=-10000:10000
PzLOW   'Lower limit of Phi'         R         R=-10000:10000
PzHIGH  'Upper limit of Phi'         R         R=-10000:10000
ZLOW    'Lower limit of Z of Vertex' R         R=-10000:10000
ZHIGH   'Upper limit of Z of vertex' R         R=-10000:10000
option  'choise of Geant or PDG particle ID' C D='G'  R='G,P,E'
>Guidance
 Generates particles in a given momentum bin
or to provide a particle filter
parameters for external generator input.
 
 Parameters are number of tracks per event, Geant particle ID for
particle in-line generation, or -1 and first event number for
input event stream.
 Following optional parameters are
lower and upper bounds of Px, Py and Pz.
If no parameters are given, a single muon will be generated per event,
distributed uniformely in the interval -1<Px,Py,Px<1 GeV.
 
To switch to PDG particle ID instead of the GEANT one, the options P or
E can be used.
 
  If NTRACK equal -1 events are read from P input stream instead of
been generated. In this case the second parameter is the initial
event number.
Other parameters are use as a filter to select particles fed into
simulations.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GFILE
>Parameters
+
streamtype  'I/O stream and data type combined in one word'  C  D='P'
file            'name of the file'                   C  D='ZEBRA'
sets            'list of data sets to read/write'    C  D='*'
Modif           'filename modification mode'         C  D=' '
num             'numbers for filename modification'  I
>Guidance
Open an input or output data file with events.
 
 Stream. Different I/O streams are:
  P      - physics events input stream
  B      - background events to pile up on top of physics events,
  I      - general input data (no geometry record in the beginning),
  O      - output data.
 
 Data types may be:
 ' ' - Standard GENZ Zebra format with Lrec=8100 (default),
  Z  - Standard GEANT FZ format with Lrec=900 words,
  L  - Records include Length (Fortran-type OPEN used),
  F  - Fatmen catalog used to access Zebra tapes,
  N  - special Colomn Wise Ntuple with GENZ-type events for input,
  U  - user defined data type. In this case user has to supply his own
       routines AGUSREAD(ier) and to link it dinamically using gexec.
       The input file is opened by default on unit 20 as FORMATTED.
       For a user-specific file openning user has to provide his own
       routine AGUSOPEN(file) and to link it dinamically using gexec.
 
File: is the name of the data file.
It may include directory path and wildcard characters.
Default extensions for the default file name are P, B and O.
 
Sets: list of data sets to be read or written:	
 G - GEANT detector geometry plus DETM bank
     (unless they are already loaded or created)
 E - GENZ RUNT/EVNT banks with parton level information,
 K - Geant KINE/VERT/HEAD information,
 H - HIT banks,
 D - DIGI banks,
 R - reconstruction banks,
 S - data structure description (both include files and rz-database) is
     updated automatically as it is done with the STRUCTURES commands,
 * - all above (default).
 
Note that GEANT simulations are allowed ONLY if the input does not contain
hits or digits (i.e. disallowed by default list!).
 
Modif (to be implemented on request):
  The way how the * wildcard character is replaced using the
  numbers which follow this parameter.
  Possible choice is LOOP or LIST (see software note 008).
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GHIST
>Parameters
+
file         'name of the file'               C  D='atlas.his'
directory    'rz-directory for n-tuples'      C  D='SLUGRZ'
unit         'logical unit number'            I  D=33
 
>Guidance
Open a histogram output file. This file is used to keep
disk resident N-tuples and to save all histograms at the end
of run.
 
 Before opening a disk resident N-tuple, user should do
 the following directory setting:
 
    Call RZCDIR('//SLUGRZ',' ')
    Call  HCDIR('//SLUGRZ',' ')
 
 At the end of the run you should do EXIT command to finish GEANT -
 this will do the actual histogram saving.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GBACK
>parameters
+
Nbefor  'number of bunchs to add prior to the trigger one' I D=0
Nafter  'number of bunchs to add after the trigger one'    I D=0
BgMult  'Average pile-up multiplicity of bunch crossing'   R D=23
BgTime  'Time between bunch crossings (in ns)'             R D=25
BGSkip  'average number of skept events for randomizing'   R D=1
>Guidance
Secondary event stream 'B' use used to put pile-up pre-simulated
events on top of a physics event.
Background data should be in GEANT or GENZ format.
Interaction time, vertex and track numbers of each secondary event
are updated upon read.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command REBANK
>Guidance
 
Bank access mechanism is implemeted as it is described in Atlas note
SOFT-NO-002. The only correction to the note is the call to the REBANK
itself, which now has an additional parameter Ia:
 
          call REBANK (Path,IDN,Npar,Link*,Ia*)
 
The returned value of Ia contains the displacement in the bank,
for a single raw request. Remember that this routine is not intended
for general usage and should be avoided - use FILL/USE operators
RBSTORE/RBCOPY, RBGET/RBPUT routines instead.
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command USE
>Guidance
 
Here we provide some general guidance in addition to the Atlas note
SOFT-NO-014, for using USE operator in the reconstruction code
 
the complete format of the USE operator is
 
 USE Path [ variable=value ] [ OPER={DELETE/UNIQUE/NEXT/ZERO} ] [ STAT=istat ]
 
All fields apart from Path are optional.
 
  Path : is the Unix-like path to the selected bank or a chain of banks
         It may include after bank names integer indeces
         If omitted, default value for index is supposed to be 1.
 
         The Path may be absolute, i.e. starting from /DETM or /RECB, in
         which case the selected bank becomes the Current Working Directory
         or relative, i.e. starting from the current working directory,
         selected by the previous USE operator.
         Module names in the begining of the path are recognized as
         the absolute path in DETM tree.
 
  OPER:  Different operations are :
   DELETE - deletes the selected bank from the tree AFTER copying its
            content in the corresponding structure
   ZERO   - reset the bank content to ZERO (agaim AFTER coping)
   UNIQUE - moves the selected bank to the first position in the chain
            and drops all other banks in this chain making a unique
            version available for the further analysis.
   NEXT   - select the next bank in the chain without searching the
            path again. If STAT option is used, this is done only
            if the status control variable is OK [0], otherwise
            a normal search in the path is done, thus allowing
            to select a starting bank and its descendent in the
            same USE
 
  STAT=ISTAT returns in ISTAT the bank access status (0 if OK).
             Initial value of ISTAT should be defined with a DATA statement.
 
>Action AGXUSER
 
*-----------------------------------------------------------------------------
>Command GEXEC
>Parameters
file         'name of the *.g file'               C
+
library     'additional library path and libraies'  C  D=' '
 
>Guidance
parse to fortran, compile, link as a shared library
and execute users program, stored in the file.g.
The file may contain several subroutines.
The one which has the same name as the file is executed.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command VERSIONS
>parameters
+
Option 'program, component or data versions'   C    D='*'
>Guidance
This command can be used to steer version dependance,
which cannot be derived from the nature of input data.
 
List of known program version :
 
 RZ95, RZ96 - Different key formats in RZ files (affects RZ/FILE)
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GSTAT
>Parameters
+
key   'name of the selected histogram'  C   D='ALL'
>Guidance
 Book a standard set of the GEANT control histogram:
 TIME -  Time per event
 SIZE -  Space used in IXDIV per event
 MULT -  Total number of tracks per event
 NTRA -  Long life tracks per event
 STAK -  Maximum stack size per event
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command STRUCTURES
>Parameters
+
name   'name of the system whose structures should be dumped'  C  D='*'
type   'type of the output'                                    C  D=' '
 
>Guidance
Produce a definition file with data structure description and
update the documentation database in accordance with the
input data stream. This file may automatically be read by geant
parser so that user can get access to structure description
with +cde or +include statements.
 
type of the output may be
  def   - AGI preprocessor input file,
  idl   - CORBA interface definitions language,
  other - internal table format
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command TABLES
>Parameters
+
name   'name of the system to be converted into table'  C  D='*'
type   'output directory'                               C  D=' '
 
>Guidance
Convert AGI structures and objects into StaF tables.
Actual structure address is mapped to the table.
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command GMAKE
>Parameters
source      'default path to the module source'        C  D='.'
+
name        'name of the makefile '                    C  D=' '
library     'additional keyword parameters for make'   C  D=' '
 
>Guidance
Redefine default path to the source for GEXEC command,
as well as the name of the makefile to be executed by GEXEC.
Additional parameters for the make procedure may be supplied with
their keywords (examples: LIB_PATH=... LIBS=...)
 
>Action AGXUSER
*-----------------------------------------------------------------------------
>Command STOP
>Parameters
>Guidance
 abort the program - the fastest possible exit
>Action AGXUSER
*-----------------------------------------------------------------------------
 
+DECK,guinti,T=kuip. -------------------------------------------------------------
*CMZ :          16/10/97  10.49.22  by  Pavel Nevski
*CMZ :  1.30/00 17/04/97  20.34.55  by  Pavel Nevski
*-- Author :    Pavel Nevski   28/04/96
******************************************************************************
*               G U I N T I    C D F
******************************************************************************
>Name GUINTI
 
>Menu USER
>Guidance
User defined menu for GSTAR
 
>Command INPUT
>Parameters
TYPE 'Type of event input' C D='TX' R='FZ,TX,FZTX,TXOLD,TXOTX,FZTXO'
INFILE1 'First input file name' C D=' '
+
INFILE2 'Second input file name (must be TX)' C D=' '
>Guidance
Opens one or two files of events as input to Geant. If read types FZ
(Zebra) or TX (Star new text format) are given, only one file of the given
type is opened using the first input filename. If read type FZTX or
TXOTX is given, two files are opened and merged within Geant. For
the FZTX option, the first filename must be an FZ file and the second
filename a TX file (new text format). For the TXOTX, the first file
must be an old format text file, and the second a TX file.
In the FZTX and TXOTX options, if the tracks and vertices of the two files
are to be disentangled again downstream of Geant, it is the user's
responsibility to ensure that they are labelled in a unique way. One
simple way to do this is to make all vertex processes in the TX file
negative.
 
If a file of the given type is open at the time of this call, it will be
closed before further action is taken.
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command OUTPUT
>Parameters
ACTION  'Open or close output file' C D=' ' R='O,C'
+
OUTFILE 'FZ output file name' C D='geant.fzd'
>Guidance
Opens/Closes an FZ output file.
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command PHASESPACE
>Parameters
+
NTRACK  'Number of tracks per event' I D=100
ID      'Geant Particle ID'       I D=8
PTLOW   'Lower limit of pT'       R D=0.
PTHIGH  'Upper limit of pT'       R D=1.
YLOW    'Lower limit of rapidity' R D=-1.
YHIGH   'Upper limit of rapidity' R D=1.
PHILOW  'Lower limit of phi'      R D=0.
PHIHIGH 'Upper limit of phi'      R D=6.283
>Guidance
 
Generates flat phase space in place of input file of events.
Parameters are Geant PID, lower and upper bounds of rapidity interval,
lower and upper bounds of pT interval, and number of tracks per
event. Full azimuthal interval is used (0<phi<two pi radians).
 
If no parameters are given, old values existing in the program are preserved.
Initial limits are 0<pT<10000, -10<y<+10, 0<phi<2pi.
 
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command MOMENTUMBIN
>Parameters
+
NTRACK 'Number of tracks per event' I D=100
ID     'Geant Particle ID' I D=8
PXLOW  'Lower limit of px' R D=-1.
PXHIGH 'Upper limit of px' R D=1.
PYLOW  'Lower limit of py' R D=-1.
PYHIGH 'Upper limit of py' R D=1.
PZLOW  'Lower limit of pz' R D=-1.
PZHIGH 'Upper limit of pz' R D=1.
>Guidance
 
Generates uniform distribution within given 3-momentum bin in place of
input file of events.
Parameters are Geant PID, lower and upper bounds
of px, py and pz, and number of tracks per event.
 
If no parameters are given, 100 pi+ will be generated per event,
distributed uniformly in the interval -1<px<1, -1<py<1, -1<pz<1 GeV.
If px_high is less than px_low, then px_high will be set equal to px_low
(i.e. px will have the same value for all tracks),
and similarly for py and pz.
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command SKIP
>Parameters
NEVENT 'Number of input events to skip' I D=0
+
NSUBEVENT 'Number of subevents to skip in first processed event' I D=0
SUBRAN1 'First random seed at start of first processed subevent' I D=0
SUBRAN2 'Second random seed at start of first processed subevent' I D=0
>Guidance
 
Skips the next NEVENT events of input event file. If NSUBEVENT>0,
skips first NSUBEVENT subevents in first processed event, using random
seeds SUBRAN1 and SUBRAN2. This allows the user to set the seeds to
randomize the target position correctly at the beginning of the desired
event and then skip directly to any subevent.
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command UDECAY
>Parameters
PIDPARENT 'Geant PID of parent' I D=11
RIN 'Inner limit of radial interval for uniform decay' R D=10.
ROUT 'Outer limit of radial interval for uniform decay' R D=100.
PID1 'Geant PID of first decay daughter' I D=5
PID2 'Geant PID of second decay daughter' I D=4
+
PID3 'Geant PID of third decay daughter, if present' I D=0
>Guidance
Initializes parameters for the decay of a particle with uniform
probability along its trajectory between the cylindrical surfaces
R=RIN and R=ROUT. This can be used to enhance statistics for the
efficiency studies of the reconstruction of decays. A new particle is
defined, having PIDNEW=PIDPARENT+200, and which does not have any
decay modes defined in Geant. When particle PIDPARENT appears in the
input list of kinematics, its pid is replaced by PIDNEW. It is
propogated from its origin through the surface R=ROUT, and then a decay
point is chosen uniformly along its trajectory between RIN and
ROUT. GSTAR explicitly creates a new vertex at this decay point, with
100% branching ratio for decay into the two or three daughters
defined, with kinematics defined appropriately (three-body decay
assumes scalar particles). Since the path length to the generated
vertex and the parent 4-momentum are known, the appropriate weighting
factor for the vertex due to the lifetime of the parent can be
calculated.
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command SPARTSTAR
>Parameters
>Guidance
 Obsolete command. Use GEANT/CONTROL/SPART instead
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command GFDK
>Parameters
+
IPART 'Geant PID' I D=0
>Guidance
Writes out decay modes for particle id IPART.
>Action AGSUSER
*----------------------------------------------------------------------------
 
>Command SECONDARIES
>Parameters
SCND 'secondaraies treatment flag'  I D=1  R=0:2
>Guidance
Controls the way how secondary particles are treated:
 0 - secondaries ignored;
 1 - secondaries are put in jstak only (standard)
 2 - some secondaries are saved in KINE bank.
     This concerns decay products of particles, already existing in KINE.
     Other products (than decay) of these particles are saved in KINE
     only if they are produced in specially named media, which should
     be different from the medium, where the parent was born.
>Action  AGSUSER
*----------------------------------------------------------------------------
 
>Command VXYZ
>Parameters
VX ' primary vertex x ' R D=0 R=-1000:1000
VY ' primary vertex y ' R D=0 R=-1000:1000
VZ ' primary vertex z ' R D=0 R=-1000:1000
>Guidance
Displaces an average position of the interactions vertex in (Vx,Vy,Vz)
>Action  AGSUSER
*----------------------------------------------------------------------------
 
>Command VSIG
>Parameters
VSIGT 'transverse vertex spread'        R D=0 R=0:1000
VSIGZ 'longitudinal vertex spread'      R D=0 R=0:1000
>Guidance
Defines sigma if the generated vertex spread both in transverse and
longitudinal(along the beam axis) direction.
>Action  AGSUSER
*----------------------------------------------------------------------------
 
>Command SUBEVENT
>Parameters
NSUB 'number of final state tracks per sub-event'  I D=200      R=0:10000000
+
Ntrk_max 'maximum of tracks per single KINE bank ' I D=64000    R=0:10000000
Nhit_max 'maximum length of a single HITS bank'    I D=10000000 R=0:10000000
>Guidance
Controls splitting of full events into a number of smaller sub-events
in the GEANT simulation phase.
>Action  AGSUSER
*----------------------------------------------------------------------------
 
>Command SHADOW
>Parameters
SHDO 'tracking flag for dense materials'  I D=1  R=0:1
>Guidance
Flag to set tracking threshold in dense materials very high.
This will prevent showering in magnets and other dense objects,
but they will still block unphysical tracks
>Action  AGSUSER
*----------------------------------------------------------------------------
 
>Command SENSECUTE
>Parameters
CUTE 'electron tracking cut'              R D=-1 R=-1.0:10.0
>Guidance
Changing electron tracking cut in sensitive gases one can control
delta-electron production in detector itself.
>Action  AGSUSER
*----------------------------------------------------------------------------
 
 
+DECK,agxuser,T=geant. --------------------------------------------------------
*CMZ :          16/03/98  03.22.25  by  Pavel Nevski
*CMZ :  1.30/00 23/04/97  18.45.29  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/04/96
*********+*********+*********+*********+*********+*********+*********+*********+
*                                                                              *
      SUBROUTINE AGXUSER
* Description:  define AgI KUIP command repertoire                             *
*********+*********+*********+*********+*********+*********+*********+*********+
+CDE,TYPING,GCBANK,GCUNIT,GCNUM,GCFLAG,GCKINE,GCTRAK.
+CDE,QUEST,GCPHYS,GCCUTS,GCLIST,AsFLAGS,AgCKINE,SCLINK.
     character     command*32,Cword*4,C*1
     character*256 string1,string2,string3
     integer       LENOCC,CSADDR,SYSTEMF,Npar,Len1,Len2,Len3,Ip,Kp,Jp,
                   L1,L,i,j,K,i0,j0,id,id1,id2,address,JAD,IAD,Ival,Ier,
                   Iprin/1/,Li/20/
     Character*160 source,      destin,      mname,     library
     data          source/' '/, destin/' '/, mname/' '/,library/' '/
     Real          PAR(1000),Rval,dummy1,dummy2
*    force string1,2 at word boundary - comis pass whole words only
     EQUIVALENCE  (string1,dummy1),(string2,dummy2)
*    reset comis error (PAWFCA ... symbol not found ...)
     Integer         ii
     common /hcbits/ ii(37)
*
  call KUPATL( command, npar )
  Iprin=Idebug;  Ncommand+=1;
 
  if command=='GDUMP' | command=='DUMP'
  {  " dump a sub-tree of banks "
     call kugetc (string1,Len1)
     call kugetc (string2,Len2)
     Call AgDUMP (string1(1:Len1),0,string2(1:Len2))
  }
  else If Command=='GFILE'
  {  " open an I/O: file stream request"  Ccommand=' '
     Call KUGETC(string1,len1);
     Call KUGETS(string2,len2);
     Call KUGETC(string3,len3);         C='P'
     IF (Index(String1(1:len1),'B')>0)  C='B'
     IF (Index(String1(1:len1),'O')>0)  C='O'
     If (string2(1:len2)=='ZEBRA')  { String2='ZEBRA.'//C; Len2=7; }
     Do i=4,Npar { Call KUGETI(PAR(i-3)) }
 
     If  Index(String1(1:len1),'U')>0
     {  { Ikine,IkineOld }=-5;  CoptKine=string3;
        call AgFOPEN(li,string2(1:len2),ier)
        Address=CsADDR('AgUSOPEN')
        L1 = 4*((len2+3)/4)
        If (address>0) CALL CsJCAL(address,2,string2(1:L1))
     }
     else If Index(String1(1:len1),'N')>0
     {  Call AgNTOpen(String2(1:len2),4) }
     else
     {  Call AgZOPEN(string1(1:len1),string2(1:len2),string3(1:len3),
                                                          Npar-3,PAR)
        IF (Index(String1(1:len1),'P')>0)  Call AGZREAD ('P',ier)
        IF (Index(String1(1:len1),'B')>0)  Call AGZREAD ('B',ier)
        IF (Index(String1(1:len1),'O')>0)  Call AGZWRITE('O',ier)
     }
     If (Index(String3(1:Len3),'S')>0 | String3(1:1)='*') Call AGKEEPS('*')
  }
  else If Command=='GHIST' | Command=='HFILE'
  {  " open a histigram file
     Call KUGETS(string1,len1); CFHIST=string1(1:len1)
     Call KUGETC(string2,len2); CDHIST=string2(1:len2)
     Call KUGETI(IUHIST)
     Call HROPEN(IUHIST,CDHIST,CFHIST,'N',1024,IVAL)
     prin1 %L(CDHIST),%L(CFHIST),IUHIST
     (' Creating RZ-directory ',a,' for histogram file ',a,' on unit ',i3)
  }
  else If Command=='ACTIONS'
  {  Call KUGETC(string1,len1);  CRunType=string1(1:len1)
     prin1 CrunType; (' Allowed actions: ',a)
  }
  else If Command=='VERSIONS'
  {  Call KUGETC(string1,len1);
     IF (String1(1:4)=='RZ95') { prin1; (' RZ format 95 '); IQUEST(99)=0  }
     IF (String1(1:4)=='RZ96') { prin1; (' RZ format 96 '); IQUEST(99)=96 }
  }
  else If Command=='GKINE' | Command=='PHASESPACE' _
        | Command='GMOMENTUM' | Command=='MOMENTUMBIN'
  {  " Flat phase space generation - old KINE card function "
     " Ntracks=" call KUGETI(Ikine);  "Ipart=" call KUGETI(ip);
     " get all other parameters - Pt,eta,phi,z limits "
     Do i=2,min(Npar-2,8),2
     { " historical order - may disappear sometime "
       j=i; If (i==8) j=9;
       call KUGETR(pkine(j));  call KUGETR(pkine(j+1))
       pkine(j+1) = max(pkine(j),pkine(j+1))
     }
*    Ival=2 means not only fix pT, but also Geant particle code rather then PDG
     Ival=2; If Npar>=9       " get GEANT/PDG PID switch "
     {  Call KUGETC(string2,len2); C=String2(1:1)
        If C=='E' {Ival=0} else If C=='P' {Ival=1}
     }
     If Ikine>=0
     {  " check to see if particle exists: "
        Kp=Ip; If (Ival<2) Call aPDG2GEA(IP,Kp)
        Jp=0;  If (1<=Kp&Kp<=Npart) Jp=LQ(Jpart-Kp)
        if Jp<=0 { <w> ip; (' AGXUSER: unknown particle id =',i6); Return; }
        Call UHTOC(IQ(JP+1),4,string1,20);  Len1=LENOCC(string1(1:20))
        Prin1 Ikine,string1(1:len1);
        (' Generating ',i5,2x,a,' events in interval:')
     } else
     {  prin1 Ip;
        (' reading events with following cuts (skipping ',i5,' events)')
     } Pkine(1)=IP
*
     If Command=='GKINE' | Command=='PHASESPACE' _
     {  If Ival==0 { Prin1 (pkine(i),i=2,3); ( 10x,f8.2, ' <  E  < ', f8.2) }
        else       { Prin1 (pkine(i),i=2,3); ( 10x,f8.2, ' < pT  < ', f8.2) }
        Prin1 (pkine(i),i=4,7),(pkine(i),i=9,10)
          ( 10x,f8.2, ' < eta < ', f8.2,
           /10x,f8.3, ' < phi < ', f8.3,
           /10x,f8.1, ' <  Z  < ', f8.1)
        Pkine(8)=Ival
     }  else
     {  Prin1 (pkine(i),i=2,7),(pkine(i),i=9,10)
          ( 10x,f8.2, ' < px  < ', f8.2,
           /10x,f8.2, ' < py  < ', f8.2,
           /10x,f8.2, ' < pz  < ', f8.2,
           /10x,f8.1, ' <  Z  < ', f8.1)
        Pkine(8)=Ival+10
     }
  }
  else if Command=='GBACK'
  {  Iback=-1;             Call KUGETI(IbBefor); Call KUGETI(IbAfter);
     Call KUGETR(BgMUlt);  Call KUGETR(BgTIME);  Call KUGETR(BgSKIP);
     prin1 IbBefor,IbAfter,BgMult,BgTime,BgSkip;
     (' Reading Background from ',i3,' to ',i3,' pile-up bunchs '/,
      ' with ',F5.1,' events in average, ',F5.1,' ns between them.'/,
      ' Average Randomizing skip ',F5.1,' events')
  }
  else If Command=='GVERTEX'
  {" set up the vertex position "
     AvFLAG=1;     Do I=1,Npar { CAll KUGETR(AVcoor(i)); }
     Prin1 Avcoor; (' AGXUSER: generating vertex at ',3f12.4)
  }
  else If Command=='GSPREAD'
  {" set up the vertex position "
     AvFLAG=1;     Do I=1,Npar { CAll KUGETR(AVsigm(i)) }
     Prin1 AVsigm; (' AGXUSER: generating vertex spread ',3f9.4)
  }
  else If Command=='GDROP' | Command=='DROP'
  {" drop selected bank tree "
     Call KUGETC(String1,Len1); Call AGDROP(String1(1:len1));
  }
  else If Command=='GMODE' | Command=='MODE'
  {" detector mode datacard  "
     Call KUGETC(String1,Len1); Cword=String1(1:len1);
     If Cword=='ALL'  { ID1=1; ID2=0; IF (LKDETM>0) ID2=IQ(LKDETM-2); }
     else             { Call AsBDETE(Cword,ID1);    ID2=ID1;          }
     Do i=2,Npar-1,2
     {  Call KUGETC(String2,Len2); Cword=String2(1:len2); Call KUGETI(IVAL)
        Do j=1,NFLAGS
        { Check Cword==CFLAG(j); Do ID=ID1,ID2
          { If (LQ(LKDETM-ID)>0) IQ(LQ(LKDETM-ID)+j)=IVAL; }
     }  }
     Do ID=ID1,ID2
     { Check LQ(LKDETM-ID)>0;
       Prin1 IQ(LKDETM+ID),(Cflag(j),IQ(LQ(LKDETM-ID)+j),j=1,Nflags)
                  (1x,A4,' mode:',15(1x,a4,i2))
  }  }
  Else If Command=='DETP' | Command=='GPAR'
  {" detector parameters in DETM bank "
      Call KUGETC(string1,len1); Cword=string1(1:4)
      Call AsBDETE('DOCU',ID);   Call AsBDETE(Cword,ID);
      j=2;  string2=' ';   Len2=0;  Len3=0;
      Do i=2,Npar
      { * awful coding, may be sometime will do it better. PN.
         :more:       string1=string2; Len1=Len2;
         if Len3==0 { Call KUGETC(string2,len2);  }
         else       { string2=string3; Len2=Len3; }
         Call KUDPAR(string2,Ival,Rval,string3,len3,C);
         Len3=0
         if C=='C'
         {  i0=INDEX(string2,'=')
            if 0<i0 & i0<len2
            { string3=string2(i0+1:len2);  Len3=Len2-i0
              string2=string2(1:i0);       Len2=i0
            }
            If i0==1 & len2==1   " = "
            { string2=string1(1:len1)//'=';     j=j0; len2=len1+1;   }
            Call UCTOH(string2,PAR(j),4,len2);  j0=j; j+=(len2-1)/4+1;
            If J>=1000 { print *,' Tooooo many input parameters !!!'; Break; }
         }
         If C=='R'  { PAR(j)=Rval;  J+=1; }
         If C=='I'  { PAR(j)=Ival;  J+=1; }
         prin2 C,string2(1:len2),len2; (' DETP input: ',a,' = ',a,i6)
         If (Len3>0) goto :more:
      }  Call AsLSETBA(CWORD,'DETP',j-1,PAR)
  }
  Else If Command=='GFLAG' | Command=='GSFLAG'
  {" all possible subsystem control flags "
     Do i=1,Npar-1,2
     {  Call KUGETC(string1,len1);  Call KUGETI(Ival);
        Call AgSFLAG(string1(1:len1),Ival)
        Prin1 string1(1:len1),Ival; (' Flag ',a,' set to ',i3)
  }  }
  Else If Command=='GDEBUG'
  {" make hard debugging level available "
     Call KUGETI (Idebug);          Call KUGETI (Itest)
  }
  Else If Command=='GCLOSE'
  {" close geometry and possible recalculate cross-sections"
     Call GGCLOS;
*    hide gphysi table in this case in a file
     Ival=Lout;  If (Idebug==0) Lout=99;
     If (Npar>0) Call AGPHYSI
     Lout=Ival
  }
  Else If Command=='GAUTO'
  {" set geant IGAUTO flag (does not work in GEANT yet)"
     Call KUGETC(string1,len1);
     If string1(1:2)=='ON' | string1(1:1)='1' {IGAUTO=1} else {IGAUTO=0}
     prin1 IGAUTO; (' IGAUTO flag set to ',i2)
  }
  Else If Command=='GSTOP'
  {" stopping electron control "
     Call KuGETI(Ival);  DPHYS1=Ival;
     prin1 Ival;   ('  stopping electron mode=',i2)
  }
  Else If Command=='GPRINT'
  {" different object print out - to be improved later "
     Call KUGETC(string1,len1); cword=string1(1:len1)
     If cword='PART' | cword='MATE' | cword='TMED' | cword='ROTM' _
      | cword='SETS' | cword='VERT' | cword='KINE' | cword='JXYZ' _
     {  IP=0;  if (Npar>1) CALL KUGETI(IP);  call GPRINT(Cword,IP)  }
     else If cword='DECA'|cword='DCAY'
     {  IP=0;  if (Npar>1) CALL KUGETI(IP);  call GPDCAY(IP)        }
     else If cword='HITS'|cword='DIGI'
     {  Call KuGETC(string1,len1); Call KuGETC(string2,len2)
        if (string1!='*') string1=string1(1:3)//Cword(1:1)
        call AgPDIGI(string1,string2)
     }
     else If cword='VOLU' & JVOLUM>0
     {  Call KuGETC(string1,Len1); Do I=1,NVOLUM
        {  Call UHTOC(IQ(LQ(JVOLUM-I)-4),4,String2,4)
           If (String1=='*' | String1(1:4)==string2(1:4)) Call GPVOLU(I)
     }  }
  }
  Else If Command=='GPHITS' | Command=='GPDIGI'
  {  Call KuGETC(string1,len1); Call KuGETC(string2,len2)
     if (string1!='*') string1=string1(1:3)//Command(3:3)
     call AgPDIGI(string1,string2)
  }
  Else If Command=='GEXEC'
  {  * PN, 04.03.98:  make it case sensitive
     Call KuGetS(string1,len1); " Call CUTOL(string1(1:Len1)) "
     If (Npar>1) Call KuGetS(Library,len2)
     L=0; K=1; DO i=1,Len1
     { if (string1(i:i)=='/') K=i+1; if (string1(i:i)=='.') break; L=i; }
 
*    call to csrmsl is needed to free the sl file before compilation
     If LENOCC(Source)+LENOCC(Destin)==0
     {  Call CSRMSL(String1(1:L));         CALL PAWCS;
        II(4)=0;
        Ier=SystemF('make '//string1(1:L)//'.sl')
        CALL PAWFCA(string1(1:L)//'.csl',L+4,JAD,Idebug)
     }
     else
     {  Call CSRMSL('sl/'//String1(K:L));  CALL PAWCS;
        II(4)=0;
        Prin1       'gmake '//%L(mname)//                      _
                    ' INP_DIR='//%L(Source)//'/'//%L(string1)//_
                    ' '//%L(library)
                    ('gexec: ',a)
        Ier=SystemF('gmake '//%L(mname)//                      _
                    ' INP_DIR='//%L(Source)//'/'//%L(string1)//_
                    ' '//%L(library))
        CALL PAWFCA('sl/'//string1(K:L)//'.csl',L-K+8,JAD,Idebug)
     }
     IAD=CsADDR(string1(K:L)//'_init'); if (IAD!=0) JAD=IAD
     IF (JAD>0) CALL CSJCAL(JAD,0,0)
  }
  Else If Command=='GMAKE'
  {  Call KuGetS(source,len1)
     if (Npar>1) { Call KuGetS(string2,len2); mname = ' -m '//string2 }
     if (Npar>2) { Call KuGetS(library,len3);                         }
  }
  Else If Command=='GSTAT'
  {  DO i=1,Npar
     {  CALL KUGETC(string1,Len1)
        IF String1(1:Len1)=='ALL' | String1(1:len1).EQ.'*'
        {  NHSTA=5;  CALL UCTOH('TIMESIZEMULTNTRASTAK',LHSTA,4,20); }
        else
        {  NHSTA=i;  CALL UCTOH(String1,LHSTA(i),4,4); }
     }
     CALL GBHSTA; prin1 NHSTA,(LHSTA(i),i=1,NHSTA)
     (I5,' standard GEANT histogram activated:',10(1x,a4))
  }
  Else If Command=='STRUCTURES'
  {   Call KuGetS (string1,len1); Call KuGetS (string2,len2);
      Call AGKEEPS(string1(1:len1), string2(1:len2));
  }
  Else If Command=='TABLES'
  {   Call KuGetS (string1,len1); Call KuGetS (string2,len2);
      Call AGSTRUT(string1(1:len1), string2(1:len2));
  }
  Else If Command=='STOP'
  { stop ' quick exit ' }
  else
  { print *,' AGXuser: Unknown Command - ',command(1:lenocc(command)),
            ', Npar = ',Npar
  }
*
  end
 
 
+DECK,agsuser. ------------------------------------------------------------------
*CMZ :          19/07/97  14.41.41  by  Pavel Nevski
*CMZ :  1.30/00 29/04/97  23.40.13  by  Pavel Nevski
*-- Author :    Pavel Nevski   29/03/97
c***********************************************************************
      SUBROUTINE AGSUSER
c
c***  Subroutine called by GUINTI to process interactive commands
c***  New, highly simplified version for STAR Geant   pmj 6/6/95
c
c***********************************************************************
*
+CDE,typing,GCFLAG,QUEST,GCKINE,AGCKINE.
c
c*** defines structures for uniform decay of specified particles
c
      integer udecay_count
     >       ,udecay_count_max
     >       ,udecay_nstep
     >       ,udecay_nstep_max
     >       ,i_udecay
     >       ,udecay_nstep_last
 
      logical udecay_track, udecay_in_region_last_step
      real    udecay_pathlength_entrance
      parameter (udecay_count_max=10)
      parameter (udecay_nstep_max=5000)
 
+SELF,IF=-F77.
      structure /udecay_t/
         integer parent
         integer new_parent
         real    r_in
         real    r_out
         integer daughter_1
         integer daughter_2
         integer daughter_3
         real    mass_p
         real    mass_1
         real    mass_2
         real    mass_3
         integer nbody
      end structure
      record /udecay_t/ udecay(udecay_count_max)
 
      structure /udecay_step_t/
         real x
         real y
         real z
         real px
         real py
         real pz
         real pathlength
      end structure
      record /udecay_step_t/ udecay_step(udecay_nstep_max)
 
      common/c_udecay/
     >         udecay_count
     >        ,udecay
     >        ,udecay_nstep
     >        ,udecay_step
     >        ,i_udecay
     >        ,udecay_track
     >        ,udecay_in_region_last_step
     >        ,udecay_nstep_last
     >        ,udecay_pathlength_entrance
+SELF.
*---------------------------------------------------------------------------
 
      Integer       CSADDR, LENOCC, Input, Li, Ifile, Iadr, L, L1
      character*32  command
      character*256 string1/' '/, string/' '/
      character*1   blank  /' '/, char, C
      integer       npar, length1, length, line1, line
      logical       exist
      integer       i_part_dk
      equivalence   (string1,line1), (string,line)
 
c*** udecay stuff : local variables used in calls to gfpart
 
      character*20  p_name
      integer       p_itrtyp, p_nwbuf, i, j, ier, IPU(5)
      real          p_charge, p_tlife, p_ubuf
 
C========+=========+=========+=========+=========+=========+=========+
 
c***  Get command and number of parameters passed
 
       Ncommand = Ncommand+1
       call KUPATL( command, npar )
       if ( command .eq. 'INPUT' ) then
*     ----
         input = 0
         call kugetc( string, length )
         if (string(1:length) .eq. 'TX')      input    =  1
         if (string(1:length) .eq. 'TXOLD')   input    =  2
         if (string(1:length) .eq. 'TXOTX')   input    =  3
         if (string(1:length) .eq. 'FZ')      input    =  4
         if (string(1:length) .eq. 'FZTX')    input    =  5
         if (string(1:length) .eq. 'FZTXOLD') input    =  6
         IKINE    = -3
         Ccommand = ' '
*
         Do 500 Ifile = 1,Npar-1
*        - - - -
            call kugets (string1, length1)
            inquire (file=string1(1:length1), exist=exist)
            if ( .not. exist  ) then
               write(6,*)' file ',string1(1:length1),' does not exist'
               goto 500
            endif
 
            C  = ' '
            L  = LENOCC(Ccommand)+1
            Li = 21-L
            If (input .ge. 4) then
                input = input - 4
                write(6,*)'*** input: EGZ(FZ) file ',string1(1:length1)
                Call AgZOPEN ('PZ',string1(1:length1),'E',0,0)
                Call AGZREAD ('P',ier)
                IKINE = -3
                If (Ier.ne.0) go to 490
                C='e'
            else If (input .ge. 2) then
                input = input - 2
                write(6,*)'*** input:  Old TX file ',string1(1:length1)
                Call AgFOPEN (li,string1(1:Length1),ier)
                If (ier.ne.0) goto 490
                C='t'
            else If (input .ge. 1) then
                input = input - 1
                write(6,*)'*** input:  New TX file ',string1(1:length1)
                Call AgFOPEN (li,string1(1:Length1),ier)
                If (ier.ne.0) goto 490
                C='t'
            else
                Iadr=CSADDR('agusopen')
                if (Iadr.eq.0) goto 490
*               Comis pass whole words only (both start and length !)
                L1    = 4*((Length1+3)/4)
                call CSJCAL(Iadr,2,string1(1:L1))
                IKINE = -4
            endif
*
            IKineOld = Ikine
            if (C.ne.' ') Ccommand(L:L)=C
            go to 500
*
 490        write(6,*)' AgSUSER: error opening file ',string1(1:length1)
 500     Continue
*        - - - -
*
      else if ( command .eq. 'OUTPUT' ) then
*     ----
          call KUGETC ( string, length )
          char = string(1:1)
 
          if ( char .eq. 'O' ) then                     !  open output
 
              call KUGETS ( string1, length1 )
              write(6,*) ' GXUSER: opening output file ',
     >                              string1(1:length1)
              Call AgZOPEN  ('OZ',string1(1:length1),'GEKHD',0,0)
              Call AGZWRITE ('O',ier)
 
          else                                          !  close output
              Call AgZOPEN('O',' ',' ',0,0)
          endif
*
      else if (command.eq.'PHASESPACE'.or.command.eq.'MOMENTUMBIN') then
*     ----
              Call AGXUSER
 
      else if (command.eq.'SKIP') then
 
         call KUGETI( NtoSkip )
         call KUGETI( NsubToSkip )
         call KUGETI( NsubRan(1) )
         call KUGETI( NsubRan(2) )
         NEVENT = IEVENT+NtoSKIP
         CALL QNEXT
*
      else if (command.eq.'UDECAY') then
*     ----
+SELF,IF=-F77.
         if ( udecay_count .gt. udecay_count_max ) then
 
            write(6,*)' Too many uniform decay modes specified '
            goto 5000
 
         endif
 
         i = udecay_count + 1
         udecay(i).nbody  = 2
         call KUGETI( udecay(i).parent )
         call KUGETR( udecay(i).r_in )
         call KUGETR( udecay(i).r_out )
         call KUGETI( udecay(i).daughter_1 )
         call KUGETI( udecay(i).daughter_2 )
 
         if( npar .gt. 5 ) then
            udecay(i).nbody = 3
            call KUGETI( udecay(i).daughter_3 )
         endif
 
         udecay(i).r_in  = max (0.,             udecay(i).r_in)
         udecay(i).r_out = max (udecay(i).r_in, udecay(i).r_out)
 
c*** check to see if all particles exist in Geant:
 
         IPU(1)=udecay(i).parent
         IPU(2)=udecay(i).daughter_1
         IPU(3)=udecay(i).daughter_2
         IPU(4)=udecay(i).daughter_3
 
         Do J = udecay(i).nbody+1,1,-1
            call gfpart (IPU(i) , p_name, p_itrtyp, udecay(i).mass_p,
     >                            p_charge, p_tlife, p_ubuf, p_nwbuf)
 
            if ( p_itrtyp .le. 0 ) then
               write(6,*) '*** UDECAY: unknown particle id ',IPU(i)
               goto 5000
            endif
         enddo
 
c*** define new parent with identical properties but with infinite lifetime
 
         p_tlife = 1.e10
         p_name  = 'udecay_'//p_name(1:13)
         udecay(i).new_parent = udecay(i).parent + 200
 
         write(6,*)'*** Defining new udecay parent ',p_name,
     >             '  pid =',udecay(i).new_parent
 
         call gspart( udecay(i).new_parent, p_name, p_itrtyp,
     >           udecay(i).mass_p, p_charge, p_tlife, p_ubuf, p_nwbuf)
 
         call gprint( 'PART', udecay(i).new_parent )
 
c*** increment counter of number of defined udecay particles
 
         udecay_count = udecay_count + 1
*
+SELF.
      else if (command.eq.'SPARTSTAR') then
*     ----
         WRITE(6,*) '  => use  GEANT/CONTROL/SPART command '
*
      else if (command.eq.'GFDK') then
*     ----
         call KUGETI( i_part_dk )
         call GPDCAY( i_part_dk )
*
      else If (command.eq.'SECONDARIES') then
*     ----
         Call KUGETI(flag_secondaries)
         If(flag_secondaries.eq.0) write (6,7001)'ignored'
         If(flag_secondaries.eq.1) write (6,7001)'saved to jstak'
         If(flag_secondaries.eq.2) write (6,7001)'written to jkine'
 7001    format('  secondary products will be ',a)
*
      else If (command.eq.'VXYZ') then
*     ----
         do i=1,3
            Call KUGETR ( AvCOOR(i) )
         enddo
         write (6,*) ' primary vertex set to ',AvCOOR
*
      else If (command.eq.'VSIG') then
*     ----
         call KUGETR ( AvSIGM(1) )
         AvSIGM(2)  =  AvSIGM(1)
         call KUGETR ( AvSIGM(3) )
         write (6,*) ' primary vertex spread set to',AvSIGM(1),AVSIGM(3)
*
      else If (command.eq.'SUBEVENT') then
*     ----
         call KUGETI ( NtrSubEv )
         call KUGETI ( NkineMax )
         call KUGETI ( NhitsMax )
 
         If (NtrSubEv. gt. 0) write (6,*)
     >   ' Number of tracks per sub-event will be',NtrSubEv
 
         If (NtrSubEv. le. 0) write (6,*)
     >   ' Events will not be splitted into subevents '
*
      else If (command.eq.'SHADOW') then
*     ----
c***    flag to set tracking thresholds in dense materials very high.
c***    this will prevent showering in magnets and other dense
c***    objects but they will still block uphysical tracks
*
         call KUGETI ( make_shadow )
 
         if (make_shadow.eq.0) write (6,*)
     >      ' normal tracking in dense material required '
 
         if (make_shadow.eq.1) write (6,*)
     >      ' tracking thresholds in dense materials will be set high'
*
      else If (command.eq.'SENSECUTE') then
*     ----
**** PN, 1/04/96: *** flag for electron tracking cut in sensitive gases
         call KUGETR ( cutele_gas )
         write (6,*) ' cut for electron tracking in sensitive gases =',
     >                 cutele_gas
*
      else
*     ----
         write (6,*) ' unknown user command '
*
      endif
*     ----
c----------------------------------------------------------------------
 5000  continue
       return
       end
 
 
+DECK,gupart. -------------------------------------------------------------------
*CMZ :          30/10/97  11.01.25  by  Pavel Nevski
*CMZ :  1.30/00 29/03/97  18.01.53  by  Pavel Nevski
*-- Author :    P.Jacobs  20/03/95
      Subroutine GUPART
c**********************************************************************
c
c***Geant routine to define particle unknown to core Geant
c
c Author: P. Jacobs
c Creation date: 15/2/95
c
c Remark: the particle ID numbers used by the original STAR Geant
c in Geant v3.15 can no longer be used in v3.21 because of a significant
c expansion of idenitfied particles in the core Geant (CONS300-1). Therefore,
c particles should be refered to only symbolically, and their integer pid
c defined in one and only one place (i.e. gstar_pid.inc), constructed to be
c consistent with v 3.21 and not overwrite its definitions.    pmj 15/2/95
c
c Remark: branching ratios taken from Particle Data Booklet of July '94
c                             pmj 16/2/95
c
c-----------------------------------------------------------------------
      implicit none
c-----------------------------------------------------------------------
* #include "gstar_pid.inc"
c
c*** file of parameters and other definitions for symbolic reference to particle IDs
c*** specific to STAR Geant
c                               pmj  16/2/95
c------------------------------------------------------------------------------------
 
 
      integer pid_omega
     &   ,pid_phi
     &   ,pid_rho0
     &   ,pid_rho_plus
     &   ,pid_rho_minus
     &   ,pid_D_plus
     &   ,pid_D0
 
      parameter( pid_omega = 150 )
      parameter( pid_phi = 151 )
      parameter( pid_rho0 = 152 )
      parameter( pid_rho_plus = 153 )
      parameter( pid_rho_minus = 154 )
      parameter( pid_D_plus = 155 )
      parameter( pid_D0 = 156 )
 
c***  define quarks and gluon for jet studies: down, up, strange, charm,
c***  bottom, top and gluons
 
      integer pid_dq
     &   ,pid_dqb
     &   ,pid_uq
     &   ,pid_uqb
     &   ,pid_sq
     &   ,pid_sqb
     &   ,pid_cq
     &   ,pid_cqb
     &   ,pid_bq
     &   ,pid_bqb
     &   ,pid_tq
     &   ,pid_tqb
     &   ,pid_g
 
      parameter( pid_dq = 157 )
      parameter( pid_dqb = 158 )
      parameter( pid_uq = 159 )
      parameter( pid_uqb = 160 )
      parameter( pid_sq = 161 )
      parameter( pid_sqb = 162 )
      parameter( pid_cq = 163 )
      parameter( pid_cqb = 164 )
      parameter( pid_bq = 165 )
      parameter( pid_bqb = 166 )
      parameter( pid_tq = 167 )
      parameter( pid_tqb = 168 )
      parameter( pid_g = 169 )
 
c*** define laserino for tpc laser events (trackign type 6 = geantino)
 
	integer pid_laserino
	parameter( pid_laserino = 170 )
c-----------------------------------------------------------------------
      character*20 name, blank
      data blank/'                    '/
 
      integer      i_type,mode(6)
      real         amass,charge,tlife,bratio(6),amode(6)
      equivalence  (mode,Amode)
C=======================================================================
      name   = 'omega'
      i_type = 3
      amass  = .782
      charge = 0.
      tlife  = 7.79E-23
      Call Vzero(Bratio,6)
      Call Vzero(Amode,6)
 
      call gspart( pid_omega, name, i_type, amass, charge, tlife,0,0)
 
      bratio(1) = .888
      mode(1) = 70809
 
      bratio(2) = .085
      mode(2) = 107
 
      bratio(3) = .021
      mode(3) = 809
 
      call gsdk( pid_omega, bratio, mode )
c-------------------------------------------------------------------------
 
      name   = 'phi'
      i_type = 3
      amass  = 1019.41
      charge = 0.
      tlife  = 14.82e-23
      Call Vzero(Bratio,6)
      Call Vzero(Amode,6)
 
      call gspart( pid_phi, name, i_type, amass, charge, tlife,0,0)
 
      bratio(1) = .491
      mode(1) = 1112
 
      bratio(2) = .343
      mode(2) = 1016
 
*** group rho-pi and pi-pi-pi together (in practice indistinguishable)
*   pmj 16/2/95
 
      bratio(3) = .154
      mode(3) = 70809
 
      bratio(4) = .0128
      mode(4) = 1701
 
      bratio(5) = .00131
      mode(5) = 701
 
      call gsdk( pid_phi, bratio, mode )
*-------------------------------------------------------------------------
 
      name   = 'rho0'
      i_type = 3
      amass  = .770
      charge = 0.
      tlife  = 4.35E-24
      Call Vzero(Bratio,6)
      Call Vzero(Amode,6)
 
      call gspart( pid_rho0, name, i_type, amass, charge, tlife,0,0)
 
      bratio(1) = 1.
      mode(1) = 809
 
      call gsdk( pid_rho0, bratio, mode )
*-------------------------------------------------------------------------
 
      name   = 'rho_plus'
      i_type = 4
      amass  = .767
      charge = 1.
      tlife  = 4.35E-24
      Call Vzero(Bratio,6)
      Call Vzero(Amode,6)
 
      call gspart( pid_rho_plus, name, i_type,amass,charge,tlife,0,0)
 
      bratio(1) = 1.
      mode(1) = 807
 
      call gsdk( pid_rho_plus, bratio, mode )
*-------------------------------------------------------------------------
 
      name   = 'rho_minus'
      i_type = 4
      amass  = .767
      charge = -1.
      tlife  = 4.35E-24
      Call Vzero(Bratio,6)
      Call Vzero(Amode,6)
 
      call gspart( pid_rho_minus, name,i_type,amass,charge,tlife,0,0)
 
      bratio(1) = 1.
      mode(1) = 907
 
      call gsdk( pid_rho_minus, bratio, mode )
*-------------------------------------------------------------------------
 
      name   = 'D_plus'
      i_type = 4
      amass  = 1.869
      charge = 1.
      tlife  = 1.057e-12
      Call Vzero(Bratio,6)
      Call Vzero(Amode,6)
 
      call gspart( pid_D_plus, name, i_type, amass, charge, tlife,0,0)
 
*** For D+, include only K0_S + pi+ decay mode  pmj 16/2/95
 
      bratio(1) = 1.
      mode(1) = 1608
 
      call gsdk( pid_D_plus, bratio, mode )
*-------------------------------------------------------------------------
 
      name   = 'D0'
      i_type = 3
      amass  = 1.865
      charge = 0.
      tlife  = .415e-12
      Call Vzero(Bratio,6)
      Call Vzero(Amode,6)
 
      call gspart( pid_D0, name, i_type, amass, charge, tlife,0,0)
 
*** For D0, include only K+ + pi- decay mode  pmj 16/2/95
 
      bratio(1) = 1.
      mode(1) = 1208
 
      call gsdk( pid_D0, bratio, mode )
*-------------------------------------------------------------------------
 
c*** define quarks for EMC jet analysis with geantino tracking type,
c*** as done by Richard Morse   pmj 16/2/95
 
      i_type = 6
      amass  = 0.
      charge = 0.
      tlife = 1.e15
 
      call gspart(pid_dq, 'down quark',       6, 0., 0.,tlife,0,0)
      call gspart(pid_dqb,'antidown quark',   6, 0., 0.,tlife,0,0)
 
      call gspart(pid_uq, 'up quark',         6, 0., 0.,tlife,0,0)
      call gspart(pid_uqb,'antiup quark',     6, 0., 0.,tlife,0,0)
 
      call gspart(pid_sq, 'strange quark',    6, 0., 0.,tlife,0,0)
      call gspart(pid_sqb,'antistrange quark',6, 0., 0.,tlife,0,0)
 
      call gspart(pid_cq, 'charm quark',      6, 0., 0.,tlife,0,0)
      call gspart(pid_cqb,'anticharm quark',  6, 0., 0.,tlife,0,0)
 
      call gspart(pid_bq, 'bottom quark',     6, 0., 0.,tlife,0,0)
      call gspart(pid_bqb,'antibottom quark', 6, 0., 0.,tlife,0,0)
 
      call gspart(pid_tq, 'top quark',        6, 0., 0.,tlife,0,0)
      call gspart(pid_tqb,'antitop quark',    6, 0., 0.,tlife,0,0)
 
      call gspart(pid_g,  'gluon',            6, 0., 0.,tlife,0,0)
 
*--------+--------+---------+--------+---------+---------+---------+---------+
 
      name   = 'LASERINO'
      i_type = 6
      amass  = 0.
      charge = 0.
      tlife  = 1.e10
 
      call gspart( pid_laserino, name, i_type,amass,charge,tlife,0,0)
 
*---------------------------------------------------------------------
      Return
      End
 
+DECK,traceqc,If=-HPUX.
*CMZ :  1.30/00 29/03/97  18.01.53  by  Pavel Nevski
*-- Author :    Pavel Nevski   19/03/97
      SUBROUTINE TRACEQC
      WRITE(*,'('' Interrupt trace routine not available '')')
      END
 
+DECK,agmotif,if=-motif.
*CMZ :          17/11/97  18.33.05  by  Pavel Nevski
*-- Author :    Pavel Nevski   17/11/97
      subroutine PMINIT
      print *,'  PMINIT: motif interface not linked '
      end
      subroutine KUINIM(p)
      character*(*) p
      print *,'  KUINIM: motif interface not linked '
      end
      subroutine GBROS
      call       ZBRDEF
      end
      subroutine KUWHAM(p)
      character*(*) p
      call       KUWHAG
      end
 
 
+DECK,agupart, If=agupart.
*CMZ :  1.30/00 20/03/97  18.34.28  by  Pavel Nevski
*-- Author :    Pavel Nevski   20/03/97
***********************************************************************
*
         Subroutine aGUPART
*
* Remark: the particle ID numbers used by the original STAR Geant
* in Geant v3.15 can no longer be used in v3.21 because of a significant
* expansion of idenitfied particles in the core Geant (CONS300-1). Therefore,
* particles should be refered to only symbolically, and their integer pid
* defined in one and only one place (i.e. gstar_pid.inc), constructed to be
* consistent with v 3.21 and not overwrite its definitions.    pmj 15/2/95
*
* Remark: branching ratios taken from Particle Data Booklet of July '94
*
* Author: P. Jacobs
* Creation date: 15/2/95
*-----------------------------------------------------------------------
      implicit      none
      character*20  name
      integer       TrkTyp,nwb,mode(6)
      real          amass,charge,tlife,ub,bratio(6)
*
*     included gstar_pid.inc
*
      PARTICLE omega=150 TrkTyp=3  mass=.782    charge=0  tlife=7.79E-23,
                         bratio  = { .888, .085, .021 },
                         mode    = { 70809, 107,  809 }
 
*     group rho-pi and pi-pi-pi together (in practice indistinguishable)
      Particle phi=151   TrkTyp=3  mass=1019.41 charge=0  tlife=14.82e-23,
                         bratio = { .491, .343, .154, .0128, .00131 },
                         mode   = { 1112, 1016, 70809, 1701, 701}
 
      Particle rho0=152  TrkTyp=3 mass =.770  charge=0   tlife=4.35E-24
                         bratio = { 1.  }    mode   = { 809 }
 
      Particle rho_plus=153 TrkTyp=4  mass =.767 charge=1 tlife=4.35E-24
                         bratio = { 1.  }    mode   = { 807 }
 
      Particle rho_minus=154 TrkTyp=4  mass =.767 charge=-1 tlife=4.35E-24
                         bratio = { 1.  }    mode   = { 907 }
 
*     For D+, include only K0_S + pi+ decay mode  pmj 16/2/95
      Particle D_plus=155  TrkTyp=4  mass =1.869  charge=1  tlife =1.057e-12
                         bratio = { 1.  }    mode   = {1608 }
 
*     For D0, include only K+ + pi- decay mode  pmj 16/2/95
      Particle D0=156      TrkTyp=3  mass =1.865  charge=0  tlife =.415e-12
                         bratio = { 1.  }    mode   = {1208 }
 
*    define quarks with geantino tracking type, as done by Richard Morse
 
      Particle down_quark=157 TrkTyp=6 mass=0 charge=0 tlife=big
      Particle antidown_quark   =158
      Particle up_quark         =159
      Particle antiup_quark     =160
      Particle strange_quark    =161
      Particle antistrange_quark=162
      Particle charm_quark      =163
      Particle anticharm_quark  =164
      Particle bottom_quark     =165
      Particle antibottom_quark =166
      Particle top_quark        =167
      Particle antitop_quark    =168
      Particle gluon            =169
      Particle LASERINO=170  TrkTyp=6  mass=0  charge=0  tlife=big
*
 End
 
 
+DECK,qnext,T=GEANT. -----------------------------------------------------------
*CMZ :  1.30/00 15/04/97  19.40.26  by  Pavel Nevski
*-- Author :    Pavel Nevski   18/03/97
************************************************************************
      SUBROUTINE QNEXT
*                                                                      *
* Description:    Process events, protected against ZEBRA faults       *
* Modifications:  Clear ZEBRA storage after memory fault   PN 01/04/97 *
************************************************************************
+CDE,GCBANK,GCUNIT,GCFLAG,GCTIME,QUEST,SCLINK,MZCA.
      REAL    TIMNOW/0/
      INTEGER IDEBAG/0/,TRIG/0/,AgPHASE
      COMMON /AgCPHASE/ AgPHASE
*
         TRIG      = TRIG + 1
         IQUEST(1) = 1
         CALL ZPHASE(1)
*
         DO WHILE (IEVENT<NEVENT)
            IQUEST(1)= 0
            IEORUN   = 0
            NQTRAC   = 0
            NQERR    = 0
            AgPHASE  = 1
 
*          due to the chaining of RAW data, drop the first one (if it is there)
            If (LKARAW>0) then
               IQ(LKARAW-5) = 0
               CALL MZDROP(IxSTOR,LKARAW,'.')
               If (LKARAW.GT.0) IQ(LKARAW-5) = 1
            Endif
*           clean up memory - fully or partially
            If (LKARAW.EQ.0) CALL GTRIGC
            If (LKARP1.GT.0) CALL MZDROP(IxSTOR,LKARP1,'L')
            If (JHEAD.GT.0)  CALL MZDROP(IxSTOR,JHEAD,'L')
*
            CALL TIMEL(TIMNOW)
*          Check time left
            IF (ITIME.GT.0 .and. TIMNOW.LE.TIMEND) Then
               WRITE(CHMAIL,10001) TIMEND
10001          FORMAT(' ***** THE JOB STOPS NOW because the TIME',
     >                ' left is less than ',F12.3,' seconds *****')
               CALL GMAIL(0,1)
               IQUEST(1) = 1
               GO TO 19
            ENDIF
*
*              initialise event counters
            IEVENT=IEVENT+1
            IDEBAG=IDEBUG
            CALL GTRIGI
            IDEBUG=max(IDEBUG,IDEBAG)
            CALL GRNDMQ(IQ(JRUNG+19),IQ(JRUNG+20),0,'G')
            IQ(JRUNG+29)=IEVENT
*              Normal GEANT simulations (GTREVE) or RAW DATA here
            If (LKARAW.EQ.0) then
               CALL GTRIG
            else             !  very special case - test beam data
               CALL AgBEAMdat
               Call GUOUT
            endif
            CALL GFHSTA
            Call GRLEAS(JHITS)
            If (JKINE>0) Call ZSORTI(IxSTOR,JKINE,-5)
            If (JHITS>0) Call ZSORTI(IxSTOR,JHITS,-5)
*
            IF(IEORUN.NE.0) Then
               WRITE(CHMAIL,10002) TIMNOW
10002          FORMAT(' ***** THE JOB STOPS NOW because the IEORUN',
     >                ' flag set by user, Time left is ',F12.3,' *****')
               CALL GMAIL(0,1)
               IQUEST(1) = 1
               GO TO 19
            ENDIF
*
            IF(IQUEST(1).NE.0) Then
               WRITE(CHMAIL,10003) TIMNOW
10003          FORMAT(' ***** THE JOB STOPS NOW because the IQUEST',
     >             ' flag set by program, Time left is ',F12.3,' *****')
               CALL GMAIL(0,1)
               IEORUN = 1
               GO TO 19
            ENDIF
         ENDDO
 
  19     Nevent  = Ievent
         TRIG    = 0
         AgPHASE = 0
 
      END
 
 
+DECK,gdebug,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 27/11/96  15.51.58  by  Pavel Nevski
*-- Author :    Rene Brun
      SUBROUTINE GDEBUG
************************************************************************
*             Standard GEANT debug                                     *
*          ==>Called by : <USER>,GUSTEP                                *
************************************************************************
+SEQ,GCFLAG,GCKINE,GCTRAK.
*
*             Debug/plot event
            IF (IDEBUG=0) Return
*
C.      Store space point VECT in banks JXYZ
        IF (ISWIT(2)=1 | ISWIT(2)=4 | ISWIT(3)=1)  Call GSXYZ
 
C.      Print track and volume parameters at current point
        IF (ISWIT(2)=2)                            Call GPCXYZ
 
C.      Print kinematics of secondary tracks at the current interaction point
        IF (ISWIT(1)=2)                            Call GPGKIN
 
C.      Online display of the track trajectory
        IF (ISWIT(2)=3) then
           IF(ISWIT(4)=3 & CHARGE=0) RETURN
                                                   Call GDCXYZ
                                                   Call IGSA(0)
        ELSE IF(ISWIT(2)=4) THEN
C.      Store space point VECT in banks JXYZ
           IF(ISTOP.NE.0)                          Call GDTRAK(' ')
        ENDIF
*
      END
 
 
+DECK,gukine,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 17/07/96  15.57.39  by  Pavel Nevski
*-- Author :    A. Rozanov  11/03/95
***************************************************************************
*                                                                         *
                Subroutine  G U K I N E
*                                                                         *
* Description: Read or Generate Kinematics for primary tracks             *
***************************************************************************
+CDE,TYPING,GCVOLU.
        Call AgZKINE
* do it for savety, JGPAR may be dropped
        NLEVEL=0
END
 
 
+DECK,GUTREV,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 29/07/96  12.00.03  by  Pavel Nevski
*-- Author :    R.Brun
***********************************************************************
*                                                                     *
                SUBROUTINE G U T R E V
*                                                                     *
*     User routine to control tracking of one event                   *
*     ==>Called by : GTRIG                                            *
***********************************************************************
+CDE,TYPING,GCBANK,SCLINK,GCFLAG,GCKINE,AGCKINE.
      Integer LENOCC,CsADDR,Nd,Id,IP,address/0/
+CDE,STAFUNC.
*
      Nd=0;  If (LKDETM>0) Nd=IQ(LKDETM-2)
* following the best RDW traditions
      Do id=1,ND
         Check LQ(LKDETM-id)>0
         IP=LWPRIN(id)
         If (IDEBUG>0) IP=max(IP,LWDEBU(id))
         IQ(LQ(LKDETM-id)+1)=IP
      enddo
*
      address=CsADDR ('AGUTREV')
      if (address>0) CALL CsJCAL (address,0)
*
* By default (No ACTION command issued) GEANT simulations are done if:
* a: IKINE<0 and reading of HITS, DIGI and RECB is prohibited,  b: IKINE>=0.
* If ACTION is issued, Geant simulations should be asked explicitely
*
      If (Lenocc(CrunType)>0) then
         Check  Index(CrunType,'S')>0  | Index(CrunType,'*')>0
      else If (IKine<=0) then
         Check  Index(CoptKine,'H')==0 & Index(CoptKine,'D')==0
         Check  Index(CoptKine,'R')==0 & Index(CoptKine,'*')==0
      endif
 
* In addition, the presence of KINE tracks and VOLUMES and
* absence of HITS and DIGIts are required
 
      If (JHITS==0 & JDIGI==0 & JVOLUM>0 & JKINE>0) then
        CALL GTREVE
      endif
      END
 
 
+DECK,GUTRAK,T=GEANT. -------------------------------------------------------------
*CMZ :  1.30/00 17/04/97  20.57.01  by  Pavel Nevski
*-- Author : R. Brun
******************************************************************
             SUBROUTINE   G U T R A K
* Description: User routine to control tracking of one track     *
******************************************************************
+CDE,typing,GCFLAG,AGCKINE.
     integer CsADDR,idevt0/-1/,address/0/
*
     CALL AGCHAIN(NhitsMax,NkineMax)
     If (Idevt0 != Idevt) then
         Idevt0  = Idevt
         address = CsADDR ('AGUTRAK')
     endif
*
     if (address>0) CALL CsJCAL (address,0)
     CALL GTRACK
*
      END
 
 
+DECK,GUSKIP,T=geant. -----------------------------------------------------------
*CMZ :  1.30/00 01/04/97  15.49.43  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.25  by  S.Giani
*-- Author :
      SUBROUTINE GUSKIP (ISKIP)
C.
C.    ******************************************************************
C.    *                                                                *
C.    *   User routine to skip unwanted tracks                         *
C.    *                                                                *
C.    *   Called by : GSSTAK                                           *
C.    *   Author    : F.Bruyant                                        *
C.    *                                                                *
C.    ******************************************************************
C.
+CDE,TYPING,GCBANK,GCFLAG,GCKINE,GCKING,GCNUM,GCUNIT.
*
      Integer CsADDR,address/0/,Idevt0/-1/,ISKIP,L,ITRT,NVER
*
      ISKIP = 0
 
      If (Idevt0.ne.IDEVT) then
          Idevt0  = IDEVT
          address = CsADDR ('AGUTREV')
      End IF
 
      If (NGKINE.eq.0. and. JKINE.gt.0) then
*     skip particles with a vertex produced - not final state
         L = LQ(JKINE-ITRA)
         If (L.gt.0) then
            ITRT = Q(5+L)
            Nver = Q(7+L)
            If ( NVER.gt.0 .or. ITRT.le.0) then
               ISKIP = -1
               If (IDEBUG.ge.3) write (LOUT,1001) ITRA
 1001          FORMAT(' *** GUSKIP: skip track number ',i8)
            endif
         endif
      endif
 
      if (address.gt.0) CALL CsJCAL (address,1,ISKIP)
 
      END
 
 
+DECK,GUSTEP,T=geant. ----------------------------------------------------------
*CMZ :          06/02/98  15.16.04  by  Pavel Nevski
*CMZ :  1.30/00 22/04/97  20.18.53  by  Pavel Nevski
*-- Author :    Alexandre Rozanov 02.04.95
****************************************************************************
                SUBROUTINE   G U S T E P
*                                                                          *
*  Description: process one geant  step throu a volume                     *
****************************************************************************
+CDE,TYPING,GCBANK,SCLINK,GCUNIT,GCFLAG,GCKING,GCKINE,GCTRAK,AGCKINE,AGCHADR.
     INTEGER   CsAddr,Itry,Iret/0/,Idet/-1/,Isimu/0/,Idevt0/-1/,address/0/
+CDE,STAFUNC.
*
   If Idevt0 != Idevt               " On a new event set USER and TRAC: "
   {  Idevt0  = Idevt;                address=CsADDR ('AgUstep')
      Call ASLDETN('TRAC',Idet);      If (Idet>0) ISIMU=LVSIMU(Idet)
   }
*
   CALL AgGSTEP(IRET)                           ! standard hit processing
   If (Idebug>0 & ISWIT(2)==3) Call GDEBUG      ! for graphics only
   if (ipart == 48)            Call AgSMATER    ! geantino run
*
   DO itry=1,10        " let hadronic package produce what it needs "
   {  IF (NGKINE>0) then                           ! decide on secondaries
         CALL VZERO(IFLGK,NGKINE)
         If (ISIMU>=1)            Call AgUsecond   ! - mechanism based
         If (Flag_secondaries>=2) Call AgsSECOND   ! - dense media
      endif
*
      if (address>0) CALL CsJCAL (address,0)       ! let user do something
*
      If (NGKINE<=0)   Break
         NDONE += NGKINE
         CALL GSKING(0)   " really save secondaries "
         NGKINE = 0
         if (NREST<=0) Break
         CALL GUHADR
    }
 
        if(ngphot.gt.0.)then
           CALL GSKPHO(0)
        endif
 
    If (NREST>0) <W> itry,NDONE,NREST
       (' GUSTEP ERROR: after ',i2,' iterations and ',i5,'particles done'/,
          15x,        ' still ',i5,' particles left in hadronic package')
    NDONE=0
 
*
 END
 
 
+DECK,GUFLD,T=geant. -----------------------------------------------------------
*CMZ :  1.30/00 10/04/96  18.46.17  by  Pavel Nevski
*CMZU:  1.00/01 16/11/95  02.01.56  by  Pavel Nevski
*-- Author :    P. Nevski
************************************************************************
*                                                                      *
                SUBROUTINE   G U F L D (VECT,FIELD)
*                                                                      *
* Description: Geant user routine for FIELD definition step by step    *
* Arguments  : VECT   (in)   -              tracking position          *
*              Field  (out)  -              filed map at vect          *
************************************************************************
+CDE, TYPING,GCUNIT,GCFLAG.
*
      REAL      VECT(3),FIELD(3)
      Integer   CSADDR,Iprin/2/,address/0/,IevOLD/-1/
      Logical   FIRST/.TRUE./
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*    make it possible to replace field routine between events
      IF (IEVENT != IEVOLD) THEN
         address=CsADDR ('AGUFLD')
         IEVOLD=IEVENT
      endif
*
      if (address>0) then
         CALL CsJCAL (address,2,VECT,Field)
      Else
         Field={0.,0.,0.}
      Endif
*
      END
 
 
+DECK,gudigi,T=geant. ------------------------------------------------------------
*CMZ :          14/07/97  16.44.31  by  Pavel Nevski
*CMZ :  1.30/00 07/07/96  13.08.33  by  Pavel Nevski
*-- Author :    Pavel Nevski   07/07/96
     subroutine    G U D I G I
+CDE,typing,GCBANK,SCLINK.
     Integer      CsADDR,Nset,Ndet,Iset,Idet,Ldete,Lsete,address
     Character*4  Cset,Cdet
+CDE,STAFUNC.
 
     Check LkDetm>0 & Jset>0 & Jhits>0
     Ndet  = IQ(LkDetm-2);       Check Ndet>0
     Nset  = IQ(Jset - 2);       Check Nset>0
     Do Idet=1,Ndet
        Ldete=LQ(LkDetm-Idet);   Check Ldete>0
        Check LvDIGI(Idet)>0
        Call UHTOC(IQ(LkDetm+Idet),4,Cdet,4)
        Do Iset=1,Nset
           Lsete=LQ(Jset-Iset);  Check Lsete>0
           Call UHTOC(IQ(Jset+Iset),4,Cset,4)
           Check Cdet(1:3)//'H'==Cset
           address=CsADDR (cdet//'DIG')
*           print *,'digi routine for ',cdet,': address=',address
           if (address>0) CALL CsJCAL (address,0)
        enddo
     enddo
*
     address=CsADDR ('AGUDIGI')
     if (address>0) CALL CsJCAL (address,0)
 
     end
 
 
+DECK,guout,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 06/07/96  00.19.32  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/06/96
******************************************************************************
*                                                                            *
                   Subroutine  G U O U T
*                                                                            *
******************************************************************************
+CDE,TYPING,QUEST,GCFLAG,AgCKINE.
     Integer  Ier
*
      If (IOutp!=IOutpOld) then
         If (IOutp==-1) Call AgZOPEN('O','ZEBRA.O','*',0,0)
         If (IOutp > 0) IOutpOld = Ioutp
      endif
*
      Ier   = 0
      If (IOutpOld==-1)   call AgZwrite('O',ier)
      If (ier != 0)       { IOutpOld = 0;  IQUEST(1)=Ier; IEORUN=1; }
*
END
 
 
+DECK,guhadr,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 19/04/97  21.12.12  by  Pavel Nevski
*-- Author :    Rashid Mekhdiev
****************************************************************************
                SUBROUTINE   G U H A D R
****************************************************************************
+CDE, TYPING,GCPHYS,GCTRAK,GCKING.
*
      IF      IHADR==0  { ISTOP=2; KCASE=NAMEC(12); DESTEP+=GEKIN; }
      ELSE IF IHADR<=3  { CALL GHEISH }
      ELSE IF IHADR==4  { CALL FLUFIN }
      ELSE IF IHADR==5  { CALL GFMFIN }
      ELSE IF IHADR==6  { CALL GCALOR }
*
      END
 
 
+DECK,guphad,T=geant. -------------------------------------------------------------
*CMZ :  1.30/00 17/04/97  19.08.11  by  Pavel Nevski
*-- Author :    Rashid mekhdiev
****************************************************************************
      SUBROUTINE GUPHAD
****************************************************************************
+CDE, TYPING, GCPHYS.
      IF       IHADR<=3 {"geisha"       CALL GPGHEI  }
      ELSE IF  IHADR==4 {"fluka"        CALL FLDIST  }
      ELSE IF  IHADR==5 {"fluka+Mikap"  CALL GFMDIS  }
      ELSE IF  IHADR==6 {"gcalor"       CALL CALSIG  }
      END
 
 
+DECK,rndm,T=geant. -----------------------------------------------------------
*CMZ :          30/01/98  13.07.52  by  Pavel Nevski
*CMZ :  1.30/00 20/04/97  23.19.45  by  Pavel Nevski
*-- Author :    Pavel Nevski
******************************************************************
*                                                                *
                Function    R N D M (x)
*                                                                *
******************************************************************
      logical first/.true./
*
        if (first) print *,' *******  RNDM substituted by GRNDM  *******'
        first=.false.;   call GRNDM(r,1);   rndm=r;  Return;
      entry IRNDM
        if (first) print *,' *******  RNDM substituted by GRNDM  *******'
        first=.false.;   call GRNDM(i,1);  irndm=i;  Return;
      END
*
      subroutine NORRAN (a)
      real    a,b/99999/
      logical first/.true./
       if (first) print *,' *******  NORRAN substituted by RANNOR  *******'
       if b==99999 { call rannor(a,b); first=.false. } else { a=b; b=99999 }
      end
*
      function  RANF (a)
      real      RANF,a,b
      logical   first/.true./
       if (first) print *,' *******  RANF substituted by GRNDM  *******'
       first=.false.
       Call GRNDM(b,1)
       RANF=b
      end
*
      function  RN32(a)
      real      RN32,a,b
      logical   first/.true./
       if (first) print *,' *******  RN32 substituted by GRNDM  *******'
       first=.false.
       Call GRNDM(b,1)
       RN32=b
      end
*
      function  RG32(d)
      real      RG32,d,a,b/99999/
      logical   first/.true./
       if (first) print *,' *******  RG32 substituted by RANNOR  *******'
       if b==99999 { call rannor(a,b); first=.false. } else { a=b; b=99999 }
       RG32=a
      end
*
      Subroutine RDMIN
      entry      RDMOUT
        print *,' RNDM substituted by GRNDM, set seed using G/CONT/RNDM'
      end
*
      Subroutine RN32IN
      entry      RN32OT
        print *,' RN32 substituted by GRNDM, set seed using G/CONT/RNDM'
      end
*
      Subroutine RG32IN
      entry      RG32OT
        print *,' RG32 substituted by RANNOR, set seed using G/CONT/RNDM'
      end
*
 
 
 
+DECK,gcalor,T=geant,if=-GCALOR. ----------------------------------------------
*CMZ :          18/12/97  17.27.24  by  Pavel Nevski
*CMZ :  1.30/00 29/03/97  18.01.53  by  Pavel Nevski
*-- Author :    Pavel Nevski   15/08/96
 
      SUBROUTINE GCALOR
      print *,' No GCALOR available in this version'
      end
      SUBROUTINE CALSIG
      print *,' No GCALOR available in this version'
      end
 
 
+DECK,traceq,T=geant.
*CMZ :          21/11/97  15.17.21  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  18.16.37  by  Pavel Nevski
*-- Author :    Pavel Nevski
************************************************************************
      subroutine TRACEQ(LUNP,LEV)
*                                                                      *
* Description: dispatch an abnormal situation (arithmetics or ZEBRA)   *
************************************************************************
      Implicit NONE
      Integer  LUNP,LEV,AgPHASE,IgPAW,IwTYP
      Common /AgCPHASE/ AgPHASE
      Common /AgCIPAW/  IgPAW,IwTYP
*
      call traceqc
      If AgPHASE>0                                 " in event loop  "
      {  call qnexte; print *,' in traceq: qnexte exit' }
      ELSE IF IgPAW>0                              " single command "
      {  call kusibr; print *,' in traceq: kusibr exit' }
*
      print *,' Abnormal break recovery - only limited functionality'
      CALL   AGPAWQ
      STOP ' TRACEQ '
 
      END
 
 
+DECK,ISLFLAG,T=geant.
*CMZ :  1.30/00 15/07/96  15.54.59  by  Pavel Nevski
*-- Author :    P.Nevski    20/01/94
***************************************************************************
                FUNCTION   I S L F L A G (CHDET,CHFLAG)
***************************************************************************
+CDE,TYPING,GCBANK,SCLINK,GCUNIT,AsFLAGS.
      INTEGER      ISLFLAG,IDET,IFLAG
      CHARACTER*4  CHDET,CHFLAG
*
      ISLFLAG = -1;    check LkDETM>0
      CALL GLOOK(CHDET,IQ(LkDETM+1),IQ(LkDETM-1),Idet)
      check Idet>0;    Check LQ(LkDETM-Idet)>0
*
      ISLFLAG = -2
      DO IFLAG = 1,NFLAGS
         check CHFLAG==CFLAG(IFLAG)
         ISLFLAG = IQ(LQ(LKDETM-IDET)+IFLAG)
         Return
      END DO
      END
 
+DECK,zabend,T=geant.
*CMZ :          05/12/97  18.00.22  by  Pavel Nevski
*CMZ :  1.30/00 27/03/97  19.14.44  by  Pavel Nevski
*-- Author :    Pavel Nevski   10/04/96
**************************************************************************
                subroutine   z a b e n d (NQCASE,LINK)
**************************************************************************
+cde,gcbank,gcunit,gcnum,gcvolu,quest.
 
  Integer      i,NQCASE,LINK
  Character    Cname*8
  Equivalence (Cname,IQUEST(9))
*
* print *,'*************************************************************'
* print *,'***       Our old Zebra is heavilly ill, almost dead      ***'
* print *,'***       next time try to treat her more carefully       ***'
* print *,'***                 Or ask Pavel to save her              ***'
* print *,'*************************************************************'
*
* Call UHTOC(IQUEST(9),4,CNAME,8)
  <w> Nzebra,Cname,NQCASE,NQPHAS,NQFATA
  (' zebra age = ',i8,' hinted by ',a8,' for case ',i4,
   ' in phase ',i3,' fatality ',i3)
 
  If Cname='MZGAR1'
  {  L= "LQSYSR(KQT+1)" LINK;
     IF (NQCASE==1) <w> IQUEST(11),(IQ(L+i),i=-5,1)
     (' LACK OF SPACE to push a bank,',i8,' words missing '/,
      ' bank ID=',i6,a6,'  NL,ND=',3i8,'  system, data=',2i12)
  }
  else If Cname='MZTABC'
  { IF (NQCASE==1) print *,' the BANK CHAINING is CLOBBERED (corrupted)',
                           ' the start of clobbered region is ',IQuest(11)  }
  else If Cname='MZPUSH'
  { if (NQCASE==1) print *,' this means the link ',IQUEST(11),' is invalid '}
  else If Cname='ZSHUNT'
  { if (NQCASE==2) print *,' the supporting link ',IQUEST(12),' is invalid '}
  else If Cname='FZLOC'
  { print *,' FZLOC reports an illegal FZ control information access (p.269)'
    print *,' Lun=',iquest(11),' I/O mode (1-i, 2-o) ',iquest(12)
    If (NQCASE==1) print *,' WRITE after READ without switching by FZENDI  '
    If (NQCASE==2) print *,' READ after WRITE without switching by FZENDO  '
    If (NQCASE==3) print *,' access permision fault, e.g. write protected  '
    If (NQCASE==4) print *,' access to the file was not declared by FZFILE '
  }
  else
 {  Print *,' JVOLUM,NVOLUM =',JVOLUM,Nvolum
    If 0<Jvolum&Jvolum<Nzebra
  { If (IQ(Jvolum-1)!=Nvolum) print *,' real VOLU bank length=',IQ(Jvolum-1) }
  else
  { print *,' JVOLUM points outside reasonable area '}
 
  Print *,' JGPAR,NLEVEL  =',JGPAR,NLEVEL
  If (0<JGpar & JGpar<Nzebra)
  { print *,' real GPAR bank data/link length=',(IQ(JGPAR-i),i=1,3)
    "If (IQ(JGPAR-1)<=0)" JGpar=0
  }
  print *,' that is all for the moment, Have you done GGCLOS ? '
 }
  <w> (IQUEST(i),i= 1,10); (' Iquest=',10i9)
  <w> (IQUEST(i),i=11,20); (' Iquest=',10i9)
  NQCASE=0
  end
 
 
+DECK,agdummy,T=text. ---------------------------------------------------------
*CMZ :          13/02/98  14.41.58  by  Pavel Nevski
*CMZ :  1.30/00 12/05/97  18.07.33  by  Pavel Nevski
*CMZ :  1.00/00 03/08/95  12.32.47  by  Pavel Nevski
*-- Author :    Pavel Nevski   03/08/95
*************************************************************************
                SUBROUTINE    A G D U M M Y
*  description - a routine to force loading of library routines 	*
*                frequently used in some users codes                    *
Replace[REF#,#;] with [{IF}[EXIST 1]{Call #1;Call CsExt('D',#1);REF #2,;}]
*************************************************************************
Replace[LIST #;] with [ #1 _
 "Geant  "   GfKine,GfVert,GfPart,GfPath,GfHead,GDtoM,GMtoD,GlVolu,
             GpKine,GLast,GsHEAD,GsCKOV,GuPart,GpIons,Grndm,Granor,
 "vector "   vdist,vscale,vadd,vmod,sortzv,vfill,Ublank,Ufill,Uzero,IuLast,
 "tr-prop"   trprfn,trprop,trscsp,trspsc,trscsd,trsdsc,
 "minuit "   mnseti,mninit,mnstat,mnexcm,mnpout,mnparm,
 "matrix "   Rsinv,Dsinv,Rinv,Dinv,Ssmt5t,Xmm55,Dmmlt,
 "ffread "   ffinit,ffset,ffkey,ffget,ffgo,
 "random "   poissn,norran,rndm,rnorml,dircos,
 "random "   binomi,rngama,gauss,proxim,
 "comis  "   csjcal,csaddr,jumpad,Jbyt,
 "interp "   fint,polint,lfit,divdif,lfitw,lvsimx,
 "zebra  "   mzvolm,mzdred,zverif,
 "hbook  "   hplfun,hpagsz,hnoent,
 "somesg "   rm48,rm48in,rsfact,rsfinv,rsfeqn,dsfact,rfft,cfft
 " sind,cosd "
 ]
+CDE,GCFLAG.
  Integer  SystemF,Ix/0/
  list external;
* make sure that real calls will never be done even if this routine is called
  Ix = Ix+1;  if (Ix<=0) Return;
  Ix = Ix+1;  if (Ix>=0) Return;
  ix=SystemF(' ')
* now fake calls to library - no need for arguments
  list ref;
*
  END
 
 
 
+DECK,acmain,T=CC,If=CC. ------------------------------------------------------
/*CMZ :          07/12/97  14.21.32  by  Pavel Nevski*/
/*-- Author :    Pavel Nevski   28/11/97*/
/*****************************************************/
/*                    m a i n                        */
/*****************************************************/
#include <string.h>
static int        Margc=0;
static char **    Margv=NULL;
extern "C"  int   agmain_ ();
extern "C"  int   getarg_ (int*, char*, int);
extern "C"  void  k_setar (int , char** );
 
int main    (int argc, char *argv[])
{ Margc=argc;  Margv=argv;  k_setar(argc,argv);  agmain_(); }
 
int getarg_ (int *k, char *args, int n)
{ int i=0;   if (*k<Margc) i=strlen(Margv[*k]);  if (i>n) i=n;
  strncpy(args,Margv[*k],i);   memset (args+i,' ',n-i); return 0;
}
 
+DECK,afmain,IF=-CC.
*CMZ :          06/12/97  11.46.00  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/12/97
       program afmain
       call agmain
       end
+DECK,astaf,T=CC. -----------------------------------------------------------
/*CMZ :          14/03/98  22.05.30  by  Pavel Nevski*/
/*-- Author :    Pavel Nevski   28/11/97*/
/*****************************************************/
/*               S T A F   i n t e r f a c e         */
/*****************************************************/
#ifdef STAF
#include <stream.h>
#include <stdlib.h>
#include <string.h>
#include "asuLib.h"
#include "emlLib.h"
#include "socLib.h"
#include "spxLib.h"
#include "tdmLib.h"
#include "duiLib.h"
#include "dioLib.h"
#include "amiLib.h"
#include "tntLib.h"
#include "topLib.h"
extern "C" void staf_banner (FILE* stream);
#endif
 
extern "C" void staf_start_ () {
#ifdef STAF
   asu_init(); asu_start();
   eml_init(); eml_start();
   soc_init(); soc_start();
   spx_init(); spx_start();
   tdm_init(); tdm_start();
   dui_init(); dui_start();
   dio_init(); dio_start();
   ami_init(); ami_start();
   top_init(); top_start();
   tnt_init(); tnt_start();
   staf_banner(stdout);
#endif
}
 
extern "C" void staf_stop_ ()  {
#ifdef STAF
   tnt_stop();
   ami_stop();
   dio_stop();
   dui_stop();
   tdm_stop();
   spx_stop();
   soc_stop();
   eml_stop();
   asu_stop();
#endif
}
 
/*---------------------------------------------------------------------*/
 
extern "C" int staftab_(char* path, char* name, char* spec, long* l,
                        char* data, int lp, int ln, int ls)
{
#ifdef STAF
  tdmDataset*       tDs = NULL; // pointer to tdm class member function
  tdmTable*         aDs = NULL; // pointer to table finder function
  DS_DATASET_T*     pDs = NULL; // pointer to directory table
  DS_DATASET_T*     dDs = NULL; // pointer to dataset table
 
  char cpath[132];  cpath[0]=0;  strncat(cpath,path,lp);
  char cname[32];   cname[0]=0;  strncat(cname,name,ln);
  char cspec[2048]; cspec[0]=0;  strncat(cspec,spec,ls);
  long k=*l;
  //             this should work,  but it does not
  //  ier=dsNewDataset(&ds,cpath);  tdm->createTable(name, ds);
 
  if (!(tDs=tdm->findDataset(cpath))) dui->mkdir(cpath);
 
  if ( (tDs=tdm->findDataset(cpath))
       &&  (tDs->cvtDslPointer((DSL_PTR_T &)pDs)) && pDs)
     { for (int i=0;  i < pDs->elcount;  i++)
       { // printf (" dataset %d %d %d %s tested \n",i,pDs->p.link[i],
         //          (pDs->p.link[i])->flags, (pDs->p.link[i])->name);
         if ((dDs=pDs->p.link[i]) && dDs->flags && !strcmp(dDs->name,cname))
         {  if (k<0)
            { size_t rsize;  dsTableRowSize(&rsize,dDs);
              if (rsize)     k=(-k)/(rsize/sizeof(k));
              int d=k*rsize+(*l)*sizeof(k);
              if (!d) printf (" table %s rsize=%d k=%d %d\n",cname,rsize,*l,d);
            }
            dDs->maxcount = k;
            dDs->elcount  = k;
            dDs->p.data   = data;
            return          k;
            // return (DSL_PTR_T &) dDs;
       } }
       return dsAddTable(pDs,cname,cspec,k,&data);
     }
  printf (" staftab: directory %s not found \n",cpath);
#endif
  return 0;
}
 
 
+DECK,sldetn,T=geant.
*CMZ :          06/01/98  13.08.02  by  Pavel Nevski
*CMZ :  1.30/00 15/07/96  15.54.59  by  Pavel Nevski
*-- Author :    P.Nevski    20/01/94
***************************************************************************
                SUBROUTINE   S L D E T N (CHDET,IDET)
***************************************************************************
+CDE,TYPING,GCBANK,SCLINK.
      INTEGER      IDET
      CHARACTER*4  CHDET
*
      IDET    = -1;    check LkDETM>0
      CALL GLOOK(CHDET,IQ(LkDETM+1),IQ(LkDETM-1),Idet)
      check Idet>0;    If   (LQ(LkDETM-Idet)<=0) Idet = 0
*
      END
 
+PATCH,UTIL. ==================================================================
*CMZ :  1.00/00 19/12/95  10.00.04  by  G. Poulard
+KEEP,TRCALO.
*CMZ :  1.00/00 01/07/95  19.59.16  by  Pavel Nevski
*-- Author :  Pavel Nevski
*   main calo parameters for tracking
      REAL            RCAL,     ZCAL,     YCAL
      DATA            RCAL/140/,ZCAL/360/,YCAL/1.4/
*     --------------------------------
 
+KEEP,TRBANK.
*CMZ :          20/11/97  11.20.57  by  Pavel Nevski
*CMZ :  1.30/00 25/03/97  17.57.31  by  Pavel Nevski
*CMZ :  1.00/00 28/08/95  01.34.42  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
*   - Track point bank
      INTEGER         LTB,NTB,LPNT,ISPOINT
      PARAMETER       (LTB=10000,LPNT=12)
      REAL            TRPOINT, DTRPOINT
      COMMON /TRBANK/ NTB,TRPOINT(LPNT,LTB)
* ISPOINT contains IPP={IP,IZ,IF} of counter, negative if point rejected
      COMMON /TRBANI/     ISPOINT(LTB)
* DTRPOINT contains the cluster position error (ask A.Rozanov for details)
      COMMON /TRBANJ/     DTRPOINT(LTB)
      REAL            OPNT,XPNT,DPNT,SPNT,APNT,EPNT,PPNT
      COMMON /TRKPNT/ OPNT,XPNT(3),DPNT,SPNT(2),APNT(3),EPNT,PPNT
*  1  : Opnt    - 1+tilt for barrel, 2 for end-caps
* 2-4 : Xpnt(i) - r,phi,z of the element center
*  5  : Dpnt    - stereo angle for strips, drift distance for TRT
* 6-7 : Spnt(i) - error in phi and Z/R
*  8  : Apnt(1) - detector code as follows
*  9  :     (2) - plane number in AgCRTAB
* 10  :     (3) - first digi reference number
* 11  : Epnt    - energy or discriminator value
* 12  : Ppnt    - MC reference track number
      REAL            PIXB,PIXE,GAAS,SCTT,ZSCT,SITV,SIT,MSGC,XTRT
      DATA            PIXB,PIXE,GAAS,SCTT,ZSCT,SITV,SIT,MSGC,XTRT
     +                / 1,   2,   3,   4,   5,   6,  7,   8,   9  /
*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+KEEP,TRROAD.
*CMZ :  1.30/00 30/07/96  18.59.46  by  Pavel Nevski
*CMZ :  1.00/00 28/08/95  01.30.12  by  Pavel Nevski
*-- Author :  Pavel Nevski
*   - Track road parameters
      REAL            ESHE,FSHE,ZSHE,RSHE,SSHE,ZVRT,DZSIT,
     +                RRSTV,RRSIT,RRMSG,RRGAA,RRTRD,
     +                RFISTV,RFISIT,RFIMSG,RFIGAA,RFITRD
      INTEGER         IWRK
      COMMON /TRROAD/ IWRK,ESHE,FSHE,ZSHE,RSHE,SSHE,ZVRT,DZSIT,
     +                RRSTV(3),RRSIT(3),RRMSG(3),RRGAA(3),RRTRD(3),
     +                RFISTV(3),RFISIT(3),RFIMSG(3),RFIGAA(3),RFITRD(3)
      INTEGER         NTZ
      REAL            RTZ,ZTZ
      COMMON /TZROAD/ NTZ, RTZ(100),ZTZ(100)
*     --------------------------------
 
+KEEP,IREPAR.
*CMZ :  1.30/00 30/07/96  19.05.44  by  Pavel Nevski
*CMZ :  1.00/00 30/06/95  23.11.58  by  A.Rozanov
*-- Author :    Pavel Nevski   11/10/93
C  -   Fumfit control parameters
      INTEGER         IFSHOW,IFTIME,ICLEAN,IFBREM,
     >                IRC,NUV,NZM,JPR,NDF,NTR,IKINE,ISHOW
      REAL            BCONST,DBREM,CHI2,PTPR,SSHE0,UKINE,
     >                DA0,DZ0,DELCHI,CHIBAD,SIG0,DT0,XTR
      COMMON /IREDAT/ JPR,IFBREM,UKINE,IKINE,ISHOW,PTPR,SSHE0,
     >                DA0,DZ0,SIG0,DT0,DELCHI,CHIBAD
      COMMON /IREPAR/ BCONST,DBREM,IRC,CHI2,NDF,NUV,NZM,NTR,XTR,
     >                IFSHOW,IFTIME,ICLEAN
C---------------------------------------------------------------------
+KEEP,IRECFLG.
*CMZ :  1.00/00 30/06/95  23.11.58  by  A.Rozanov
*-- Author :  Pavel Nevski
*C   - INNER TRACKER reconstruction control
      INTEGER         LU,IPNOW,IPRIN,IPDEB,IGEOM,IHIST,
     1                    IGRAP,ISIMU,IDIGI,IANAL,IRS
      COMMON/IRECFLG/ LU,IPNOW,IPRIN,IPDEB,IGEOM,IHIST,
     1                    IGRAP,ISIMU,IDIGI,IANAL,IRS
*C     --------------------------------
+KEEP,agcrfun.
*CMZ :  1.30/00 03/03/96  12.20.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   03/03/96
*     Road definition function and its parameters
      Integer          IFunAdr,IfunFlag
      Real             XXf(6),YYf(6),   Xopnt,Xrz,Xsas, Xzrc,Xphic,Xres,
     >                                  Yphi, Yzr,Ydphi,Ydzr,Ysign,Yres
      Common /AgCRFun/ IFunAdr,Ifunflag,Xopnt,Xrz,Xsas, Xzrc,Xphic,Xres,
     >                                  Yphi, Yzr,Ydphi,Ydzr,Ysign,Yres
      Equivalence      (XXf,Xopnt), (YYf,Yphi)
*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+KEEP,fumsva.
*CMZ :  1.30/00 30/07/96  18.59.46  by  Pavel Nevski
*CMZ :  1.00/00 30/10/95  14.10.25  by  Pavel Nevski
*-- Author :  Pavel Nevski
*   fumili parameters - in addition to FUMSIZE
      REAL         A0FIT,FI0FIT,PTINV,Z0FIT,DZDR0,RBREM,XBREM,RSHOW
      EQUIVALENCE (A0FIT,A(1)),(FI0FIT,A(2)),(PTINV,A(3)),(Z0FIT,A(4)),
     +            (DZDR0,A(5)),(RBREM,A(6)),(XBREM,A(7)),(RSHOW,A(8))
*     -----------------------------------------------------------
+KEEP,FUMUSE.
*CMZ :  1.00/00 05/07/95  03.15.58  by  Pavel Nevski
*-- Author :  Pavel Nevski
*   fumili users commons
      INTEGER         NA, NS, NP, NN, MM
      PARAMETER       (NA=10, NS=8, NP=400)
      REAL            EX,YY
      COMMON /FUMNED/ NN,MM
      COMMON /FEXDA/  EX(NS,NP)
      COMMON /FUMYY/  YY(0:NA,NP)
*     - - - - - - - - - - - - - - - - - - - -
+KEEP,FUMVAR.
*CMZ :  1.00/00 30/10/95  14.02.51  by  Pavel Nevski
*-- Author :  Pavel Nevski
*   fumili fitted parameters
      REAL            A
      COMMON /FUMILA/ A(10)
+CDE,FUMSVA
*     --------------------------------
+KEEP,HELVAR.
*CMZ :  1.00/00 30/06/95  23.11.58  by  A.Rozanov
*-- Author :    Pavel Nevski   06/02/95
*--   helix parameters
      LOGICAL                                           TRAPPED
      REAL            BCONST,XS,YS,ZS,RS,CF,SF,TL,TT,EL
      COMMON /HELVAR/ BCONST,XS,YS,ZS,RS,CF,SF,TL,TT,EL,TRAPPED
*     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+KEEP,FUMSIZ.
*CMZ :  1.00/00 03/07/95  09.52.49  by  Pavel Nevski
*-- Author :  Pavel Nevski
*   fumili internal commons
      INTEGER        L, LL
      REAL           ZZ,Z0,A,DA,RR,GG,SIGM,AMN,AMX,PLU,PL0
      PARAMETER      (L=10,LL=L*(L+1)/2)
      COMMON /FUMIZ/  ZZ(LL)
      COMMON /FUMZ0/  Z0(LL)
      COMMON /FUMILA/ A(L)
      COMMON /FUMIR/  RR(L)
      COMMON /FUMIG/  GG(L)
      COMMON /FUMDA/  DA(L)
      COMMON /FSIGMA/ SIGM(L)
      COMMON /FUMAU/  AMX(L)
      COMMON /FUMAL/  AMN(L)
      COMMON /FUMPL/  PL0(L)
      COMMON /FUMPLU/ PLU(L)
*     - - - - - - - - - - - - - - - - -
+Keep,HISCOM.
*CMZ :  1.30/00 30/07/96  18.59.47  by  Pavel Nevski
*CMZ :  1.00/00 01/05/95  16.30.25  by  Pavel Nevski
*-- Author :    Pavel Nevski
      Implicit Character*30 (T)
      Parameter (LC=30,L=50,Idm=2000)
      Common    /histab/List(Idm),Tab(L,3),WW(L,3),
     +                  ie(3),Nen(3),nn(l),aa(l),bb(l)
*     - - - - - - - - - - - - - - - - - - - - - - - -
+DECK,MYFILL,T=geant.
*CMZ :  1.00/00 30/06/95  13.09.22  by  Pavel Nevski
*-- Author :     Pavel Nevski
    subroutine   M Y F I L L (tt,Ix,Iy);
+CDE,Hiscom.
   Equivalence (Jtit,Itit);
   character*(*) tt; Character Jtit*4,L1*1,L2*1;
   Dimension ii(5); Common /LastId/ id;   Data Iw/0/;
*
   If (Iw==0) call VZERO(List,Idm);  Iw=1;  tit=tt;
   if tit(1:1)==' ' { ie(1)=Mynum(tit,1); Return; }
   Jtit=tit(5:8);  Ie(2)=Abs(Itit);  If (Ie(2)>L) ie(2)=Mynum(tit,2);
   id=ie(1)*L+ie(2);
if List(id)==0
{ " histogram Id defined by all LC characters, find parameters with keywords ";
  tt=tab(ie(2),2); Itit=ie(2); tit(5:8)=Jtit;          L2=' '; N=0;
  do k=1,25                                                "IF:"
  { L1=L2; L2=tt(k:k); Check L1==' ' & L2#' ';      " new word started "
    tn=tt(k:k+3);  i=Mynum(tn,4);   Check i>0;      " is a keyword ->  "
    N=N+1; ii(N)=i;                                 " get  parameters  "
  }
  IF      N==0 {Call Hbook1(id,tt,     100 ,       0.,       0.,0); List(id)=1}
  else IF N==1 {Call Hbook1(id,tt,nn(ii(1)),aa(ii(1)),bb(ii(1)),0); List(id)=1}
  else         {Call Hbprof(id,tt,nn(ii(2)),aa(ii(2)),bb(ii(2)),
                                          aa(ii(1)),bb(ii(1)),'S'); List(id)=2}
}
If (List(id)>1) y=argum(Iy);  Call Hfill (id, Argum(Ix), y, 1.);
End;
 
+DECK,MYBOOK,T=geant.
*CMZ :  1.00/00 01/05/95  15.03.56  by  Pavel Nevski
*-- Author :     Pavel Nevski
    subroutine   M Y B O O K (tit,N,Ia,Ib);
+CDE,hiscom.
tn=tit(1:4); ih=Mynum(tn,3); NN(ih)=N; AA(ih)=Argum(Ia); BB(ih)=Argum(Ib);
End;
+DECK,MYNUM,T=geant.
*CMZ :  1.00/00 01/05/95  14.38.22  by  Pavel Nevski
*-- Author :     Pavel Nevski
    Function     M Y N U M   (tit,jj);
+CDE,hiscom.
    j=min(jj,3);
    :I: for i=1 to nen(j)
    { ie(j)  = mod(ie(j),nen(j))+1; if (tit==TAB(ie(j),j)) go to :FND:;}
       MYNUM=0; if (jj>3) Return;
      nen(j) = min0(nen(j)+1,L);    ie(j) = nen(j);  tab(ie(j),j) = tit;
:FND: MYNUM=ie(j);
End;
+DECK,ARGUM,T=geant.
*CMZ :  1.00/00 01/05/95  16.32.51  by  Pavel Nevski
*-- Author :     Pavel Nevski
    Function     A R G U M    (Iarg)
    Real         ARGUM,Var
    Integer      Iarg,Ivar
    Equivalence  (Var,Ivar)
 
    Ivar=Iarg;              Argum=Ivar;
    if (abs(Iarg) > 100000) Argum=Var
    END
 
+DECK,XFINTER,T=geant.
*CMZ :  1.00/00 07/05/95  00.37.37  by  Pavel Nevski
*-- Author :    Pavel Nevski
**********************************************************************
      function     X F I N T E R (X,A,F,N)
*  Description:  simple linear interpolation                         *
**********************************************************************
  Implicit  None
  Integer N,K,K1/1/,K2/1/
  Real XFINTER,X,A(n),F(n),X1,X2;
 
 XFINTER=F(1);  Check N>1;
 If (K1>=N | X<A(K1))  K1=1
 If (K2> N | X>A(K2))  K2=N
 While K2-K1>1  { K=(K1+K2)/2; IF A(K)<X {K1=K} else {K2=K} }
 X1=A(K1); X2=A(K1+1);
 XFINTER=(F(K1)*(X-X2)+F(K1+1)*(X1-X))/(X1-X2)
END
 
+DECK,XGINT,T=geant.
*CMZ :  1.00/00 07/05/95  13.12.49  by  Pavel Nevski
*-- Author :    Pavel Nevski
**********************************************************************
      function    X G I N T   (EXT,A,B,EPS)
*   Description:  famous integration procedure                       *
**********************************************************************
  Implicit None
  External EXT
  Integer  M,N,I,K
  Real     XGINT,A,B,Eps,OTB,Y,W(4),U(4),D,Ext
  DATA     M/4/,
  U/-.8611363,-.3399810, .3399810 ,.8611363/,
  W/ .3478548, .6521452, .6521452, .3478548/
 
 N=10;  OTB=0;  Loop
 {  Y=OTB; OTB=0; D=(B-A)*.5/N;
    DO I=1,N  { DO K=1,M  { OTB+=W(K)*EXT(A+D*(2*I-1+U(K)))*D; } }
    XGINT=OTB;  N=2*N;  IF N>100000 { Print *,'XGINT Divergence !!!'; Return;}
 } While EPS>0 & ABS(OTB-Y)>ABS(EPS*OTB)
END
 
+Deck,NXPOISS,T=geant.
*CMZ :          31/10/97  12.55.37  by  Pavel Nevski
*CMZ :  1.00/00 06/08/95  17.16.05  by  Pavel Nevski
*-- Author :    Pavel Nevski
*************************************************************************
      function     N X P O I S S (w)
*  Description :         simulate Poisson distribution                  *
*************************************************************************
Real Rndm,exp,w,r,P,S;  Integer n,NXpoiss
r=rndm(1.);   n =0;  P =exp(-w);  S =P;
While s<r   { n+=1;  P*=w/n;      S+=P; }
NXpoiss=n
End
 
 
+DECK,funct,T=GEANT. ----------------------------------------------------------
*CMZ :          25/11/97  23.22.25  by  Pavel Nevski
*CMZ :  1.30/00 06/09/96  18.10.33  by  Pavel Nevski
*CMZ :  1.00/00 25/08/95  00.07.49  by  Pavel Nevski
*-- Author :    A.Rozanov   30/06/95
********************************************************************
*                                                                  *
                 function      F U N C T (X)
*               track description in ATLAS tracker                 *
* OPTION choice: 0          - vertex                               *
*                1          - cylinder parallel to z               *
*                1+/- tilt  - plane parallel to z, abs(tilt)<0.5   *
*                2          - plane perpendicular to z axis        *
*                11&12      - Calorimeter points for brem fit      *
* modifications:                                                   *
* PN, 14/11/97 - bremfit corrected by David Rousseau               *
********************************************************************
+CDE,TYPING,HELVAR,FUMVAR.
*
      REAL      FUNCT,X(5),PBREM(10),TOWHERE(2),OPTION,BFLD,RMX,SAS,ZR0,TILT
      INTEGER   IOPTION,JOPTION,IBREM
      SAVE      IBREM,PBREM
      DATA      BFLD/2./,RMX/140./
*     ----------------------------
      OPTION     = X(1)
      TOWHERE(1) = X(2)
      SAS        = X(3)
      ZR0        = X(4)
      TOWHERE(2) = X(5)
      JOPTION    = nint (OPTION)
      IF (0<OPTION & OPTION<1.99) JOPTION = 1
      IOPTION    = mod (JOPTION,10)
      tilt       = Option-Joption
*
*    set starting point from vertex (0,0)+A
*
      IF IOPTION==0  " vertex "
      {  BCONST  = -2.999792E-3*BFLD
         TRAPPED = .FALSE.
         CF      = COS(FI0FIT)
         SF      = SIN(FI0FIT)
         RS      = A0FIT
         ZS      = Z0FIT
         XS      = -RS*SF
         YS      = +RS*CF
         TL      = DZDR0
         TT      = PTINV
         EL      = 0
         FUNCT   = RS
         IBREM   = 0
*        put protection against infinite momentum - 7/6/94
         IF (ABS(TT)<1.E-4) TT=SIGN(1.E-4,PTINV)
      }
      ELSE IF TOWHERE(1)!=0   " we move to the next point "
      {* special point - calorimeter: as if no brem occures
         IF (IBREM==1 & OPTION>10) CALL UCOPY(PBREM,XS,10)
         CALL HELIXA(OPTION,TOWHERE)    !  swim to r,z or plane
*        Have we crossed the brem point ?
         IF (IBREM==0 & RS>RBREM & RBREM<RMX) THEN
            IBREM = 1                   !  moment is changed
            CALL HELIXA (1., RBREM)
            CALL UCOPY  (XS,PBREM,10)
            TT = PTINV+SIGN(XBREM,PTINV)/(RBREM-RSHOW)/BCONST/RSHOW*2
            CALL HELIXA (OPTION,TOWHERE)
         ENDIF
 
*        Have we crossed the brem point back ?
         IF (IBREM==1 & RS<RBREM) THEN
            IBREM = 0                   !  moment is restored
            CALL UCOPY  (PBREM,XS,10)
            CALL HELIXA (OPTION,TOWHERE)
         ENDIF
 
         FUNCT = ATAN2(YS,XS)           ! always phi-measurement
*        introduce a shift for the strip center for u/v strips in z/r
         IF (SAS!=0 & IOPTION==1) FUNCT=FUNCT+SAS*(ZR0-ZS)/RS
                                  "  * (1-SAS*(ZR0-ZS)/RS*TILT) "
         IF (SAS!=0 & IOPTION==2) FUNCT=FUNCT+SAS*(ZR0-RS)/RS
         FUNCT=AMOD(FUNCT+6.2831853,6.2831853)
      }
      ELSE
      {*  Give Z/R component instead of Phi according to option
          IF IOPTION=1 { FUNCT = ZS } else { FUNCT = RS }
      }
      END
 
 
+DECK,HELIXA,T=GEANT. ---------------------------------------------------------
*CMZ :          20/11/97  22.25.45  by  Pavel Nevski
*CMZ :  1.30/00 11/05/96  21.53.45  by  Pavel Nevski
*CMZ :  1.00/00 25/08/95  00.07.49  by  Pavel Nevski
*-- Author :  Pavel Nevski
********************************************************************
*                                                                  *
          subroutine     H E L I X A (OPTION,TOWHERE)
*                                                                  *
*  track vector in /HELVAR/ is updated by Helix to endpoint:       *
*      OPTION = 1 : endpoint at radius TOWHERE                     *
*      OPTION = 2 : endpoint at z-coor TOWHERE                     *
*  Trapped particles (loopers) are stopped at their maximum radius *
*  Modifications:                                                  *
*  PN, 20.11.97:  tilt up to 1 accepted with OPTION (0-1.999)      *
********************************************************************
+CDE,TYPING,HELVAR.
*
      INTEGER NSMAX,NS,IOPTION
      REAL    OPTION,TOWHERE(2),TILT,SMAX,TOL,
              R0,RE,ZE,DL,DF,RP,SDF,CDF,CD1,D,C0,SB,CB,RO
      DATA    TOL/2.E-6/, SMAX/.50/, NSMAX/10/, RO/0./
*     ---------------------------------------------------
 
      IOPTION = nint(OPTION);          IF (OPTION<1.999) IOPTION = 1
      TILT    = OPTION - IOPTION
      IOPTION = MOD(IOPTION,10);       {RE,ZE} = TOWHERE(1)
 
   IF .not.TRAPPED
   {  R0=1./(BCONST*TT);  {CB,SB}=0
*   new  OPTION==3 : have to swim to a plane parallel to Z-axis
      IF TILT!=0
      {  RE      = RE*COS(TILT)
         CB      = COS(TOWHERE(2)+TILT)
         SB      = SIN(TOWHERE(2)+TILT)
      }
*   Loop here until the required precision is reached
      DO NS=1,NSMAX
      {  RO = RS
         IF IOPTION==1        " barrel-like swim "
         {  IF CB==0 | NS==1  " swim to fix RE "
            {  RP=XS*CF+YS*SF; SDF=(SQRT(MAX(RE*RE-RS*RS+RP*RP,0.))-RP)/R0 }
            ELSE " CB> & NS>1 - swim to the propre plane "
            {  RP=XS*CB+YS*SB; SDF=(RE-RP)*RS/(R0*RP)  }
         }
         ELSE IF IOPTION==2  " - swim to fix ZE "
         {  DF=(ZE-ZS)/TL;    SDF=SIN(DF/R0)  }
         *      Check if the step is too large
         IF (ABS(SDF)>SMAX) SDF = SIGN(SMAX,SDF)
         C0 = CF
         CDF = SQRT(1-SDF**2);               CD1 = SDF*SDF/(1+CDF)
         XS = XS+(SDF*CF-CD1*SF)*R0;         YS = YS+(SDF*SF+CD1*CF)*R0
         CF = CF*CDF-SF*SDF;                 SF = SF*CDF+C0*SDF
         RS = SQRT(XS**2+YS**2);             DL = R0*ASIN(SDF)
         EL = EL+DL;                         ZS = ZS+DL*TL
*       build the estimator
         IF IOPTION==1  { IF CB==0 { D=RE-RS } else { D=RE-XS*CB-YS*SB } }
         ELSE           { D=ZE-ZS }
*       Check precision and put some protection
         IF (ABS(D/TOWHERE(1)) < TOL)   return   " accuracy is achived   "
         IF (RS > 199 | ABS(ZS) > 399)  return   " outside the apperture "
       " IF ((RE-RO)*(RO-RS) > 0)        Break     particle is trapped   "
   }  }
* RE - final point, may by R (for IOPT=1) or Z (for IOPT=2)
   TRAPPED = .TRUE.
   If IOPTION==1
   {  XS=XS*RE/RS
      YS=YS*RE/RS
      ZS=ZS*RE/RS
      RS=RE
   }
   else
   {  XS=XS*ZE/ZS
      YS=YS*ZE/ZS
      RS=SQRT(XS**2+YS**2)
      ZS=ZE
   }
   END
 
 
+DECK,FUMSIZE,T=geant. --------------------------------------------------------
*CMZ :  1.00/00 25/08/95  00.07.49  by  Pavel Nevski
*-- Author :    Pavel Nevski
********************************************************************
*                                                                  *
                 subroutine    F U M S I Z E
*                                                                  *
* Original Version:                                 Pavel Nevski   *
********************************************************************
+CDE,TYPING,FUMSIZ.
      Integer i
      DO I=1,L  { AMX(I)=1.E30;   AMN(I)=-1.E30 }
      End
 
+DECK,agfkine,T=geant. ---------------------------------------------------------
*CMZU:  1.00/01 14/01/96  17.57.22  by  Pavel Nevski
*CMZ :  1.00/00 07/03/95  21.21.52  by  Pavel Nevski
*-- Author :    Pavel Nevski   07/02/95
********************************************************************
*                                                                  *
                 subroutine    A g F K I N E (ITR)
* Description: restore GCKINE common block plus auxilary AGMYKINE  *
********************************************************************
+CDE,TYPING,GCNUM,GCKINE,FUMVAR.
      INTEGER           ITR,Nw,Ip
      REAL              VMOD,UBUF(20),Rcal/168./
      REAL              PTP,TET,PHI,ETP,ENN,PLP,RAP
      COMMON /AGMYKINE/ PTP,TET,PHI,ETP,ENN,PLP,RAP
;
      {ITRA,ISTAK,IPAOLD}=0;            Check 1<=ITR&ITR<=NTRACK
      CALL GFKINE (ITR,VERT,PVERT,Ip,IVERT,UBUF,Nw);  Check Ip>0
      CALL GFPART (Ip,NAPART,ITRTYP,AMASS,CHARGE,TLIFE,UBUF,Nw)
      ITRA = ITR;
      PTP  = SQRT (PVERT(1)**2+PVERT(2)**2);
      TET  = ATAN2(PTP,PVERT(3));           ETP  = -ALOG(TAN(TET/2));
      PHI  = ATAN2(PVERT(2),PVERT(1));      IF (PHI<0) PHI+=6.283185;
*   Compute calo impact rapidity (D.Froideval personally)
      PLP  = PVERT(3) + VERT(3)/RCAL*PTP;
      ENN  = SQRT (PLP**2+PTP**2);          RAP = .5*ALOG((ENN+PLP)/(ENN-PLP));
*   Fill Funct/Fumili common to swim the track
      Fi0Fit = PHI              " Fi at origin     "
      A0Fit  = VMOD(VERT,2)     " Impact parameter "
      PTinv  = CHARGE/PTP       " 1/pT             "
      Z0Fit  = VERT(3)
      dZdR0  = 1/TAN(TET)
      Xbrem  = 0
      Rbrem  = 200
      Rshow  = Rcal
      Print *,'  get track fi0,a0,Pti,z0,dz=',Fi0Fit,A0Fit,PTinv,z0fit,dZdR0
    END
 
+DECK,xntup,T=Geant.
*CMZ :          04/12/97  13.25.20  by  Pavel Nevski
*CMZU:  1.00/01 25/01/96  02.13.04  by  Pavel Nevski
*CMZ :  1.00/00 28/08/95  00.45.41  by  Pavel Nevski
*-- Author :    Pavel Nevski   11/10/93
********************************************************************
*                                                                  *
                subroutine  X N T U P (TIT,IVAR)
*                                                                  *
*   simple mind NTUPLE, if you don't like it, do it yourself  !!!  *
* XNTUP (' a b c ',I) defines 'page' of tages with 'vector' prefix *
*                    and preselects i-th component from a,b,c      *
*         you can also use a default page without prefixes at all  *
* XNTUP ('tag',v)    defines a value of a tag in the current page  *
*                    in selected component of vector (a,b,c)       *
* XNTUP ('*',ID)     close current event                           *
*                                                                  *
* Original Version:                                   Pavel Nevski *
* Modifications:   page structure for Fabiola         08/10/94     *
*       introduce a default page without prefixes     27/08/95     *
* 04.12.97 - customise for atlsim: get IUHIST & CDHIST
********************************************************************
      IMPLICIT NONE
+CDE,AGCKINE.
      CHARACTER*(*) TIT
      CHARACTER*8   TAG,TAGS,Pfx,PfxS
      CHARACTER*16  PAGTAG,PAGE,PAG
      REAL          V,VAL
      INTEGER       IVAR,IV,ID,JD,IT,IP,II,KV,NTAG,NPAG,NPfx,NVAL,
                    K,L,N,LENOCC,NT,NV,NP,ND,Itag,Ipfx,KADR
      PARAMETER     (NTAG=200,NPAG=200,NPfx=200,NVAL=1000)
      COMMON /AGXTUPLE/ NT,NP,NV,ND,Itag(NPAG+1),Ipfx(NPAG+1),KADR(NPAG+1),
             PfxS(NPfx+1),PAGE(NPAG+1),TAGS(NTAG+1),PAGTAG(NVAL),VAL(NVAL)
      EQUIVALENCE   (V,IV)
      LOGICAL       FIRST /.TRUE./
      INTEGER       Lout/6/,Iprin/0/
      DATA          IP,KV,JD/1,1,1/
 
*   -------------------------------------------------------------------
      IF Iabs(IVAR)<1 000 000 {"integer" V=IVAR} else {"real" IV=IVAR}
*   -------------------------------------------------------------------
      ID=V
      IF TIT(1:1)==' '            " page declaration "
      {  PAG=TIT
         DO  IP=1,NP  { IF (PAG==PAGE(IP)) GOTO :P: }
         If (!First)  GoTo :e:
*           new page entered
            NP=MIN(NP+1,NPAG); IP=NP
*           page markers:     PfxS       variables   Block*Variables
            PAGE(IP)=PAG; Ipfx(IP)=ND;  Itag(IP)=NT;  KADR(IP)=NV
*           get list of prefixes
            L=LENOCC(TIT);  N=0;  Pfx=' ';  PfxS(ND+1)=' '
            DO K=1,L+1
            {  IF K<=L & TIT(K:K)!=' '
               {  N=MIN(N+1,8);  Pfx(N:N)=TIT(K:K);  Next; }
               Check N>0;  ND=MIN(ND+1,NPfx);  PfxS(ND)=Pfx;  N=0;  Pfx=' '
            }
            ND=Max(1,ND);  Ipfx(IP+1)=ND;  Itag(IP+1)=NT;  KADR(IP+1)=NV
            Prin1 PAG,ND-Ipfx(IP),NT,NV
            (' XNTUP: New Page ',A,' with ',i3,' blocks, NT,NV=',2i5)
*           No rep. for this page  - set ID selector within it
        :P: KV=Ipfx(IP+1)-Ipfx(IP);    JD=MAX(1,MIN(ID,KV))
      }
      ELSE IF TIT(1:1)!='*'       "  variable (tag)  "
      {  TAG=TIT
         DO IT=Itag(IP)+1,Itag(IP+1) { IF (TAG==TAGS(IT)) GoTo :T: }
         IF (!FIRST) GoTo :E:
            NT=MIN(NT+1,NTAG);  It=Nt;   TAGS(NT)=TAG
            Itag(IP+1)=NT;    NV=NV+KV;  KADR(IP+1)=NV
            Prin1 TAG,NT,IP,NV
            (' XNTUP: new tag ',A,i4,' on page',i3,' NVtot=',i5)
        :T: II=MIN(KADR(IP)+(IT-Itag(IP)-1)*KV+JD,NVAL);  VAL(II)=V
      }
      ELSE                        "   close event    "
      {  If (IUHIST>0) CALL RZCDIR('//'//CDHIST,' ')
         If (IUHIST>0) CALL  HCDIR('//'//CDHIST,' ')
         IF FIRST
         {  DO IP=1,max(1,Np)
            {  DO IT=Itag(IP)+1,Itag(IP+1)
               {  KV=max(1,Ipfx(IP+1)-Ipfx(IP))
                  prin1 IP,IT,KV,NV
                  (' XNTUP: defining page IP with tags IT,KV=',5i5)
                  DO JD=1,KV
                  {  II=MIN(KADR(IP)+(IT-Itag(IP)-1)*KV+JD,NVAL)
                     Pfx=' ';  If (NP>0) Pfx=PfxS(Ipfx(IP)+JD)
                     PAGTAG(II)=Pfx(1:LENOCC(Pfx))//TAGS(IT)
                     prin1 JD,II,PAGTAG(ii),LENOCC(Pfx)
                     (10x,'JD,II,PAGTAG=',2i5,2x,A,i5)
            }  }  }
            CALL HBOOKN(ID,'ATLAS',NV,CDHIST,1000,PAGTAG)
            FIRST=.FALSE.;
         }
         CALL HFN(ID,VAL)
         CALL VZERO(VAL,NVAL)
         {IP,JD,KV}=1
      }
      Return
:E:;  Prin0 TAG; (' XNTUP: too late to introduce new TAG/PAGE ',A)
      END
 
+DECK,AGGPLANE,T=geant. ------------------------------------------------------
*CMZ :          08/11/97  18.05.57  by  Pavel Nevski
*CMZU:  1.30/01 17/05/97  16.47.03  by  Pavel Nevski
*CMZ :  1.30/00 15/04/97  14.58.38  by  Pavel Nevski
*-- Author :    Pavel Nevski   03/03/96
*************************************************************************
*                                                                       *
                subroutine   A G G P L A N E (Cset,Ipp)
*                                                                       *
* Modifications:                                                        *
* A.Rozanov 07/11/97: IpOld introduced to start new plane without mods  *
*************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCVOLU,GCONST.
+CDE,TRBANK,AGCLINK,AGCCLUS,AGCRFUN,AGCRTAB.
*
Structure AgCR { char Cset, char Cdet, int Isys, int Itype, int Npl,
                 int kkk, int kfi, int krz, int mrz, drzm,
		 RRmin, RRmax, ZZmin, ZZmax, int Istart, int Nadr, int NupMax,
		 char Nam(kkk), int Nmx(kkk), int Ibuf(Nadr),int Ipla(NupMax),
                 rzp(Npl),RZmin(Npl),RZmax(Npl),Fmin(Npl),Fmax(Npl),
                 Dfi(Npl),Dzr(Npl),Tilt(Npl),Sas(Npl),Fcent(Npl),
                 int Nfi(Npl), int Nzr(Npl), int Nump(Npl), int Iadr(Npl),
                 int Jres(Npl) }
*
  INTEGER      NV,Nd;          PARAMETER   (NV=10,Nd=10)
  Integer      NVL(NV),ISC(NV),K,Ia,Iad,ip,Iz,Jz,kz,If,i,id,Lm,kk,Jd,Jf,
               AgPFLAG,Iprin,Ids,Ip2,Mz,Mf,modz,Modf,itry,ipp,Ltr,N,if0,
               IpOld,ist/0/,ok/0/,Lpacki/0/
  Real         DIGI(Nd),Fc,Df,Yphi0
  Character*4  Cset,Cdet,Cs
  Save         NVL,Cdet,Cs,Iprin,Ids,Ip2,Lm,Modz,Modf,Jd,Jf
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
  IF  Ipp>=10000  {" automatic agplane continuation "  Ip=Ipp/10000;   }
  else            {" new user plane request "  Ip=Ipp; Modz=0; Modf=0; }
 
  {Ndig,Ktyp}=0;
*                                       for the first plane, get tables
  If Ip<=0 | Ip >999 | Cset(1:3)!=Cs(1:3)
  {  " start track at the vertex "
     If IfunAdr>0  { Call Vzero(xxf,6); Call JUMPT2(IfunAdr,xxf,yyf) }
*
     call RbPUSHd
     Lm=1;     USE  /DETM/AXXX/AgXX/AgCR  Cset=Cset   Stat=Ist
     If Ip>0 & Cset=='XTRT' & Ist==ok
     { Lm=-1;  USE  /DETM/AXXX/AgXX/AgCR  Oper=Next   Stat=Ist;  }
     call RbPOPd
     Check Ist==ok;  Nplane=agcr_Npl;  Itp=agcr_Itype;
     * let user a way to increase Lpack in AXXXREC
     Lpacki=Lpack;   If (Lpacku>0) Lpacki=Lpacku
 
     Call VZERO(Nvl,Nv);    Call Vzero(Isc,Nv);   Call Vzero(Digi,Nd)
     Cs=Agcr_Cset(1:3)//'D';  Cdet=Agcr_Cdet;  {K,Ia}=0
     Call AgFDIGI (Cs,Cdet,NVL,Ltra,ISC,Digi,K,Ia)
 
     If Ip<=0 { Ip=0;                Ip2=Nplane; Ids= 1; }
     else     { Ip=min(Ip,Nplane)+1; Ip2=1;      Ids=-1; }
     " start neighbour counting "    Modz=0;  Modf=0;   Jd=1;
  }
  Iprin=AgPFLAG(Cset,'RECO');     If (Iprin<0) { Ipp=-1; return }
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
  If (modz==0 & Modf==0) Ip+=Ids;  IpOld=Ip;
  For Ip=Ip to Ip2 by Ids
  {                            " extrapolate the track to the next plane  "
     itp   = Agcr_Itype;         rzp   = Agcr.rzp(ip)
     RZmin = Agcr.RZmin(ip);     RZmax = Agcr.RZmax(ip)
     Fmin  = Agcr.Fmin(ip);      Fmax  = Agcr.Fmax(ip)
     Dfi   = Agcr.dfi(ip);       dzr   = Agcr.dzr(ip)
     Tilt  = Agcr.tilt(ip);      Sas   = Agcr.Sas(ip)
     Nfi   = Agcr.Nfi(ip);       Nzr   = Agcr.Nzr(ip)
     Nump  = Agcr.Nump(ip);      Jres  = Agcr.Jres(ip)
     Fcent = Agcr.Fcent(ip);     Iadr  = Agcr.Iadr(ip)
*    print * ,ip,modz,modf
     If (Ip != IpOld) {modz=0;modf=0;IpOld=Ip} ! start new plane without mods
*
     xxf " Xopnt,Xrz,Xsas, Xzrc,Xphic,Xres " = {Itp, rzp,  0,0,  0,0};
     yyf " Yphi, Yzr,Ydphi,Ydzr,Ysign,Yres " = {0,0, TwoPi, big, 0,0};
     If (IfunAdr>0 " & modf==0 & modz==0 ")  Call JUMPT2(IfunAdr,xxf,yyf)
*
                                     "    select one phi sector (if>=0)     "
     if=0;  If Nfi>1 & dfi!=0
     { if0=nint((Yphi-(Fmin+Fmax)/2)/Dfi);  if=If0+modf;
       jf=sign(1.,Yphi-(Fmin+Fmax)/2-if0*Dfi)
     }
     Fc=Fcent+if0*Dfi;  Df=if*Dfi;  Yphi0=Yphi
     if Itp==1 & Tilt!=0 "& modf==0 & modz==0   extrapolation for tilt plane "
     { xxf(1)=1+tilt; xxf(5)=Fc; If (IfunAdr>0) Call JUMPT2(IfunAdr,xxf,yyf)  }
     Yphi+=nint((Yphi0-Yphi)/TwoPi)*TwoPi  "    keep Yphi in the same place  "
 
*
     If nfi>1  & dfi!=0                 "    rotate to the right sector     "
     {  check Fmin+Df-Ydphi <=Yphi&Yphi<= Fmax+Df+Ydphi;  Fcent+=Df; }
*
                                        "    select z/r-section (iz>=0)   "
     {i,iz}=0;   Mz=max(Itp,Nzr);   Mf=max(1,Nfi)
*
     If Itp==1                          "    this is a barrel detector    "
     {  If (dzr!=0) iz=min(max(0,nint((Yzr-(RZmin+RZmax)/2)/dzr)),Nzr-1)
*
*       Roads may produce iz detector variations at both sides around center
        kz=iz+modz;   If RZmin+kz*dzr-Ydzr <= Yzr&Yzr <= RZmax+kz*dzr+Ydzr
        {  " closest neighbour direction is " jd=sign(1.,2*Yzr-RZmin-RZmax)
           " check next detector in advance and save it for the next entry "
           do itry=1,2
           {  modz=-modz;  if (jd*modz>=0) modz+=jd;  jz=iz+modz
              If (0<=jz&jz<=Nzr-1) break;             jz=-1
           }
           If (jz<0 | RZmin+jz*dzr-Ydzr>Yzr | Yzr>RZmax+jz*dzr+Ydzr) modz=0
           iz=kz
        }
        else                             " no detector left in this layer "
        {  modz=0;
           If Cset=='XTRT' & Lm>=0
          {" we are in the TRT barrel here - this should be followed by endcap"
             If (Ids*Lm<0) Break;     Lm=-Lm;
 
          " backward tracing will be more complicate here - will do later(pn)"
            Call RBPUSHD
            If Lm>0  { USE /DETM/AXXX/AgXX/AgCR   Cset=Cset   Stat=Ist; }
            else     { USE /DETM/AXXX/AgXX/AgCR   Oper=Next   Stat=Ist; }
            Call RBPOPD
 
            If Ist!=ok { <w> ip; (' AggPlaNa error in XTRT plane=',i3); Break;}
            Nplane=agcr_Npl;  Itp=agcr_Itype
            If Ids>0   { Ip=0; Ip2=Nplane} else { Ip=Nplane+1; Ip2=1;}
            Next
        } }
     }
     else                                "    this is an end-cap detector  "
     {" Delta Z and reflections rules may be conflicting - have to check it"
        If  dzr!=0  { iz=nint((Yzr-Rzp)/dzr); iz=min(max(0,iz),Mz-1); }
        else        { iz=0;  if (Ysign<0) iz=1; }
        Check   Rzmin-Ydzr <= Yzr & Yzr <= RZmax+Ydzr
     }
*
     If nfi>1  & dfi!=0 & modz==0        "    rotate to the next sector    "
     {  modf=-modf;  if (jf*modF>=0) modf+=jf;  Df=(if0+modf)*Dfi
        Unless (Fmin+Df-Ydphi <=Yphi & Yphi<= Fmax+Df+Ydphi) modf=0
        if (abs(modf)>=Nfi/2) modf=0     " protect against infinite search "
     }
*
     iad=agcr.Iadr(ip)+mod(if+2*Mf,Mf)+iz*Mf+1  " if,iz have 0 offset here "
     Ipp=Ip*10000+mod(if+2*Mf,Mf)+iz*max(100,Mf)
 
                                        "  pick up hits in one board  "
     Ndig=0;  Id=0;  KK=agcr.Ibuf(iad);  Call Vzero(Digi,Nd)
     IF KK>0
     {  Ndig=mod(KK,Lpacki);  K=KK/Lpacki-1 " may start from zero ";
        Do N=1,Ndig
        {  Call  AgFDIGI (Cs,Cdet,NVL,Ltr,ISC,Digi,K,Ia)
           If k<=0
           { <w> Cs,Cdet,KK,Id,K,Ia,NVL; (' AggPlaNa logic error in',
              2(1x,a4),' KK,Id,K,Ia=',4i6/20x,' NVL=',10i4);   break;
           }
           Check Ltr>=0;   Id+=1;  Kdig(id)=k;  Ltra(id)=Ltr;
*
           Ktyp=Digi(1); Fdig(id)=Digi(2); Zdig(id)=Digi(3); Edig(id)=Digi(4);
           If Cset=='XTRT'        " dfi does not change sign for reflection?"
           {  Ktyp=Itp;   Fdig(id)=Fcent+dfi*(ISC(3)-1);
              Zdig(id)=Digi(2);  Edig(id)=Digi(1);
           }
           prin5 id,Ktyp,Fdig(id),Zdig(id),Edig(id);
           ('   digit id,ktyp,f,z,E = ',2i5,3f12.4);
           KtypDig(id)=Ktyp;  Nodig(id)=Digi(5)+.001;
        }
        Ndig=Id;  Call  AgFPATH (ISC);
        Ishape=Q(LQ(JGPAR-Nlevel)-4);   Npar=Q(LQ(JGPAR-Nlevel)-1);
        Call Ucopy(Q(LQ(JGPAR-Nlevel)+1),Par,min(Npar,50));	
        Call Ucopy(GTRAN(1,NLEVEL),AgTRAN,3);
        Call Ucopy(GRMAT(1,NLEVEL),AgRMAT,10);
     }
*    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     prin4 Cset,Ipp,Ndig; (' AgGPLANE: ',a4,' Ipp,Ndig =',2i12)
     prin8 ip,Ktyp,Ishape,Npar,(par(i),i=1,Npar)
     (' plane',2i4,'  Shape,Npar=',2i5,(' par=',10f8.3))
     prin6 tilt,sas,fcent; (' plane angles t,s,f(AggPlANa)',3F12.4)
     prin5 rzp,Yphi; ('   track at point   (FUNCT)  ',5F12.4);
     Return;                                                 :dummy:
  }
  Ipp=0
*
  END
 
+DECK,AGSFUNCT,T=geant. ------------------------------------------------------
*CMZ :  1.30/00 03/03/96  12.29.00  by  Pavel Nevski
*-- Author :    Pavel Nevski   03/03/96
*************************************************************************
*                                                                       *
                subroutine   A G S F U N C T (ext,ia)
*                                                                       *
*************************************************************************
+CDE,TYPING,AGCRFUN.
   external   ext
   Integer    JUMPAD,IA
*
   IFunAdr  = JUMPAD(ext)
   IfunFlag = Ia
   end
 
 
+DECK,fumfit,T=geant. ---------------------------------------------------------
*CMZ :          20/11/97  22.28.54  by  Pavel Nevski
*CMZ :  1.30/00 01/09/96  16.24.19  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
********************************************************************
*                                                                  *
               subroutine   F U M F I T (TAG,NPAR)
**DIRECTIVE RANGE ON
**DIRECTIVE CHECK_OVERFLOW INTEGER ON 	
*             LSQ track parameters fit to IHIT bank                *
*                                                                  *
* Original Version:                                   Pavel Nevski *
* Modifications:                                      Sasha Rozanov*
* PN, 20.11.97:  to accept big tilts in barrel OPNT (0-1.999)=> 1  *
********************************************************************
+CDE,TYPING,GCUNIT,IREPAR.
+CDE,FUMUSE,FUMSIZ,FUMSVA.
+CDE,TRROAD,TRBANK,TRCALO.
* ----------------------------
 
      INTEGER     I,J,K,M,N,IW,II,I1,I2,IT,IPR,IFL,M1,IM,NPAR,Iprin
      REAL        FI,F1,F2,S,R,Z,D,AK,AL,XX(6),SS(-1:1),FUNCT,ORDER
      CHARACTER*6 TAG
      INTEGER     AgPFLAG,IOPNT,Nok,NDF0PR/0/
*
*     - - - - - - - - - - - - - - - - - - -
*     Order    <->     Option       R or Z
      ORDER(II) = 1000*Nint(EX(3,II))+ABS(EX(4,II))
*     - - - - - - - - - - - - - - - - - - -
 
      Iprin=AgPFLAG('FUMF','RECO')
      CALL VZERO (EX,NS*NP)
*     protect against bad call
      IF (NTB<=0) return
 
      MM   = NPAR
      NUV  = 0
      NZM  = 0
      NTR  = 0
      XTR = 0
*    vertex constrain
      M       = 1
      EX(1,M) = 0
      EX(2,M) = DA0
      EX(3,M) = 0
      EX(4,M) = 0
      FI      = FUNCT(EX(3,1))
      M       = 2
      EX(1,M) = 0
      EX(2,M) = DZ0
      EX(3,M) = 1
      EX(4,M) = 0
 
*   Loop here over IHIT bank and fill  FUMILIs EXDA
*   ------------------------------------------------
      Nok=0
      Prin9 ; ('FumFit called with these pts:')
      DO I = 1,NTB
 
         Check ISPOINT(i)==0
	 Nok+=1
	 Prin9 i; ('     entry ',I4)
 
         CALL UCOPY(TRPOINT(1,I),OPNT,LPNT)
         IOPNT=nint(OPNT);  If (0<OPNT&OPNT<1.999) IOPNT=1
	 Prin9 i,opnt,iopnt;  (' next point=',i5,f8.1,i5)
 
         IF (APNT(1)==0) THEN
*           this is the pointer (track/cluster), skip it
            RSHE = XPNT(1)
            FSHE = XPNT(2)
            ZSHE = XPNT(3)
            SSHE = SPNT(2)
            ESHE = EPNT
            NEXT
         ENDIF
         XX(1) = OPNT
         XX(3) = 0
         XX(4) = 0
         XX(5) = XPNT(2)
 
*      Check OPNT => fix r or z
         IF (IOPNT==1) THEN
*                               fix radius data
*                               ===============
            XX(2) = XPNT(1)
            FI    = FUNCT(XX)
            XX(2) = 0
            Z     = FUNCT(XX)
            R     = XPNT(1)
 
         ELSEIF(IOPNT==2)THEN
*                                 fix z- data
*                                 ===========
            XX(2) = XPNT(3)
            FI    = FUNCT(XX)
            XX(2) = 0
            R     = FUNCT(XX)
            Z     = XPNT(3)
 
         ELSE
            prin0 (TRPOINT(J,I),J=1,LPNT)
            (' FUMFIT: bad point in TRBANK',12F10.4)
            NEXT
         END IF
 
 
*       protection against EXDA overflow
        if(M.GE.NP)then
           prin0 I,NTB,M,NP
           (' fumfit: dimension of exda is too small, i,ntb,m,np=',6i6)
           Next
        endif
 
*       push point into fumilis common
 
         M       = M+1
         N       = 1
         EX(1,M) = XPNT(2)
         EX(2,M) = SPNT(1)/R
         EX(3,M) = OPNT
         EX(5,M) = 0
         EX(6,M) = 0
         EX(7,M) = 0
 
*      Check OPNT==1  r/z
         IF (IOPNT==1) THEN
            EX(4,M) = XPNT(1)
         ELSE
            EX(4,M) = XPNT(3)
         END IF
 
*      Check APNT(1) = MSGC   - u/v angle in R
         IF (APNT(1)==MSGC) THEN
            EX(5,M) = DPNT
            EX(6,M) = XPNT(1)
         END IF
 
*      Check APNT(1) = SCTT    - u/v angle in Z
         IF (APNT(1)==SCTT) THEN
            EX(5,M) = DPNT
            EX(6,M) = XPNT(3)
*           fi of center for tilt
            EX(7,M) = XPNT(2)
         END IF
 
*      Check APNT(1) = SITV    - cross-strips
         IF (APNT(1)==SITV) THEN
            EX(5,M) = DPNT
            EX(6,M) = XPNT(3)
*           fi of center for tilt
            EX(7,M) = XPNT(2)
         END IF
 
*      Check APNT(1) = PIXB    - pixels
         IF (APNT(1)==PIXB) THEN
            EX(5,M) = DPNT
            EX(6,M) = XPNT(3)
*           fi of center for tilt
            EX(7,M) = XPNT(2)
         END IF
 
*      Check APNT(1) = GAAS    - u/v angle in Fi
         IF (APNT(1)==GAAS) THEN
            EX(5,M) = DPNT
            EX(6,M) = XPNT(1)
         END IF
 
*      Check APNT(1) = ZSCT    - u/v angle in Fi
         IF (APNT(1)==ZSCT) THEN
            EX(5,M) = DPNT
            EX(6,M) = XPNT(1)
         END IF
 
*        u/v measurements
*        ----------------
         IF (APNT(1).NE.XTRT  &  DPNT.NE.0)NUV = NUV+1
 
*        precize z measurements
*        ----------------------
         IF (SPNT(2) <= SPNT(1))NZM = NZM+1
 
*      Check APNT(1)==XTRT - resolve the left/right ambiguity in some way
 
         IF (APNT(1)==XTRT) THEN
            NTR = NTR + 1
            IF (EPNT<0) XTR = XTR + 1
            IT  = 0
*         Check 1<I&I<NTB & IFTIME==1                   - locally
            IF (1<I & I<NTB  &  IFTIME==1) THEN
               SS(-1) = 0
               SS(+1) = 0
*            Loop here
               DO 21 I1 = -1,1,2
*               Loop here
                  DO 31 I2 = -1,1,2
                     F1 = XPNT(2)+I1*DPNT/R
*                  Loop here
                     DO 41 J = I-1,I+1,2
                        F2 = TRPOINT(3,J)+I2*TRPOINT(5,J)/R
                        IF (ABS (F1-F2)*R<DT0)SS(I1) = SS(I1)+1
41                   CONTINUE
31                CONTINUE
21             CONTINUE
 
*            Check (SS(-1) = 2 & SS(+1) = 0)    - left
               IF (SS(-1)==2  &  SS(+1)==0) THEN
                  IT = -1
               END IF
 
*            Check (SS(+1) = 2 & SS(-1) = 0)    - right
               IF (SS(+1)==2  &  SS(-1)==0) THEN
                  IT = +1
               END IF
            END IF
 
*         Check IFTIME==2                          - or globally
            IF (IFTIME==2) THEN
*            Check XPNT(2)<FI
               IF (XPNT(2)<FI) THEN
                  IT = +1
               ELSE
                  IT = -1
               END IF
            END IF
*         Check IT#0
            IF (IT.NE.0) EX(2,M) = .02/R
            EX(1,M) = EX(1,M)+IT*DPNT/R
            TRPOINT(12,I) = IT
         END IF
	 prin9 M,(EX(K,M),K=1,7); (' point m:', i6,10F10.3)
 
*       Add 2nd coordinate measurment if it is good enouph
*       --------------------------------------------------
 
         IF (SPNT(2)<SIG0) THEN
            M       = M+1
            N       = 2
            EX(2,M) = SPNT(2)
            EX(3,M) = OPNT
            EX(4,M) = 0
*         Check OPNT==1/2         ->    r/z
            IF (IOPNT==1) THEN
               EX(1,M) = XPNT(3)
            ELSE
               EX(1,M) = XPNT(1)
            END IF
            prin9 M,(EX(K,M),K=1,7); (' point m:', i6,10F10.3)
         END IF
 
 
*      Now reshuffle in increasing order - any Z is always bigger than any R
*      ----------------------------------------------------------------------
 
*      Loop here over new points
         DO K = 1,M-N
*           Skip second component and right order
            Prin9 k,Order(k); ('FumFit: K=',I4,' Order=',3F12.4)
            IF (EX(4,K)==0 | ORDER(K)<=ORDER(M-N+1)) NEXT
*           Loop here over old points
            DO 61 IW = 1,N
*              swap points
               DO 71 J = M,K,-1
71             CALL UCOPY(EX(1,J),EX(1,J+1),ns)
               CALL UCOPY(EX(1,M+1),EX(1,K),ns)
61          CONTINUE
            CALL VZERO(EX(1,M+1),ns)
            BREAK
 
         ENDDO
 
      enddo
 
      If Nok==0 { Print *,'FUMFIT ERROR: no points selected'; Goto 999; }
 
      prin9 (j,(EX(I,J),I=1,7),j=1,M)
            (' FUMFIT After ordering:'/(' fumfit j,ex=',i4,7F12.4))
*   ...
* ---------------------------------------------------------
*   ... ADD POINT FROM THE CALORIMETER (or other road pointer)
* ---------------------------------------------------------
*   ...
*   Check IFSHOW # 0 - if needed !
      IF (IFSHOW .NE. 0) THEN
*      Check RSHE==RCAL     r or z ?
         IF (RSHE==RCAL) THEN
            M       = M+1
            EX(1,M) = FSHE
            EX(2,M) = SSHE/RSHE
            EX(3,M) = 11
            EX(4,M) = RSHE
            M       = M+1
            EX(1,M) = ZSHE
            EX(2,M) = 200
            EX(3,M) = 1
            EX(4,M) = 0
         ELSE
            M       = M+1
            EX(1,M) = FSHE
            EX(2,M) = SSHE/RSHE
            EX(3,M) = 12
            EX(4,M) = ZSHE
            M       = M+1
            EX(1,M) = RSHE
            EX(2,M) = 200
            EX(3,M) = 2
            EX(4,M) = 0
         END IF
      END IF
*   ...
* ---------------------------------------------------------
*   FIT WITH FUMILI AND PRINT RESULTS
* ---------------------------------------------------------
*   ...
      CALL FUMSIZE           ! set steps for:
      PL0(1) = .01           !  A0
      PL0(2) = .01           !  F0
      PL0(3) = .01           !  1/pT
      PL0(4) = 1             !  z0
      PL0(5) = .1            !  dz/dR
      PL0(6) = 10            !  R brem
      AMN(6) =  1            !
      AMX(6) = 100           !
      PL0(7) = .01           ! and Xbrem
 
*   Check (MM>5 & XBREM==0)  - set first approximation for brem
 
      IF (MM>5  &  XBREM==0) THEN
         XBREM = DBREM
         RBREM = 12          ! better then nothing !
 
*        the most secret formula, no comments
         D = XBREM/RSHOW/(RBREM-RSHOW)/BCONST*2
         PTINV = PTINV-D
      END IF
 
*   Check XBREM>0 - fix its sign forever
      IF (XBREM>0) THEN
         AMN(7) = 0.
         AMX(7) =  100
      ELSE
         AMN(7) = -100
         AMX(7) =  0.
      END IF
 
      NN = M
      M1 = MIN(MM,5)
* try:
       IPR = -1
*      IF (MM==7)IPR = JPR
*     IPR=JPR
 
*   ===============================================
*   everything ready,      F I R E  !!!!!!
*   ===============================================
 
90    CONTINUE
 
 
	Prin9 Irc,IPR; ('IRC,IPR=',2I4);
 
      DO 91 IM = 1,3
*        Check MM>6 - go slowly, help FUMILI  manually
         IF (MM>6) CALL FUMILI (S, 6,2,2,30,0.1,AK,AL, -1,IRC)
                   CALL FUMILI (S,MM,2,2,30,0.1,AK,AL,IPR,IRC)
         Chi2=2*S
*        Check TAG=='best'&IPRIN>=2 \ IPRIN>=3  - trace fitting results
         IF (TAG=='best' & IPRIN>=2  |  IPRIN>=3) _
         <w> TAG,IRC,NTB,M,NZM,NUV,CHI2,1/PTinv,Fi0FIT,Z0FIT,XBREM,RBREM
         (1X,A6,' Irc,n,m=',5I4,' Chi2,Pt,fi0,Z0,X-Rbrem fitted=',F15.3,5F8.3)
*        calculate real NDF - number od degree of freedom
         NDF = -MM
         DO I = 1,NN  { IF (EX(2,I)<10) NDF+=1; }
*
*        Loop here over all points and select good
*        Check CHI2 <NDF*1.5  - good enouph, no clean up
         IF (CHI2<NDF*1.5) ICLEAN = 0
*        clean up if necessery
         IF (ICLEAN==0) GO TO 92
         CALL FUMCLEAN(IFL)
*        and if cleaned up, repeat fit
         IF (IFL==0) GO TO 92
*
91    CONTINUE
92    CONTINUE
 
      If NDF!=0 { A(10) = CHI2/NDF ; }
      Else      { A(10)=99999.; NDF0PR+=1;
                  If (NDF0PR<100) Print *,'FumFit: NdF=0 Chi2=',Chi2 ; }
 
      Prin5 chi2,ndf,a(10);
      (' FumFit: Chi2=',F8.1,' NdF=',I6,' Chi2/NdF=',F6.1)
*
*     TR signature
      IF (NTR>0) XTR = XTR/NTR
 
*     may be used in case of problems
*      IF (IGRAP>=2) CALL TRPLOT
 
999   Continue;
 
      END
 
 
+DECK,fumclean,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 13/03/95  23.59.17  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
      SUBROUTINE FUMCLEAN (IFL)
********************************************************************
*                                                                  *
*                    F U M C L E A N (IFL)
*                                                                  *
* Original Version:                                   Pavel Nevski *
* Modifications:                                      Never done   *
********************************************************************
+CDE,TYPING,FUMUSE.
 
*
      INTEGER   I,IM,IFL
      REAL      Y,CH2,CHMAX,FUNCT
      EXTERNAL  FUNCT
*
      CHMAX=0
      IFL=0
*
*   Loop here over points (do not through the last) and find the worst one
*
      DO I=1,NN-2
      {   Y=FUNCT(EX(3,I))
         Check I>2
         CH2=ABS((EX(1,I)-Y)/EX(2,I))
         Check CH2>CHMAX
         IM=I
         CHMAX=CH2
      }
      Check CHMAX>5.0
      EX(2,IM)=100*EX(2,IM)
*     Print *,' measurement rejected:', im,(EX(i,im),i=1,4),Chmax;
      IFL=IFL+1
      END
 
+DECK,AGPLANE,T=geant. --------------------------------------------------------
*CMZU:  1.00/01 25/01/96  22.22.59  by  Pavel Nevski
*CMZ :  1.00/00 04/10/95  19.58.59  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
*************************************************************************
*                                                                       *
                subroutine   A G P L A N E (Cset,Ip)
*                                                                       *
*************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCVOLU,AGCRTAB,AGCCLUS,AGCBUFF,HELVAR.
  INTEGER      NV,Nd;          PARAMETER   (NV=10,Nd=10);
  Integer      NVL(NV),ISC(NV),K,L,Ia,Iad,ip,Iz,Jz,kz,If,i,id,Lm,kk,Jd,
               AgPFLAG,Iprin,Ids,Ip2,Mz,Mf,modz,itry
  Real         DIGI(Nd),Fi,ZR,x(6),FUNCT,Fc,Df,Dz
  Character*4  Cset,Cdet,Cs
  Save         x,NVL,Cdet,Cs,Iprin,Ids,Ip2,Lm,Modz,Jd
*
*                                       for the first plane, get tables
;
  {Ndig,Ktyp}=0
;
  If Ip<=0 | Ip >999 | Cset(1:3)!=Cs(1:3)
  {  " start track at the vertex "
     Call Vzero(x,6);       Fi=Funct(x);
     Lm=Lhead+Lr*Lstack;    Call ASLGETBA (Cset,'RMAP',Lm,L,Isys);
     If Ip>0   { Lm=-Lm;    Call ASLGETBA (Cset,'RMAP',Lm,L,Isys);}
     Check  L>Lhead;
     Call VZERO(Nvl,Nv);    Call Vzero(Isc,Nv);   Call Vzero(Digi,Nd)
     Cs=Cset(1:3)//'D';     Call UHTOC(Inamd,4,Cdet,4);     {K,Ia}=0
     Call AgFDIGI (Cs,Cdet,NVL,Ltra,ISC,Digi,K,Ia)
     If Ip<=0 { Ip=0;                Ip2=Nplane; Ids=1;  }
     else     { Ip=min(Ip,Nplane)+1; Ip2=1;      Ids=-1; }
     " start neighbour counting "    Modz=0;  Jd=1;
     Iprin=AgPFLAG(Cset,'RECO')
  }
  If (Iprin<0) Return
*
  If (modz==0)  Ip+=Ids
  For Ip=Ip to Ip2 by Ids
  {                            " extrapolate the track to the next plane  "
     Call Ucopy(Rstack(1,Ip),rzp,Lr)
     Call Vzero(x,6);       x(1)=Itp;
     x(2)=rzp;  If (Itp==2) x(2)=sign(rzp,TL);
     Fi=Funct(x)
     Df=1.0/rs;  Dz=20;
                                     "    select one phi sector (if>=0)   "
     if=0;    If (dfi#0) if=nint((Fi-(Fmin+Fmax)/2)/Dfi);   Fc=Fcent+if*Dfi;
     if Itp=1 & Tilt#0   { x(1)=1+tilt; x(5)=Fc; Fi=Funct(x); }
     If nfi>1  { check Fmin+if*Dfi-Df <= Fi&Fi <= Fmax+if*Dfi+df; Fcent=Fc; }
*
                                        "    select z/r-section (iz>=0)   "
     {i,iz}=0;   x(2)=0;  ZR=Funct(x)
     Mz=max(Itp,Nzr);   Mf=max(1,Nfi)
     If Itp==1                          "    this is a barrel detector    "
     {  If (dzr!=0) iz=min(max(0,nint((ZR-(RZmin+RZmax)/2)/dzr)),Nzr-1)
        * Print *,' AgPLANE: ip,rzp,if,iz=',ip,rzp,if,iz,Rzmin,Rzmax,dzr
*
*       Roads may produce iz detector variations at both sides around center
        kz=iz+modz;  If RZmin+kz*dzr-dz <= ZR&ZR <= RZmax+kz*dzr+dz
        {  " closest neighbour direction is "  jd=sign(1.,2*ZR-RZmin-RZmax)
           " check next detector in advance and save it for the next entry "
           do itry=1,2
           {  modz=-modz;  if (jd*modz>=0) modz+=jd;  jz=iz+modz;
              If (0<=jz&jz<=Nzr-1) break;             jz=-1
           }
           If (jz<0 | RZmin+jz*dzr-dz>ZR | ZR>RZmax+jz*dzr+dz) modz=0;
           iz=kz;  * print *,'          itry,modz,iz,jz=', itry,modz,iz,jz
        }
        else                             " no detector left in this layer "
        { modz=0;  If (Cset!='XTRT' | Lm<0) Next
          " we are in the TRT barrel here - this should be followed by endcap"
          " backward tracing will be more complicate here - will do later(pn)"
          If (Ids*Lm<0) Break;       Lm=-Lm
          Call ASLGETBA (Cset,'RMAP',Lm,L,Isys)
          If L<0    { <w> ip; (' AgPLANE error in XTRT plane=',i3); Break; }
          If Ids>0  { Ip=0; Ip2=Nplane; }    else    { Ip=Nplane+1; Ip2=1; }
          Next
        }
     }
     else
     {" Delta Z and reflections rules may be conflicting - have to check it"
        If  dzr!=0  { iz=nint((ZS-Rzp)/dzr); iz=min(max(0,iz),Mz-1); }
        else        { iz=0;  if (ZS<0) iz=1; }
     }
     iad=Istart+Iadr+mod(if+Mf,Mf)+iz*max(1,Mf)
*
                                        "  pick up hits in one board  "
     Ndig=0;  KK=Ibuf(iad+1);
     IF KK>0
     {  Ndig=mod(KK,Lpack);  K=KK/Lpack-1 " may start from zero ";
        Do Id=1,Ndig
        {  Kdig(id)=k; Call  AgFDIGI (Cs,Cdet,NVL,Ltra(id),ISC,Digi,K,Ia);
           If k<=0
           { <w> Cs,Cdet,KK,Id,K,Ia,NVL; (' AgPLANE logic error in',
              2(1x,a4),' KK,Id,K,Ia=',4i6/20x,' NVL=',10i4);  break;
           }
           Ktyp=Digi(1); Fdig(id)=Digi(2); Zdig(id)=Digi(3); Edig(id)=Digi(4);
           If Cset=='XTRT'
           {  Ktyp=Itp;  Fdig(id)=Fcent+dfi*(ISC(3)-1);
              Zdig(id)=Digi(2);  Edig(id)=Digi(1);
           }
           prin5 id,Ktyp,Fdig(id),Zdig(id),Edig(id);
           ('   digit id,ktyp,f,z,E = ',2i5,3f12.4);
        }
        Call  AgFPATH (ISC);
        Ishape=Q(LQ(JGPAR-Nlevel)-4);   Npar=Q(LQ(JGPAR-Nlevel)-1);
        Call Ucopy(Q(LQ(JGPAR-Nlevel)+1),Par,min(Npar,50));	
        Call Ucopy(GTRAN(1,NLEVEL),AgTRAN,3);
        Call Ucopy(GRMAT(1,NLEVEL),AgRMAT,10);
     }
     prin8 Cset,ip,Ktyp,Ndig,Ishape,Npar,(par(i),i=1,Npar);
     (1x,a4,' plane',2i4,' Ndig=',i4,'  Shape,Npar=',2i5,(' par=',10f8.3));
     prin6 tilt,sas,fcent; (' plane angles t,s,f(AgPLANE) ',3F12.4);
     prin5 xs,ys,zs,rs,fi; ('   track at point   (FUNCT)  ',5F12.4);
     Return;                                                 :dummy:
  }
  Ip=0;
*
  END
 
 
+DECK,arclus,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 17/09/95  22.47.16  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
************************************************************************
*                                                                      *
                subroutine    A R C L U S (Par,Key)
*                                                                      *
* description:  SMEAR CLOSE HITS. key>0 - 2 dimensional pixels         *
*                                 key<0 strips                         *
************************************************************************
+CDE,TYPING,AGCCLUS.
*
  INTEGER    Itype,Key,MM,MY,MZ,ID,JD,IT,IND,JND,NN
  Real       Par(3),Dfp,Dzp,SE,SY,SZ
*
    Itype = nint(Par(1))
    Dfp   = Par(2)
    Dzp   = Par(3)
    If Itype=1 { "pixel" If Dfp<Dzp { Key=1 } else {Key=2 }; MM=100000}
    else       { "s.s.s" If Dfp<Dzp { Key=-1} else {Key=-2}; MM=0 }
 
*   select direction of clustering
    IF Dfp<Dzp {"Phi measurement, strips or pads in z (or R)" MY=1; MZ=MM;}
    else       {"z (or R) measurement, strips or pads in Phi" MY=MM; MZ=1;}
*
    DO ID=1,Ndig
    {   Check Edig(Id)>0
        IND=nint(Fdig(ID)/dfp+0.5)*MY+nint(Zdig(ID)/dzp+0.5)*MZ;
        { NN,SE,Sy,Sz }=0;    IT=Ltra(ID);
        DO JD=ID,Ndig
        {  Check Edig(JD)>0
           JND=nint(Fdig(JD)/dfp+0.5)*MY+nint(Zdig(JD)/dzp+0.5)*MZ;
                                     "   check if hits are adjacent   "
           IF JND=IND
           {  NN+=1;            IND+=1;
              SE+=Edig(JD);     SY+=Fdig(JD);    SZ+=Zdig(JD);
              IF (IT!=Ltra(Jd)) IT=0;            Edig(JD)=0;
        }  }
        Edig(Id)=SE; Fdig(Id)=SY/NN; Zdig(Id)=SZ/NN; Nclu(Id)=NN; Ltra(Id)=IT;
    }
  END
 
+DECK,AGDECODE,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 08/09/96  13.33.40  by  Pavel Nevski
*CMZU:  1.00/01 21/12/95  13.52.03  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
*************************************************************************
*                                                                       *
                subroutine   A g D e c o d e (Cdet,itype)
*                                                                       *
* Description:                                                          *
*   Geometry of a given sensetive detector is generalised in a table.   *
*   Each table line repersent a hyper-plane (repetetive elements) with  *
*   known periodicities in phi and z.                                   *
*   If itype is more than 10, only elements with this serial number     *
*   are scanned.                                                        *
*   Z periodicity may be approximative (dz-rule) or be a reflection     *
*   In the first case detectors should be always position from left to  *
*   right sequentially, in the second - always starting from innermost  *
*   pair (or center), otherwise problems may arise.                     *
* known problems:                                                       *
*   It is not yet as versatile as one may think, this will come         *
*************************************************************************
Replace[ERR(#)]   with _
       [{<W> Cdet; (' error in AgDECODE for detector ',a4,2x,'#1'); RETURN;}]
*
+CDE,TYPING,GCBANK,GCNUM,GCVOLU,GCONST,GCUNIT,AGCRTAB.
Integer       LOCF,LENOCC,ICDECI,Itype,Js,Jd,Jdu,i,j,k,i1,i2,L,LL,p,N,
              Lv,Iv,Jv,Jvo,ip,it,iz,ir,mm,nz,Iax,Ish,Imo,Ivo,Jm,In,Jn,Nin,
              Nr,Name,Nick,ier,Natt,Nvr,Nvb,Nb,kk0,jj,JATTF,serial,
              Ndv(2),Nvl(15),Lnam(15),Ivol(15),NwuVol/3/,Irot/0/
Real          VMOD,ATAN2,c0(2),st(2),Att(20),pp(3),p0(3),xyz(3),e1,e2,e3,d2m,
              r,f,z,v,Rmin,Rmax,Zmin,Zmax,d1,d2,d3,pt,pr,pz,ptm,prm,pzm,ds,es,
              zero(3)/3*0./,eps/1.e-4/
Character     Cdet*(*),Cs*4,cd*4
JATTF(Jj)  =  Jj+int(Q(Jj+5))+6
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*   Routine is not fully reentrant when geometry is changed (Irot...)   *
  L=0;  If  (JROTM>0 & Irot>0)               L=LQ(JROTM-Irot)
        If  (L>0 & Q(L+1)+Q(L+5)+Q(L+9)!=3)  L=0
*
  If L==0                                     " no rotation matrix "
  {  N=0;  If (JROTM>0) N=IQ(JROTM-2)
     Do Irot=1,N+1 { If (LQ(JROTM-Irot)<=0 | Irot>N) Break; }
     call GSROTM (Irot,90.,0.,90.,90.,0.,0.)
  }
*                                       first, make a set up
  call Vzero(ISYS,Lhead);   Check Jset>0;   Itp=mod(Itype-1,2)+1;
  " get level offset from the detector name "
  Nvr=0; if (Lenocc(Cdet)>=6) Nvr=ICDECI(Cdet,5,6);
  RRmin=10000;  ZZmin=10000;
 
*                                       find the set/det and its user bank
  :set: DO Iset=1,IQ(Jset-1)                                 " Over Nset "
  {  JS=LQ(Jset-Iset);   Check JS>0;  Call UHTOC (IQ(Jset+Iset),4,Cs,4);
     :det: DO Idet=1,IQ(LQ(Jset-Iset)-1)                     " Over Ndet "
     {  JD=LQ(JS-Idet);  Check JD>0;  Call UHTOC (IQ(JS + Idet),4,Cd,4);
        Check Cdet(1:4)=cd;   JDU=LQ(JD-3);    Check JDU>0;    goto :F:;
  }  }  Return;                                                     :F:
*
*              now unpack the tree info and find the known periodicities
*              using generic volumes only ( to avoid to much scanning )
  i1=Q(Jdu+3); i2=Q(Jdu+5); {k,kkk,kfi,krz,kk0}=0;  Nvb=Q(Jdu+6)+Nvr; d2m=0;
  do i=i1,i2-1,NwuVol
  {  kkk+=1;  j=jdu+i;  iv=Q(j+1);  Nmx(kkk)=Q(j+2);  Nam(kkk)=IQ(Jvolum+iv);
     Nb=Q(j+3);   If (Nb>0) K+=1;   if (K<=Nvb) kk0=kkk;
     jv=LQ(Jvolum-iv); nin=Q(jv+3); Ish=Q(jv+2);
     if nin<0
     {  jd=LQ(jv-1); Iax=Q(jd+1);
        If Iax=2 & (5<=Ish&Ish<=8 | 11<=Ish&Ish<=12)        " phi-divisions"
        {  If kfi#0  { <w> Cdet,kkk,nam(kkk); (' error in agdecode for ',a4,
                      ' at level',i5,2x,a4,' many phi divisions');   next;
        }  kfi=kkk+1;}
        else                                                " z-divisions "
        {  If krz#0  { <w> Cdet,kkk,nam(kkk); (' error in agdecode for ',a4,
                      ' at level',i5,2x,a4,' many  z  divisions');   next;
        }  krz=kkk+1; }
  }  }
*                                                   dont scan known things
  if (kfi#0) Nmx(kfi)=-Nmx(kfi);  if (krz#0) Nmx(krz)=-Nmx(krz);
*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
  { c0(1),c0(2),st(1),st(2),Ndv(1),Ndv(2) }=0;
  LL=1;  Nvl(1)=0;  Ivol(1)=Q(Jdu+i1+1);  Lnam(1)=IQ(Jvolum+Ivol(1));
  :LL: while LL>0
  { NVL(LL)+=1 ;    if NVL(LL)>max(1,Nmx(LL)) { LL-=1; Next; }
    Lv=LL; LL=kkk;  do i=Lv+1,kkk             { NVL(i)=1; }
    Call Vzero(rzp,Lr);
    :L: Do L=Lv,kkk                    " encode the nickname path    "
    {  If (L=1) Next;  Imo=Ivol(L-1);  Jm=LQ(JVOLUM-Imo); nin=Q(Jm+3);
       p=0;  if  nin<0 & L=kfi {p=1}  else  if  nin<0 & L=krz  {p=2};
       if p>0                         " save steps for periodicities "
       { jd=LQ(Jm-1);  Ndv(p)=Q(jd+3); C0(p)=Q(jd+4); St(p)=Q(jd+5); }
       do in=1,max(nin,1)             " find next nickname content   "
       {  jn=LQ(Jm-in);  Ivo=Q(jn+2);  Jvo=LQ(JVOLUM-Ivo);  Nr=Q(jn+3);
          Name=IQ(jvo-4); Nick=IQ(JVOLUM+Ivo); Ish=Q(jvo+2);
          Serial=Q(JATTF(jvo)+10)
          Check   nam(L)=Name     | nam(L)=Nick;
          Check   nin>0&Nvl(L)=Nr | nin<0&Nvl(L)<=Nr;
          Lnam(L)=IQ(JVOLUM+Ivo);    Ivol(L)=Ivo;     Next :L:;
       }  LL=L-1; Next :LL:;
    }
  * make device typing stronger - skip elements which do not fit definition
    If (Itype>2 & Serial!=Itype) Next
    call GLVOLU(kkk,Lnam,NVL,ier);  call GDTOM(zero,xyz,1);
  *
  * copy the current rotation into a working matrix
    call Ucopy  (GRMAT(1,kkk),Q(LQ(Jrotm-Irot)+1),10)
    call GFIPAR (jvo,jn,in,Npar,Natt,Par,att)
    call GFLRAD (4,ish,Irot,GTRAN(1,kkk),Par,Rmin,Rmax,ier)
    call GFLPHI (  ish,Irot,GTRAN(1,kkk),Par,Fmin,Fmax,ier)
    call GFLCAR (3,ish,Irot,             Par,Zmin,Zmax,ier)
    If (Fmin>Fmax) Fmin-=360
    Fmin*=DegRad;                         Fmax*=DegRad;
    Zmin+=GTRAN(3,kkk);                   Zmax+=GTRAN(3,kkk);
    RRmin=min(RRmin,Rmin);                RRmax=max(RRmax,Rmax);
    ZZmin=min(ZZmin,abs(Zmin),abs(Zmax)); ZZmax=max(ZZmax,abs(Zmin),abs(Zmax))
  *
    r=vmod(xyz,2);     z=xyz(3);     f=0;    Jres=Serial;
    if r>0 { f=atan2(xyz(2),xyz(1)); if (f<0) f+=2*pi; };  Fcent=f;
    " tilt is a dfi/dr - angle between plane normal and radius to it center"
    " sas  is a dfi/dz - tangent component of a local axial vector "
    { ir,it,iz,prm,ptm,pzm,tilt,sas }=0
    do i=1,3
    { Call Vzero(p0,3);   p0(i)=1;   call GDTOM(p0,pp,2);   v=Vmod(pp,2);
      pr=xyz(1)*pp(1)+xyz(2)*pp(2);  pt=xyz(1)*pp(2)-xyz(2)*pp(1);  pz=pp(3);
      If abs(pr)>prm  { ir=i; prm=abs(pr); Tilt=pt/(r*v); }
      If abs(pt)>ptm  { it=i; ptm=abs(pt); }
      If abs(pz)>pzm  { iz=i; pzm=abs(pz); }
    } sas=GRMAT("iz" 3+3*(it-1),kkk);  Iaxr=ir; Iaxt=It; Iaxz=Iz;
    *
    *                    make a new entry
    if Itp=1
    {  drzm=max(drzm,Rmax-Rmin);  rzp=r; Rzmin=Zmin; RZmax=Zmax; }
    else
    {  drzm=max(drzm,Zmax-Zmin);  rzp=z; RZmin=Rmin; RZmax=Rmax; }
 
    If kfi!=0   { Nfi=Ndv(1);  Dfi=sign(st(1),GRMAT(9,kfi))*DegRad; }
    If krz!=0   { Nzr=Ndv(2);  Dzr=st(2); }
    Nump=0;  do i=1,kkk { check Nmx(i)>1;  Nump*=Nmx(i)+NVL(i)-1; }
    *
    *                    put it in the table
    DFN [I_[NAME]]  as  [ Istack(LOCF(#1)-LOCF(rzp)+1,ip) ]
    DFN [R_[NAME]]  as  [ Rstack(LOCF(#1)-LOCF(rzp)+1,ip) ]
    do ip=1,Nplane
    {  d1=abs(rzp)-abs(R_rzp); e1=abs(d1)-eps*abs(rzp)
       if e1>0  { check d1<0; go to :ins: }
       d2=RZmin-R_RZmin;       e2=abs(d2)-eps*abs(RZmin)
       ds=abs(RZmin+R_RZmax)+abs(RZmax+R_RZmin)
       es=abs(ds)-eps*abs(RZmin+Rzmax)
       d3=Fmin-R_Fmin;        e3=abs(d3)-eps*abs(Fmin)
 
       If Itp=1 & krz==0 & e3<0                  " some artificial rules"
       { If mrz==0
         {  If ("dz-rule"  dfi==R_dfi & abs(R_RZmin+R_Rzmax)>abs(RZmin+RZmax)_
              | "reflection"  dfi==-R_dfi & Es<0 )  mrz=Nump-I_Nump
         }
         If mrz>0
         {  Nz=(Nump-I_Nump)/mrz;  I_Nzr=max(I_Nzr,Nz+1)
            if (R_dzr==0 & Nz>0)   R_dzr=(RZmin-R_RZmin)/nz
            d2=d2-R_dzr*Nz;        d2m=max(d2m,abs(d2))
            if (abs(d2)>1.) <w> Ip,Nz,d2; (' bad dz rule: Ip,nz,d2=',2i5,f9.3)
            goto :eq:
       } }
       if abs(d2)>eps*abs(RZmin)   { check d2<0; go to :ins: }
       if abs(d3)>eps*abs(Fmin)    { check d3<0; go to :ins: }
       goto :eq:
    }  ip=Nplane+1;
    :ins: call Ucopy2(Rstack(1,ip),Rstack(1,ip+1),Lr*(Nplane-ip+1));
          call Ucopy (rzp,Rstack(1,ip),Lr);           Nplane+=1;
          if Nplane>=Lstack {err(too many planes found, quit)};
    :eq:  if abs(rzp+R_rzp)<eps*abs(rzp) & Itp=2 & Dfi==-R_Dfi "reflection"
          {  mm=Nump-I_Nump;       If (mrz=0 & mm!=0) mrz=mm;
             If mm!=mrz {err(z-reflections are too complicate, quit)}
          }
  }
  * last pass over the table - addresses and extremis
  Nadr=0; NumPmx=0; drzm=max(drzm,d2m);
  * scan volume offset (kk0) is taken into account only for divisions:
  do ip=1,Nplane                       " temporary - may find a better way  "
  {  if (kfi>=kk0) I_nfi=-I_nfi;   if (krz>=kk0) I_nzr=-I_nzr;
     " NumP may have increasing modifications due to dz or reflection rules "
       NumPmx=max(NumPmx,I_NumP+(max(I_Nzr,Itp)-1)*mrz+1)    " 1 word fence "
     " take into accont that in end-caps we always have only reflections    "
     I_Iadr=Nadr;  Nadr+=Max(1,I_Nfi)*Max(Itp,I_Nzr);
  }
  END
 
 
 
 
+DECK,agetplane,T=geant.
*CMZ :  1.30/00 28/06/96  18.19.55  by  Pavel Nevski
*-- Author :    Pavel Nevski   28/06/96
****************************************************************************
       subroutine AGETPLANE (Clev,IP,IF,IZ)
*                                                                          *
* decscription:                                                            *
*   given a layer generic name, reconstructs all its GEANT parameters      *
*   (shape, position, rotation) for a selected entry in AGCRTAB            *
****************************************************************************
+CDE,typing,GCUNIT,GCBANK,GCVOLU,AGCRDIG,AGCRTAB.
*  -----------------------------------------------------------------
*
       Integer      IP,IF,IZ,I,K,KK,NUM,ILEV,LEV,NUMBV(20)
       Character    Clev*(*)
*
*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*      If (Cd!=Cdet(1:4)) Call AGDECODE(Cdet,IT)
       JS=LQ(Jset-Iset);  Check JS>0;  Call UHTOC (IQ(Jset+Iset),4,Cs,4);
       JD=LQ(JS-Idet);    Check JD>0;  Call UHTOC (IQ(JS + Idet),4,Cd,4);
       JDU=LQ(JD-3);      Check JDU>0;
*
       Call UCOPY(Rstack(1,ip),rzp,Lr)
       Call UCTOH(Clev,ILev,4,4)
       K=0; NUM=NUMP; Lev=kkk
       Do i=1,kkk
          If (ILev==NAM(i))  Lev=i
          If (abs(NMX(i))>1) k=k+1
       enddo
       kk=k
       Do i=kkk,1,-1
          Check abs(NMX(i))>1
          If (nmx(i)>1)  then
             NUMBV(k)=mod(NUM,NMX(i))+1
             NUM = NUM/NMX(i)
          else
             NUMBV(k)=1
             If (K==kfi) NUMBV(k)=IF
             If (K==krz) NUMBV(k)=IZ
          endif
          k=k-1
       enddo
*      <w> ip,(numbv(i),i=1,kk); (' ip=',i3,' numbv=',15i5)
       Call AGFPATH(NUMBV)
 
       Ishape=Q(LQ(JGPAR-Lev)-4);   Npar=Q(LQ(JGPAR-lev)-1);
       Call Ucopy(Q(LQ(JGPAR-lev)+1),Par,min(Npar,50));	
       Call Ucopy(GTRAN(1,LEV),AgTRAN,3);
       Call Ucopy(GRMAT(1,LEV),AgRMAT,10);
*
       END
 
 
 
+DECK,AxxxPREP,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 19/06/96  03.24.23  by  Pavel Nevski
*CMZ :  1.00/00 04/10/95  19.54.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/02/95
************************************************************************
*                                                                      *
                   subroutine    A x x x P R E P
*Attention: XTRT is special now - it is TWO detectors with types 11 &12*
************************************************************************
Replace[CHK#;] with _
  [; IF (~(#1)) { <W> Cset; (' Error in XXXPREP for detector ',a4,
                             ' condition #1 is not satisfied'); NEXT; };
  ]
+CDE,TYPING,GCUNIT,AGCBUFF,AGCRTAB.
  INTEGER       NN,  NV,   Nd,   Lt
  PARAMETER    (NN=7,NV=10,Nd=10,Lt=3000)
  * trt: XGAS, mdt: FMUC/FTUI, MUCH/MTUI
  Character*6  Csets(NN)/'PIXB','PIXE','SITV','SCTT','ZSCT','XTRT',  'XTRT'/;
  Character*6  Cdets(NN)/'PBCR','PECR','STCR','SCTB','ZSEN','XGAS-1','XGAS-1'/
  Integer      Itypes(NN)/   1 ,    2 ,    1 ,    1 ,    2 ,   11  ,    12 /;
  Integer      NVL(NV),ISC(NV),Iaddr(0:Lt),Nfdim(0:Lt),Nzdim(0:Lt);
* - - - - - - - - - -
*CDE,SLDBNK. - Slug auxilary common for SLDETBA routine
      CHARACTER*4  CHFOR
      INTEGER      IOWDS
      COMMON /SLDBNK/ CHFOR,IOWDS(16)
* - - - - - - - - - -
  INTEGER      AgPFLAG,Id,Ip,Iprin,Ifree,Itype,Lmap,N,I,J,K,L,
               Ia,i1,i2,Ndi,Nds,Ndd,Ltra;
  Character*6  Cset,Cdet;
  Real         Digi(Nd);
  Logical      First/.true./;
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 Ifree=1;   Call Vzero(Ibuf,Lbuf);
 Do Id=1,NN
 {  Itype=Itypes(Id);  Cset=Csets(Id);  Cdet=Cdets(id);
    IPrin=AgPFLAG(Cset,'RECO');         Check IPrin>=0;
    If First
    {  Call AgDECODE(Cdet,Itype);   Check Nplane>0;
       Call UCTOH(Cdet,Inamd,4,4);  Isys=Id;  Istart=Ifree;
       L=Lhead+Lr*Nplane;
       If (Cset=='XTRT' & Itype==12) L=-L;
*      - - - - - - - - - - - - - - - - - -
       CALL MZIOCH (IOWDS,16,'9I 5F 3I 1H 4I 15H 15I / 10F 5I'); CHFOR='RMAP';
       Call ASLSETBA(Cset,'RMAP',L,Isys);                         CHFOR=' ';
 
       Prin2 (nam(i),i=1,15); (' Names=',15(2x,a4))
       Prin2 (Nmx(i),i=1,15); (' LVmax=',15i6)
       Prin2 Itp,Nplane,kfi,krz,mrz,drzm,iaxr,iaxt,iaxz
             (' type',i2,' Nplane=',i3,' k=',2i3,i6,f8.3,' axes r,t,z=',3i2)
       Prin3 ((Rstack(i,ip),i=1,10),(Istack(i,ip),i=11,Lr),Ip=1,Nplane)
             (' R,z,F=',3F8.2,3F7.3,F8.2,3F7.4,' N=',3i4,i6,i4)
       Prin1 Cset,Ifree,Ifree+Nadr
             (' AXXXPREP: Detector ',A4,', required space',2i8);
    }
    else
    {  L=Lhead+Lr*Lstack;
       If (Cset=='XTRT' & Itype==12) L=-L;
*      - - - - - - - - - - - - - - - - - -
       Call ASLGETBA(Cset,'RMAP',L,Lmap,Isys);
    "  <w> L,Lmap,Isys,Istart,Nadr;(' ASLGETBA: L,Lmap,Isys,Istart,Nadr=',5I6)"
       Check Lmap>0;   CHK Lmap>=Lhead+Lr*Nplane;
    "  <w> Cset,Lmap; (' AXXXPREP error: ',a,' reconstruction bank len=',i4) "
    }
   *                    make intermediate map
    Ifree+=Nadr+1;                                CHK Ifree<Lbuf;
    Call Vzero(Ibuf(Istart+1),Nadr+1);            Call Vzero(Iaddr,Lt+1);
    Do Ip=1,Nplane
    {  Call Ucopy(Rstack(1,ip),rzp,Lr);           CHK Nump<=Lt;
       Ia=Istart+Iadr;                            CHK Ia<Ifree;
       Iaddr(NumP)=Ia;                            Nfdim(NumP)=Max(1,Nfi);
       " in endcaps we always do a reflection "   Nzdim(NumP)=Max(Itp,Nzr);
    }
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Call VZERO(NVL,NV);   {K,ia,Ndi,Nds}=0;
    Loop
    {  Call AgFDIGI (Cset(1:3)//'D',Cdet,NVL,Ltra,ISC,DIGI,K,IA);
       If (k<=0) Break;
       If Cset=='XTRT' { Check Itype==11 & ISC(1)<=2 | Itype==12 & ISC(1)>=3; }
       Ndi+=1;  {N,j}=0; { i1,i2 }=1;
      * - - -    step one - map ISC to the packed address NumP
       do i=1,kkk
       { Check abs(Nmx(i))>1;  j+=1;  If (Nmx(i)>1) N*=Nmx(i)+ISC(j)-1;
         If (i==kfi)  i1=ISC(j);      If (i==Krz)  i2=ISC(j);
       }
       prin9 Ndi,(ISC(i),i=1,j),N;  (' AXXPREP Ndig,ISC,Nump=',10i6)
 
       * step two - modify Nump to account for z shifts (dz rule or reflection)
       CHK N<=Lt;  Ia=Iaddr(N);
       if krz=0 & mrz>0  { while Ia=0&N>=mrz { i2+=1; N-=mrz; Ia=Iaddr(N); } }
 
       " skip hits which are not mapped "  chk Ia>0;
       CHK N>=0;    i1=min(i1,NFdim(N));   i2=min(i2,NZdim(N));
       prin9 N,Ia,i1,i2,Ltra;   (' selected Npack,Ia,i1,i2,Ltra=',6i6);
       ia+=i1+(i2-1)*Nfdim(N);    CHK Istart <=Ia&Ia< Ifree;
       Ndd=Ibuf(Ia);   IF (Ndd=0) Ndd=k*Lpack;   Ndd+=1;
       if mod(Ndd,Lpack)=0  { <W> Cset,(ISC(i),i=1,J);
          (' AXXXPREP overflow in det=',a4,' nbv=',15i5); Break; }
       Ibuf(Ia)=Ndd;   Nds+=1;
    }
    Prin2 Cset,Ndi,Nds; (' AXXXPREP: total digits in detector ',a4,' =',2I8);
    " prin9 (Ibuf(i),i=1,Ifree); (20i5); "
 }
 First=.false.
 end
 
 
+DECK,fumili,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 25/08/95  00.09.19  by  Pavel Nevski
*-- Author :  Silin & Sokolov
********************************************************************
*                                                                  *
               subroutine     F U M I L I _
            (S,M,N1,N2,N3,EPS,AKP,ALM,IT,MC)
*                                                                  *
*           almost copy of D520 from CERNLIB                       *
* Original Version:                                Silin & Sokolov *
* Modifications:                                    Pavel Nevski   *
********************************************************************
+CDE,TYPING,FUMSIZ.
      C O M M O N /ENDFLG/NA,IEND,IND
      LOGICAL FUMPLA
      INTEGER M,N1,N2,N3,IT,MC,NA,IEND,IND,NN1,NN2,NN3,NINF,NFIX,
              I,N0,NN0,I1,I2,J,J1,J2,IMX,IFX,M1,L1,IFI
      REAL    S,EPS,AKP,ALM,T,GT,T1,RP,SP,DS,OLDS,Ai,AJ,Ak,Al,Afix,d,
              SIGI,AMAX
      DATA RP/1.E-5/ ! 10*MAX. RELATIVE PRECISION
* ..
      NN2  = 0
      NN3  = 0
      NINF = 0
      NFIX = 0
      IEND = 0
      CALL VZERO (RR,M)
      CALL UCOPY (PL0,PLU,M)
      IF (EPS>0) CALL VZERO (SIGM,M)
* ...                             *****  new iteration *****
10 T1  = 1
   NN1 = 1
   Loop
   {  S   = 0
      CALL VZERO (GG,M)                      ! REPEAT WITH SMALLER STEP
      DO I = 1,M
      {  Check FUMPLA(PL0,I,N0)
         IF (PLU(I)>0) PL0(I) = PLU(I)       ! save PL, may be fixed later
      }
      NN0 = N0*(N0+1)/2
      CALL VZERO (ZZ,NN0)
      NA = M
      CALL FUMSGZ (M,S)
      SP = RP*ABS(S)
      DS = OLDS-S
      CALL UCOPY(ZZ,Z0,NN0)
      IF (NN3<=0 | NN1>N1 | DS>GT/6 | ABS(DS) <=SP & GT<=SP) Break
* ...                                  **** relaxation ****
      T = AMAX1(0.5*GT/(GT-DS),0.25)
      GT = GT*T
      T1 = T1*T
      NN2 = 0
      NN1 = NN1+1
      DO I = 1,M
      {  Check PLU(I)>0
         A(I)   = A(I)-DA(I)*(1-T)
         PLU(I) = PLU(I)*T
         DA(I)  = DA(I)*T
      }
   }
* ..                                   fix some parameters and compress Z
50 Loop
   {  I2 = 0
      DO I = 1,M
      {  Check FUMPLA(PL0,I,I1)
         IF (PLU(I)==0)      PLU(I) = PL0(I)
         IF (PLU(I)>0 & (A(I)>=AMX(I)&GG(I)<=0 | A(I)<=AMN(I)&GG(I)>=0)) _
                                                                PLU(I)=0
         check FUMPLA(PLU,I,I2)
         J2 = 0
         DO J = 1,I
         {  Check FUMPLA(PL0,J,J1)
            Check FUMPLA(PLU,J,J2)
            ZZ(I2*(I2-1)/2+J2) = Z0(I1*(I1-1)/2+J1)
         }
         RR(I) = ZZ(I2*(I2+1)/2)    ! save ZZ(I,I) in correlation factors
      }
* ...                            ***  get covariance matrix ***
      CALL FUMCONV(I2)
      If (IND==0) Break
      NINF = NINF+IND
      NFIX = NFIX+1
      IFI  = 0
   }
 
* ..             CALCULATE STEPS, CHECK BOUND, LIMITING OF STEPS
      ALM  = 1
      AKP  = 0
      AFIX = 0
      IMX  = 0
      IFX  = 0
      DO I = 1,M
      {  DA(I) = 0
         Check FUMPLA(PLU,I,I1)
         D=0
         DO J = 1,M
         {  Check FUMPLA(PLU,J,J1)
            M1 = MAX0(I1,J1)
            D = D-GG(J)*ZZ(M1*(M1-3)/2+I1+J1)
         }
         AI = A(I)
         L1 = I1*(I1+1)/2
* ...                                    calculate A,KAP,LAM
         AJ = min(max(AMN(I),AI-PLU(I),AI+D),AI+PLU(I),AMX(I))
         SIGI  = SQRT(ABS(ZZ(L1)))
         RR(I) = RR(I)*ZZ(L1)
         IF (EPS>0) SIGM(I) = SIGI
         AK  = ABS(D/SIGI)              ! parameter step vs its accuracy
         AL  = ABS((AI-AJ)/D)           ! actual(plu limited) step vs desired
         AKP = max(AKP,ABS(D/SIGM(I)))
* ...                                    check for fixation and limitation
         IF AK>AFIX & (AI>=AMX(I)&D>0 | AI<=AMN(I)&D<0) { AFIX=AK;  IFX=I; }
         If AL<=ALM                           {  ALM=AL;  AMAX=AJ;  IMX=I; }
         DA(I) = D
      }
      IF (IFX<=0) GO TO 120
      PLU(IFX) = -1
  110 NFIX = NFIX+1
      IFI = 0
      GO TO 50
* ..                                     trying to increase step
  120 GT = 0
      DO 140 I = 1,M
         IF (PLU(I)<=0) GO TO 140
         IF (NN2<=N2  |  ABS(PLU(I)/DA(I))>4*ALM) GO TO 130
         PLU(I) = 4*PLU(I)
         T1     = 4
  130    DA(I)  = DA(I)*ALM
         GT     = GT-DA(I)*GG(I)
  140 CONTINUE
* ...
      IF (AKP<=ABS(EPS)) GO TO 160       ! accuracy check
      IEND = 0
      IFI  = IFI+1
      IF (NFIX==0 | IFI-1<=NFIX) GO TO 170
  150 CALL UCOPY(PL0,PLU,M)              ! un-fix parameters
      NFIX = 0
      NINF = 0
      GO TO 50
* ...
  160 IEND = IEND+1
      IF (NFIX==0) GO TO 170
      IF (IEND==1) GO TO 150
* * *       IF (NFIX>NINF) IEND = 0        ! estx ON BOUND
* ...
  170 IF (IEND==0 & NN3>=N3) IEND = -3 ! ITER.LIMIT
      IF (IEND>0 & NINF>0)   IEND = -2 ! INF.ER.ESTIM
      IF (GT<=SP & T1<1 & ALM<1) IEND = -1
      IF (IT>=0) CALL FUMONITO(S,M,NN3,N3,IT,EPS,GT,AKP,ALM,T1)
* ...
      MC = IEND
      IF (IEND!=0) RETURN              ! TEST FOR END
      OLDS = S
      NN2 = NN2+1
      NN3 = NN3+1
      DO 180 I = 1,M
  180 A(I) = A(I)+DA(I)
      IF (IMX>0) A(IMX) = AMAX
      GO TO 10
      END
 
********************************************************************
*                                                                  *
               subroutine   F U M O N I T O _
            (S,M,NN3,N3,IT,EPS,GT,AKP,ALM,T1)
*                                                                  *
* Original Version:                                Silin & Sokolov *
* Modifications:      03/10/94                      Pavel Nevski   *
********************************************************************
+CDE,FUMSIZ.
      C O M M O N /ENDFLG/NA,IEND,IND
      Integer M,NN3,N3,IT,NA,IEND,IND,IP,LU/6/
      Real    S,EPS,GT,AKP,ALM,T1,P
*
      IP=1
      IF (IT>0) IP=MOD(NN3,IT)
*     print each IT iteration or the last one, if IT positive:
      IF (IP==0  |  IEND.NE.0)  &  IT>=0
      {  Output NN3,S*2,GT*2,AKP,ALM,T1
         (/8(' *'),I3,5H ITER,2X,3H2S= ,E11.4,2X,3HGT=,E10.2/,
            15X,4HKAP=,E8.2, 2X,5HLAMB=,E8.2, 2X,3HT1=,E8.2//,
            15X,10HPARAMETERS, 5X,6HERRORS, 10X,7HFACTORS)
         DO I=1,M
         {  P=-100
            IF (PL0(I)>0)   P=PLU(I)
            IF (P>0)        output I,A(I),SIGM(I),RR(I)
                   (10X,I3,E13.5,3H+/-,E10.4,6X,E10.3)
            IF (-1<=P&P<=0) output I,A(I),SIGM(I),RR(I)
                   (10X,I3,E13.5,3H+/-,E10.4,6X,E10.3,'  ON BOUND')
            IF (P==-2)      output I,A(I)
                    (10X,I3,E13.5,12H+/- INFINITE)
      }  }
      IF(IEND==-1) output; (' S does not decrease, bad derivatives')
      IF(IEND==-2) output; (' infinite parameter errors    ')
      IF(IEND==-3) output; (' iteration limit is exceeded  ')
      END
 
 
********************************************************************
*                                                                  *
        FUNCTION     F U M P L A (PL,I,I1)
*                                                                  *
*       find next free parameter                                   *
* Original Version:                                 Pavel Nevski   *
********************************************************************
        IMPLICIT NONE
        LOGICAL  FUMPLA,L
        INTEGER  I,I1
        REAL     PL(*)
        IF (I==1) I1=0
        L=PL(I).GT.0
        IF(L) I1=I1+1
        FUMPLA=L
        END
 
********************************************************************
*                                                                  *
               SUBROUTINE   F U M C O N V (N)
*                                                                  *
*         fast matrix conversion - FUMILI original                 *
* Original Version:                                Silin & Sokolov *
* Modifications:                             never done since 1961 *
********************************************************************
+CDE,TYPING,FUMSIZ.
        Integer         NA,IEND,IND,N,IR,I,Ni,II,L1,K,NL,KI,NK
        Real            Aps,Rp,Am,Ap,D,C,ZI
        COMMON /ENDFLG/ NA,IEND,IND
        DATA   RP/1.E-5/     ! MAX.REL.PRECISION - 10/10/94 * 10
        DATA   AM/1.E+35/    ! MAXIMAL NUMBER ON THE COMPUTER
*
   IND = 0
   Check N>0
   APS = SQRT(AM/N)
   AP  = 1/APS**2
   IR  = 0
   DO I=1,N
   {  IR+=1;  while PLU(IR)<=0 { IR+=1; }
      NI=I*(I-1)/2
      II=NI+I
      ZI=ZZ(II)
      IF (ZI<=RP*ABS(RR(IR)) | ZI<=AP) GO TO 170
      ZI=1./SQRT(ZI)
      ZZ(II)=ZI
      Do NL=II-1,NI+1,-1
      { ZZ(NL)=ZZ(NL)*ZI;  IF (ABS(ZZ(NL))>=APS) GO TO 140;   }
      Check I<N
 
* . . .  inversion here  . . .
      Do K=N,I+1,-1
      {  NK = K*(K-1)/2
         NL = NK
         D  = ZZ(NK+I)*ZI
         C  = D*ZI
         Do L1=K,1,-1
         { IF   L1>I    { ZZ(NK+L1)-=ZZ(NL+I)*C;  NL=NL-L1+1; }
           Else IF L1<I { ZZ(NK+L1)-=ZZ(NI+L1)*D;             }
           Else         { ZZ(NK+L1)=-C;                       }
   }  }  }
 
* . . .  normal exit here  . . .
      DO I=1,N
      {  DO K=I,N
         {  NL=K*(K-1)/2
            D=0.
            DO L1=K,N  { D+=ZZ(NL+I)*ZZ(NL+K); NL+=L1; }
            KI=K*(K-1)/2+I
            ZZ(KI)=D
      }  }
      RETURN
 
* . . .  error exit here  . . .
  140 K=I+NL-II
      IR=0
      DO I=1,K  { IR+=1; While PLU(IR)<=0 { IR+=1; } }
*
  170 PLU(IR)=-2
      RR(IR)=0
      IND=1
      END
 
********************************************************************
*                                                                  *
                 subroutine    F U M S G Z (M,S)
*                                                                  *
*     calculation of chi-square deviations and derivatives         *
* Original Version:                                Silin & Sokolov *
* Modifications:                                    Pavel Nevski   *
********************************************************************
+CDE,TYPING,FUMSIZ,FUMUSE.
     Integer I,J,K,M,N
     Real Funct,S,Ai,Hi,E,D,Y,DY,S1,S2,Rpd/1.e-4/
     Real PI/3.14159265/
;                                            " starting parameters "
Do n=1,NN {  YY(0,n)=FUNCT(Ex(3,n)); }
DO I=1,M                                    " calculate derivatives "
{  Check PL0(i)>0;
   AI=A(I); HI=AMAX1(PL0(I)*0.1,RPD*ABS(AI));
        IF  AI+HI<=AMX(I)       { A(I)=AI+HI }
   else IF  AI-HI>=AMN(I)       { A(I)=AI-HI }
   else IF  AI-AMN(I)>AMX(I)-AI { A(I)=AMN(I)} else { A(I)=AMX(i)};
   Do n=1,NN { Dy=FUNCT(Ex(3,n))-YY(0,n);
                              "check that deltaFi is from -Pi to +Pi"
   if(Ex(3,n)!=0. & Ex(4,n)!=0. & abs(DY)>PI) {
     if(DY>PI){DY=DY-2*PI}elseif(DY<-PI){DY=DY+2*PI};};
               YY(I,n)=DY/(A(i)-Ai); }
   A(I)=AI;
}
DO n=1,NN                      " calculate gradients and derivatives matrix "
{  K=0;  E=EX(1,n);  D=EX(2,n);  Y=YY(0,n);
   DY=Y-E;
                              "check that deltaFi is from -Pi to +Pi"
   if(Ex(3,n)!=0. & Ex(4,n)!=0. & abs(DY)>PI) {
     if(DY>PI){DY=DY-2*PI}elseif(DY<-PI){DY=DY+2*PI};};
   Check D>0 | Y>1.e-9;
   IF D>0  { S2=1/D**2;  S1=DY*S2;  S+=DY*S1/2; }
   else    { S2=E/Y**2;  S1=DY/Y;   S+=Y;  IF(E>0) S-=E*ALOG((E+DY)/E)-E; }
   DO I=1,M
   { Check PL0(I)>0;      GG(I)+=YY(I,n)*S1;
     DO J=1,I  {  Check PL0(J)>0; K+=1;  ZZ(K)+=YY(I,n)*YY(J,n)*S2; }
}  }
End
 
********************************************************************
*                                                                  *
               subroutine    F U M S G Z O L D (M,S)
*                                                                  *
*     calculation of chi-square deviations and derivatives         *
* Original Version:                                Silin & Sokolov *
* Modifications:                                    Pavel Nevski   *
********************************************************************
+CDE,TYPING,FUMSIZ,FUMUSE.
     Integer I,J,K,M,N
     Real Funct,S,Ai,Hi,E,D,Y,DY,S1,S2,Rpd/1.e-4/
;                                            " starting parameters "
Do n=1,NN {  YY(0,n)=FUNCT(Ex(3,n)); }
DO I=1,M                                    " calculate derivatives "
{  Check PL0(i)>0;
   AI=A(I); HI=AMAX1(PL0(I)*0.1,RPD*ABS(AI));
        IF  AI+HI<=AMX(I)       { A(I)=AI+HI }
   else IF  AI-HI>=AMN(I)       { A(I)=AI-HI }
   else IF  AI-AMN(I)>AMX(I)-AI { A(I)=AMN(I)} else { A(I)=AMX(i)};
   Do n=1,NN { Dy=FUNCT(Ex(3,n))-YY(0,n); YY(I,n)=DY/(A(i)-Ai); }
   A(I)=AI;
}
DO n=1,NN                      " calculate gradients and derivatives matrix "
{  K=0;  E=EX(1,n);  D=EX(2,n);  Y=YY(0,n);
   Check D>0 | Y>1.e-9;
   IF D>0  { S2=1/D**2;  S1=(Y-E)*S2;  S+=(Y-E)*S1/2; }
   else    { S2=E/Y**2;  S1=(Y-E)/Y;   S+=Y;  IF(E>0) S-=E*ALOG(Y/E)-E; }
   DO I=1,M
   { Check PL0(I)>0;      GG(I)+=YY(I,n)*S1;
     DO J=1,I  {  Check PL0(J)>0; K+=1;  ZZ(K)+=YY(I,n)*YY(J,n)*S2; }
}  }
End
 
+DECK,trigon,T=geant.
*CMZ :          05/11/97  15.31.12  by  Pavel Nevski
*-- Author :    Pavel Nevski   04/11/97
function sind(x);     +cde,gconst;  sind=sin(degrad*x);       end;
function cosd(x);     +cde,gconst;  cosd=cos(degrad*x);       end;
function tand(x);     +cde,gconst;  tand=tan(degrad*x);       end;
function asind(x);    +cde,gconst;  asind=raddeg*asin(x);     end;
function acosd(x);    +cde,gconst;  acosd=raddeg*acos(x);     end;
function atand(x);    +cde,gconst;  atand=raddeg*atan(x);     end;
function atan2d(x,y); +cde,gconst;  atan2d=raddeg*atan2(x,y); end;
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+DECK,TTAN,T=geant.
*CMZ :          10/11/97  15.32.54  by  Pavel Nevski
*CMZ :  1.30/00 18/06/96  12.32.41  by  Pavel Nevski
*CMZU:  1.03/00 28/10/93  12.54.58  by  M. Nessi CERN
*-- Author :  Pavel Nevski
************************************************************************
      FUNCTION TTAN (Y)
*
* Description :     translate rapidity to tangent of polar theta       *
************************************************************************
*
      REAL Y,TTAN
      TTAN = TAN(2*ATAN(EXP(-Y)))
*
      END
+DECK,BITCH,T=geant.
*CMZ :          31/01/98  14.01.41  by  Pavel Nevski
*-- Author :    Bill LOVE
C----------------------------------------------------------------------
      FUNCTION  BITCH(INT,FORMAT)
C
C   Functional Description :
C BITCH Converts a 32 bit integer, INT, into either 8 hexadecimal
C or 11 octal characters (according to the value of FORMAT) and
C returns as the value of BITCH as many characters as will fit
C from the right end of the string (Caller declares length of BITCH).
C If FORMAT is something other than 'H' or 'O' BITCH returns blank.
C
C   Input arguments
C      INTEGER   INT        ! actually a bit string, assumed 32 bits long
C      CHARACTER FORMAT     ! either 'H' or 'O'.
C   Returned value : ASCII string of digits representing INT.
C
C Converted to STAR style  5 Feb 1992   Bill Love
C----------------------------------------------------------------------
      IMPLICIT   NONE
      CHARACTER  BITCH*(*)
      INTEGER    INT        ! actually a bit string, assumed 32 bits long
      CHARACTER  FORMAT     ! either 'H' or 'O'.
      INTEGER    I,L,M3,M4
      CHARACTER  TAB(16),STRING*11
C-------
      DATA M3/7/,M4/15/
      DATA TAB/'0','1','2','3','4','5','6','7',
     >         '8','9','A','B','C','D','E','F'/
C-------
C
        STRING=' '
        IF(FORMAT.EQ.'H')THEN
            DO I=1,8
              STRING(I+3:I+3)=TAB(IAND(M4,ISHFT(INT,4*(I-8)))+1)
            ENDDO ! I loop to 8
        ELSE IF(FORMAT.EQ.'O')THEN
            DO I=1,11
              STRING(I:I)=TAB(IAND(M3,ISHFT(INT,3*(I-11)))+1)
            ENDDO ! I loop to 11
        ENDIF
        BITCH = STRING
        L     = LEN(BITCH)
        IF(L.LT.11) BITCH=STRING(12-L:11)
        RETURN
        END
 
+DECK,IFNB,T=geant.
*CMZ :          31/01/98  14.01.41  by  Pavel Nevski
*-- Author :    Bill Love
C----------------------------------------------------------------------
      FUNCTION IFNB(STRING)
C
C   IFNB returns the position of the first non-blank character in STRING
C
C----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER  IFNB
      CHARACTER*(*) STRING    ! String input argument
*
      IFNB = 0
      IF (LEN(STRING).EQ.0) RETURN
*
      DO IFNB = 1,LEN(STRING)
        IF (STRING(IFNB:IFNB).NE.' ') RETURN
      ENDDO
*
      END
 
+DECK,LSTRG,T=geant.
*CMZ :          31/01/98  14.01.41  by  Pavel Nevski
*-- Author :    Bill Love
C----------------------------------------------------------------------
        FUNCTION LSTRG(STRING)
C
C   Input argument :   String whose actual length is returned.
C   Returns the length of textstrings, i. e. the position of the
C      last non-blank character.
C   Converted to STAR style  5-Feb-1992   Bill Love
C----------------------------------------------------------------------
        IMPLICIT NONE
	INTEGER  LSTRG
	CHARACTER*(*) STRING
        INTEGER  I,LS
 
	LSTRG=0
	LS=LEN(STRING)
	DO I=1,LS
           IF(STRING(I:I).NE.' ')LSTRG=I
        ENDDO
	RETURN
	END
 
+DECK,QIKS,T=geant.
*CMZ :          31/01/98  14.12.02  by  Pavel Nevski
*-- Author :    Bill Love
C----------------------------------------------------------------------
      SUBROUTINE QIKS (MM,NN,MOVE,COMPARE)
C
C INPUTS         MM,NN          QIKS sorts a list of items numbered
C                               sequentially from MM to NN.  Every item
C    in the list to be sorted must be associated with a unique integer from
C    MM to NN inclusive.  Zero cannot be included in the range, i.e. both
C    MM and NN should be positive integers.  In the vast majority of cases
C    MM is 1 and NN is the number of items in the list.
C              MOVE,COMPARE     MOVE and COMPARE must be defined as
C                               external in the calling program.
C                               SUBROUTINE MOVE(I,J) must perform the
C     operation of moving an item from position I to position J.  If
C     either I or J is zero, the move should be from or to an extra item
C     of storage (this extra storage must be provided by the routine
C     which calls QIKS).  The values of I and J transmitted to
C     MOVE and COMPARE are generated by QIKS - the user has no control
C     over them.  However, he must make provision in MOVE and in COMPARE
C     to recognize when I or J are zero and take appropriate action.
C     The calling routine is presumed to communicate with MOVE and COMPARE
C     through common.  The layout of the item is entirely up to the caller,
C     QIKS will never see it.  The item may have several separate pieces.
C  FUNCTION COMPARE (I,J) must return a value that is negative, O, or
C     positive according to whether item I is to occupy a position in the
C     sequence respectively, lower than, equivalent to, or higher than J.
C     Again, if either I or J is zero, comparison is with the extra item.
C     COMPARE should be declared as INTEGER.
C PROGRAMMER   R. HUNN
C         BNL modification by K. Fuchel and R. Horwitz     Feb. 67.
C         Moved to PDP-10 and updated to FORTRAN-IV by W. A. Love 2-April-79.
C         Added to E810 library [mpslib.e810.sources]gutil.src 2 Oct 87.
C         Converted to F77+VAX extensions (DO WHILE) Feb 1992 WAL
C         Reverted the spreader to F66 version after hang Jun 1992 WAL
C PURPOSE      QIKS is a FORTRAN internal sort subroutine useful for
C         sorting arrays in memory.  It is fast and requires only one
C additional item of working storage.  Definition of the items to be sorted
C is completely flexible, being specified by user-supplied subprograms.
C
C ERROR CONDITIONS     QIKS has been in use for 30 years now without error
C                      to my knowledge.  There is potential with a long enough
C list to overflow the 20 levels of push-down provided (unchecked) but since
C the main virtue of QIKS is its speed, I am reluctant to add error checking
C until we turn up an example.
C
C TYPICAL USE                  PROGRAM XXX
C                              COMMON/SORTITEMS/IA(10000)
C                              COMMON/EXTRAITEM/IB
C                              EXTERNAL MO, CO
C                              INTEGER CO
C                                       .
C                              fill array IA to N items, set M=1
C                                       .
C                              CALL QIKS (M,N,MO,CO)
C                                       .
C                                       .
C COMMON BLOCKS    As required by user to communicate between the calling
C                  routine and the user supplied move and compare routines.
C
C METHOD       QIKS is based on C. A. R. Hoare's quicksort and partition
C              algorithms (Nos. 64 and 63 respectively)
C              See  COM. ACM 4,321 (JULY 1961).
C
C----------------------------------------------------------------------
C
      IMPLICIT NONE
      INTEGER  MM,NN,COMPARE
      EXTERNAL MOVE,COMPARE
      INTEGER  I,J,M,N,KEY,LEVL
      INTEGER  MSAVE(20),NSAVE(20)
      LOGICAL  SWITCH
C
      I=0
      J=0
      LEVL = 0
      M=MM
      N=NN
   35 CONTINUE
C     Test for number of items left unsorted.
      IF((N-M).GT.1)THEN
C        More than 2 items, partition and push down
C        Partition Routine
         I=M
         J=N
C        Simplest key, i. e. middle element, works as well as any.
         KEY=(N+M)/2
         CALL MOVE(KEY, 0)
         IF(N.NE.KEY)CALL MOVE(N,KEY)
         SWITCH=.TRUE.
         DO WHILE (I.NE.J)
         IF(SWITCH)THEN
            IF(COMPARE(0,I).LT.0)THEN
C              Hole at bottom
               CALL MOVE(I,J)
               J=J-1
               SWITCH=.FALSE.
            ELSE
               I=I+1
            ENDIF
         ELSE
            IF(COMPARE(0,J).GT.0)THEN
C              Hole at top
               CALL MOVE(J,I)
               I=I+1
               SWITCH=.TRUE.
            ELSE
               J=J-1
            ENDIF
         ENDIF
         ENDDO      ! while (i.ne.j)
C        end partition
C        Spreader
         CALL MOVE(0,I)
 12      IF(I.EQ.N)GO TO 10
         I = I + 1
         IF(COMPARE(0,I).EQ.0)GO TO 12
 10      IF(J.EQ.M)GO TO 8
         J = J - 1
         IF(COMPARE(0,J).EQ.0)GO TO 10
 8       CONTINUE
C        Have partitioned this level in two
C        Push down
         LEVL = LEVL+1
C        Work on smallest portion, push down the other
         IF ((J-M).LE.(N-I))THEN
            MSAVE(LEVL) =I
            NSAVE(LEVL) = N
            N=J
         ELSE
            MSAVE(LEVL) = M
            NSAVE(LEVL) = J
            M=I
         ENDIF
      ELSE
C        One or two items remain in the partition
         IF((N-M).EQ.1)THEN
C           Come here when two items remain in any partition
            IF(COMPARE(M,N).GT.0)THEN
C              Swap if two items are out of order
               CALL MOVE(M,0)
               CALL MOVE(N,M)
               CALL MOVE(0,N)
            ENDIF
         ENDIF
C        Pop up; QIKS is finished when LEVL returns to 0
         IF(LEVL.EQ.0)RETURN
         M = MSAVE(LEVL)
         N = NSAVE(LEVL)
         LEVL = LEVL - 1
      ENDIF
      GO TO 35
      END
 
+PATCH,COMIS. =================================================================
*CMZ :  1.30/00 25/01/97  03.42.29  by  Pavel Nevski
+DECK,CSINIT. -----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.30/00 22/04/97  15.56.15  by  Pavel Nevski
*-- Author : V.Berezhnoi
         SUBROUTINE CSINIT(NW)
***---------------------------
+SEQ,CSLUN.
         COMMON/CSCONT/LCONT
+SEQ,CSPAR.
+SEQ,MDPOOL.
+SEQ,COMIS.
+SEQ,CSBUF.
+SEQ,CSREC.
+SEQ,CSTAB.
+SEQ,CSPNTS.
+SEQ,CSSYSD.
+SEQ,CSDPVS.
+SEQ,CSKEYS.
+SEQ,CSCBWL.
+SEQ,CSICHV.
+SEQ,CSKUCS.
+SELF,IF=SHL.
+SEQ, CSHLNM.
+SELF,IF=PAW.
+SEQ, CSHFILL.
+SELF.
      COMMON /MPLIST/ INDP
         EXTERNAL MDEXP, CSMBIT
         EXTERNAL CSOFIL,CSOLOG,CSOMAP,CSLIB
         EXTERNAL CGCONT,CSCOMX,CSEXTX,CSPTFS
         EXTERNAL CSNPAR,CSKPAR,CSIPAR,CSRPAR,CSLPAR,
     +            CSTPAR,CSCPAR,CSSPAR
         CHARACTER KWORDS*22
      DATA KWORDS/'ENDIFITHENELSEIFENDDOD'/
      COMMON /CSDEBUG/ ICSDEBUG
 
      INDP      = 0
      CALL MDINIT(LHP,MDEXP)
      CALL MHDEF (LHP-6,MDEXP)
      LAST      = MAX0(NW,LASTK)-2
      IBASE     = 0
      IPC       = 0
      ITA       = 0
      IDP       = 0
      IFORS     = 1
      NCBARR    = 0
      NTRACE    = 1
      NPARAM    = 1
      IBSEM     = MHLOC(LSSTK)
      ITS       = IBSEM
      ILSEM     = LSSTK+IBSEM
      LIMPL     = 17
      IBIMPL    = MHLOC(LIMPL)
      IQ(IBIMPL)= 0
      LBB       = 10
      NBB       = 0
      NBG       = 0
      IBB       = MHLOC(LBB)-1
      IPMCAD    = 0
      IPGB      = 0
      IPGP      = 0
      IPGI      = 0
      IPLI      = 0
      IPLL      = 0
      LDATA     = 0
      IEXTGB    = 0
      LCONT     = 0
      NUMST     = 0
      JTCH      = MJCHAR(IBUF(1))
      NCHS      = LCSTK*NBYTPW
      JID       = MJCHAR(IDEN(1))
      JTOPA     = LOCF(IA(1))-1
      JPMB      = 0
      JPMC      = 0
      JMB       = JTCH
      JMC       = JMB
      NMC       = 0
      NMB       = NCHS
      JFI1      = MJSCHA(KWORDS)
      JFI2      = JFI1+4
      JTHEN     = JFI2+2
      JELSE     = JTHEN+4
      JOD1      = JELSE+6
      JOD2      = JOD1+4
      JSR       = MJSCHA(REC)
      JSR1      = MJSCHA(REC1)
      JSMAIN    = MJSCHA(MAINPR)
      JB4       = MJCHAR(IB(4))
      PROMPT(1) = 'CS>'
      PROMPT(2) = 'FSD>'
      PROMPT(3) = 'MND>'
      PROMPT(4) = 'PAU>'
      PROMPT(5) = '???>'
      KEYRD     = 0
      LIBRD     = 0
      KEYC      = 0
      IRECU     = 1-LRECU
      LUNINP    = 5
      ISTPM     = 0
      ICBWL     = 0
      LISTCL    = 0
      ICHLA     = ICHAR('A')
      ICHLZ     = ICHAR('Z')
      ICHD0     = ICHAR('0')
      ICHD9     = ICHAR('9')
      ICHSUSC   = ICHAR('_')
      ICHSX     = ICHAR('#')
      ICHSE     = ICHAR('!')
      ICHBLN    = ICHAR(' ')
      CALL UCTOH('    ',KBLN,4,4)
      ICHQUO    = ICHAR('''')
      ICHSSC    = ICHAR(';')
      ICHSEQ    = ICHAR('=')
      ICHBRA    = ICHAR('(')
      ICHKET    = ICHAR(')')
      ICHMINU   = ICHAR('-')
      ICHPLUS   = ICHAR('+')
      ICHCOMM   = ICHAR(',')
+SELF,IF=PAW.
      CALL CSPAWI
      MODHFI    = 0
+SELF,IF=-PAW.
      JKUVBS    =-1
+SELF.
      CHPATH='/tmp/'
+SELF,IF=HPUX,IF=SHL.
      CHF77 ='f77 -c +z +ppu -K -O'
      CHCC  ='cc -c +z -O'
+SELF,IF=AIX,IF=SHL.
      CHF77 ='xlf -qextname -qrndsngl -qcharlen=32767 -c'
      CHCC  ='cc -c'
+SELF,IF=SUN,MSDOS,IF=SOLARIS,IF=SHL.
* increase some internal tables: up to 100 nested control statements,
* 200 continuation lines, 10000 identifier names per module
      CHF77 ='/opt/SUNWspro/bin/f77 -Nc100 -Nl200 -Nn10000 -c -pic'
      CHCC  ='/opt/SUNWspro/bin/cc -c -K pic'
+SELF,IF=SUN,IF=-SOLARIS,IF=SHL.
      CHF77 ='f77 -c -pic'
      CHCC  ='cc -c -pic'
+SELF,IF=SGI,IF=SHL.
      CHF77 ='f77 -c'
      CHCC  ='cc -cckr -c'
+SELF,IF=ALPHA_OSF,IF=SHL.
      CHF77 ='f77 -c'
      CHCC  ='cc -c'
+SELF,IF=LINUX,IF=SHL.
* pn, 29.10.97: not clear yet, may be '-pic' not needed
      CHF77 ='f77 -c -PIC'
      CHCC  ='cc -c -PIC'
+SELF.
      RETURN
      END
 
+DECK,CSLINK. -----------------------------------------------------------------
*CMZ :          23/05/97  18.43.27  by  Pavel Nevski
*CMZ :  1.30/00 22/04/97  15.56.16  by  Pavel Nevski
*CMZ :  1.18/14 16/01/95  11.45.29  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSLINK
***------------------------
*     this is comis linker
***------------------------
+SEQ,CSPAR.
+SEQ,MDPOOL.
+SEQ,CSTABPS.
+SEQ,CSTAB.
+SEQ,CSPNTS.
+SEQ,CSLUN.
+SELF,IF=SHL.
      CHARACTER*(KLENID) FNNAME
      INTEGER CS_GET_FUNC
+SELF.
      INTEGER CSPMFS,CSLLIB
      COMMON /CSTBCS/  ITBC,ITBS
      COMMON /CSDEBUG/ ICSDEBUG
      COMMON /CSGSCM/  IGS,JGS,NGS,CSJUNK(3)
*
      if (ICSDEBUG.gt.0) print *,' ===> in CSLINK <=== '
      IF(ISTLIB.EQ.0 .AND. ITBS.EQ.0)RETURN
   2  I=IPGP
   3  IF(I.EQ.0)GO TO  5
      CALL CCOPYA(IQ(I+1),NCIDGP,KSIDP-1)
      IF(IADGP.EQ.0)THEN
        IF(ISTLIB.NE.0)THEN
          JGP=MJCHAR(IQ(I+KSIDP))
          IP=CSLLIB(JGP,NCIDGP)
          IF(IP.NE.0)THEN
             LIBRD=1
             NWIDEN=(NCIDGP+3)/4
             NCIDEN=NCIDGP
             CALL CCOPYA(IQ(I+KSIDP),IDEN(1),NWIDEN)
             CALL CSRD(JGS,NGS)
             IF (NGS .LT. 0) GO TO 5
             KPRO=CSPMFS(IBC)
             LIBRD=0
             KEYRD=0
             GO TO 4
          ENDIF
        ENDIF
*MAP-file
        IF(ITBS.NE.0)THEN
+SELF,IF=VAX.
          IP=MLSEAR(ITBS,IQ(I+KSIDP))
          IF(IP.GT.0)THEN
            IADGP=IQ(IP)
            IFCS=-1
            CALL CSRTGP(I)
          ENDIF
+SELF,IF=SHL.
          CALL CSGTIDP(I,FNNAME,NC)
          CALL CUTOL(FNNAME(1:NC))
          IADGP=CS_GET_FUNC(FNNAME(1:NC)//'_')
          IF(IADGP.NE.0)THEN
            IFCS=-2
            CALL CSRTGP(I)
          ENDIF
+SELF.
          IP=0
        ENDIF
      ENDIF
  4   I=IQ(I)
      GO TO 3
  5   END
 
+DECK,CSMAP. ------------------------------------------------------------------
*CMZ :          31/10/97  13.20.19  by  Pavel Nevski
*CMZ :  1.18/14 19/09/94  10.05.14  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSMAP(NAME)
      CHARACTER*(*) NAME
      COMMON /CSTBCS/ ITBC,ITBS
      CHARACTER *80 LIBNAME,SYMBOL*32
      INTEGER CS_SHL_LOAD,CSLTGP
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSMAP (',name,') <==='
      LIBNAME=NAME
      N=LENOCC(LIBNAME)
      CALL CUTOL(LIBNAME(1:N))
      IF(ITBS.NE.0)THEN
        NS=-1
        CALL CS_SHL_SYMBOLS(LIBNAME(1:N),NS,SYMBOL)
        IF(NS.EQ.-2)GO TO 20
 10     L=LENOCC(SYMBOL)
        IF(SYMBOL(L:L).EQ.'_')L=L-1
        CALL CSCHID(SYMBOL(:L))
        IT=CSLTGP(IPVS)
        IF(IT.GT.0)CALL CSDPRO(IT)
        CALL CS_SHL_SYMBOLS(LIBNAME(1:N),NS,SYMBOL)
        IF(NS.NE.-2)GO TO 10
        CALL CS_SHL_UNLOAD(LIBNAME(1:N))
        ITBS=ITBS-1
 20     CONTINUE
      ENDIF
      IERR=CS_SHL_LOAD(LIBNAME(1:N))
      IF(IERR.EQ.0)THEN
        ITBS=ITBS+1
      ELSE
        CALL CS_SHL_UNLOAD(LIBNAME(1:N))
      ENDIF
      END
 
+DECK,CSFILE. -----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.18/14 20/09/94  14.48.52  by  Fons Rademakers
*-- Author : V.Berezhnoi
************************************************************************
      SUBROUTINE CSFILE(FILENAME)
*                                                                      *
* Description: comis loader top level interface                        *
* Modifications:                                                       *
* pn, 29.10.97 according to the mail from VB (20.09.97):               *
*     FILENAME in concatineted parameters replaced by LIBNAME          *
************************************************************************
      CHARACTER*(*) FILENAME
      COMMON /CSERRNO/ IERR
      COMMON /CSDEBUG/ ICSDEBUG
+SELF,IF=SHL.
+SEQ,CSHLNM.
*     CHPATH='/tmp/' comes from CSHLNM
      CHARACTER  LIBNAME*72,LINE*80,PATH*72,NAME*72,CPID*8,FEXT*8
      INTEGER    SYSTEMF
      LOGICAL    EXIST1
*
      ICASE   = 0
      IERR    = 0
      L       = LENOCC(FILENAME)
      LCHPATH = LENOCC(CHPATH)
      if (ICSDEBUG.gt.0) print *,' ===> in CSFILE (',
     *                                  filename(:L),') <==='
      CALL CSPARSFN(FILENAME(:L),PATH,NAME,FEXT)
      LPATH   = LENOCC(PATH)
      LNAME   = LENOCC(NAME)
 
      LX=LENOCC(FEXT)
      IF (FEXT.EQ.'.csl')THEN
        ICASE = 4
      ELSE IF (FEXT.EQ.'.sl')THEN
        ICASE = 3
      ELSE IF (FEXT.EQ.'.c')THEN
        ICASE = 2
      ELSE IF (FEXT(LX-1:LX).EQ.'77')THEN
        ICASE = 1
        INQUIRE(FILE=FILENAME(:L),EXIST=EXIST1)
        IF (.NOT.EXIST1) FEXT=FEXT(1:LX-2)
      ENDIF
      LEXT    = LENOCC(FEXT)
*
      IF(ICASE.GT.0)THEN
        CALL GETPIDF(IPID)
        CPID    = ' '
        WRITE (CPID,'(I8)') IPID
        LP      = LOG10(REAL(IPID))+1
        CPID    = CPID(9-LP:)
        LIBNAME = CHPATH(:LCHPATH)// NAME(:LNAME) // '_' // CPID(:LP)
        LL      = LENOCC(LIBNAME)
        If (IcsDebug.GT.0) print *,' libname =',LL,libname(:ll)
        If (ICASE.EQ.1) THEN
*---- file...77
          IF (LPATH.GT.0) THEN
            LINE=PATH(:LPATH)//NAME(:LNAME)//FEXT(:LEXT)
          ELSE
            LINE=NAME(:LNAME)//FEXT(:LEXT)
          ENDIF
          CALL CSRMSL(LIBNAME(:LL))
          CALL CSF77 (LINE,LIBNAME(:LL)//'.f',IERR)
          IF (IERR.NE.0) THEN
            PRINT *,' error during conversion to f77::File: ',
     +          FILENAME(:L)
            RETURN
          ENDIF
        ELSE IF (ICASE.EQ.2) THEN
*---- file.c
          LINE = 'cp '//FILENAME(:L)//' '//LIBNAME(:LL)//'.c'
          LE   = LENOCC(LINE)
          IERR = SYSTEMF(LINE(:LE))
          IF (IERR.NE.0) RETURN
          CALL CSRMSL(LIBNAME(:LL))
        ELSE IF (ICASE.EQ.3) THEN
*---- file.sl
          IL = L-3
          LIBNAME = FILENAME(:IL)
          LL = IL
          CALL CSRMSL(LIBNAME(:LL))
*-- ' ' means do not produced output file
*         CALL CSF77 (FILENAME(:IL)//'.f',' ',IERR)
          CALL CSF77 (LIBNAME(:IL) //'.f',' ',IERR)
          IF (IERR.NE.0) THEN
            PRINT *,' error during translation csf77-file: '
     +            ,FILENAME(:L)
            RETURN
          ENDIF
        ELSE IF(ICASE.EQ.4)THEN
*---- file.csl
          IL = L-4
          LIBNAME= FILENAME(:IL)
          LL = IL
          CALL CSRMSL(LIBNAME(:LL))
        ENDIF
        IF (INDEX(LIBNAME(:LL),'/') .EQ. 0) THEN
           LINE = LIBNAME
           LIBNAME = './'//LINE
           LL = LL + 2
        ENDIF
        CALL CSCRSL(LIBNAME(:LL),CPID(:LP),FEXT(:LEXT),IERR)
        IF (IERR.EQ.0) RETURN
      ENDIF
+SELF.
      IERR=0
      CALL CSFILX(LIBNAME)
      END
 
 
+DECK,CSADDR. ----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.18/03 09/06/94  17.55.36  by  Rene Brun
*-- Author : V.Berezhnoi
******************************************************************************
      FUNCTION  CSADDR (CHNAME)
*
*    returns the memory address of a comis-routine
******************************************************************************
      CHARACTER*(*)    CHNAME
      INTEGER          CSADDR,CSLTGP,CSITGP
      CHARACTER*32     NAME
+SEQ,CSTAB.
+SELF,IF=SHL.
      INTEGER          CS_GET_FUNC
      COMMON /CSDEBUG/ ICSDEBUG
*
      NAME = CHNAME
      NC   = LENOCC(NAME)
      if (ICSDEBUG.gt.0) print *,' ===> in CSADDR (',NAME(:NC),') <==='
      CALL CSCHID(NAME(:NC))
      CALL CUTOL (NAME(:NC))
      I    = CSLTGP(IPVS)
      IF(I.GT.0)THEN
        IF(IFCS.EQ.0)THEN
          IADGP=CS_GET_FUNC(NAME(1:NC)//'_')
          IF(IADGP.NE.0)THEN
            IFCS=-2
            CALL CSRTGP(I)
          ELSE
            I=0
          ENDIF
        ENDIF
      ELSE
        IADGP=CS_GET_FUNC(NAME(1:NC)//'_')
        IF(IADGP.NE.0)THEN
          IFCS=-2
          ITYPGP=-2
          I=CSITGP(IPVS)
        ENDIF
      END IF
      CSADDR=I
+SELF,IF=-SHL.
      NAME=CHNAME
      CALL CSCHID(NAME)
      I=CSLTGP(IPVS)
      IF(I.GT.0)THEN
        IF(IFCS.EQ.0)I=0
      END IF
      CSADDR=I
+SELF.
      END
 
+DECK,CSCRSL. -----------------------------------------------------------------
*CMZ :          29/10/97  09.43.10  by  Pavel Nevski
*CMZ :  1.18/02 07/04/94  15.26.09  by  Vladimir Berezhnoi
*-- Author :    Vladimir Berezhnoi   07/01/94
*************************************************************************
      SUBROUTINE       CSCRSL (NAME,CPID,FEXT,IERR)
*                                                                       *
* Description: interface to CS_SHL_LOAD                                 *
* Modifications:                                                        *
* pn, 29.10.97 modified according to the mail from VB (20.09.97):       *
*     NAME in concatineted parameters replaced by CHLINE                *
*                                                                       *
*************************************************************************
      CHARACTER *(*)   NAME,CPID,FEXT
      COMMON /CSTBCS/  ITBC,ITBS
+SELF,IF=SHL.
+SEQ,CSHLNM.
      CHARACTER*72     CHLINE,FEXEC
      INTEGER          SYSTEMF,CS_SHL_LOAD
      COMMON /CSDEBUG/ ICSDEBUG
*--
      if (ICSDEBUG.gt.0) print *,' ===> in CSCRSL (',NAME,') <==='
      LN=LENOCC(NAME)
      LP=LENOCC(CPID)
*c    IF (ITBS.NE.0) CALL CSRMSL(NAME)
 
      IF (FEXT.ne.'.sl' .and. FEXT.ne.'.csl') THEN  ! do the library
        FEXEC=CHPATH(:LENOCC(CHPATH))//'exec_'//CPID//'.exec'
        CALL CSCREXEC(NAME,CPID,FEXT,FEXEC,IERR)
 
        CHLINE='/bin/sh '//FEXEC
        IERR=SYSTEMF(CHLINE(:LENOCC(CHLINE)))
        IF (IERR .NE. 0) RETURN
 
        CHLINE='/bin/rm -f '//FEXEC
        IERR=SYSTEMF(CHLINE(:LENOCC(CHLINE)))
        IF (IERR .NE. 0) RETURN
      endif
 
*c now really load
      CHLINE=NAME(1:LN)
      IERR=CS_SHL_LOAD(CHLINE(1:LN)//'.sl')
      IF (IERR.ne.0) THEN
        CALL CS_SHL_UNLOAD(CHLINE(1:LN)//'.sl')
        return
      ENDIF
      ITBS=ITBS+1
+SELF.
      END
 
+DECK,CSSHLD. -----------------------------------------------------------------
*CMZ :          10/11/97  12.13.09  by  Pavel Nevski
*CMZ :  1.18/01 30/03/94  11.56.54  by  Vladimir Berezhnoi
*-- Author :    Vladimir Berezhnoi   07/01/94
      SUBROUTINE CSSHLD
+SELF,IF=SHL.
+SEQ,CSHLNM.
      COMMON /CSTBCS/ ITBC,ITBS
      CHARACTER *8 CPID
      CHARACTER *80 CHLINE,LIBNAME
      INTEGER  SYSTEMF
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSSHLD <=== '
      CALL GETPIDF(IPID)
      CPID = ' '
      WRITE(CPID,'(I8)')IPID
      LP   = LOG10(REAL(IPID))+1
      CPID = CPID(9-LP:)
      IF(ITBS.EQ.0)GO TO 2
      N=0
 1    CALL CS_SHL_GET(N,LIBNAME)
      IF(LIBNAME.NE.' ')THEN
        LL=LENOCC(LIBNAME)
***        IF(     INDEX(LIBNAME(:LL),  '/tmp/').NE.0
***     +    .AND. INDEX(LIBNAME(:LL),CPID(:LP)).NE.0)
***     +  THEN
        IF(INDEX(LIBNAME(:LL),CPID(:LP)).NE.0)THEN
          CALL CS_SHL_UNLOAD(LIBNAME(:LL))
          ITBS=ITBS-1
          CHLINE='/bin/rm -f '//LIBNAME(:LL)
          L=LENOCC(CHLINE)
          IERR=SYSTEMF(CHLINE(:L))
*          print *,'csshlDELl: ',chline(:l)
        ELSE
*          print *,'csshlkeep: ',libname(:ll)
          N=N+1
        ENDIF
        GO TO 1
      ENDIF
*
*-- delete .f files
*
 2    LPATH  = LENOCC(CHPATH)
      CHLINE = '/bin/rm -f '//CHPATH(:LPATH)//'*_'//CPID(:LP)//'.f'
+SELF,IF=SGI,ALPHA_OSF,IF=SHL.
     +         //' '//CHPATH(:LPATH)//'so_locations'
+SELF,IF=SHL.
      L = LENOCC(CHLINE)
      IERR = SYSTEMF(CHLINE(:L))
+SELF.
      END
 
+DECK,CSHLOPT. ----------------------------------------------------------------
*CMZ :          23/05/97  18.43.27  by  Pavel Nevski
*CMZ :  1.18/01 30/03/94  11.58.04  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSHLOPT(TEXT,CHVAR)
      CHARACTER*(*)TEXT,CHVAR
+SELF,IF=SHL.
+SEQ,CSHLNM.
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSHLOPT <=== '
      CALL CUTOL(CHVAR)
      IF(CHVAR(1:1).EQ.'p')THEN
        CHPATH=TEXT
        IF(CHPATH.EQ.' ')CHPATH='./'
        L=LENOCC(CHPATH)
        IF(CHPATH(L:L).NE.'/')CHPATH=CHPATH(:L)//'/'
      ELSEIF(CHVAR(1:1).EQ.'f')THEN
        CHF77=TEXT
      ELSEIF(CHVAR(1:1).EQ.'c')THEN
        CHCC=TEXT
      ELSEIF(CHVAR(1:1).EQ.' ')THEN
        PRINT *,' PATH=',CHPATH(:LENOCC(CHPATH))
        PRINT *,' FORT=',CHF77(:LENOCC(CHF77))
        PRINT *,'   CC=',CHCC(:LENOCC(CHCC))
      ELSE
        PRINT *,' CS.SET: unknown option:',CHVAR
        PRINT *,' possible options are: path, f77, cc'
      ENDIF
+SELF.
      END
 
+DECK,CSRMSL. ----------------------------------------------------------------
*CMZ :          23/05/97  19.31.06  by  Pavel Nevski
*CMZ :  1.19/01 14/11/94  18.10.10  by  Fons Rademakers
*-- Author :    Vladimir Berezhnoi   07/02/94
      SUBROUTINE CSRMSL(NAME1)
      CHARACTER *(*)NAME1
+SELF,IF=SHL.
+SEQ,CSHLNM.
      COMMON /CSTBCS/ ITBC,ITBS
      CHARACTER *80 LIBNAME,NAME,SYMBOL*32
      INTEGER CSLTGP
      COMMON /CSDEBUG/ ICSDEBUG
 
      if (ICSDEBUG.gt.0) print *,' ===> in CSRMSL (',NAME1,') <=== '
*
*-- match only file names (remove path)
*
      NAME = NAME1
      LN = LENOCC(NAME)
      IF (INDEX(NAME(:LN),'/') .EQ. 0) THEN
         LIBNAME = NAME
         NAME = '/'//LIBNAME
         LN = LN + 1
      ELSE
         DO 5 I = LN, 1, -1
            IF (NAME(I:I) .EQ. '/') THEN
               NAME = NAME(I:)
               LN = LENOCC(NAME)
               GOTO 6
            ENDIF
 5       CONTINUE
      ENDIF
*
 6    CONTINUE
*
      N=0
 1    CALL CS_SHL_GET(N,LIBNAME)
      IF (LIBNAME.NE.' ') THEN
        LL=LENOCC(LIBNAME)
        LS=LL-LN-2
        IF (LS .LT. 1) LS = 1
        IF (LIBNAME(LS:LL) .EQ. NAME(1:LN)//'.sl') THEN
           NS=-1
 10        CALL CS_SHL_SYMBOLS(LIBNAME(1:LL),NS,SYMBOL)
           IF(NS.EQ.-2) GO TO 20
           L=LENOCC(SYMBOL)
           IF(SYMBOL(L:L).EQ.'_') L=L-1
           CALL CLTOU (SYMBOL(:L))
           CALL CSCHID(SYMBOL(:L))
           IT=CSLTGP(IPVS)
           IF(IT.GT.0)CALL CSDPRO(IT)
           go to 10
 
 20        CALL CS_SHL_UNLOAD(LIBNAME(1:LL))
           ITBS=ITBS-1
           RETURN
        ENDIF
        N=N+1
        GOTO 1
      ENDIF
+SELF.
      END
+DECK,CSCREXEC,IF=SHL. -------------------------------------------------------
*CMZ :          10/11/97  11.27.40  by  Pavel Nevski
*CMZ :  1.17/07 10/01/94  16.41.15  by  Vladimir Berezhnoi
*-- Author :    Vladimir Berezhnoi   07/01/94
*************************************************************************
      SUBROUTINE CSCREXEC(NAME,CPID,FEXT,FEXEC,IERR)
*                                                                       *
* Description: comis exec processor                                     *
* Modifications:                                                        *
* PN, 29.10.97 - LINUX version added according to VB mail of 20.09.97   *
*              - system branches cleaned up, USERLIB is a common option *
*************************************************************************
      CHARACTER *(*)      NAME,CPID,FEXT,FEXEC
+SEQ,CSHLNM.
      CHARACTER *256  CHLINE
      CHARACTER *4096 USERLIBS
      COMMON /CSDEBUG/ ICSDEBUG
 
      IERR  = 0
      LN    = LENOCC(NAME)
      LP    = LENOCC(CPID)
      LPATH = LENOCC(CHPATH)
      LEXEC = LENOCC(FEXEC)
      if (ICSDEBUG.gt.0) print *,' ===> in CSCREXEC <=== ',NAME(:LN)
 
**    CALL PALUNF(60,3,LUNOUT)
      CALL CSLUNF(LUNOUT)
      IF (LUNOUT.EQ.0) GO TO 99
      OPEN(LUNOUT,FILE=FEXEC(:LEXEC), STATUS='UNKNOWN',ERR=99)
      WRITE (LUNOUT,'(A)')        '#! /bin/sh'
      WRITE (LUNOUT,'(A)')        'olddir=`pwd`'
*     WRITE (LUNOUT,'(A)')        'cd '//CHPATH(:LPATH)
      CHLINE=                     'cd '//CHPATH(:LPATH)
      L=LENOCC(CHLINE)
      WRITE (LUNOUT,'(A)') CHLINE(:L)
*     WRITE (LUNOUT,'(A)')        '/bin/rm -f '//NAME(:LN)//'.sl'
      CHLINE=                     '/bin/rm -f '//NAME(:LN)//'.sl'
      L=LENOCC(CHLINE)
      WRITE (LUNOUT,'(A)') CHLINE(:L)
      IF(FEXT.EQ.'.c')THEN
*                                 'cc -c .... name.c'
        L=LENOCC(CHCC)
        CHLINE=CHCC(:L)//' '//NAME(:LN)// '.c'
      ELSE
*                                 'f77 -c .... name.f'
        L=LENOCC(CHF77)
        CHLINE=CHF77(:L)//' '//NAME(:LN)// '.f'
      ENDIF
*
      L=LENOCC(CHLINE)
      WRITE(LUNOUT,'(A)') CHLINE(:L)
      WRITE(LUNOUT,'(A)')         'errno=$?'
      WRITE(LUNOUT,'(A)')         'if [ $errno != 0 ]'
      WRITE(LUNOUT,'(A)')         'then'
      WRITE(LUNOUT,'(A)')         '   exit $errno'
      WRITE(LUNOUT,'(A)')         'fi'
*
+SELF,IF=HPUX.
      CHLINE=                     'ld -b -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=AIX.
      CHLINE=                     '/usr/ucb/nm '// NAME(:LN) //
     + '.o | egrep '' [BAD] ''| cut -f3 -d'' '' |sed -e ''s/^#/ #/'' '
     + // '| sort | uniq > '// NAME(:LN) //'.exp'
      L=LENOCC(CHLINE)
      WRITE (LUNOUT,'(A)') CHLINE(:L)
      CHLINE=                     'ld -bE:'// NAME(:LN) //'.exp -o '
     + // NAME(:LN) //'.sl /pathtoimp/aixpawimp.o '// NAME(:LN) //'.o'
     + // ' -bh:4 -T512 -H512'
      L=LENOCC(CHLINE)
      IF(FEXT.EQ.'.c')THEN
        CHLINE= CHLINE(:L)// ' -lc'
      ELSE
        CHLINE= CHLINE(:L)// ' -lxlf90'
      ENDIF
+SELF,IF=SUN,MSDOS,IF=SOLARIS.
      CHLINE=                     '/usr/ccs/bin/ld -G -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=SUN,IF=-SOLARIS.
      CHLINE=                     'ld -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=SGI.
      CHLINE=                     'ld -shared -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF,IF=ALPHA_OSF.
      CHLINE=                     'ld -shared -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
     +                    // ' -lUfor -lfor -lFutil -lm -lots -lc'
+SELF,IF=LINUX.
      CHLINE=                     'ld -shared -o '
     +                    // NAME(:LN) //'.sl '// NAME(:LN) //'.o'
+SELF.
*
      USERLIBS=                   '         '
      CALL GETENV('USERLIB',USERLIBS)
      L       = LENOCC(CHLINE)
      LUSRLIB = max(1,LENOCC(USERLIBS))
      WRITE (LUNOUT,'(A)') CHLINE(:L) // USERLIBS(:LUSRLIB)
*
      WRITE(LUNOUT,'(A)')         'errno=$?'
      WRITE(LUNOUT,'(A)')         'if [ $errno != 0 ]'
      WRITE(LUNOUT,'(A)')         'then'
      WRITE(LUNOUT,'(A)')         '   exit $errno'
      WRITE(LUNOUT,'(A)')         'fi'
      CHLINE=                     '/bin/chmod 555 '//NAME(:LN)//'.sl'
      L=LENOCC(CHLINE)
      WRITE(LUNOUT,'(A)')CHLINE(:L)
*?     CHLINE='/bin/rm -f *_'//CPID(:LP)//'.o *_'//CPID(:LP)//'.f'
*      CHLINE=                    '/bin/rm -f *_'//CPID(:LP)//'.o'
      CHLINE=                     '/bin/rm -f '//NAME(:LN)//'.o'
      L=LENOCC(CHLINE)
      WRITE(LUNOUT,'(A)')CHLINE(:L)
      WRITE(LUNOUT,'(A)')         'cd $olddir'
      WRITE(LUNOUT,'(A)')         'exit 0'
      CALL CSCLOS(LUNOUT)
      CLOSE(LUNOUT)
      RETURN
*
 99   PRINT *,' CS: could not open file: ',FEXEC(:LENOCC(FEXEC))
      IERR=1
      IF(LUNOUT.GT.0)CALL CSCLOS(LUNOUT)
      END
+DECK,CSFILX.
*CMZ :          02/12/97  12.36.02  by  Pavel Nevski
*CMZ :  1.18/00 25/01/94  18.26.31  by  Vladimir Berezhnoi
*-- Author : V.Berezhnoi
      SUBROUTINE CSFILX(NAME)
***---------------------------------
+SEQ,CSLUN.
+SELF,IF=IBM.
         CHARACTER *80 VMIBM
+SELF.
      CHARACTER *(*) NAME
      IF(ISTFIL.NE.0)THEN
        CLOSE(LUNFIL)
        ISTFIL=0
      ENDIF
+SELF,IF=VAX.
      OPEN( LUNFIL,FILE=NAME,SHARED,READONLY,STATUS='OLD' ,ERR=1)
+SELF,IF=APOLLO,UNIX.
      OPEN( LUNFIL,FILE=NAME,STATUS='OLD' ,ERR=1)
+SELF,IF=IBM,IF=-IBMMVS,IF=-PAW.
      VMIBM=NAME
      L=LENOCC(NAME)
      DO 77 I=1,L
         IF(VMIBM(I:).EQ.'.')VMIBM(I:I)=' '
  77  CONTINUE
      IS=INDEX(VMIBM,'/')
      IF(IS.NE.0)VMIBM(IS:IS)=' '
      OPEN( LUNFIL,FILE='/'//VMIBM,STATUS='UNKNOWN' ,ERR=1)
+SELF,IF=IBM,IF=-IBMMVS,IF=PAW.
      CALL KUOPEN ( LUNFIL, NAME, 'OLD', ISTAT )
      IF ( ISTAT .NE. 0 )               GO TO 1
+SELF,IF=IBMMVS.
      CALL KUOPEN ( LUNFIL, NAME, 'OLD', ISTAT )
      IF ( ISTAT .NE. 0 )               GO TO 1
+SELF.
      ISTFIL=1
  1   RETURN
*      CALL CSSOUT('FILE WAS NOT OPEN')
*      CALL CSSOUT(NAME)
      END
+PATCH,DECCC. ================================================================
*CMZ :  1.30/00 23/07/96  18.37.07  by  Pavel Nevski
+KEEP,dlfcn,IF=AIX,IF=SHL,T=XCC. ---------------------------------------------
/*CMZ :          20/11/97  22.10.22  by  Pavel Nevski*/
/*-- Author :    HELIOS Software GmbH*/
/*
 * @(#)dlfcn.h	1.4 revision of 95/04/25  09:36:52
 * This is an unpublished work copyright (c) 1992 HELIOS Software GmbH
 * 30159 Hannover, Germany
 */
 
#ifndef __dlfcn_h__
#define __dlfcn_h__
 
#ifdef __cplusplus
extern "C" {
#endif
 
/*
 * Mode flags for the dlopen routine.
 */
#define RTLD_LAZY	1	/* lazy function call binding */
#define RTLD_NOW	2	/* immediate function call binding */
#define RTLD_GLOBAL	0x100	/* allow symbols to be global */
 
/*
 * To be able to intialize, a library may provide a dl_info structure
 * that contains functions to be called to initialize and terminate.
 */
struct dl_info {
	void (*init)(void);
	void (*fini)(void);
};
 
#if __STDC__ || defined(_IBMR2)
 void *dlopen(const char *path, int mode);
 void *dlsym(void *handle, const char *symbol);
 char *dlerror(void);
 int dlclose(void *handle);
#else
 void *dlopen();
 void *dlsym();
 char *dlerror();
 int dlclose();
#endif
 
#ifdef __cplusplus
}
#endif
 
#endif /* __dlfcn_h__ */
 
 
 
+DECK,CS_HPSHL,T=XCC,IF=HPUX,IF=SHL. --------------------------------------
/*CMZ :          18/05/97  14.03.45  by  Pavel Nevski*/
/*-- Author :*/
#include <string.h>
#include <stdlib.h>
#include <dl.h>
 
void perror();
int  cs_shl_load_(path, n)
   char *path;
   int n;
{
   shl_t  handle;
   char   lib_name[80];
/* int    flags=BIND_DEFERRED; */
   int    flags=BIND_IMMEDIATE | BIND_VERBOSE;
/* int    flags=BIND_IMMEDIATE | BIND_NONFATAL; */
   long   address=0L;
   extern int errno;
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
   handle = shl_load(lib_name, flags, address);
   return (errno);
}
/****************************************************************************/
long cs_get_func_(sym,n)
   char *sym;
   int n;
{
   shl_t handle;
   short type;
   long  addr;
   char  func_name[80];
 
   strncpy(func_name, sym, n);  func_name[n] = '\0';
 
   handle = NULL;
   if (shl_findsym(&handle,func_name,TYPE_PROCEDURE,&addr) == 0) return(addr);
   else /* printf(" CS: function not found: %s\n",func_name); */ return (0L);
}
/****************************************************************************/
void cs_shl_unload_(path, n)
   char *path;
   int n;
{
   shl_t  handle;
   struct shl_descriptor *desc;
   char   lib_name[80];
   int    index;
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
   /* find handle of shared library using its name */
   index  = 0;
   handle = NULL;
   while (shl_get(index++, &desc) == 0)
   { if (!strcmp(lib_name, desc->filename)) { handle = desc->handle; break; } }
 
   if (!handle)
   {  printf(" CS: Shared library not loaded: %s\n", lib_name);  return; }
 
   if (shl_unload(handle) == -1)
      printf(" CS: Could not unload shared library: %s\n", lib_name);
}
/****************************************************************************/
void cs_shl_symbols_(path, ns, symbol, n)
   char *path, *symbol;
   int  *ns;
   int   n;
{
   shl_t  handle;
   struct shl_descriptor *desc;
   char   lib_name[80];
   int    index, flags;
   short  type;
   static nsym;
   static struct shl_symbol *symbols;
 
   if (*ns == -1)
   {  strncpy(lib_name, path, n);   lib_name[n] = '\0';
 
      /* find handle of shared library using its name */
      index  = 0;
      handle = NULL;
      while (shl_get(index++, &desc) == 0)
      { if (!strcmp(lib_name,desc->filename)) { handle=desc->handle; break; } }
      if (!handle) { *ns = -2; return;  }
 
      nsym = shl_getsymbols(handle, TYPE_PROCEDURE,
                            EXPORT_SYMBOLS|NO_VALUES, malloc, &symbols);
      if (nsym == -1)
      {  printf(" CS: Could not get symbols from shared library: %s\n",
                lib_name);  *ns = -2; return;
      }
      *ns = 0;
   }
   else
   {  if (*ns >= nsym-1) { *ns = -2;  free(symbols);  return; }
      else                (*ns)++;
   }
   memset(symbol, ' ', 32);
   strncpy(symbol, symbols[*ns].name, strlen(symbols[*ns].name));
}
/****************************************************************************/
void cs_shl_get_(ns, symbol, n)
   char *symbol;
   int  *ns;
   int   n;
{  /* find name of ns [ns=0 for first] shared library  */
   struct shl_descriptor *desc;
 
   memset(symbol, ' ', n);
   if (shl_get(*ns, &desc) == 0)
      strncpy(symbol,desc->filename , strlen(desc->filename));
}
 
 
 
+DECK,CS_dlfcn,T=XCC,IF=AIX,IF=SHL. --------------------------------------------
/*CMZ :          06/07/97  15.44.20  by  Pavel Nevski*/
/*-- Author :*/
/*
 * @(#)dlfcn.c	1.11 revision of 96/04/10  20:12:51
 * This is an unpublished work copyright (c) 1992 HELIOS Software GmbH
 * 30159 Hannover, Germany
 *
 * We simulate dlopen() et al. through a call to load. Because AIX has
 * no call to find an exported symbol we read the loader section of the
 * loaded module and build a list of exported symbols and their virtual
 * address.
 *
 * Changes marked with `--jwe' were made on April 7 1996 by John W. Eaton
 * <jwe@bevo.che.wisc.edu> to support g++ and/or use with Octave.
 * This makes my life easier with Octave.  --jwe
 */
 
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ldr.h>
#include <a.out.h>
#include <ldfcn.h>
+cde,dlfcn.
 
typedef struct {
	char		*name;		/* the symbols's name */
	void		*addr;		/* its relocated virtual address */
} Export, *ExportPtr;
 
/*
 * xlC uses the following structure to list its constructors and
 * destructors. This is gleaned from the output of munch.
 */
 
typedef struct {
	void (*init)(void);		/* call static constructors */
	void (*term)(void);		/* call static destructors */
} Cdtor, *CdtorPtr;
 
typedef void (*GccCDtorPtr)(void);
 
/*
 * The void * handle returned from dlopen is actually a ModulePtr.
 */
 
typedef struct Module {
	struct Module	*next;
	char		*name;		/* module name for refcounting */
	int		refCnt;		/* the number of references */
	void		*entry;		/* entry point from load */
	struct dl_info	*info;		/* optional init/terminate functions */
	CdtorPtr	cdtors;		/* optional C++ constructors */
	GccCDtorPtr	gcc_ctor;	/* g++ constructors  --jwe */
	GccCDtorPtr	gcc_dtor;	/* g++ destructors  --jwe */
	int		nExports;	/* the number of exports found */
	ExportPtr	exports;	/* the array of exports */
} Module, *ModulePtr;
 
/*
 * We keep a list of all loaded modules to be able to call the fini
 * handlers and destructors at atexit() time.
 */
static ModulePtr modList;
 
/*
 * The last error from one of the dl* routines is kept in static
 * variables here. Each error is returned only once to the caller.
 */
static char errbuf[BUFSIZ];
static int errvalid;
 
/*
 * The `fixed' gcc header files on AIX 3.2.5 provide a prototype for
 * strdup().  --jwe
 */
#ifndef HAVE_STRDUP
extern char *strdup(const char *);
#endif
static void caterr(char *);
static int readExports(ModulePtr);
static void terminate(void);
static void *findMain(void);
 
void *dlopen(const char *path, int mode)
{
	register ModulePtr mp;
	static void *mainModule;
 
	/*
	 * Upon the first call register a terminate handler that will
	 * close all libraries. Also get a reference to the main module
	 * for use with loadbind.
	 */
	if (!mainModule) {
		if ((mainModule = findMain()) == NULL)
			return NULL;
		atexit(terminate);
	}
	/*
         * SunOS/System V.4 allows handle to be a NULL pointer to refer
         * to the module the call is made from, this is not implemented.
         */
	if (path == NULL) {
                mp = mainModule;
		if (readExports(mp) == -1) {
                printf("can not readExports for mainModule \n");
	 	return NULL;
         	}
                return mp;
        }
	/*
	 * Scan the list of modules if we have the module already loaded.
	 */
	for (mp = modList; mp; mp = mp->next)
		if (strcmp(mp->name, path) == 0) {
			mp->refCnt++;
			return mp;
		}
	if ((mp = (ModulePtr)calloc(1, sizeof(*mp))) == NULL) {
		errvalid++;
		strcpy(errbuf, "calloc: ");
		strcat(errbuf, strerror(errno));
		return NULL;
	}
	if ((mp->name = strdup(path)) == NULL) {
		errvalid++;
		strcpy(errbuf, "strdup: ");
		strcat(errbuf, strerror(errno));
		free(mp);
		return NULL;
	}
	/*
	 * load should be declared load(const char *...). Thus we
	 * cast the path to a normal char *. Ugly.
	 */
	if ((mp->entry = (void *)load((char *)path, L_NOAUTODEFER, NULL)) == NULL) {
		free(mp->name);
		free(mp);
		errvalid++;
		strcpy(errbuf, "dlopen: ");
		strcat(errbuf, path);
		strcat(errbuf, ": ");
		/*
		 * If AIX says the file is not executable, the error
		 * can be further described by querying the loader about
		 * the last error.
		 */
		if (errno == ENOEXEC) {
			char *tmp[BUFSIZ/sizeof(char *)];
			if (loadquery(L_GETMESSAGES, tmp, sizeof(tmp)) == -1)
				strcpy(errbuf, strerror(errno));
			else {
				char **p;
				for (p = tmp; *p; p++)
					caterr(*p);
			}
		} else
			strcat(errbuf, strerror(errno));
		return NULL;
	}
	mp->refCnt = 1;
	mp->next = modList;
	modList = mp;
	if (loadbind(0, mainModule, mp->entry) == -1) {
		dlclose(mp);
		errvalid++;
		strcpy(errbuf, "loadbind: ");
		strcat(errbuf, strerror(errno));
		return NULL;
	}
	/*
	 * If the user wants global binding, loadbind against all other
	 * loaded modules.
	 */
	if (mode & RTLD_GLOBAL) {
		register ModulePtr mp1;
		for (mp1 = mp->next; mp1; mp1 = mp1->next)
			if (loadbind(0, mp1->entry, mp->entry) == -1) {
				dlclose(mp);
				errvalid++;
				strcpy(errbuf, "loadbind: ");
				strcat(errbuf, strerror(errno));
				return NULL;
			}
	}
	if (readExports(mp) == -1) {
		dlclose(mp);
		return NULL;
	}
	/*
	 * If there is a dl_info structure, call the init function.
	 */
	if (mp->info = (struct dl_info *)dlsym(mp, "dl_info")) {
		if (mp->info->init)
			(*mp->info->init)();
	} else
		errvalid = 0;
	/*
	 * If the shared object was compiled using xlC we will need
	 * to call static constructors (and later on dlclose destructors).
	 */
	if (mp->cdtors = (CdtorPtr)dlsym(mp, "__cdtors")) {
		CdtorPtr cp = mp->cdtors;
		while (cp->init || cp->term) {
			if (cp->init && cp->init != (void (*)(void))0xffffffff)
				(*cp->init)();
			cp++;
		}
	/*
	 * If the shared object was compiled using g++, we will need
	 * to call global constructors using the _GLOBAL__DI function,
	 * and later, global destructors using the _GLOBAL_DD
	 * funciton.  --jwe
	 */
	} else if (mp->gcc_ctor = (GccCDtorPtr)dlsym(mp, "_GLOBAL__DI")) {
		(*mp->gcc_ctor)();
		mp->gcc_dtor = (GccCDtorPtr)dlsym(mp, "_GLOBAL__DD");
	} else
		errvalid = 0;
	return mp;
}
 
/*
 * Attempt to decipher an AIX loader error message and append it
 * to our static error message buffer.
 */
static void caterr(char *s)
{
	register char *p = s;
 
	while (*p >= '0' && *p <= '9')
		p++;
	switch(atoi(s)) {
	case L_ERROR_TOOMANY:
		strcat(errbuf, "to many errors");
		break;
	case L_ERROR_NOLIB:
		strcat(errbuf, "can't load library");
		strcat(errbuf, p);
		break;
	case L_ERROR_UNDEF:
		strcat(errbuf, "can't find symbol");
		strcat(errbuf, p);
		break;
	case L_ERROR_RLDBAD:
		strcat(errbuf, "bad RLD");
		strcat(errbuf, p);
		break;
	case L_ERROR_FORMAT:
		strcat(errbuf, "bad exec format in");
		strcat(errbuf, p);
		break;
	case L_ERROR_ERRNO:
		strcat(errbuf, strerror(atoi(++p)));
		break;
	default:
		strcat(errbuf, s);
		break;
	}
}
 
void *dlsym(void *handle, const char *symbol)
{
	register ModulePtr mp = (ModulePtr)handle;
	register ExportPtr ep;
	register int i;
 
	/*
	 * Could speed up the search, but I assume that one assigns
	 * the result to function pointers anyways.
	 */
	for (ep = mp->exports, i = mp->nExports; i; i--, ep++)
		if (strcmp(ep->name, symbol) == 0)
			return ep->addr;
	errvalid++;
	strcpy(errbuf, "dlsym: undefined symbol ");
	strcat(errbuf, symbol);
	return NULL;
}
 
char *dlerror(void)
{
	if (errvalid) {
		errvalid = 0;
		return errbuf;
	}
	return NULL;
}
 
int dlclose(void *handle)
{
	register ModulePtr mp = (ModulePtr)handle;
	int result;
	register ModulePtr mp1;
 
	if (--mp->refCnt > 0)
		return 0;
	if (mp->info && mp->info->fini)
		(*mp->info->fini)();
	if (mp->cdtors) {
		CdtorPtr cp = mp->cdtors;
		while (cp->init || cp->term) {
			if (cp->term && cp->init != (void (*)(void))0xffffffff)
				(*cp->term)();
			cp++;
		}
	/*
	 * If the function to handle global destructors for g++
	 * exists, call it.  --jwe
	 */
	} else if (mp->gcc_dtor) {
	        (*mp->gcc_dtor)();
	}
	result = unload(mp->entry);
	if (result == -1) {
		errvalid++;
		strcpy(errbuf, strerror(errno));
	}
	if (mp->exports) {
		register ExportPtr ep;
		register int i;
		for (ep = mp->exports, i = mp->nExports; i; i--, ep++)
			if (ep->name)
				free(ep->name);
		free(mp->exports);
	}
	if (mp == modList)
		modList = mp->next;
	else {
		for (mp1 = modList; mp1; mp1 = mp1->next)
			if (mp1->next == mp) {
				mp1->next = mp->next;
				break;
			}
	}
	free(mp->name);
	free(mp);
	return result;
}
 
static void terminate(void)
{
	while (modList)
		dlclose(modList);
}
 
/*
 * Build the export table from the XCOFF .loader section.
 */
static int readExports(ModulePtr mp)
{
	LDFILE *ldp = NULL;
	SCNHDR sh, shdata;
	LDHDR *lhp;
	char *ldbuf;
	LDSYM *ls;
	int i;
	ExportPtr ep;
 
	if ((ldp = ldopen(mp->name, ldp)) == NULL) {
		struct ld_info *lp;
		char *buf;
		int size = 4*1024;
		if (errno != ENOENT) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			return -1;
		}
		/*
		 * The module might be loaded due to the LIBPATH
		 * environment variable. Search for the loaded
		 * module using L_GETINFO.
		 */
		if ((buf = malloc(size)) == NULL) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			return -1;
		}
		while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
			free(buf);
			size += 4*1024;
			if ((buf = malloc(size)) == NULL) {
				errvalid++;
				strcpy(errbuf, "readExports: ");
				strcat(errbuf, strerror(errno));
				return -1;
			}
		}
		if (i == -1) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			free(buf);
			return -1;
		}
		/*
		 * Traverse the list of loaded modules. The entry point
		 * returned by load() does actually point to the data
		 * segment origin.
		 */
		lp = (struct ld_info *)buf;
		while (lp) {
			if (lp->ldinfo_dataorg == mp->entry) {
				ldp = ldopen(lp->ldinfo_filename, ldp);
				break;
			}
			if (lp->ldinfo_next == 0)
				lp = NULL;
			else
				lp = (struct ld_info *)((char *)lp + lp->ldinfo_next);
		}
		free(buf);
		if (!ldp) {
			errvalid++;
			strcpy(errbuf, "readExports: ");
			strcat(errbuf, strerror(errno));
			return -1;
		}
	}
	if (TYPE(ldp) != U802TOCMAGIC) {
		errvalid++;
		strcpy(errbuf, "readExports: bad magic");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * Get the padding for the data section. This is needed for
	 * AIX 4.1 compilers. This is used when building the final
	 * function pointer to the exported symbol.
	 */
	if (ldnshread(ldp, _DATA, &shdata) != SUCCESS) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot read data section header");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (ldnshread(ldp, _LOADER, &sh) != SUCCESS) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot read loader section header");
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * We read the complete loader section in one chunk, this makes
	 * finding long symbol names residing in the string table easier.
	 */
	if ((ldbuf = (char *)malloc(sh.s_size)) == NULL) {
		errvalid++;
		strcpy(errbuf, "readExports: ");
		strcat(errbuf, strerror(errno));
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (FSEEK(ldp, sh.s_scnptr, BEGINNING) != OKFSEEK) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot seek to loader section");
		free(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	if (FREAD(ldbuf, sh.s_size, 1, ldp) != 1) {
		errvalid++;
		strcpy(errbuf, "readExports: cannot read loader section");
		free(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	lhp = (LDHDR *)ldbuf;
	ls = (LDSYM *)(ldbuf+LDHDRSZ);
	/*
	 * Count the number of exports to include in our export table.
	 */
	for (i = lhp->l_nsyms; i; i--, ls++) {
		if (!LDR_EXPORT(*ls))
			continue;
		mp->nExports++;
	}
	if ((mp->exports = (ExportPtr)calloc(mp->nExports, sizeof(*mp->exports))) == NULL) {
		errvalid++;
		strcpy(errbuf, "readExports: ");
		strcat(errbuf, strerror(errno));
		free(ldbuf);
		while(ldclose(ldp) == FAILURE)
			;
		return -1;
	}
	/*
	 * Fill in the export table. All entries are relative to
	 * the entry point we got from load.
	 */
	ep = mp->exports;
	ls = (LDSYM *)(ldbuf+LDHDRSZ);
	for (i = lhp->l_nsyms; i; i--, ls++) {
		char *symname;
		char tmpsym[SYMNMLEN+1];
		if (!LDR_EXPORT(*ls))
			continue;
		if (ls->l_zeroes == 0)
			symname = ls->l_offset+lhp->l_stoff+ldbuf;
		else {
			/*
			 * The l_name member is not zero terminated, we
			 * must copy the first SYMNMLEN chars and make
			 * sure we have a zero byte at the end.
			 */
			strncpy(tmpsym, ls->l_name, SYMNMLEN);
			tmpsym[SYMNMLEN] = '\0';
			symname = tmpsym;
		}
		ep->name = strdup(symname);
		ep->addr = (void *)((unsigned long)mp->entry +
					ls->l_value - shdata.s_vaddr);
		ep++;
	}
	free(ldbuf);
	while(ldclose(ldp) == FAILURE)
		;
	return 0;
}
 
/*
 * Find the main modules entry point. This is used as export pointer
 * for loadbind() to be able to resolve references to the main part.
 */
static void * findMain(void)
{
	struct ld_info *lp;
	char *buf;
	int size = 4*1024;
	int i;
	void *ret;
 
	if ((buf = malloc(size)) == NULL) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strcat(errbuf, strerror(errno));
		return NULL;
	}
	while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {
		free(buf);
		size += 4*1024;
		if ((buf = malloc(size)) == NULL) {
			errvalid++;
			strcpy(errbuf, "findMain: ");
			strcat(errbuf, strerror(errno));
			return NULL;
		}
	}
	if (i == -1) {
		errvalid++;
		strcpy(errbuf, "findMain: ");
		strcat(errbuf, strerror(errno));
		free(buf);
		return NULL;
	}
	/*
	 * The first entry is the main module. The entry point
	 * returned by load() does actually point to the data
	 * segment origin.
	 */
	lp = (struct ld_info *)buf;
	ret = lp->ldinfo_dataorg;
	free(buf);
	return ret;
}
 
 
 
+DECK,CS_HLSHL,T=XCC,IF=-HPUX. ===============================================
/*CMZ :          05/11/97  15.53.29  by  Pavel Nevski*/
/*-- Author : Vladimir Berejnoi*/
+SELF,IF=ALPHA_OSF.
#define  ALPHA_OSF
+SELF.
 
#include "dlfcn.h"
#include <string.h>
 
#define MAXLENFL        60
#ifndef RTLD_NOW
#define RTLD_NOW	2	/* immediate function call binding */
#endif
#ifndef RTLD_GLOBAL
#define RTLD_GLOBAL	0x100	/* allow symbols to be global */
#endif
#define RTLD_NOW_CONST (RTLD_NOW || RTLD_GLOBAL)
 
/****************************************************************************/
 
struct procedures
{  char procname[32];
   int  (*funcptr)();
   struct procedures *next;
};
 
struct files
{  char filename[MAXLENFL];
   void              *file_handle;
   struct procedures *first_proc;
   struct files      *next;
};
 
static struct files *first_file = NULL;
static int    debug_level = 0;
 
/****************************************************************************/
struct files *searchfile(filename, f)
  char *filename;
  struct files *f;
{
  while (f != NULL)
  { if (strcmp(filename,f->filename) == 0) return(f);  else f = f->next; }
  return(f);
}
/****************************************************************************/
struct procedures *searchproc(procname, p)
  char *procname;
  struct procedures *p;
{
  while (p != NULL)
  { if (strcmp(procname,p->procname) == 0) return(p);  else p = p->next; }
  return(p);
}
/****************************************************************************/
void Delete_all(f)
struct files *f;
{
 struct procedures *p;
 
 while (f->first_proc != NULL)
 {  p = f->first_proc;  f->first_proc = p->next;  free(p);  }
}
/****************************************************************************/
int  cs_shl_load_(path, n)
   char *path;
   int n;
{
   struct files *f;
   void   *file_handle;
   char   lib_name[MAXLENFL];
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
    if (strcmp(lib_name, "./0.sl") == 0)
    {  file_handle = dlopen( NULL,    RTLD_NOW_CONST); }
    else
    {  file_handle = dlopen(lib_name, RTLD_NOW_CONST); }
    if (file_handle == NULL)
    {  printf("  %s \n",dlerror() );  return 1;        }
 
/*   Add new file to the files list */
 
   f = (struct files *) malloc(sizeof(struct files));
   strcpy(f->filename,lib_name);
   f->file_handle = file_handle;
   f->next        = first_file;
   f->first_proc  = NULL;
   first_file     = f;
   return 0;
}
/****************************************************************************/
void cs_shl_unload_(path, n)
   char *path;
   int n;
{
   struct files *f,  *before;
   char   lib_name[MAXLENFL];
 
   strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
   /*       find file    */
 
   f = searchfile(lib_name,first_file);
   if (f == NULL)
   {  if (debug_level > 0) printf("File not found.\n");  return; }
 
   if (f != first_file)
   {  before = first_file;
      while (before->next != f) before = before->next;
      before->next = f->next;
   }
   else
   {  first_file = f->next; }
   Delete_all(f);
 
   if (dlclose(f->file_handle) != 0)
   {  if (debug_level > 0) printf("Error in dlclose()...\n");  return; }
   free(f);
   if (debug_level > 0) printf("Unlink %s file.\n",lib_name);
   return;
}
/****************************************************************************/
void * cs_get_func_(sym,n)
   char *sym;
   int n;
{
   struct procedures *p;
   struct files      *f;
   void   *fill_procaddr;
   char   procname[80];
#ifdef ALPHA_OSF
         int jumpad_();
         unsigned long ptr = (unsigned long)jumpad_;
#endif
   strncpy(procname, sym, n);  procname[n] = '\0';
 
/* --   Search for all files -- */
 
   f = first_file;
   while (f != NULL)
   { p = searchproc(procname, f->first_proc);
     if (p != NULL) return (void *)(p->funcptr);
     fill_procaddr =  dlsym(f->file_handle, procname);
     if (fill_procaddr != (void *) NULL)
     {   p = (struct procedures *) malloc(sizeof(struct procedures));
         strcpy(p->procname, procname);
#ifdef ALPHA_OSF
         ptr = (unsigned long) fill_procaddr - ptr;
         p->funcptr = (int (*) ()) ptr;
#else
         p->funcptr = (int (*) ()) fill_procaddr;
#endif
         p->next = f->first_proc;
         f->first_proc = p;
         return (void *)(p->funcptr);
     }
     f = f->next;
   } /* end while */
  return 0;
}
/****************************************************************************/
void cs_shl_get_(ns, libname, n)
   char *libname;
   int  *ns;
   int   n;
{  /* find name of ns [ns=0 for first] shared library  */
   struct files *f;
   int i=0;
 
   f=first_file;
   while (f != NULL && i < *ns)  { f = f->next;  i++; }
 
   memset(libname, ' ', n);
   if (f != NULL) strncpy(libname, f->filename, strlen(f->filename));
}
/****************************************************************************/
void cs_shl_symbols_(path, ns, symbol, n, nsy)
   char *path, *symbol;
   int  *ns;
   int   n, nsy;
{  char   lib_name[MAXLENFL];
   struct files  *f;
   static struct procedures *p;
 
   if (*ns == -1)
   {  strncpy(lib_name, path, n);  lib_name[n] = '\0';
 
      /* find shared library using its name */
      f = first_file;  *ns = -2;
      while (f != NULL)
      {  if (!strcmp(lib_name, f->filename))  { p = f->first_proc;  break; }
         else f = f->next;
      }
      if (f == NULL) return;
      if (p == NULL)
      { printf(" CS: no symbols in shared library: %s\n",lib_name); return;}
 
     *ns = 0;
   }
   else {  if (p == NULL) { *ns = -2; return; }  }
 
   memset(symbol, ' ', 32);
   strncpy(symbol, p->procname, strlen(p->procname));
   p = p->next;  (*ns)++;
}
 
 
 
+DECK,TRACEQC,T=XCC,IF=HPUX. -------------------------------------------------
/*CMZ :  1.30/00 22/04/97  14.49.55  by  Pavel Nevski*/
/*-- Author :    FR & JZ*/
void traceqc_()
{  void    U_STACK_TRACE();  U_STACK_TRACE();  return; }
 
+DECK,memget,T=XCC.
/*CMZ :          08/07/97  16.16.29  by  Pavel Nevski*/
/*-- Author :    Mark Hsu 2/1/91 HPCSD, Kingston, NY.*/
/* memget.c: allow dynamic memory allocation from FORTRAN
 * Mark Hsu 2/1/91 HPCSD, Kingston, NY.
 * usage from FORTRAN:    a = memget(n)
 * where n is the number of bytes requested and the value returned
 * in a is the base address. To access the allocation, pass the
 * pointer value as an address by using the val function, e.g.,
 *
 *  iptr = memget(n)
 *  call fsub(n, val(iptr),...)
 *  . . .
 *  subroutine fsub(n,array,...)
 */
/*  char *malloc(); */
memget_(n)
int *n;
{
  /* malloc() requires unsigned arg. FORTRAN passes signed integers */
  unsigned i;
  i = (unsigned)  *n;
  /* malloc() returns a pointer;     memget() returns an integer.   */
  return ( (int) malloc(i) );
}
+DECK,dumsgi6,T=C,IF=SGI6.
/*CMZ :          01/12/97  23.48.16  by  Pavel Nevski*/
/*-- Author :    Pavel Nevski   01/12/97*/
void regcmp () { }
void regex  () { }
+PATCH,AGZIO.
*CMZ :  1.30/00 19/02/97  22.17.46  by  Pavel Nevski
+DECK,AgZopen,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 29/04/97  23.23.51  by  Pavel Nevski
*CMZU:  1.00/01 15/01/96  20.20.30  by  Pavel Nevski
*-- Author :    L.Vacavant, A.Rozanov    14/12/94
******************************************************************************
*                                                                            *
     subroutine    A G Z O P E N (stream,name,Copt,Npar,Ipar)
*                                                                            *
* Description: (re)open a file with events in GENZ format-via Fatmen or GENZ *
*   After a succesful open, K keeps track of what should be closed next call *
******************************************************************************
+CDE,Typing,QUEST,GCBANK,GCFLAG,GCKINE,AgCKINE.
Character  Stream*(*),Name*(*),Copt*(*),FName*255/' '/,IOFILE*8,
           CREQ*256,COPTN*20,FZOP*4
Integer    LOCF,Npar,Ipar(*),KEYS(10),LENOCC,Nfound,Jcont,Unit,
           Ier,Irc,Jrc,K,Lc,iend,mem,iu,IREQ,ko,LREC
Common     /AgZbuffer/  K,JRC,JCONT,CREQ,COPTN,IREQ,iend,mem(100,5)
*
*  extract requested unit record
   If      INDEX(Stream,'B')>0 { iu=2; IBack = -1; IBackOld = 0; }
   else If INDEX(Stream,'O')>0 { iu=3; Ioutp = -1; IOutpOld = 0; }
   else                        { iu=1; IKine = -1; IKineOld = 0; }
   Call UCOPY(mem(1,iu),K,LocF(iend)-LocF(K));
   Unit=20+iu;  write (IOFILE,'(6hIOFILE,i2)') Unit;
 
*  close previously opened unit
   If  K==1   { Call FMCLOS(FName,IOFILE,0,'DE',Irc);  IF (Jrc==0) Jcont=0;  }
   elseIf K>0 { if iu<=2 {Call FZENDI(Unit,'TX')}else{Call FZENDO(Unit,'TX')}}
*
   If Name!=' '  { CREQ=Name; COPTN=COPT; IREQ=1; }
   else          { if (iu!=2) IREQ-=1;            }
   LC=LENOCC(CREQ);  FName=' ';  Nfound=0;  Ier=-1;  Ko=K;  K=0;
   LREC=8100;        If (Index(Stream,'Z')>0) LREC=0
   If Index(Stream,'F')>0
   {  Print *,'* AGZOPEN trying to get tape from FATMEN catalog *'
      CALL FMLOGL(-2); Call FMLFIL(CREQ(1:LC),FName,KEYS,NFound,1,JCont,JRC)
      If NFound>0 & Jrc<=0                       " fatmen request manager "
      {  K=1;  IQUEST(10)=3;                  "inhibit tape label processing"
         Call FMFILE(Unit,FName,'FN',Irc);      ier=0;  If (Irc>1) ier=irc
   }  }
   else If iu<=2 & IREQ>0                         " direct  file  request  "
   { " first try the variable record length format, then the fix length one "
      Print *,' ANZOPEN opening file ',CREQ(1:LC);
      If Index(Stream,'L')>0
      {  Fzop='XI';  K=2;  OPEN (Unit,FILE=CREQ,Iostat=Ier,
                           STATUS='OLD',FORM='UNFORMATTED',RECL=8100) }
      else
      {  Fzop='XIL'; K=3;  CALL CFOPEN(IQUEST,0,0,'r ',0,CREQ,ier)    }
      IF Ier==0
      { :R: Call FZFILE(Unit,LREC,Fzop);  Ier=Iquest(1); K=3;
         If ier==202
         { print *,' Block size wrong: Expected ',IQUEST(14),
                                       ', Found ',IQUEST(15)
           LREC=IQUEST(15); print *,' LREC forced to ',LREC; GoTo :R:
      }  }
   }
   else If iu==3 & IREQ>0
   {  CALL CFOPEN(IQUEST,0,LREC,'w ',0,CREQ,ier);          K=3;
      IF Ier==0 { Call FZFILE(Unit,LREC,'XOL');  Ier=Iquest(1); }
   }
   IF Ier!=0 { If (IREQ>0) print *,' AGZOPEN error K,ier=',K,Ier,
                                   ' file =',CREQ(1:LC);   K=0;
             }
   else      { If iu==1 { IKine = -1; IKineOld = -1; CoptKine = Coptn; }
               If iu==2 { IBack = -1; IBackOld = -1; CoptBack = Coptn; }
               If iu==3 { Ioutp = -1; IOutpOld = -1; CoptOutp = Coptn; }
               CALL FZLOGL(Unit,-2)
             }
   Kevent(iu)=0;  Call UCOPY(K,mem(1,iu),LocF(iend)-LocF(K))
*
End
 
 
+DECK,AgZread,T=geant. --------------------------------------------------------
*CMZ :          24/11/97  23.53.13  by  Pavel Nevski
*CMZ :  1.30/00 19/03/97  21.57.11  by  Pavel Nevski
*CMZU:  1.00/01 15/01/96  20.20.30  by  Pavel Nevski
*-- Author :    L.Vacavant, A.Rozanov    14/12/94
******************************************************************************
*                                                                            *
                subroutine    A G Z R E A D (Stream,ier)
* Modifications and comments:                                                *
* last event may be lost                                                     *
* PN, 24.11.97 - both IDEVT and IDRUN are taken only from the primary stream *
******************************************************************************
+CDE,TYPING,QUEST,GCBANK,GCUNIT,GCNUM,GCFLAG,SCLINK,AgCKINE.
   Integer      ISLFLAG,i,ier,iprin,jvol,Ldata,Lk,N,NP,NT,IdZ/0/,IdG/0/
   Integer      NHSETS,NDSETS,NSECT,NDETM,NSET,JOCRUN,JOCEVT,IGEN,NTRA
   Integer      CSADDR,Iadr,iu,jb,none,Idev
   Integer      Lun/21/,Lhead/0/,ifl/0/,nw/0/,Lsup,Iev/0/,Ihead(400)/400*0/
   Character    Stream*(*),HEAD*4,CHEAD(2)*4/2*' '/,Chopt*8/'*'/,IDH*4
   Logical      Done/.true./
*  tentative guess for standard GFOUT data
   Character*4  Gsets(23)/'PART','MATE','TMED','VOLU','ROTM','SETS','DRAW',
                          'RUNG',  'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a' ,
                          'HEAD','VERT','KINE','JXYZ','HITS','DIGI','SCAN'/
   Character*4  Esets(3) /'CODE','RUN ','EVEN'/
*
  Replace [INP(#,#,#,#,#)] with [
    CHECK (Index(Chopt,'#1')>0 | Index(Chopt,'*')>0);   Nt=Nt+1;
    {IF} '#1'='G' { Np=Np+1; CHECK Jvol==0; IF (#3>0) Call MZDROP(#2,#3,'L'); }
    IF #3==0 { Call FZIN(LUN,#2,#3,1,'A',Nhead,Ihead); jb=#3;    }
    ELSE     { jb=#3; WHILE LQ(jb)>0 { jb=LQ(jb) };
               Call FZIN(LUN,#2,jb,0,'A',Nhead,Ihead); jb=LQ(jb) }
    Ier=Iquest(1);  Nw=Iquest(14);  CHECK jb>0;  Call UHTOC(IQ(jb-4),4,IDH,4);
    IF (IDH!=HEAD&IDEBUG>0) print *,' AGZREAD got ',IDH,' instead of ',HEAD;
    IQ(jb-5)=iu;  #4=IQ(jb+(#5));
    IF (#5==-2&Ier==0) { DO I=1,IQ(jb-2) { IF (LQ(jb-I)>0) #4=I; }}
    PRIN2 '#3','#4',#4,Nw; (' AGZREAD: read',2(2x,a6),' = ',i6,'  Leng = ',i8)
  ]
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
    Check ( index(stream,'P')>0 & IkineOld<=-1 _
          | index(stream,'B')>0 & IBackOld<=-1 )
10  Iprin=max(Idebug+1,ISLFLAG('INPU','PRIN'))
                             iu=1;  Chopt=CoptKine;
    If index(stream,'B')>0 { iu=2;  Chopt=CoptBack; }
    If index(stream,'S')>0 {        Chopt=' ';      }
    Lun=20+iu;  HEAD=CHEAD(iu);  jvol=JVOLUM; Np=0; Nt=0;
    Done=.false.;  If (Kevent(iu)==0) Done=.true.
*
  Loop
  {  If done | HEAD=='NONE'
     {  Lhead=400;      Call FZIN(LUN,IXDIV,LSUP,2,'S',LHEAD,IHEAD)
        Ier=Iquest(1);  ifl=Iquest(11);  Nw=Iquest(14);  HEAD='NONE'
        If Ier<0  { prin0 ifl; (' error',i6,', see ZEBRA manual page 299');
               If (IQUEST(11)==-4 & IQUEST(12)==202) <w> IQUEST(14),IQUEST(15)
                  (10x,'Expected block size',i6,', found on input',i6); Next;}
        If Ier==1 { prin1 ifl; (' zebra sor, run ',i6); Iev=0; IDz=Ifl; Next;}
        If Ier==2 { prin1 ifl; (' zebra eor, run ',i6); Ier=0; ifl=1;
                                                       Kevent(iu)+=1;  Break;}
        If Ier>=3 { prin1 Ier,ifl; (' zebra err, run ',2i6);           Break;}
        If      Lhead=1 & Ifl=0 { i=IHEAD(1); If (1<=i&i<=22) HEAD=Gsets(i); }
        else If Lhead=2 & Ifl>0 { HEAD='RUNG'; if(Kevent(iu)>0) HEAD='HEAD'; }
        else If Lhead=1 & Ifl>0 { i=IHEAD(1); IF (1<=i&i<=3)  HEAD=Esets(i); }
        else If LHead==3 & Ihead(1)+IHEAD(2)+Ihead(3)==0      { HEAD='RAWD'; }
        else If Lhead>2 {"atlas genz format" Call UHTOC(Ihead(3),4,HEAD,4);  }
        if ifl>0  { prin2 kevent(iu),Lun,IHEAD(1),HEAD
                    (' AGZREAD: event',i8,' on unit',i4,' ended by',i8,A6)
                    If ((HEAD!='RUNG'|Nt>0)&HEAD!='CODE'&HEAD!='RUN') Break;
                  }
     }  Done=.true.
*
     If (iu==1 & Head=='HEAD' & JHEAD>0) Call MZDROP(IxDIV,JHEAD,' ')
     If      Head=='RUNG' { inp(G,IXCONS,JRUNG,  IdG,    +1)
             If (iu==1)          IDRUN=max(IdG,IdZ,IHEAD(1)) }
     else If Head=='PART' { inp(G,IXCONS,JPART,  NPART,  -2) }
     else If Head=='MATE' { inp(G,IXCONS,JMATE,  NMATE,  -2) }
     else If Head=='TMED' { inp(G,IXCONS,JTMED,  NTMED,  -2) }
     else If Head=='ROTM' { inp(G,IXCONS,JROTM,  NROTM,  -2) }
     else If Head=='VOLU' { inp(G,IXCONS,JVOLUM, NVOLUM, -2) }
     else If Head=='SETS' { inp(G,IXCONS,JSET,   NSET,   -1) }
     else If Head=='DETM' { inp(G,IXCONS,LKDETM, NDETM,  -1) }
     else If Head=='SCAN' { inp(G,IXCONS,LKDETM, NDETM,  -1) }
     else If Head=='CODE' { inp(E,IxCONS,LKRUNT, IGEN,   +1) }
     else If Head=='RUN ' { inp(E,IxCONS,LKRUNT, none,   +1) }
     else if iu==1 & kevent(1)<Ptype+1         { Next;     }
     else If Head=='RUNT' { inp(E,IxDIV, LKRUNT, JOCRUN, +5) }
     else If Head=='EVNT' { inp(E,IxDIV, LKEVNT, JOCEVT, +6) }
     else If Head=='EVEN' { inp(E,IxDIV, LKEVNT, NTRA,   +1) }
     else If Head=='HEAD' { inp(K,IxDIV, JHEAD,  IDEV ,  +2)
          If iu==1 & Jb>0 & IQ(Jb+1)>1  {IDRUN=IQ(Jb+1); IDEVT=IDEV}}
     else If Head=='VERT' { inp(K,IXDIV, JVERTX, NVERTX, +1) }
     else If Head=='KINE' { inp(K,IXDIV, JKINE,  NTRACK, +1) }
     else If Head=='HITS' { inp(H,IXDIV, JHITS,  NHSETS, -2) }
     else If Head=='DIGI' { inp(D,IXDIV, JDIGI,  NDSETS, -2) }
     else If Head=='RECB' { inp(R,IXDIV, LKARP1, NSECT,  -2) }
     else If Head=='RAWD' { inp(R,IXDIV, LKARAW, Ldata,  -1)
              Lk=LkaRaw; N=0; while Lk>0
              {  prin2 (IQ(LK-i),i=1,5);(' ND,NS,NL=',3i6,' IDH,IDN =',a4,i8)
                 N+=1; Call UCTOH('RAWD',IQ(Lk-4),4,4); IQ(Lk-5)=N; Lk=LQ(Lk)
              }
          }
     else {   prin1 HEAD,LHEAD,(IHEAD(i),i=1,min(LHEAD,10))
              (' READRZ: unknown structure ',A,' skipped '/,
                 8x,'Lhead=',i6,' header=',10z9/(20x,10z9))
          }
     IF Ier#0 { <W> Ier,head; (' READRZ error ',i5,' entering ',A); }
  }
*
  If (JKINE>0  & IQ(JKINE-1)==1 ) Call MZPUSH(IxDIV,JKINE, 0,1,'I')
  If (JVERTX>0 & IQ(JVERTX-1)==1) Call MZPUSH(IxDIV,JVERTX,0,1,'I')
*
  CHEAD(iu)=HEAD; Kevent(iu)+=1;
  If Stream=='P'
  {  if ( jvol==0 & Jvolum>0 )   Call AgReINIT
     if ( 1<kevent(1) & kevent(1)<=Ptype+1 )   Goto 10
     If (LKEVNT>0&INDEX(Chopt,'E')>0&INDEX(Chopt,'K')==0)
     {  Iadr=CSADDR('AGUSKINE');  call UHTOC(IQ(LKEVNT-4),4,IDH,4)
        If      IDH=='EVNT' { Call AgGZKINE(iprin)      }
        else If IDH=='EVEN' { Call AgEZKINE(iprin)      }
        else If IADR!=0     { Call CSJCAL(Iadr,1,Iprin) }
        else { <w> IDH; (' READRZ error: unknown event bank :',a) }
     }
     If (LKARAW>0 & LKARP1==0)   Call AgBEAMdat
  }
  End
 
 
+DECK,agntopen,T=geant. ------------------------------------------------------
*CMZ :  1.30/00 23/05/96  22.35.51  by  Pavel Nevski
*CMZU:  1.00/01 14/01/96  18.11.41  by  Pavel Nevski
*-- Author :    Pavel Nevski   14/01/96
***************************************************************************
                   Subroutine  A G N T O P E N (File,IDH)
* Description:  Open a CW n-tuple (done AgGENZ) with generated events     *
*               Status is saved in 'opened'                               *
***************************************************************************
+CDE,Typing,GCUNIT,GCFLAG,GCKINE,AgCKINE.
     Character*(*) File
     Integer       LENOCC,Li/20/,Iprin,Ier,IDH
     Logical       opened/.false./
*
     Iprin=Idebug
     If (Opened) then
        Call  HREND('HCWN')
        Close (Li)
     endif
*
     call HRopen (Li,'HCWN',file,' ',1024,Ier)
     If (ier!=0)
     {  <w> Ier,file(1:Lenocc(file)); (' AgNTOPEN: error ',i6,' openning ',a)
        opened = .false.
     }
     else
     {  Opened = .true.;   IdInp   = IDH;   Kevent(1) = 0
        IKine  = -2;       IkineOld = -2
     }
     end
 
 
+DECK,agntread,T=geant. --------------------------------------------------------
*CMZ :          31/10/97  13.01.26  by  Pavel Nevski
*CMZ :  1.30/00 04/07/96  14.07.00  by  Pavel Nevski
*CMZU:  1.00/01 14/01/96  22.35.50  by  Pavel Nevski
*-- Author :    A. Rozanov  11/03/95
***************************************************************************
                Subroutine  A G N T R E A D (ier)
* Description:  Read Kinematics of primary tracks from Ntuples            *
***************************************************************************
+CDE,Typing,GCUNIT,GCFLAG,GCKINE,GCONST,AgCKINE.
      Integer    ier,Ntrk,Nvrt,IPARTI,ITR,Nv
      Real       vertex(4),P(4),E,Ener,VMOD
*
      Integer           Mxtr,irun,Nparti,Itype
      Real              vxyz,pp4
      Parameter         (MxTr=2000)
      common /AgBlock1/ irun,vxyz(4)
      common /AgBlock2/ Nparti,itype(MxTr,5),PP4(MxTr,8)
*     - - - - - - - - - - - - - - - - - - - - - - - - -
*
       kevent(1) = max(nint(ptype),kevent(1)+1)
*      call hldir  ('//','T')
       call hcdir  ('//HCWN',' ')
       call hrin   (IdInp,9999,0)
       call hbname (IdInp,'      ',0,     '$CLEAR')
       call hbname (IdInp,'Block1',irun,  '$SET')
       call hbname (IdInp,'Block2',Nparti,'$SET')
       call HGNT   (IdInp,kevent,ier)
       if ier!=0
       { <w> kevent(1),ier; (' AGNTREAD error: Kevnt,ier=',2i8); return }
*
       CALL aGSVERT(vxyz,0,0,0.,0,Nvrt)
       Ener   = 0
       ntrk   = 0
       do itr=1,Nparti
          check itype(itr,1) == 1 & itype(itr,5) == 0
          p      = { pp4(itr,1), pp4(itr,2), pp4(itr,3), pp4(itr,4) }
          vertex = { pp4(itr,6), pp4(itr,7), pp4(itr,8), pp4(itr,5) }
          E      =  VMOD(P,4)
*
          Call aGSVERT (Vertex,0,0,0.,0,Nv)
          Call aPDG2GEA(itype(itr,2),IPARTI)
          Call aGSKINE (P,IPARTI,Nv,float(itr),0,NTrk)
          check Ntrk>0
          Nvrt  = Max(Nv,Nvrt)
          Ener += E
       enddo
       Print *,' AGNTREAD: # of particles fed to GEANT=',Ntrk,
                         ' # VERTEX=',Nvrt,' Etot=',Ener
    END
 
 
+DECK,AgZwrite,T=geant. =====================================================
*CMZ :          18/08/97  11.17.47  by  Pavel Nevski
*CMZ :  1.30/00 16/04/97  20.01.44  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/06/96
******************************************************************************
*                                                                            *
                subroutine    A G Z W R I T E (Stream,ier)
*                                                                            *
******************************************************************************
+CDE,typing,QUEST,GCBANK,GCUNIT,GCFLAG,SCLINK,AgCKINE.
   Integer      iu,Lun,Iev,Ier,iprin, Idevt0/-1/,IsubE0/0/,Lk/0/
   Logical      Done/.true./
   Character    stream*(*)
*  tentative guess for standard GFOUT data
*  'PART','MATE','TMED','VOLU','ROTM','SETS','DRAW','RUNG','DETM','a',
*  'RUNT','EVNT','DETM','a','a','a','HEAD','VERT','KINE','JXYZ','HITS','DIGI'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
    Ier=999;  Check Stream=='O';  Ier=0;  Iu=3;
    Iprin=Idebug;   Lun=20+iu;  Iev=Kevent(iu);
    prin3 Idevt,Idevt0,Iev,CoptOutp
    (' AGZwrite Idevt,Idevt0,Iev = ',3I10,' opt=',a)
*
    If Kevent(iu)==0
    {  Call AgZout(LUN,'RUNG','G',Iev,CoptOutp,JRUNG, 'IDRUN',  +1, 8, ier)
       Call AgZout(LUN,'PART','G',Iev,CoptOutp,JPART, 'NPART',  -2, 1, ier)
       Call AgZout(LUN,'MATE','G',Iev,CoptOutp,JMATE, 'NMATE',  -2, 2, ier)
       Call AgZout(LUN,'TMED','G',Iev,CoptOutp,JTMED, 'NTMED',  -2, 3, ier)
       Call AgZout(LUN,'ROTM','G',Iev,CoptOutp,JROTM, 'NROTM',  -2, 5, ier)
       Call AgZout(LUN,'VOLU','G',Iev,CoptOutp,JVOLUM,'NVOLUM', -2, 4, ier)
       Call AgZout(LUN,'SETS','G',Iev,CoptOutp,JSET,  'NSET',   -1, 6, ier)
       Call AgZout(LUN,'DETM','G',Iev,CoptOutp,LKDETM,'NDETM',  -1, 9, ier)
       Kevent(iu)=1;  Lk=-1;  Idevt0=-1;  If (Ier!=0) IOutpOld=0;  Return
    }
    If Idevt != Idevt0 | IsubEVnt !=IsubE0
    {  if (JHITS>0) Call GRLEAS (JHITS)
       if (JDIGI>0) Call GRLEAS (JDIGI)
       Call AgZout(LUN,'HEAD','*',Iev,CoptOutp,JHEAD, 'IDEVT',  +2, 17,ier)
       Call AgZout(LUN,'RUNT','E',Iev,CoptOutp,LKRUNT,'JOCRUN', +5, 11,ier)
       Call AgZout(LUN,'EVNT','E',Iev,CoptOutp,LKEVNT,'JOCEVT', +6, 12,ier)
       Call AgZout(LUN,'VERT','K',Iev,CoptOutp,JVERTX,'NVERTX', +1, 18,ier)
       Call AgZout(LUN,'KINE','K',Iev,CoptOutp,JKINE, 'NTRACK', +1, 19,ier)
       Call AgZout(LUN,'HITS','H',Iev,CoptOutp,JHITS, 'NHSETS', -2, 21,ier)
       Call AgZout(LUN,'DIGI','D',Iev,CoptOutp,JDIGI, 'NDSETS', -2, 22,ier)
       Call AgZout(LUN,'RECB','R',Iev,CoptOutp,LKARP1,'NSECT',  -2, 13,ier)
       Kevent(iu)+=1;
    }
    else If LK==0           " second call after users reconstruction "
    {  Call AgZout(LUN,'RECB','R',-1, CoptOutp,LKARP1,'NSECT',  -2, 13,ier) }
*
    If (Ier!=0) IOutpOld=0
    Lk      =   LKARP1
    Idevt0  =   Idevt
    IsubE0  =   IsubEvnt
end
 
 
+DECK,AgSvert,T=geant. ---------------------------------------------------------
*CMZ :          30/07/97  11.24.59  by  Pavel Nevski
*-- Author :    Pavel Nevski 06/06/97
***************************************************************************
                Subroutine  A G S V E R T (Vertex,NtBeam,NtTarg,UBUF,NU,Nv)
* Description:                                                            *
*               add a common vertex displacement in an event              *
*               and save vertices in GEANT VERT bank                      *
* Note:         An additional word in Vertex(4) is Time-of-flight - this  *
*               is different from GSVERT, which pass it in /GCTRAK/ TOFG  *
***************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,GCNUM,GCTRAK,AgCKINE.
*
     Real     Vertex(4),UBUF(*)
     Integer  NtBeam,NtTarg,NU
     Integer  Iv,Nv,IDEVT0/-999/,Iprin/0/
     REAL     RNDM,VDIST,VMOD,a,b,d,z,d1,Vxyz(4),Vcut/0/
*
     Iprin=Idebug
*    if 3 sigma interval overlaps with request and Sigma is not too big:
     If Idevt0!=Idevt
     {  Idevt0=Idevt; D=abs(AvSigm(3));  Z=-1.e+10
        if Zmin<AvCoor(3)+3*D & AvCoor(3)-3*D<Zmax & Zmax-Zmin > D/5
             { until ZMin<=z&z<=ZMax { call rannor(a,b); z=Avcoor(3)+D*b } }
        else { z=Zmin+Rndm(-1.)*(Zmax-Zmin) }
        call rannor(a,b)
        VertexNow = {Avcoor(1)+Avsigm(1)*a,Avcoor(2)+Avsigm(2)*b,z}
        If (VMOD(VertexNow,3)>0 & Iprin>=2) <w> VertexNow;
           (' AgSVERT: vertex shifted at ',3F10.4)
     }
*
      D1=VMOD(Vertex,4)
      CALL VADD (Vertex,VertexNow,Vxyz,3)
      TOFG=Vertex(4);  Vxyz(4)=TOFG
      DO IV=1,Nvertx
         Check NtBeam == Q(LQ(Jvertx-IV)+5)
         Check NtTarg == Q(LQ(Jvertx-IV)+6)
         If NtBeam!=0 { If (D1>0) Call UCOPY(Vxyz,Q(LQ(Jvertx-IV)+1),4) }
         else         { If (VDIST(Q(LQ(Jvertx-IV)+1),Vxyz,4)>0)  Next;  }
         Nv=Iv; Return
      Enddo
*
      Call GsVERT(Vxyz,NtBeam,NtTarg,UBUF,NU,Nv)
      If (Nv>0) Return
      <w> ntbeam; (' AgSVERT can not set vertex ',i8)
END
 
 
 
+DECK,AgZback,T=geant. --------------------------------------------------------
*CMZ :          27/11/97  16.36.28  by  Pavel Nevski
*CMZ :  1.30/00 21/03/97  15.15.10  by  Pavel Nevski
*-- Author :    Pavel Nevski   27/05/96
************************************************************************
                SUBROUTINE A G Z B A C K
*                                                                      *
* Description: AG pileup facility - draft, to be polished later        *
* Modifications:                                                       *
* PN, 27.11.97 : Neagitive Bg multiplicity means no fluctuations       *
************************************************************************
+CDE,TYPING,GCUNIT,GCFLAG,AgCKINE.
     Character Copt*4
     Integer   AgPFLAG,Iprin,Nback,Ibevnt,Nskip,Ier,I
     Real      Tbunch,RNDM
*
     Iprin = AgPFLAG('BACK','RECO')
     :bunch: Do IbCurrent=-IbBefor,IbAfter
    {  Call POISSN(BgMult,NBack,Ier)
       If (BgMULT<0) NBack=nint(abs(BgMULT))
       Tbunch=IbCurrent*BgTime*1.e-9
       Prin1 IbCurrent,Nback
       (' AGZBACK: pile-up in bunch',i5,' consists of ',i5,' event(s)')
       Do IBevnt=1,Nback
       {  Nskip=2*Rndm(-1.)*BgSkip+.5
          Prin3 IbEvnt,Nskip
          (' AGZBACK:    merging event',i5,' after skipping',i5)
          Do I=1,Nskip+1
          { Copt='BS';   If (I>Nskip) Copt='B'
            Call AgZREAD (Copt,ier); Check Ier>0  " event still was read "
            Call AGZOPEN ('B', ' ', ' ', 0, 0)
            Call AgZREAD (Copt,ier); Check Ier>0  " geometry skept Only  "
            Prin0; (' AGZBACK error: CANNOT OPEN FILE WITH EVENTS, QUIT !')
            IbackOld=0;  Return
          }
          call AgMERGE (Iprin,IbCurrent,IbEvnt,Tbunch,Ier)
          If (Ier!=0) Break :bunch:
    }  }
    Call AgTRIM
*
    END
 
 
***************************************************************************
   subroutine AgMERGE (Iprin,IbCurrent,IbEvnt,Tbunch,Ier)
***************************************************************************
+cde,typing,gcunit,gcbank,gcnum,gcflag,quest,sclink.
*
   Integer            Laref,   Jd,jhs,jhd,jv2,jk2
   Common  /agcmerge/ Laref(2),Jd,jhs,jhd,jv2,jk2
   Integer            AgPointr,Iprin,IbCurrent,IbEvnt,Ier,Ib,
                      Dum(20)/20*0/,Jdu,Idu,Nv1,Nv2,Nt1,Nt2,Nh1,Nh2,
                      Iv,Jv,It,Jt,i,j,Isel,Nw,Nw1,Nw2,L,L1,L2
   REAL               Tbunch
*  GEANT general definitions for SET-type banks:
   Integer            JSF,JDF,IDF,ISF,LINK,Iset,Idet
+CDE,STAFUNC.
   "link" JSF(LINK) = LQ(LINK-Iset);  JDF(LINK) = LQ(LQ(LINK-Iset)-Idet)
   "data" ISF(LINK) = IQ(LINK+Iset);  IDF(LINK) = IQ(LQ(LINK-Iset)+Idet)
*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
   Call MZLINT(IXSTOR,'AgCMERGE',Laref,Jd,Jk2)
   Call AgMER(Iprin,JVERTX,+1,Nv1,Nv2);  Nvertx=Nv1+Nv2;
   Call AgMER(Iprin,JKINE, +1,Nt1,Nt2);  Ntrack=Nt1+Nt2;
*
*                        adjust track-vertex cross references
   do iv=Nv1+1,Nvertx
   {  jv=LQ(JVERTX-iv); check jv>0;   "ToF"  Q(jv+4)+=Tbunch;
      do i=5,7+nint(Q(jv+7))          " update track numbers in vertices "
      {  check i!=7;  j=jv+i; if (Q(j)>0) Q(j)+=Nt1; If (Q(j)>Ntrack) Q(j)=0; }
   }
   do it=Nt1+1,Ntrack
   {  jt=LQ(JKINE-it);  check jt>0;
      do i=6,7+nint(Q(jt+7))          " update vertex numbers  in tracks "
      {  check i!=7;  j=jt+i; if (Q(j)>0) Q(j)+=Nv1; if (Q(j)>Nvertx) Q(j)=0; }
   }
*
*  First, count number of hit sets in both streams as the number of links
   Check Jhits>0;   Call AgMER(Iprin,Jhits,-2,Nh1,Nh2)
   prin3 Nh1,Nh2; (' AgMerge: start hit sets merging',2i8)
   If Nh2>0
   {  **>                            correct only track references now
      Iset=0;  J=JHITS; If (LQ(J)>0) J=LQ(J)
      While AgPOINTR (J,Iset,Idet)==0
      {  JDU=LQ(JDF(JSET)-3); Check JDU>0; Idu=Q(JDU+9); Ib=LVBACK(Idu)
         L = abs(ib);  L1=-L;  L2=+L                    " rule 1: t+/-(i-1)
         IF (L>=10)  { L1= - (L/100);  L2= mod(L,10) }  " rule 2: -i1,1,+i2
         If Ib>=0 & L1<=IBcurrent&IBcurrent<=L2
         {  Nw2=IDF(J);  JHS=JDF(J);  Nw=1+IQ(JDF(JSET)+1)+IQ(JDF(JSET)+3)
            Isel=Nw2/Nw; do i=JHS+1,JHS+Nw2,Nw
            { If (IQ(i)>0) IQ(i)+=Nt1; IF (IQ(i)>Ntrack) IQ(i)=0; }
         }
         else { Isel=0;  Call MZDROP (IxSTOR,JDF(J),'L') }
         prin3 ISF(JSET),IDF(JSET),Isel,Ibcurrent
         (' AgMERGE:',2(1x,a4),i8,' Hits selected in bunch',i3)
   }  }
   If Nh1>0 & Nh2>0
   {  Iset=0;
      While AgPOINTR (LQ(JHITS),Iset,Idet)==0
      {  IF JSF(JHITS)<=0 | JDF(JHITS)<=0
         { " hit set/det did not exist previously "
            Call GSAHIT (Iset,Idet,Dum,Dum,Dum,Ier)
            IF Ier<=0
            { <w> ISF(JSET),IDF(JSET)
              (' AgMERGE: Unable to create bank for secondary HITS for ',2a6)
              Ier=1;  Break
            } IQ(LQ(JHITS-Iset)+Idet)=0;  Ier=0
         }
         **>                                     Check geometry consistance
         IF Iset>IQ(JHITS-2) | Idet>(IQ(JSF(JHITS)-2))
         {  <w> IQ(JHITS-2),IQ(JSF(JHITS)-2),ISF(JSET),IDF(JSET)
            (' AgMERGE: HITS bank has too few links ',2I3,' to accept ',2a6)
            Ier=2;  Break
         }
         **>                                     Copy hits to existing bank
         Nw1=IDF(JHITS);   Nw2=IDF(LQ(JHITS))
         prin4 nw2,nw1,ISF(JSET),IDF(JSET)
         ('  ===> Copying',i10,' words to',i10,' in set/det',2(2x,a4))
         JHS=JDF(LQ(JHITS));   JHD=JDF(JHITS)
         Call AgPUSH (Iprin,JHD,0,Nw1+Nw2,Ier);
         IF Ier>0
         {  <w> IbCurrent; (/1x,30(1H*),' AgMERGE ERROR ',30(1H*)/,
            5x,'not enouph memory to merge bunch',i3,', merging abandoned'/)
            Break
         }
         **>
         Call UCOPY (IQ(JHS+1),IQ(JHD+Nw1+1),Nw2)
         IQ(LQ(JHITS-Iset)+Idet)=Nw1+Nw2
         Call MZDROP (IxSTOR,JHS,'L')
      }  Call MZDROP(IxSTOR,LQ(JHITS),'L')
   }
   If (IDebug>0) Call DZVERI(' VERT/KINE/HITS merged',IXDIV,'CLU')
   If (Ier==0)   Ier=Iquest(1)
   Laref(1)=0
END
 
 
*****************************************************************************
     subroutine AgMER (Iprin,Jj,k,N1,N2)
* Description : for positive k, IQ(J+k) should contain object counter
*               for negative, it is number of words or liks.
*****************************************************************************
+cde,typing,gcbank,gcnum.
   Integer Iprin,N1,N2,jj,jv,jv2,i,k,ier
 
   check Jj>0; Jv=Jj;
   do i=1,2  { N1=N2; N2=0; check Jv>0; N2=IQ(Jv+k); Jv=LQ(Jv); }
   If (JV>0) print *,'****  AGMER WARNING: SOMETHING LEFT !!! ***'
   Check k>0;  If N1>0 & N2>0
   {  Call agpush(Iprin,Jj,N1+N2,1,Ier);  check Ier==0;
      DO I=1,N2
      { JV2=LQ(LQ(Jj)-I); Check JV2>0; Call ZSHUNT(IXSTOR,JV2,Jj,-(N1+I),1) }
      Call MZDROP(IXSTOR,LQ(Jj),'L');
   }  IQ(Jj+k)=N1+N2
END
 
 
*****************************************************************************
      Subroutine AgTRIM
*****************************************************************************
+CDE,TYPING,GCBANK.
   Integer AgPOINTR,Link,JDF,IDF,Iset,Idet,JHS,Nextra,Nw
*  GEANT general definitions for SET-type banks:
   "link" JDF(LINK) = LQ(LQ(LINK-Iset)-Idet)
   "data" IDF(LINK) = IQ(LQ(LINK-Iset)+Idet)
*
   Check Jhits>0;  Iset=0
   While AgPOINTR (JHITS,Iset,Idet)==0
   {   Nw=IDF(JHITS); JHS=JDF(JHITS);  Nextra=IQ(JHS-1)-Nw
       If (Nextra>0) Call MzPUSH(IxDIV,JHS,0,-Nextra,'I')
   }
END
 
 
*****************************************************************************
      SUBROUTINE AgPUSH (iprin,LINK,NLINK,NDATA,Ier)
*****************************************************************************
+CDE,GCBANK,GCUNIT,QUEST.
      Integer Iprin,LINK,NLINK,NDATA,Ier,MBANK,
              NLOLD,NDOLD,NNEW,NLEFT,NLNEED,NDNEED
*
      Ier   = 0
      MBANK = IQ(LINK-4)
      NLOLD = IQ(LINK-3)
      NDOLD = IQ(LINK-1)
      check (NDATA>NDOLD | NLINK>NLOLD)
      NNEW  = 20+max(NDOLD,NDATA)+max(NLOLD,NLINK)
      Call MZNEED(IXDIV,NNEW,'G');  NLEFT=IQUEST(11) " after request "
      prin5  MBANK,NLOLD,NDOLD,NLINK,NDATA,NLEFT
      (' AgPUSH: pushing bank ',A4,' from ',2i8,' to ',2i8,' Nleft=',i8)
*
      IF NLEFT<=100
      {  prin0  MBANK,ABS(NLEFT),NNEW
         (' AgPUSH: Not enough memory for pushing bank ',A4/ _
          ' ***',I8,' words short in relocating',I8,' words ***')
         Ier=NNEW;  return
      }
      NLNEED=max(NLINK-NLOLD,0); If (NLNeed>0 & NLeft>1000)  NLNeed+=100;
      NDNEED=max(NDATA-NDOLD,0); If (NDNeed>0 & NLeft>10000) NDNeed+=5000;
      Call MZPUSH(IXDIV,LINK,NLNEED,NDNEED,'I')
      IF IQUEST(1) != 0
      {  prin0  MBANK,ABS(NLEFT),NNEW
         (' AgPUSH: wrong strategy for pushing bank ',A4/ _
          ' ***',I8,' words short in relocating',I8,' words ***')
         Ier=NNEW;  return
      }
      END
 
 
************************************************************************
                  FUNCTION AGPOINTR(LINK,IS,ID)
*                                                                      *
* Description :                                                        *
*        give the address of a next HIT/DIGI bank in GEANT             *
* Arguments   :                                                        *
*        LINK  (in)  - link to the top level bank (i.e HITS,HIT2 etc)  *
*        IS,ID (out) - Geant Iset/Idet of the next non-empty bank      *
************************************************************************
+CDE,TYPING,GCBANK.
      INTEGER  AGPOINTR,LINK,IS,ID,JH,JS,JP,JD,NW
*
      AGPOINTR = 1;    IF (IS>0) GOTO :cont:
      :set: Loop
      { IS=IS+1;  ID=0;  :cont:   IF (IS>IQ(LINK-2) | IS>IQ(JSET-1)) RETURN
        JH=LQ(LINK-IS);  JS=LQ(JSET-IS);  IF (JS<=0 | JH<=0) next :set:
        :det: Loop
        {  ID=ID+1;                       IF (ID > IQ(JH-2)) next :set:
           JP=LQ(JH-ID); JD=LQ(JS-ID);    IF (JD<=0 | JP<=0) next :det:
           NW=IQ(JH+ID);                  IF (NW<=0)         next :det:
           AGPOINTR = 0;  Return;          :done:
      } }
END
 
 
 
 
 
 
 
 
 
+DECK,AGRFILE,T=geant.
*CMZ :          29/01/98  00.21.52  by  Pavel Nevski
*CMZ :  1.30/00 27/03/97  19.08.58  by  Pavel Nevski
*CMZ :  1.00/00 12/01/95  23.13.14  by  Pavel Nevski
*-- Author :    Pavel Nevski   09/01/95
****************************************************************************
*                                                                          *
                 SUBROUTINE   A G R F I L E (Lun,File,Option)
*                                                                          *
*  Description: save DETM structure together with GEANT standard structures*
*               do it now in a simple way instead of the scan structure    *
*       Routine to open a GEANT/RZ data base.                              *
*       LUN logical unit number associated to the file                     *
*       FILE RZ file name                                                  *
*       CHOPT is a character string which may be I or O                    *
****************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,SCLINK,GCSCAL,AGCDOCL,QUEST.
 
      Integer       INDEX,LENOCC,Lun,Lsv,L,Istat
      EQUIVALENCE   (LKSLUG(NSLINK),Lsv)
      Character     File*(*),Option*(*),Ctree*4,Cdoc*4
*     Integer       Keys(2),ICycle,Istat,Idvers/1/
*     Character*20  ChDir
      SAVE          CHTOP,     CHTAGS
      CHARACTER*8   CHTOP,     CHTAGS(2)
      DATA          CHTOP/' '/,CHTAGS/'Object','Version'/
*
      If (LdArea(1)=0) call MZLINT(IxCONS,'AGCDOCL',LDarea,Lpar,LDarea)
 
*   Save GEANT standard structures in a new file
      Lsv=Lscan;                           Lscan=Lkdetm;
 
      if (Idebug>1) print *,' AgRFILE: file=',%L(file)
      if index(Option,'i')+index(Option,'I')>0
      { if (Idebug>1) print *,' AgRFILE: calling RZOPEN '
        CALL RZOPEN(LUN,CHTOP,File,'XW',1024,ISTAT)
        If istat!=0
        { print *,' AgRFILE error ',ISTAT,' opening file ',%L(file)
          return
        }
        CALL RZFILE(LUN,CHTOP,'X')
        if IQUEST(1)!=0
        { print *,' AgRFILE error ',IQUEST(1),' on rzfile ',%L(file)
          return
        }
        if (Idebug>1) print *,' AgRFILE: calling GRIN '
        CALL GRIN  ('INIT', 0,' ')
        Ctree=' ';  If (Lscan>0) call UHTOC(IQ(Lscan-4),4,Ctree,4)
        if Ctree=='DETM'
        {  LkDetm=Lscan; L=LQ(LKDETM-1);
           Cdoc=' ';  If (L>0) call UHTOC(IQ(L-4),4,Cdoc,4)
           if (Cdoc=='DOCU') L1DOC=L
      } }
      else
      { CALL RZOPEN(LUN,CHTOP,File,'NWX',1024,ISTAT)
        CALL RZMAKE(LUN,CHTOP,2,'HI',CHTAGS,5000,'XO')
        CALL GROUT ('INIT', 1,' ')
      }
      CALL RZEND(CHTOP)
      CLOSE(LUN)
 
      Lscan=Lsv; if (ISTAT==0) return;
"   Update existing file in exchange mode, return directory    "
"     Call RzOpen(Lun,ChDir,Cfile,'UXW',1024,Istat)            "
"   Update, show and reset LOCK, exchange mode                 "
"     Call RzFile(Lun,ChDir,'ULDX')                            "
"   Append the DETM structure after GEANT standard objects     "
"     Call UCTOH('DETM',Keys,4,4);   Keys(2)=Idvers;           "
"     If (LkDETM>0) Call RzOut(IxCons,LkDETM,keys,ICycle,' '); "
"     Call RzEnd(Chdir);  Close(Lun);                          "
*
      Prin0 ISTAT; (' AGRFILE error =',i6)
*
      End
 
 
 
 
+DECK,AGFOUT,T=geant.
*CMZ :  1.30/00 26/04/96  17.40.50  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/04/96
****************************************************************************
                subroutine   A g F O U T (Lun,Chopt,Ier)
* Description:  write out DETM parameter bank and optionally DOCUmentation *
****************************************************************************
+CDE,Typing,GCBANK,GCFLAG,GCUNIT,SCLINK,AGCDOCL.
     Integer        Lun,Ier,IOPD,INDEX,Iprin
     Character*(*)  Chopt
*
     Iprin=Idebug
     IOPD=Index(Chopt,'d')+Index(Chopt,'D')
     If LKDETM>0
     {  CALL FZOUT(LUN,IxCONS,LKDETM,0,'L',2,1,24)
        Prin1;(' *** AGFOUT ** Data structure DETM (N=24) written out')
     }
     If LKDoc>0&IOPD>0
     {  CALL FZOUT(LUN,IxCONS,LKDoc, 0,'L',2,1,25)
        Prin1;(' *** AGFOUT ** Data structure DOCU (N=25) written out')
     }
*
  END
 
 
+DECK,AgZout,T=geant. =====================================================
*CMZ :          31/07/97  17.26.28  by  Pavel Nevski
*CMZ :  1.30/00 16/04/97  20.30.01  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/06/96
***************************************************************************
    subroutine  A g Z o u t (LUN,Name,Key,Iev,Chopt,J,Var,K1,K2,Ier)
***************************************************************************
+CDE,typing,QUEST,GCUNIT,GCBANK,GCFLAG,SCLINK.
    Character  chopt*(*),key*1,name*4,Var*(*)
    Integer    LUN,IEV,J,K1,K2, Is,Ier,n1,nw,mw,INDEX,Nob,
               Iprin/3/,IOH(3)/0,0,0/,LH/3/,IHEAD(10)
*
    Iprin=Idebug
    If (IOH(1)==0) Call MZIOCH(IOH,3,'2I 1H -I')
    Check J>0 & Ier==0 & Index(Chopt,key)+Index(Chopt,'*')+Index(Key,'*')>0
    Call UCTOH(name,IHEAD(3),4,4);  IHEAD(1)=K2;  IHEAD(2)=0
    If IQ(J-4)!=IHEAD(3)
    {  prin2 IQ(J-4),IHEAD(3)
       (' AgZOUT warning: bank ',a4,' found instead of ',a4)
    }
    Is=0; N1=IQ(J+K1);  If IEV>=0
    { * count objects for SLUG .... shit, may be more than really exist.
      Nob=0;  if (Var=='IDRUN') { Nob=7; }
      else  { If (Index(Chopt,'E')+Index(Chopt,'*')>0 & LKRUNT>0)  Nob+=1
              If (Index(Chopt,'E')+Index(Chopt,'*')>0 & LKEVNT>0)  Nob+=1
              If (Index(Chopt,'K')+Index(Chopt,'*')>0 & JVERTX>0)  Nob+=1
              If (Index(Chopt,'K')+Index(Chopt,'*')>0 & JKINE >0)  Nob+=1
              If (Index(Chopt,'H')+Index(Chopt,'*')>0 & JHITS >0)  Nob+=1
              If (Index(Chopt,'D')+Index(Chopt,'*')>0 & JDIGI >0)  Nob+=1
              If (Index(Chopt,'R')+Index(Chopt,'*')>0)             Nob+=1
            }
      Is=1; IHEAD(1)=IEV; IHEAD(2)=Nob; IEV=-1;
    }
*   ----------Zebra(1994), p.107-----------
    Call FZOUT(LUN,0,J,Is,'L',IOH,LH,Ihead)
*   ---------------------------------------
    Ier=Iquest(1);  nw=Iquest(11); Mw=Iquest(14)
    PRIN2 Is,Name,var,N1,nw; (' AGZwrite:',i3,2(2x,a6),'=',i6,'  Leng=',i8)
    Check Ier!=0; print *,' AgZOUT error ier=',ier,' after ',Mw,'Mw written'
    If (Ier==+1)  print *,' software EOT set by FZLIMIT reached '
    If (Ier==-1)  print *,' attempt to write after End-Of-Data  '
    If (Ier==-2)  print *,' write error occured on output stream'
*
End
 
 
+DECK,aggzkine,t=geant.
*CMZ :          30/07/97  13.50.48  by  Pavel Nevski
*CMZ :  1.30/00 12/03/97  13.19.34  by  Pavel Nevski
*-- Author :    Pavel Nevski
**************************************************************************
                SUBROUTINE   A g G Z K I N E   (Iprin)
* Description: routine for feeding GENZ information into GEANT.          *
* Note the use of TOFG in common GCTRAK, set before Calls to GSVERT,     *
* to store the correct time of the vertices                              *
* Original version:                              Robert DeWolf  23/07/92 *
* Mod:  Minimum cut on secondary vertices (10 microns)       PN 12/01/96 *
*       No user words with EVNT references are save in KINE  PN 04/07/96 *
**************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCNUM,GCTRAK.
      CHARACTER*4 CGENE
      INTEGER     IE,IP,NEVTS,NPART1,NKEEP,ICODE,ISTAT,IV,IV1,IEVT,IRUN,
                  IWTFL,IPA,ITRA,Iprin,MOTH(2),IDAU,K,NU/2/
      REAL        AMAS,Vrt(4),UB(2),VV(4),VDIST,VCUT,VERT(4),WEIGH,P4(4)
      DATA        VCUT /0.0010/
 
      Call AgNZGETG(1,NEVTS)
      Prin2 NEVTS; (' AgGZKINE: Gate found with ',I8,' events.')
 
      NKEEP = 0
      DO IE = 1,NEVTS
         Call AgNZGETE(1,IE,NPART1,IRUN,IEVT,CGENE,VERT,IWTFL,WEIGH)
         prin2 CGENE,IRUN,IEVT,IE,NPART1,WEIGH
               (' AgGZKINE: Generator ',A4,'  Run',I8,' Gate',I8/10x,
                ' Event',I6,' has',I7,' particles.  Weight =',E10.5)
*
         UB(1) = IE                         "  store event number here
         IV1   = Nvertx
         DO IP = 1,NPART1
            Call AgNZGETP(1,IE,IP,ISTAT,ICODE,P4,AMAS,MOTH,TOFG,IDAU,VV)
            Check ISTAT==1                  "  Skip non stable particles    "
            Check IDAU<=0                   "  and particles with daughters "
            Prin5 IP,ICODE,ISTAT,IDAU; (3x,'partc: IP,ICODE,ISTAT,IDAU=',4I8)
 
            K=ABS(ICODE)
*           stable particle but not e,nu,mu,Mmu    Ntau  or   phot ?
            IF (.not.(11<=K&K<=14 | K==16 | K==22 | K>=100)) then
               prin1 ICODE; (' AgGZKINE: Stable particle with funny code',I10)
            endif
            Call VSCALE (VV,100.,Vrt,3)       " get vertex in cm "
            Vrt(4) = TOFG                     "  for print only  "
            DO 11 IV=IV1+1,Nvertx
 11         IF ( VDIST(Q(LQ(Jvertx-IV)+1),Vrt,3) <= Vcut) GO TO 19
            UB(2) = MOTH(1);  Call aGSVERT (Vrt,0,0,UB,NU,IV)
            Prin3 IV,Vrt; (3x,'vertx',I5,' booked at ',3F10.5,' Time=',E10.3)
 
 19         Call aPDG2GEA (ICODE,IPA)
            IF (IPA<=0) THEN
               prin1 ICODE,IP; (' AgGZKINE: PDG code ',I7,' for particle',I6,
                                ' is not recognized by GEANT. SKIP.')
               next
            ENDIF
 
            UB(2) = IP;     Call aGSKINE (P4, IPA, IV, UB, NU, ITRA)
            Check ITRA>0;   NKEEP = NKEEP + 1
*
*          Set the flag in the GENZ record as negative of the Geant KINE ?
*           Call AgNZXREF(1,IE,IP,ITRA,NORPH)
        enddo
     enddo
     prin1 NKEEP,Nvertx;
           (' AgGZKINE: # of particles fed to GEANT=',I6,' # of VERTEX',I6)
     END
 
 
+DECK,AgNZgetg,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 07/07/96  13.29.54  by  Pavel Nevski
*-- Author :    Pavel Nevski   14/01/96
**************************************************************************
                SUBROUTINE   A g N Z G E T G (ILINK,NEVEN)
* Description: Get number of  Gates in event (Neven)                     *
* Input : ILINK - Link number : 1 = primary, 2 = secondary               *
* Original version:                              Robert DeWolf  23/07/92 *
**************************************************************************
+CDE,TYPING,GCBANK,SCLINK.
      INTEGER ILINK,NEVEN,NZBANK
      entry gnzgetg (ILINK,NEVEN)
      NEVEN = -1
      If (LKEVNT>0) NEVEN = NZBANK(IXDIV,LKEVNT)
      END
 
 
+DECK,AgNZgete,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 07/07/96  13.29.54  by  Pavel Nevski
*-- Author :    Pavel Nevski   14/01/96
***************************************************************************
    SUBROUTINE AgNZGETE(ILK,IDE,NPART,IRUN,IEVT,CGNAM,VERT,IWTFL,WEIGH)
* Description: Get parameters of a single event in gates                  *
* Input : ILK   - Link number  : 1 = primary, 2 = secondary (obsolete)    *
*         IDE   - ID of event in gate ( ZEBRA IDN)                        *
* Output: NPART - Number of particles in event record                     *
*         IRUN  - run number as recorded by generator                     *
*         IEVT  - event number as recorded by generator                   *
*         CGNAM - generator name                                          *
*         VERT(4)- x,y,z,t of event (metres,seconds)                      *
*         IWTFL - weight flag                                             *
*         WEIGH - event weight                                            *
* Original version:                              Robert DeWolf  23/07/92  *
***************************************************************************
+CDE,TYPING,GCBANK,SCLINK.
      CHARACTER*(*)  CGNAM
      REAL           VERT(4),WEIGH
      INTEGER        ILK,IDE,NPART,IRUN,IEVT,IWTFL,LGENE,LGENP,LZFIND
 
      entry gNZGETE(ILK,IDE,NPART,IRUN,IEVT,CGNAM,VERT,IWTFL,WEIGH)
      NPART = -1;                                   check   LKEVNT>0
      check  "#of links"   IQ(LKEVNT-2)>=2 & "2nd link"  LQ(LKEVNT-2)>0
      LGENE = LZFIND(IXDIV,LQ(LKevnt-2),IDE,-5);    check   LGENE>0
      check  "bank length" IQ(LGENE-1)>=12 & "#of links" IQ(LGENE-2)>=1
*
      IRUN  =    IQ(LGENE+4)
      IEVT  =    IQ(LGENE+5)
      CALL UHTOC(IQ(LGENE+6),4,CGNAM,4)
      CALL UCOPY( Q(LGENE+7),VERT,4)
      IWTFL =    IQ(LGENE+11)
      WEIGH =     Q(LGENE+12)
*
* Find the number of particles
      LGENP = LQ(LGENE-1);                    Check LGENP>0
      NPART = MOD(IQ(LGENP+2),100000)
*
      END
 
 
+DECK,AgNZgetp,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 07/07/96  13.29.54  by  Pavel Nevski
*-- Author :    Pavel Nevski   14/01/96
****************************************************************************
    SUBROUTINE AgNZGETP(IL,IDE,IP,ISTAT,IDPDG,P,AMASS,MOTH,TIME,IDAU1,V)
* Description: Get parameters of a single particle from EVNT bank          *
* Input : IL    - Link number : 1 = primary, 2 = secondary (obsolete)      *
*         IDE   - ID of event in gate                                      *
*         IP    - Number of particle in event record                       *
* Output: ISTAT - HEPEVT status flag. Returns 0 if record not found.       *
*         IDPDG - PDG code for particle                                    *
*         P     - 4-momentum (px,py,pz,E)                                  *
*         AMASS - particle (quark) mass                                    *
*         MOTH  - mothers. If MOTH(2)<0 the range is MOTH(1)-ABS(MOTH(2))  *
*         TIME  - Start time of particle relative to interaction (sec)     *
*         IDAU1 - a daughter pointer                                       *
*         V     - vertex coordinates (in meter)                            *
* Original version:                              Robert DeWolf  23/07/92   *
****************************************************************************
+CDE,TYPING,GCBANK,SCLINK.
      REAL     P(4),AMASS,PTOT,VMOD,TIME,V(3)
      INTEGER  IL,IDE,IP,IDPDG,ISTAT,MOTH(2),IDAU1,
               LGENE,LGENP,LZFIND,MODUL,ND,IOFF
*
      entry gNZGETP(IL,IDE,IP,ISTAT,IDPDG,P,AMASS,MOTH,TIME,IDAU1,V)
      IDPDG = 0
      ISTAT = 0
      Check Lkevnt>0
*
* Find the event with the desired IDN:
      check  "#of links"   IQ(LKEVNT-2)>=2 & "2nd link"  LQ(LKEVNT-2)>0
      LGENE = LZFIND(IXDIV,LQ(LKevnt-2),IDE,-5);    check   LGENE>0
      check  "bank length" IQ(LGENE-1)>=12 & "#of links" IQ(LGENE-2)>=1
      LGENP = LQ(LGENE-1);                          Check   LGENP>0
*
      MODUL   = MOD(IQ(LGENP+3),100 000)
      ND      = IQ(LGENP-1)
      IOFF    = MODUL * (IP-1) + 3
      Check     IOFF+MODUL<=ND
*
      LGENP   = LGENP + IOFF
      ISTAT   = IQ(LGENP + 1)
      IDPDG   = IQ(LGENP + 2)
      MOTH(1) = IQ(LGENP + 3)
      MOTH(2) = IQ(LGENP + 4)
      IDAU1   = IQ(LGENP + 5)
      call UCOPY(Q(LGENP + 6),P,3)
      AMASS   =  Q(LGENP + 9)
      TIME    =  Q(LGENP + 10)
      call UCOPY(Q(LGENP + 11),V,3)
      PTOT    = VMOD( Q(LGENP+6),3)
      IF AMASS>=0. { P(4) = SQRT(PTOT**2  +  AMASS**2)     }
      ELSE         { P(4) = SQRT(MAX(PTOT**2-AMASS**2,0.)) }
*
      END
 
 
 
 
 
+DECK,aggzuflt,T=geant. --------------------------------------------------------
*CMZ :          14/08/97  15.27.58  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  17.34.39  by  Pavel Nevski
*CMZU:  1.00/01 14/01/96  21.33.44  by  Pavel Nevski
*-- Author :    A. Rozanov  11/03/95
***************************************************************************
    Subroutine  A G G Z U F L T (COPTS,Ieven,Ipart,Idpdg,vert,Pmom,Irc)
* Description : select particles according to the SLUG KINE card standard *
*    PtFlag:  <---collider mode--->   <-----fix target----->              *
*             <pdg>   <---geant--->   <-pdg->  <---geant--->              *
*             0   1   2 . . . . . 9   10   11  12 . . . . 20              *
*             E  PT........................................>              *
***************************************************************************
+cde,Typing,GCONST,AgCKINE.
     Character*(*)  COPTS
     Integer        Ieven,Ipart,Idpdg,Irc
     Real           vert(4),Pmom(4),VMOD,Psel,theta,eta,phi,ptot,pt
*
  Irc   = 0             ! track would be rejected
  If (PtFlag<10) then
     pt    = vmod(pmom,2)
     ptot  = vmod(pmom,3)
     If ptflag==0  { Psel=ptot }  else  { Psel=pt }
     Irc+=1; Check  Ptmin <= Psel & Psel <= Ptmax
*
*    eta should fit into +/-10
     theta = max(asin(pt/ptot),1.e-4);  if (pmom(3)<0) theta=pi-theta
     eta   = -alog(tan(theta/2.))
     Irc+=1; Check  EtaMin <=Eta & Eta<= EtaMax
*
*    atan2 require (y,x) or (sin,cos):
     phi   = atan2(pmom(2),pmom(1));    if ( phi < 0 ) phi=phi+TwoPi
     Irc+=1; Check  PhiMin <=Phi & Phi<= PhiMax
     Irc+=1; Check  Zmin<=vert(3)&vert(3)<=Zmax
  else
     Irc+=1; Check  Pxmin<=Pmom(1)&Pmom(1)<=Pxmax
     Irc+=1; Check  Pymin<=Pmom(2)&Pmom(2)<=Pymax
     Irc+=1; Check  Pzmin<=Pmom(3)&Pmom(3)<=Pzmax
  endif
*
  Irc = 0               ! track selected
END
 
 
 
+DECK,apdg2gea,T=geant.
*CMZ :  1.30/00 10/07/96  10.34.36  by  Pavel Nevski
*CMZU:  1.00/01 29/01/96  16.49.07  by  Pavel Nevski
*-- Author :    Pavel Nevski
*----------------------------------------------------------------------------
                SUBROUTINE   A P D G 2 G E A  (IDIN,IDOUT)
* For a given PDG particle code in IDIN, returns GEANT particle ID in IDOUT
*----------------------------------------------------------------------------
      INTEGER    NPARTC
      PARAMETER (NPARTC = 52)
      INTEGER IDGEA(0:NPARTC),IDPDG(0:NPARTC),IDMAX,IGMAX
*
* In rough order of multiplicity: gamma,pi+,pi-,pi0,etc
  DATA IDGEA /   0,    1,    8,    9,    7,   10,   11,  12,   16,   17,
                14,   13,   15,   25,    2,    3,   4,    4,    5,    6,
                18,   19,   20,   21,   22,   23,  24,
                26,   27,   28,   29,   30,   31,  32,
                33,   34,   35,   36,   37,   38,  39,   40,   41,
                42,   43,   44,    4,    4,    4,   4,   48,   48,   48/
  DATA IDPDG /   0,   22,  211, -211,  111,  130,  321, -321, 310,  221,
              2212, 2112,-2212,-2112,  -11,   11,  -12,  12,  -13,   13,
              3122, 3222, 3212, 3112, 3322, 3312, 3334,
             -3122,-3222,-3212,-3112,-3322,-3312,-3334,
               -15,   15,  411, -411,  421, -421,  431, -431, 4122,
                24,  -24,   23,  -14,   14,  -16,   16,   71,   72,  75/
  DATA IDMAX/4122/,IGMAX/50/
*
      Entry  PDG2GE   (IDIN,IDOUT)
      IDOUT = 0
      IF (abs(IDIN)<=IDMAX) IDOUT = IDGEA(IUCOMP(IDIN,IDPDG(1),NPARTC))
      return
*
      Entry  AGEA2PDG (IDIN,IDOUT)
      IDOUT = 0
      IF (abs(IDIN)<=IDMAX) IDOUT = IDPDG(IUCOMP(IDIN,IDGEA(1),NPARTC))
      return
*
  END
 
 
+DECK,gepcode,t=geant.
*CMZ :  1.30/00 08/07/96  16.11.19  by  Pavel Nevski
*-- Author :    Pavel Nevski   08/07/96
 
      SUBROUTINE GEPCODE (In,Io, Ic)
      if ic==0 { Call APDG2GEA(In,Io) } else { call AGEA2PDG(In,Io) }
      end
 
 
+DECK,gnzpdat,T=geant.
*CMZ :  1.30/00 10/07/96  11.22.34  by  Pavel Nevski
*-- Author :    Pavel Nevski   10/07/96
**************************************************************************
         SUBROUTINE   G N Z P D A T (IDPDG,CPNAM,PMASS,PCHAR,IER)
*                                                                        *
*  Given the particle code IDPDG, this routine returns the information   *
*  about the particle. The data from the EURODE* database has been used  *
*                                                                        *
* Input : IDPDG ( int*4)        - Particle Data Group particle code      *
* Output: CPNAM ( character*8 ) - Name for particle                      *
*         PMASS ( real*4 )      - Particle mass in GeV                   *
*         PCHAR ( real*4 )      - Charge in multiples of proton charge   *
*         IER   ( int*4 )       - error flag                             *
* Original Version.                                 R. DeWolf   12/03/91 *
**************************************************************************
*CDE,TYPING.
     integer     idpdg,ier,k,i,IA,IQ1,IQ2,IQ3
     real        pmass,pchar,m,l
     character   cpnam*8,c
*
     K=IDpdg;    Ia=abs(K);
     i=0;  Q=0;  Ier=0;
     IQ1 = MOD(IA,10000)/1000
     IQ2 = MOD(IA,1000)/100
     IQ3 = MOD(IA,100)/10
*
IF  Ia>0
{   IF IA<=10
 {"quarks"   Q = .6666667-MOD(IA,2)
        if K==     1 { i=  1; c='DOWN    '; m=.15       ; l= .0        }
   else If K==     2 { i=  2; c='UP      '; m=.15       ; l= .0        }
   else If K==     3 { i=  3; c='STRANGE '; m=.35       ; l= .0        }
   else If K==     4 { i=  4; c='CHARM   '; m=1.75      ; l= .0        }
   else If K==     5 { i=  5; c='BOTTOM  '; m=5.1       ; l= .0        }
   else If K==     6 { i=  6; c='TOP     '; m=60.       ; l= .0        }
   else If K==     7 { i=  7; c='LOW     '; m=100.      ; l= .0        }
   else If K==     8 { i=  8; c='HIGH    '; m=160.      ; l= .0        }
   else If K==     9 { i=  9; c='GLUON   '; m=.0        ; l= .0        }
 }
 else IF IA<=20
 {"leptons"  Q =  -MOD(IA,2)
        If K==    11 { i= 11; c='E      -'; m=.510e-03  ; l= .10000e+13}
   else If K==    12 { i= 12; c='ENEU    '; m=.0        ; l= .10000e+13}
   else If K==    13 { i= 13; c='MU     -'; m=.10566    ; l= .21970e-05}
   else If K==    14 { i= 14; c='MUNEU   '; m=.0        ; l= .10000e+13}
   else If K==    15 { i= 15; c='TAU    -'; m=1.7842    ; l= .30400e-12}
   else If K==    16 { i= 16; c='TAUNEU  '; m=.0        ; l= .10000e+13}
   else If K==    17 { i= 17; c='SIGMA  -'; m=40.       ; l= .10000e-19}
   else If K==    18 { i= 18; c='SIGNEU  '; m=.0        ; l= .10000e+13}
 }
 else If Ia<=100
 {  If  (Ia==24 | Ia==37)  Q=1
        If K==    22 { i= 22; c='GAMMA   '; m=.0        ; l= .10000e+13}
   else If K==    23 { i= 23; c='Z0      '; m=93.       ; l= .25360e-24}
   else If K==    24 { i= 24; c='W      +'; m=82.       ; l= .27860e-24}
   else If K==    25 { i= 25; c='HIGGS0  '; m=9.6       ; l= .99730e-20}
   else If K==    37 { i= 37; c='HIGGS  +'; m=23.       ; l= .34310e-20}
 }
 else If Ia<=1000
 {"Mesons"    Q = MOD((IQ2-IQ3),2)
        If K==   111 { i=117; c='PI0     '; m=.13496    ; l= .87000e-16}
   else If K==  -211 { i=118; c='PI     -'; m=.13957    ; l= .26030e-07}
   else If K==   221 { i=119; c='ETA     '; m=.54880    ; l= .62687e-18}
   else If K==  -321 { i=120; c='K      -'; m=.49367    ; l= .12371e-07}
   else If K==  -311 { i=121; c='K0     B'; m=.49772    ; l= .89230e-10}
   else If K==   331 { i=122; c='ETAP    '; m=.95760    ; l= .27400e-20}
   else If K==   113 { i=123; c='RHO0    '; m=.77030    ; l= .43021e-23}
   else If K==  -213 { i=124; c='RHO    -'; m=.76680    ; l= .43021e-23}
   else If K==   223 { i=125; c='OMEGA   '; m=.78260    ; l= .67200e-22}
   else If K==  -323 { i=126; c='K*     -'; m=.89210    ; l= .12900e-22}
   else If K==  -313 { i=127; c='K*0    B'; m=.89210    ; l= .12900e-22}
   else If K==   310 { i=128; c='KSHORT  '; m=.49772    ; l= .89230e-10}
   else If K==   130 { i=129; c='KLONG   '; m=.49772    ; l= .51830e-07}
   else If K==   333 { i=130; c='PHI     '; m=1.0195    ; l= .15600e-21}
   else If K==   115 { i=131; c='A20     '; m=1.32      ; l= .59800e-23}
   else If K==  -215 { i=132; c='A2     -'; m=1.32      ; l= .59800e-23}
   else If K==   421 { i=153; c='D0      '; m=1.8647    ; l= .42700e-12}
   else If K==   411 { i=154; c='D      +'; m=1.8694    ; l= .10450e-11}
   else If K==   431 { i=155; c='DS     +'; m=1.9719    ; l= .43300e-12}
   else If K==   423 { i=156; c='D*0     '; m=2.0072    ; l= .0        }
   else If K==   413 { i=157; c='D*     +'; m=2.0101    ; l= .0        }
   else If K==   433 { i=158; c='DS*    +'; m=2.1150    ; l= .0        }
   else If K==   441 { i=159; c='ETAC1S  '; m=2.9796    ; l= .63900e-22}
   else If K==   443 { i=160; c='J-PSI   '; m=3.0969    ; l= .96797e-20}
   else If K==   445 { i=165; c='CHIC21P '; m=3.5563    ; l= .25320e-21}
   else If K==  -521 { i=188; c='B      -'; m=5.2782    ; l= .14200e-11}
   else If K==  -511 { i=189; c='B0     B'; m=5.2795    ; l= .14200e-11}
   else If K==  -531 { i=190; c='BS0    B'; m=5.4       ; l= .14200e-11}
   else If K==  -541 { i=191; c='BC     -'; m=6.55      ; l= .14200e-11}
   else If K==  -523 { i=192; c='B*     -'; m=5.4250    ; l= .0        }
   else If K==  -513 { i=193; c='B*0    B'; m=5.4180    ; l= .0        }
   else If K==  -533 { i=194; c='BS*0   B'; m=5.54      ; l= .0        }
   else If K==  -543 { i=195; c='BC*    -'; m=6.6       ; l= .0        }
   else If K==   551 { i=196; c='ETAB1S  '; m=9.4       ; l= .10000e-23}
   else If K==   553 { i=197; c='YPSI1S  '; m=9.4603    ; l= .12760e-19}
   else If K==   555 { i=204; c='CHIB21P '; m=9.9132    ; l= .0        }
   else If K==   621 { i=231; c='T0      '; m=60.2      ; l= .0        }
   else If K==   611 { i=232; c='T      +'; m=60.2      ; l= .0        }
   else If K==   631 { i=233; c='TS     +'; m=60.4      ; l= .0        }
   else If K==   641 { i=234; c='TC0     '; m=61.2      ; l= .0        }
   else If K==   623 { i=235; c='T*0     '; m=60.350    ; l= .0        }
   else If K==   613 { i=236; c='T*     +'; m=60.355    ; l= .0        }
   else If K==   633 { i=237; c='TS*    +'; m=60.5      ; l= .0        }
   else If K==   643 { i=238; c='TC*0    '; m=61.350    ; l= .0        }
   else If K==   661 { i=239; c='ETAT1S  '; m=118.08    ; l= .14820e-20}
   else If K==   663 { i=240; c='THET1S  '; m=118.13    ; l= .10760e-20}
   else If K==   665 { i=247; c='CHIT21P '; m=119.13    ; l= .12500e-20}
   else If K==  -721 { i=274; c='L      -'; m=100.27    ; l= .0        }
   else If K==  -711 { i=275; c='L0     B'; m=100.27    ; l= .0        }
   else If K==  -731 { i=276; c='LS0    B'; m=100.40    ; l= .0        }
   else If K==  -741 { i=277; c='LC     -'; m=101.37    ; l= .0        }
   else If K==  -723 { i=278; c='L*     -'; m=100.43    ; l= .0        }
   else If K==  -713 { i=279; c='L*0    B'; m=100.42    ; l= .0        }
   else If K==  -733 { i=280; c='LS*0   B'; m=100.54    ; l= .0        }
   else If K==  -743 { i=281; c='LC*    -'; m=101.63    ; l= .0        }
   else If K==   821 { i=308; c='H0      '; m=160.20    ; l= .0        }
   else If K==   811 { i=309; c='H      +'; m=160.20    ; l= .0        }
   else If K==   831 { i=310; c='HS     +'; m=160.40    ; l= .0        }
   else If K==   841 { i=311; c='HC0     '; m=161.30    ; l= .0        }
   else If K==   823 { i=312; c='H*0     '; m=160.35    ; l= .0        }
   else If K==   813 { i=313; c='H*     +'; m=160.35    ; l= .0        }
   else If K==   833 { i=314; c='HS*    +'; m=160.50    ; l= .0        }
   else If K==   843 { i=315; c='HC*0    '; m=161.50    ; l= .0        }
 }
 else
 { IF IQ3==0 {"Di-quarks" Q=1.333333    -MOD(IQ1,2)-MOD(IQ2,2) }
   else      {" Baryons " Q=2-MOD(IQ1,2)-MOD(IQ2,2)-MOD(IQ3,2) }
        If K==  2212 { i=135; c='P      +'; m=.93828    ; l= .10000e+13}
   else If K==  2112 { i=136; c='N       '; m=.93957    ; l=  898.     }
   else If K==  1001 { i=342; c='QL1     '; m=10.       ; l= .0        }
   else If K==  1002 { i=343; c='QL2     '; m=20.       ; l= .0        }
   else If K==  1003 { i=344; c='QL3     '; m=80.       ; l= .0        }
   else If K==  1004 { i=345; c='QL4     '; m=200.      ; l= .0        }
   else If K==  3222 { i=137; c='SIGMAU +'; m=1.1894    ; l= .80000e-10}
   else If K==  3212 { i=138; c='SIGMA0  '; m=1.1925    ; l= .58000e-19}
   else If K==  3122 { i=139; c='LAMBDA  '; m=1.1156    ; l= .26320e-09}
   else If K==  3112 { i=140; c='SIGMAD -'; m=1.1973    ; l= .14820e-09}
   else If K==  3322 { i=141; c='CASCA0  '; m=1.3149    ; l= .29000e-09}
   else If K==  3312 { i=142; c='CASCA  -'; m=1.3213    ; l= .16420e-09}
   else If K==  2224 { i=143; c='DELTA 2+'; m=1.23      ; l= .59800e-23}
   else If K==  2214 { i=144; c='DELTAU +'; m=1.2310    ; l= .59800e-23}
   else If K==  2114 { i=145; c='DELTA0  '; m=1.2320    ; l= .59800e-23}
   else If K==  1114 { i=146; c='DELTAD -'; m=1.2330    ; l= .59800e-23}
   else If K==  3224 { i=147; c='SIGM*U +'; m=1.3823    ; l= .18300e-22}
   else If K==  3214 { i=148; c='SIGM*0  '; m=1.3820    ; l= .18300e-22}
   else If K==  3114 { i=149; c='SIGM*D -'; m=1.3874    ; l= .16900e-22}
   else If K==  3324 { i=150; c='CASC*0  '; m=1.5318    ; l= .72300e-22}
   else If K==  3314 { i=151; c='CASC*  -'; m=1.5350    ; l= .65200e-22}
   else If K==  3334 { i=152; c='OMEGA* -'; m=1.6722    ; l= .82200e-10}
   else If K==  2203 { i=101; c='UU1     '; m=.30       ; l= .0        }
   else If K==  2101 { i=102; c='DU0     '; m=.30       ; l= .0        }
   else If K==  2103 { i=103; c='DU1     '; m=.30       ; l= .0        }
   else If K==  1103 { i=104; c='DD1     '; m=.30       ; l= .0        }
   else If K==  3201 { i=105; c='SU0     '; m=.50       ; l= .0        }
   else If K==  3203 { i=106; c='SU1     '; m=.50       ; l= .0        }
   else If K==  3101 { i=107; c='SD0     '; m=.50       ; l= .0        }
   else If K==  3103 { i=108; c='SD1     '; m=.50       ; l= .0        }
   else If K==  3303 { i=109; c='SS1     '; m=.70       ; l= .0        }
   else If K==  4201 { i=110; c='CU0     '; m=1.9       ; l= .0        }
   else If K==  4203 { i=111; c='CU1     '; m=1.9       ; l= .0        }
   else If K==  4101 { i=112; c='CD0     '; m=1.9       ; l= .0        }
   else If K==  4103 { i=113; c='CD1     '; m=1.9       ; l= .0        }
   else If K==  4301 { i=114; c='CS0     '; m=2.1       ; l= .0        }
   else If K==  4303 { i=115; c='CS1     '; m=2.1       ; l= .0        }
   else If K==  4403 { i=116; c='CC1     '; m=3.5       ; l= .0        }
   else If K==  4222 { i=166; c='SIGMC 2+'; m=2.44      ; l= .0        }
   else If K==  4212 { i=167; c='SIGMC  +'; m=2.44      ; l= .0        }
   else If K==  4122 { i=168; c='LAMBC  +'; m=2.2812    ; l= .16400e-12}
   else If K==  4112 { i=169; c='SIGMC0  '; m=2.44      ; l= .0        }
   else If K==  4322 { i=170; c='CASCC  +'; m=2.5       ; l= .11000e-12}
   else If K==  4232 { i=171; c='CASCCP +'; m=2.55      ; l= .0        }
   else If K==  4312 { i=172; c='CASCC0  '; m=2.5       ; l= .11000e-12}
   else If K==  4132 { i=173; c='CASCCP0 '; m=2.55      ; l= .0        }
   else If K==  4332 { i=174; c='OMEGC0  '; m=2.6       ; l= .0        }
   else If K==  4422 { i=175; c='CCU   2+'; m=3.63      ; l= .0        }
   else If K==  4412 { i=176; c='CCD    +'; m=3.63      ; l= .0        }
   else If K==  4432 { i=177; c='CCS    +'; m=3.8       ; l= .0        }
   else If K==  4224 { i=178; c='SIGMC*2+'; m=2.53      ; l= .0        }
   else If K==  4214 { i=179; c='SIGMC* +'; m=2.53      ; l= .0        }
   else If K==  4114 { i=180; c='SIGMC*0 '; m=2.53      ; l= .0        }
   else If K==  4324 { i=181; c='CASCC* +'; m=2.65      ; l= .0        }
   else If K==  4314 { i=182; c='CASCC*0 '; m=2.65      ; l= .0        }
   else If K==  4334 { i=183; c='OMEGC*0 '; m=2.75      ; l= .0        }
   else If K==  4424 { i=184; c='CCU*  2+'; m=3.69      ; l= .0        }
   else If K==  4414 { i=185; c='CCD*   +'; m=3.69      ; l= .0        }
   else If K==  4434 { i=186; c='CCS*   +'; m=3.85      ; l= .0        }
   else If K==  4444 { i=187; c='CCC*  2+'; m=4.9       ; l= .0        }
   else If K==  5222 { i=205; c='SIGMBU +'; m=5.67      ; l= .40000e-12}
   else If K==  5212 { i=206; c='SIGMB0  '; m=5.67      ; l= .40000e-12}
   else If K==  5122 { i=207; c='LAMBB0  '; m=5.32      ; l= .40000e-12}
   else If K==  5112 { i=208; c='SIGMBD -'; m=5.67      ; l= .40000e-12}
   else If K==  5322 { i=209; c='CASCB0  '; m=5.77      ; l= .40000e-12}
   else If K==  5232 { i=210; c='CASCBP0 '; m=5.87      ; l= .40000e-12}
   else If K==  5312 { i=211; c='CASCB  -'; m=5.77      ; l= .40000e-12}
   else If K==  5132 { i=212; c='CASCBP -'; m=5.87      ; l= .40000e-12}
   else If K==  5332 { i=213; c='OMEGB  -'; m=5.97      ; l= .40000e-12}
   else If K==  5422 { i=214; c='BCU    +'; m=7.07      ; l= .40000e-12}
   else If K==  5242 { i=215; c='BCUP   +'; m=7.17      ; l= .0        }
   else If K==  5412 { i=216; c='BCD0    '; m=7.07      ; l= .40000e-12}
   else If K==  5242 { i=217; c='BCDP0   '; m=7.17      ; l= .0        }
   else If K==  5432 { i=218; c='BCS0    '; m=7.27      ; l= .40000e-12}
   else If K==  5342 { i=219; c='BCSP0   '; m=7.37      ; l= .0        }
   else If K==  5442 { i=220; c='BCC    +'; m=8.27      ; l= .40000e-12}
   else If K==  5224 { i=221; c='SIGMB*U+'; m=5.97      ; l= .0        }
   else If K==  5214 { i=222; c='SIGMB*0 '; m=5.97      ; l= .0        }
   else If K==  5114 { i=223; c='SIGMB*D-'; m=5.97      ; l= .0        }
   else If K==  5324 { i=224; c='CASCB*0 '; m=6.17      ; l= .0        }
   else If K==  5314 { i=225; c='CASCB* -'; m=6.17      ; l= .0        }
   else If K==  5334 { i=226; c='OMEGB* -'; m=6.37      ; l= .0        }
   else If K==  5424 { i=227; c='BCU*   +'; m=7.37      ; l= .0        }
   else If K==  5414 { i=228; c='BCD*0   '; m=7.37      ; l= .0        }
   else If K==  5434 { i=229; c='BCS*0   '; m=7.57      ; l= .0        }
   else If K==  5444 { i=230; c='BCC*   +'; m=8.57      ; l= .0        }
   else If K==  6222 { i=248; c='SIGMT 2+'; m=60.570    ; l= .0        }
   else If K==  6212 { i=249; c='SIGMT  +'; m=60.570    ; l= .0        }
   else If K==  6122 { i=250; c='LAMBT  +'; m=60.570    ; l= .0        }
   else If K==  6112 { i=251; c='SIGMT0  '; m=60.570    ; l= .0        }
   else If K==  6322 { i=252; c='CASCT  +'; m=60.770    ; l= .0        }
   else If K==  6232 { i=253; c='CASCTP +'; m=60.770    ; l= .0        }
   else If K==  6312 { i=254; c='CASCT0  '; m=60.770    ; l= .0        }
   else If K==  6132 { i=255; c='CASCTP0 '; m=60.770    ; l= .0        }
   else If K==  6332 { i=256; c='OMEGT0  '; m=60.970    ; l= .0        }
   else If K==  6422 { i=257; c='TCU   2+'; m=61.5      ; l= .0        }
   else If K==  6242 { i=258; c='TCUP  2+'; m=61.7      ; l= .0        }
   else If K==  6412 { i=259; c='TCD    +'; m=61.5      ; l= .0        }
   else If K==  6142 { i=260; c='TCDP   +'; m=61.7      ; l= .0        }
   else If K==  6432 { i=261; c='TCS    +'; m=61.8      ; l= .0        }
   else If K==  6342 { i=262; c='TCSP   +'; m=62.       ; l= .0        }
   else If K==  6442 { i=263; c='TCC   2+'; m=62.5      ; l= .0        }
   else If K==  6224 { i=264; c='SIGMT*2+'; m=60.770    ; l= .0        }
   else If K==  6214 { i=265; c='SIGMT* +'; m=60.770    ; l= .0        }
   else If K==  6114 { i=266; c='SIGMT*0 '; m=60.770    ; l= .0        }
   else If K==  6324 { i=267; c='CASCT* +'; m=60.970    ; l= .0        }
   else If K==  6314 { i=268; c='CASCT*0 '; m=60.970    ; l= .0        }
   else If K==  6334 { i=269; c='OMEGT*0 '; m=61.170    ; l= .0        }
   else If K==  6424 { i=270; c='TCU*  2+'; m=61.970    ; l= .0        }
   else If K==  6414 { i=271; c='TCD*   +'; m=61.970    ; l= .0        }
   else If K==  6434 { i=272; c='TCS*   +'; m=62.170    ; l= .0        }
   else If K==  6444 { i=273; c='TCC*  2+'; m=63.170    ; l= .0        }
   else If K==  7222 { i=282; c='SIGMLU +'; m=100.47    ; l= .0        }
   else If K==  7212 { i=283; c='SIGML0  '; m=100.47    ; l= .0        }
   else If K==  7122 { i=284; c='LAMBL0  '; m=100.47    ; l= .0        }
   else If K==  7112 { i=285; c='SIGMLD -'; m=100.47    ; l= .0        }
   else If K==  7322 { i=286; c='CASCL0  '; m=100.67    ; l= .0        }
   else If K==  7232 { i=287; c='CASCLP0 '; m=100.67    ; l= .0        }
   else If K==  7312 { i=288; c='CASCL  -'; m=100.67    ; l= .0        }
   else If K==  7132 { i=289; c='CASCLP -'; m=100.67    ; l= .0        }
   else If K==  7332 { i=290; c='OMEGL  -'; m=100.87    ; l= .0        }
   else If K==  7422 { i=291; c='LCU    +'; m=100.50    ; l= .0        }
   else If K==  7242 { i=292; c='LCUP   +'; m=100.70    ; l= .0        }
   else If K==  7412 { i=293; c='LCD0    '; m=101.50    ; l= .0        }
   else If K==  7142 { i=294; c='LCDP0   '; m=101.70    ; l= .0        }
   else If K==  7432 { i=295; c='LCS0    '; m=101.80    ; l= .0        }
   else If K==  7342 { i=296; c='LCSP0   '; m=102.      ; l= .0        }
   else If K==  7442 { i=297; c='LCC    +'; m=102.50    ; l= .0        }
   else If K==  7224 { i=298; c='SIGML*U+'; m=100.77    ; l= .0        }
   else If K==  7214 { i=299; c='SIGML*0 '; m=100.77    ; l= .0        }
   else If K==  7114 { i=300; c='SIGML*D-'; m=100.77    ; l= .0        }
   else If K==  7324 { i=301; c='CASCL*0 '; m=100.97    ; l= .0        }
   else If K==  7314 { i=302; c='CASCL* -'; m=100.97    ; l= .0        }
   else If K==  7334 { i=303; c='OMEGL* -'; m=101.17    ; l= .0        }
   else If K==  7424 { i=304; c='LCU*   +'; m=101.97    ; l= .0        }
   else If K==  7414 { i=305; c='LCD*0   '; m=101.97    ; l= .0        }
   else If K==  7434 { i=306; c='LCS*0   '; m=102.17    ; l= .0        }
   else If K==  7444 { i=307; c='LCC*   +'; m=103.17    ; l= .0        }
   else If K==  8222 { i=316; c='SIGMH 2+'; m=160.57    ; l= .0        }
   else If K==  8212 { i=317; c='SIGMH  +'; m=160.57    ; l= .0        }
   else If K==  8122 { i=318; c='LAMBH  +'; m=160.37    ; l= .0        }
   else If K==  8112 { i=319; c='SIGMH0  '; m=160.57    ; l= .0        }
   else If K==  8322 { i=320; c='CASCH  +'; m=160.77    ; l= .0        }
   else If K==  8232 { i=321; c='CASCHP +'; m=160.97    ; l= .0        }
   else If K==  8312 { i=322; c='CASCH0  '; m=160.77    ; l= .0        }
   else If K==  8132 { i=323; c='CASCHP0 '; m=160.97    ; l= .0        }
   else If K==  8332 { i=324; c='OMEGH0  '; m=161.17    ; l= .0        }
   else If K==  8422 { i=325; c='HCU   2+'; m=161.50    ; l= .0        }
   else If K==  8242 { i=326; c='HCUP  2+'; m=161.70    ; l= .0        }
   else If K==  8412 { i=327; c='HCD    +'; m=161.50    ; l= .0        }
   else If K==  8142 { i=328; c='HCDP   +'; m=161.70    ; l= .0        }
   else If K==  8432 { i=329; c='HCS    +'; m=161.80    ; l= .0        }
   else If K==  8342 { i=330; c='HCSP   +'; m=162.      ; l= .0        }
   else If K==  8442 { i=331; c='HCC   2+'; m=162.50    ; l= .0        }
   else If K==  8224 { i=332; c='SIGMH*2+'; m=160.77    ; l= .0        }
   else If K==  8214 { i=333; c='SIGMH* +'; m=160.77    ; l= .0        }
   else If K==  8114 { i=334; c='SIGMH*0 '; m=160.77    ; l= .0        }
   else If K==  8324 { i=335; c='CASCH* +'; m=160.97    ; l= .0        }
   else If K==  8314 { i=336; c='CASCH*0 '; m=160.97    ; l= .0        }
   else If K==  8334 { i=337; c='OMEGH*0 '; m=161.17    ; l= .0        }
   else If K==  8424 { i=338; c='HCU*  2+'; m=161.97    ; l= .0        }
   else If K==  8414 { i=339; c='HCD*   +'; m=161.97    ; l= .0        }
   else If K==  8434 { i=340; c='HCS*   +'; m=162.17    ; l= .0        }
   else If K==  8444 { i=341; c='HCC*  2+'; m=163.17    ; l= .0        }
   else If K== 10441 { i=163; c='CHIC01P '; m=3.4151    ; l= .48760e-22}
   else If K== 10443 { i=164; c='CHIC11P '; m=3.5106    ; l= .50630e-21}
   else If K== 10551 { i=202; c='CHIB01P '; m=9.8598    ; l= .0        }
   else If K== 10553 { i=203; c='CHIB11P '; m=9.8919    ; l= .0        }
   else If K== 10661 { i=245; c='CHIT01P '; m=119.13    ; l= .12500e-20}
   else If K== 10663 { i=246; c='CHIT11P '; m=119.13    ; l= .12500e-20}
   else If K== 20443 { i=161; c='PSI2S   '; m=3.6860    ; l= .27090e-20}
   else If K== 30443 { i=162; c='PSI3S   '; m=3.7699    ; l= .26020e-22}
   else If K== 20113 { i=133; c='A10     '; m=1.2620    ; l= .16920e-23}
   else If K==-20213 { i=134; c='A1     -'; m=1.2620    ; l= .16920e-23}
   else If K== 20663 { i=241; c='THET2S  '; m=119.23    ; l= .13540e-20}
   else If K== 30663 { i=242; c='THET3S  '; m=119.62    ; l= .0        }
   else If K== 40663 { i=243; c='THET4S  '; m=119.85    ; l= .0        }
   else If K== 50663 { i=244; c='THET5S  '; m=120.02    ; l= .0        }
   else If K== 20553 { i=198; c='YPSI2S  '; m=10.023    ; l= .14960e-19}
   else If K== 30553 { i=199; c='YPSI3S  '; m=10.355    ; l= .25320e-19}
   else If K== 40553 { i=200; c='YPSI4S  '; m=10.580    ; l= .27660e-22}
   else If K== 50553 { i=201; c='YPSI5S  '; m=10.865    ; l= .59840e-23}
}}
*  Apply charge conjugation:
   CPNAM=c; PMASS=m; PCHAR=Q*sign(1,IDpdg); if (i==0) ier=1
*
 END
 
 
 
 
 
 
 
 
 
 
 
 
 
+DECK,agbeamdat,T=geant.
*CMZ :  1.30/00 15/04/97  21.39.26  by  Pavel Nevski
*-- Author :    Pavel Nevski   21/07/96
************************************************************************
       Subroutine    A g B E A M D A T
************************************************************************
+CDE,TYPING,GCBANK,SCLINK,GCUNIT,GCFLAG,QUEST.
Integer Iarray(10000), Lbuff/10000/, Lsize, num(5)
Integer itit(100,5),ICntr,ICnts,Ndet,id,ITR,Idet,ld,Jdet,JCntr,JCnts,Ldet
Integer Nsub,is,JTR,Jsub,Lsub,Lab,ls,KCntr,KCnts,Nsss,KTR,Ksss,j,iz,
        larea,lf,LLast,N,Lt,Iprin/0/,ISLFLAG,L
common /beamLINK/ Larea(2),Lf,Ld,Ls,LLast
Character*4  cform/'-I'/
 
Call  MZLINT(IxSTOR,'beamLINK',Larea,Lf,LLast)
Lf=LkARAW; N=1; Iprin=max(Idebug+1,Islflag('INPU','RECO'));
Check LkARAW>0
Lsize=0
" get general event header, pointers to control and data (detector list)"
 ICntr=IQ(lf+9);   ICnts=IQ(lf+10);
 Lt=11; If (Icntr>0) Lt=min(11+IQ(lf+ICntr+1),100)
 Call UCOPY(IQ(lf+1),Itit(1,1),Lt);
 num(1)=1; num(2)=N; call RBSTORE('/RECB/RAWH',num,Cform,Lt,Itit(1,1))
"      top data block: number of detectors and their id+pointers        "
Check Icnts>0
Ndet = IQ(lf+ICnts+1)
 
Do id=1,2*NDet,2
{ ITR =IQ(lf+ICnts+1+id);  " pointer to the detector block "
  Idet=IQ(lf+ICnts+2+id);  " it's identificator  "
  Prin5 IDet,ITR;  (' AgBEAMdat: Found detector Idet=',i5,' at pointer ',i5)
 
  "  get into the detector header "  ld=lf+ITR; Jdet=max(1,Idet/1000)
  JCntr=IQ(ld+9);  JCnts=IQ(ld+10);  Ldet=IQ(ld+2)
  Lt=11; If (Jcntr>0) Lt=min(11+IQ(ld+JCntr+1),100)
  Call UCOPY(IQ(ld+1),Itit(1,2),Lt)
  num(3)=Jdet; call RBSTORE('/RECB/RAWH/DETE',num,Cform,Lt,Itit(1,2))
 
  check Jcnts>0;
  Nsub=IQ(ld+Jcnts+1);  Do is=1,2*Nsub,2
  { JTR =IQ(ld+JCnts+1+is);  " pointer to the subdetector block "
    Jsub=IQ(ld+JCnts+2+is);  " it's identificator  "
    Lsub=IQ(ld+JTR+1);        " subdet info length  "
    Lab =IQ(ld+JTR+2);        " suddet label   "
    If Jsub<1000
    { Prin1 Jsub,JTR,Lsub,Lab
      (' AgBEAMdat: bad detector Isub=',i6,' at pointer',i6,
       ' Len=',i6,' label',i6);  next;
    }
    if Lsub<Ldet
    { Prin5 Jsub,JTR,Lsub,Lab
      (' AgBEAMdat: Found subdetec Isub=',i6,' at pointer',i6,
       ' Len=',i6,' label',i6)
        Lsize=Lsub-2;  If Lsize>Lbuff
        { prin0 lab,Lsize,Lbuff
         (' Insufficient length of user array for subdet block',i8,/,
          ' Length=',i8,' available size=',i8,' the rest will be lost')
        }
        L=min(Lsize,Lbuff);  Call Ucopy(IQ(ld+JTR+3),Iarray,L);  num(4)=Jsub;
        Prin8 Lsub, Lab, (IQ(ld+JTR+2+j),j=1,L)
              (' AgBEAMdat: Raw data: size, ID=',2i6/(10z9))
        call RBSTORE('/RECB/RAWH/DETE/SUBD',num,Cform,L,Iarray)
    }
    else   " detector with  subsubdivisions - not tested "
    { Prin5 Jsub,JTR
      (' AgBEAMdat: Found subsystem Jsub=',i5,' at pointer',i5)
      " get into the subdet header "  ls=ld+JTR
      Call UCOPY(IQ(ls+1),Itit(1,3),8); KCntr=IQ(ls+9); KCnts=IQ(ls+10)
      num(4)=Jsub;
      call RBSTORE('/RECB/RAWH/DETE/SUBA',num,Cform,8,Itit(1,3))
 
      Nsss=IQ(ls+KCnts+1)
      Do iz=1,2*Nsss,2
      { KTR =IQ(ls+KCnts+1+iz);  " pointer to the subsubdet block "
        Ksss=IQ(ls+KCnts+2+iz);  " it's identificator  "
        Lsub=IQ(ls+KTR+1);       " subdet info length  "
        Lab =IQ(ls+KTR+2);       " suddet label        "
        If Ksss<1000 | Ksss!=Lab
        { Prin1 Ksss,KTR,Lsub,Lab
          (' AgBEAMdat: bad subdetec Isub=',i5,' at pointer',i5,
           ' Len=',i5,' label',i5);  next;
        }
        Lsize=Lsub-2; Prin5 Ksss,KTR,Lsize,Lab
        (18x,'subsubdet Isub=',i5,' at pointer',i5,'  Len=',i5,' label',i5)
        If Lsize>Lbuff
        { <w> Ksss,Lbuff,Lsize
          (' Insufficient length of user array for subsubdetector block',i6/,
          ' User array length',i6,' block length',i6,' the rest will be lost')
        }
        L=min(Lsize,Lbuff); Call Ucopy(IQ(ls+KTR+3),Iarray,L); num(5)=Lab;
        Prin8 Lsub, Lab, (IQ(ls+KTR+2+j),j=1,L)
        (' AgBEAMdat: Raw data: size, ID=',2i6/(10z9))
        call RBSTORE('/RECB/RAWH/DETE/SUBA/SUBD',num,Cform,L,Iarray)
} } } }
larea(1)=0; Iquest(1)=0
End
 
+DECK,agreinit,T=geant.
*CMZ :  1.30/00 27/07/96  15.41.07  by  Pavel Nevski
*-- Author :    Pavel Nevski   27/07/96
************************************************************************
                SUBROUTINE   A G R E I N I T
*                                                                      *
* description: after a new JVOLUME and DETM structures are read        *
* get rid of traces of old job: drop DETP banks, clear read-done flag  *
* reset jump pointers because thay are not valid anymore               *
************************************************************************
+CDE,Typing,GCBANK,SCLINK,GCFLAG.
  Integer IdetP,Idet,Ldet,Ib,Lb
 
  Call UCTOH('DETP',IdetP,4,4)
*
  If LkDETM>0
  {  Call MZFLAG(IxSTOR,LkDETM,1,'Z')
     Do Idet=1,IQ(LkDETM-2)
     {  * clean up SIMU and RESA - no jumps are defined
        Ldet=LQ(LkDETM-Idet);  Check Ldet>0;  Check IQ(Ldet-1)>=13
        "IRESA" IQ(Ldet+13)=0;        "ISIMU" IQ(Ldet+7) =0
 
        * drop DETP banks
        Do Ib=1,IQ(Ldet-2)
        {  Lb=LQ(Ldet-Ib);     Check Lb>0;    Check IQ(Lb-4)==IdetP
           CALL MZDROP(IxStor,Lb,' ');  Break;
  }  }  }
  call GGCLOS
  End
+DECK,AgZkine,T=geant. ---------------------------------------------------------
*CMZ :          14/08/97  15.35.55  by  Pavel Nevski
*CMZ :  1.30/00 02/05/97  17.21.14  by  Pavel Nevski
*-- Author :    A. Rozanov  11/03/95
******************************************************************************
*                                                                            *
                   Subroutine  A G Z K I N E
*                                                                            *
* Description: Read or Generate Kinematics for primary tracks (new version)  *
* This routine understands the KINE card in the following format (a la SLUG) *
* KINE IKINE part pmin pmax etamin etamax phimin phimax gmode zmin zmax      *
*   - if IKINE=0 and gmode=0                                                 *
*                px,py,pz and z are generated randomly according to          *
*                pmin-pmax, etamin-etamax, phimin-phimax, zmin-zmax ranges   *
*   -  . . . .   gmode=1 - same, but pt-range is assumed instead of E-range  *
*   - if IKINE=-1                                                            *
*                FZ file opened on unit 21 is used as input (GNZ format)     *
*                If not opened previously with AgZOpen, ZEBRA.P is opened    *
*   - if IKINE=-2                                                            *
*                a hbook file with a CWN (on unit 20) is used as an input    *
*                If not opened previously with AgNTopen, hcwn.hbook is used  *
******************************************************************************
+CDE,TYPING,QUEST,GCBANK,GCONST,GCFLAG,GCKINE,GCNUM,GCUNIT,AgCKINE.
     Integer  Ier,Iev,CsADDR,J,L
     Real     Undf/9.e9/
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     IF (NtrSubEV>0 & IsubEVNT<NsubEvnt) Go to :splitted:
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
* prepare AgCKINE/VERT parameters here, because they may be common for all KINE
*
     If Pkine(1)<Undf  { PType =    Pkine(1)         }  else  { Ptype = 0    }
     If Pkine(2)<Undf  { PtMin =max(Pkine(2),0.)     }  else  { PtMin = 0    }
     If Pkine(3)<Undf  { PtMax =max(Pkine(3),Ptmin)  }  else  { PtMax = 99999}
     If Pkine(4)<Undf  { EtaMin=max(Pkine(4),-10.)   }  else  { EtaMin=-10   }
     If Pkine(5)<Undf  { EtaMax=min(Pkine(5),+10.)   }  else  { EtaMax=+10   }
     If Pkine(6)<Undf  { PhiMin=max(Pkine(6),-TwoPi) }  else  { PhiMin= 0    }
     If Pkine(7)<Undf  { PhiMax=min(Pkine(7), TwoPi) }  else  { PhiMax= TwoPi}
     If Pkine(8)<Undf  { Ptflag=    Pkine(8)         }  else  { Ptflag= 0    }
     If Pkine(9)<Undf  { ZMin  =max(Pkine(9),-10000.)}  else  { ZMin  =-10000}
     If Pkine(10)<Undf { ZMax  =min(Pkine(10),10000.)}  else  { ZMax  = 10000}
*   Fixed target version
     If Pkine(2)<Undf  { Pxmin =max(Pkine(2),-10000.)}  else  { Pxmin  = -1 }
     If Pkine(3)<Undf  { Pxmax =max(Pkine(3),Pxmin)  }  else  { Pxmax  =  1 }
     If Pkine(4)<Undf  { Pymin =max(Pkine(4),-10000.)}  else  { Pymin  = -1 }
     If Pkine(5)<Undf  { Pymax =max(Pkine(5),Pymin)  }  else  { Pymax  =  1 }
     If Pkine(6)<Undf  { Pzmin =max(Pkine(6),-10000.)}  else  { Pzmin  = -1 }
     If Pkine(7)<Undf  { Pzmax =max(Pkine(7),Pzmin)  }  else  { Pzmax  =  1 }
*
*get event:
* initialise data file - when called directly be user, these routines should
* reset IKineOld to prevent file name redifinition to defaults
*
      If (IKINE!=IKineOld) then
         If (IKine > 0) IKineOld = Ikine
         If (IKine==-1) Call AgZOPEN (' ', ' ', '*', 0,0)
         If (IKine==-2) Call AgNTOPEN('hcwn.hbook' ,  4 )
         If (IKine==-3) Call AgFOPEN ( 0,  ' ',      ier)
         If (IKine<=-4) { J=CsADDR('AGUSOPEN'); IkineOld=Ikine;
                          If (J>0) Call CSjCAL(J,2,' ') }
      endif
*
      Ier   = 0
      If (Idebug>0)     Itest=max(Itest,1)
      If  IKINE >0      { Do iev=1,IKINE { Call AgSPkine } }
      If (IKineOld==-1) call AgZread ('P',ier)
      If (IKINEold==-2) call AgNTread(ier)
      If (IKINEold<=-3) call AgFread (ier)
      If (IKINEold<=-4) {J=CsADDR('AGUSREAD'); If (J>0) Call CSjCAL(J,1,Ier)}
                         J=CsADDR('AGUKINE');  If (J>0) Call CSjCAL(J,1,Ier)
*
      If  ier!=0  { Ikineold=0; Ieotri=1; Iquest(1)=Ier; Return; }
*
      If NtoSKIP>0 & IDEBUG>0
      { <w> Ievent,Idevt; (' AGZKINE event ',2i7,' is skipped ')
        NtoSKip-=1; Ieotri=1; Return;
      }
*
      If (IBackOld==-1)           Call AgZback
      L=max(Alog10(1.+NVERTX),Alog10(1.+NTRACK))
      If (Idebug>L & JVertx>0)    Call GPVERT(0)
      If (Idebug>L & Jkine >0)    Call GPKINE(0)
      NsubEvnt=-1
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:splitted:        Check NtrSubEV>0
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
*     count subevents from one, first is always event generator info only
      If NsubEvnt==-1  { NsubEvnt=(NTRACK-1)/NtrSubEv+2; IsubEvnt=0;
*                        Call GSVERT(VertexNow,0,0,0,0,Nv)
                       }
      IsubEvnt+=1;  Call AgSPLIT(NtrSubEv,ier)
      If (Ier!=0) <w> IsubEvnt,NsubEvnt;
      (' AgSPLIT track counting wrong in sub-event',i4,' out of',i4)
      IF (IsubEvnt > 1)         "not first - for Identity"  Idevt  -= 1
      IF (IsubEvnt!=NsubEvnt)   "not last  - for counting"  Ievent -= 1
*
*     set header bank
      If Jhead>0       { IQ(JHEAD+5)=NsubEvnt; IQ(JHEAD+6)=IsubEvnt; }
      return
END
 
 
+DECK,agezkine,t=geant.
*CMZ :          30/07/97  16.14.22  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  22.56.50  by  Pavel Nevski
*-- Author :    Pavel Nevski
**************************************************************************
                SUBROUTINE   A g E Z K I N E   (Iprin)
* Description: routine for feeding EGZ information into GEANT.           *
* Note the use of TOFG in common GCTRAK, set before Calls to GSVERT,     *
* to store the correct time of the vertices.                             *
* Iprin is defined as Idebug+1 in AGZREAD                                *
**************************************************************************
+CDE,typing,GCBANK,GCFLAG,GCUNIT,GCNUM,SCLINK.
    Character Cname*4,Gname*8,Gnamo*8/' '/
    Real      evtver,zproj,aproj,ztarg,atarg,sqrts,bmin,bmax,bimevt,
              plab(4),UBUF(100),VERT(4)/4*0/
    Integer   Iprin,L,i,nptls,nptarg,nntarg,npproj,nnproj,ntry,
              IdPtl,IoPtl,IC,Ipart,NVTX,Nt,part_size/6/,Nu/0/
*
*     generator run header
      check   LKRUNT>0;    call UHTOC(IQ(LKRUNT-4),4,CNAME,4)
      check  "bank length" IQ(LKRUNT-1)>=10 & "name" CNAME=='CODE'
*
      call UHTOC(IQ(LKRUNT+1),4,Gname,8)
      evtver  = Q(LKRUNT+3)
      zproj   = Q(LKRUNT+4)
      aproj   = Q(LKRUNT+5)
      ztarg   = Q(LKRUNT+6)
      atarg   = Q(LKRUNT+7)
      sqrts   = Q(LKRUNT+8)
      bmin    = Q(LKRUNT+9)
      bmax    = Q(LKRUNT+10)
      If Gname!=Gnamo
      { Prin1 Gname,evtver,zproj,aproj,ztarg,atarg,sqrts,bmin,bmax
        (' AgEZKINE: generator ',a8,' version ',f8.3/10x,
        ' beam z/a',2f5.0,' target a/z',2f5.0,' sqrt(s)=',f6.1,' b=',2f8.3)
      }
          Gnamo=Gname;                       IC=0
      If (Gname='VENUS'  | Gname='HIJET')    IC=1
      If (Gname='HIJING')                    IC=2
      If (Gname='FRITIOF'| Gname='FRTIOF17') IC=3
      If (IC==0) <w> Gname; (' AgEZKINE error: unknown event generator ',a)
 
*     Normal event following
      Check   LKEVNT>0;    Call UHTOC(IQ(LKEVNT-4),4,CNAME,4)
      check  "bank length" IQ(LKEVNT-1)>=7 & "name" CNAME=='EVEN'
 
*     Do leading part of bank
      nptls   = IQ(LKEVNT+1)
      nptarg  = IQ(LKEVNT+2)
      nntarg  = IQ(LKEVNT+3)
      npproj  = IQ(LKEVNT+4)
      nnproj  = IQ(LKEVNT+5)
      ntry    = IQ(LKEVNT+6)
      bimevt  =  q(LKEVNT+7)
      Call aGSVERT(VERT,0,0,Ubuf,Nu,Nvtx)
      prin3 nptls,npproj,nnproj,nptarg,nntarg,ntry,bimevt
      (' AgEZKINE: setting GEANT vertex with Npart=',i6,' (before filter)'/,
        10x,' beam p/n=',2i5,'  targ p/n=',2i5,'  ntry=',i6,'  b=',f8.3)
 
*     Do trailing part of bank:  ID, 4-momentum, daughter/parent information
      do i=1,nptls
         L=LKEVNT+7+(i-1)*part_size
         Ipart    =  0
         Idptl    = IQ(L+1)
         plab(1)  =  Q(L+2)
         plab(2)  =  Q(L+3)
         plab(3)  =  Q(L+4)
         plab(4)  =  Q(L+5)
         ioptl    = IQ(L+6)
         If (Ic==1) Call ISA_to_GEANT    (IdPtl,Ipart)
*        If (Ic==2) Call HIJING_to_GEANT (IdPtl,Ipart)
         If (Ic==2) Call a PDG 2 GEA     (IdPtl,Ipart)
         If (Ic==3) Call LUND_to_GEANT   (IdPtl,Ipart)
         If Ipart<=0
         {  Prin2 IdPtl,Gname;
            (' AgEZKine: particle code ',i6,' from ',A,' is unknown ')
            Next
         }
         CALL aGSKINE (Plab,Ipart,NVTX,Ubuf,Nu,Nt)
      enddo
*
    prin2 Ntrack,Nvertx;
         (' AgEZKINE: # of particles in GEANT=',I6,' # of VERTEX',I6)
*
    END
 
 
+deck,hijing_to_geant,T=geant.
*CMZ :  1.30/00 12/03/97  13.19.34  by  Pavel Nevski
*-- Author :
******************************************************************
      SUBROUTINE HIJING_TO_GEANT(LUID,GEID)
*                                                                *
*  Subroutine to convert HIJING (PDG) id's to GEANT ID's         *
*                                                                *
*  Author:    Richard Morse  LBL (510)-486-6349                  *
*  Modified:  9 May 1995 Matt Bloomer                            *
*      - extended GLTBLE to include Delta resonances.            *
*      - Fixed bug: GEID -> LUID in neutrino IF statement.       *
******************************************************************
      implicit  none
      INTEGER   IUCOMP, LUID, GEID, NUMID
      PARAMETER (NUMID=75)
      INTEGER   GLTBLE(1:NUMID)
*
      DATA GLTBLE/   22,  -11,   11,   12,  -13,
     +               13,  111,  211, -211,  130,
     +              321, -321, 2112, 2212,-2212,
     +              310,  221, 3122, 3222, 3212,
     +             3112, 3322, 3312, 3334,-2112,
     +            -3122,-3112,-3212,-3222,-3322,
     +            -3312,-3334,  -15,   15,  411,
     +             -411,  421, -421,  431, -431,
     +             4122,   24,  -24,   23,    0,
     +                0,    0,    0,  223,  333,
     +              113,  213, -213,  411,  421,
     +             1114, 2114, 2214, 2224,    0,
     +                1,   -1,    2,   -2,    3,
     +               -3,    4,   -4,    5,   -5,
     +                6,   -6,    21, -21,    0/
*
      GEID=IUCOMP(LUID,GLTBLE,NUMID)
*
*     We must map all neutrinos onto a single ID...
      IF (ABS(LUID)==12 | ABS(LUID)==14 | ABS(LUID)==16) GEID=4
*
      End
 
+deck,isa_to_geant,T=geant.
*CMZ :  1.30/00 12/03/97  13.19.34  by  Pavel Nevski
*-- Author :
*********************************************************************
      subroutine isa_to_geant(isa,id)
*                                                                   *
*  translates isa (isajet particle code) to id (geant code)         *
*  Author: Tom Throwe, bnl                                          *
*  Correction: PN, 2/26/97 isa was overwritten                      *
*********************************************************************
      implicit  none
      integer   IUCOMP,isa,id,isacod(44)
      data isacod/10,  -12,   12,   11,  -14,   14,
     +           110,  120, -120,  -20,  130, -130,
     +          1220, 1120,-1120,   20,  220, 2130,
     +          1130, 1230, 2230, 1330, 2330, 3331,
     +         -1220,-2130,-1130,-1230,-2230,-1330,
     +         -2330,-3331,  -16,   16, -240,  240,
     +          -140,  140, -340,  340, 2140,   80, -80, 90/
*
      ID=IUCOMP(ISA,isacod,44)
*
* special cases: different types of neutrino are all neutrino, anti-pi0 is pi0
      If (abs(isa)==11 | abs(isa)==13 | abs(isa)==15)  Id = 4
      If (isa==-110)                                   Id = 7
*
      end
 
 
 
+deck,lund_to_geant,T=geant.
*CMZ :  1.30/00 19/03/97  15.33.37  by  Pavel Nevski
*-- Author :
*     =========================================
      subroutine lund_to_geant(lund_id,geant_id)
*     ==========================================
      implicit none
      integer lund_id, geant_id, numid, i
      parameter (numid=41)
      integer lundid_table(numid),gltble(-100:100), jantid(numid)
      logical first/.true./
*
      data lundid_table /
     +     1, -7,  7,  8, -8, -9,  9, 10,-10, 12,-12, 17,-17,
     +     18,-18, 37, 38, 41,-41, 42,-42, 43,-43, 45,-45, 46,-46,
     +     47,-47, 57,-57, 70,-70, 11,-11, 44,-44, 24,-24, 23,-23/
      data jantid/
     +     1,  2,  3,  4,  4,  5,  6,  4,  4,  4,  4,  8,  9,
     +     11, 12, 16, 10, 14, 15, 13, 25, 19, 29, 21, 27, 22, 30,
     +     23, 31, 18, 26, 24, 32, 34, 33, 20, 28, 17, 17,  7,  7/
 
 
      if (first) then
*     make lund to geant code lookup table
          do i=-100,100
              gltble(i)=0
          end do
          do i=1,numid
              gltble(lundid_table(i))=jantid(i)
          end do
          first = .false.
      end if
 
*     convert the type
      if(ABS(lund_id) .le. 100) then
          geant_id = gltble(lund_id)
      else
          geant_id = 0
      endif
*
      end
 
+DECK,agneed,T=geant.
*CMZ :  1.30/00 21/03/97  12.42.58  by  Pavel Nevski
*-- Author :    Pavel Nevski   16/03/97
      SUBROUTINE   AGNEED (IER)
+CDE,typing,GCBANK,GCUNIT,GCNUM,GCFLAG,QUEST.
      Integer      Ier,LSTACK,NNEW,IPRIN
 
      Ier  = IEOTRI
      If (IER.NE.0) RETURN
      Iprin=IDEBUG
 
      LSTACK=0;  IF (JSTAK>0) LSTACK=IQ(JSTAK-1)
      NNEW = 500+max(NTRACK,NVERTX,LSTACK)
      Call MZNEED(IXDIV,NNEW,'G');  CHECK IQUEST(11)<0
*     Iswit(9)-=1; if (Iswit(9)<0) return
*
      Call MZGARB(2,0);  CALL MZGARB(20,0);  Call MZDRED(20);
      prin2;  (' ***** AGNEED compression done *****')
      Call MZNEED(IXDIV,NNEW,'G');  CHECK IQUEST(11)<0
 
      prin0  ABS(IQUEST(11)),NNEW
      (' ***** AgNEED: Not enough memory for KINE/VERT/STACK *****'/,
       ' ***',  I9, ' words short in relocating',  I9, ' words ***'/,
       ' ************** event simulation abandoned ***************')
      IQUEST(1) = 0
      IEOTRI    = 1
      IER       = 1
      end
 
+DECK,lgkine,T=GEANT.
*CMZ :  1.30/00 24/04/97  20.12.49  by  Pavel Nevski
*-- Author :    Pavel Nevski   22/03/97
***************************************************************************
     FUNCTION LgKINE (JO,I)
* Description: return Link to the t-th track in LgKINE and Link           *
*              to its mother bank (in JKINE linear chain) in J0           *
***************************************************************************
+CDE,typing,GCBANK.
     Integer  LgKINE,I,J,JO,NF
*
     LgKine=0; j=JKINE; JO=j; NF=IQ(j+2)
     while  0<j&j<NZEBRA
     { JO=J; If NF==0
       { If      I >IQ(j+1) "move right" {  J=LQ(J)  }
         else If I<=IQ(j+2) "move left"  { J=LQ(J+2) }
         else    {  LgKINe=LQ(j-I+IQ(j+2));  Return  }
       }
       else
       { If      I<=IQ(j+2) "move right" {  J=LQ(J)  }
         else    {  LgKINe=LQ(j-I+IQ(j+2));  Return  }
     } }
*      Print *,' LgKINE error - track ',I,' not found'
     END
 
+DECK,AgCHAIN,T=geant.
*CMZ :  1.30/00 31/03/97  21.39.29  by  Pavel Nevski
*-- Author :    Pavel Nevski
****************************************************************************
         SUBROUTINE   A G C H A I N (MaxHITS,MaxKINE)
*                                                                          *
* Description: If length of the HITS or KINE structures is more than       *
*        the maximum a new bank is chained at the corresponding link.      *
*        For hits this is transparent for hit storing routines             *
*        For KINE a special versions of GSVERT/GSKINE should be used       *
*        otherwise no action is taken                                      *
****************************************************************************
+CDE,typing,GCBANK,GCUNIT,GCFLAG,GCNUM,GCPUSH.
      Integer  MaxHits,MZVOLM,Nw,Nset,Iprin,MAXKINE
*
      IPRIN=IDEBUG
      IF JKINE>0
      {  IF IQ(JKINE-1)>1 & NTRACK-IQ(JKINE+2)>=MAXKINE
         {  CALL MZBOOK(IXDIV,JKINE,JKINE,1,'KINE',NCKINE,NCKINE,2,2,0)
            IQ(JKINE+2)=NTRACK;
            Prin2 NTRACK,IQ(JKINE-5)
            (' AGCHAIN: after',i8,' tracks new KINE bank chained at ID=',i3)
      }  }
*
      IF JHITS>0 & JSET>0
      {  NW=MZVOLM(IxDIV,JHITS,' ')
         IF NW>MaxHITS
         {  CALL GRLEAS(JHITS); NSET=IQ(JSET-2)
            CALL MZBOOK(IXDIV,JHITS,JHITS,1,'HITS',NSET,NSET,0,2,0)
            Prin2 NW,IQ(JHITS-5)
            (' AGCHAIN: HITS bank size=',i9,'  new bank chained at ID=',i3)
      }  }
      END
 
 
+DECK,agsplit,T=geant.
*CMZ :          11/12/97  00.29.35  by  Pavel Nevski
*CMZ :  1.30/00 03/04/97  13.58.50  by  Pavel Nevski
*-- Author :    Pavel Nevski   31/03/97
***************************************************************************
                subroutine A G S P L I T (N0,Ier)
*                                                                         *
* Description: If KINE bank contains too many tracks, event is splitted   *
*              into a number of smaller events with exactly N0 tracks     *
*              First guess for the algorithm, may be done better          *
***************************************************************************
+CDE,typing,GCBANK,GCNUM,GCUNIT,GCFLAG,SCLINK.
   integer itr1,itr2,itr,jtr,it,iv,jv,Lk,Lv,Nt
   Integer IDN,N0,Ier,IsubEV/-1/,Iprin,NTRA,NVER
 
 Ier=-1; Check  N0>0;
 Iprin=Idebug; NTRACK=0; NVERTX=0;
 IF JVERTX>0 & JKINE>0
 { IDN=IQ(JVERTX-5); If IDN==0
   {  If (LKAGEV>0) Call MZDROP (IxSTOR,LKAGEV,   'L')
      CALL MZGARB (IxDiV,0)
      Call MZCOPY (IxDIV,JVERTX, IxCONS,LKAGEV, 1,' ')
      call MZCOPY (IxDIV,JKINE,  IxCONS,LKAGEV, 0,'L')
      IQ(LKAGEV-5)=-1;  IQ(LQ(LKAGEV)-5)=-1
      call MZDROP(IxSTOR,JVERTX,'L')
      call MZDROP(IxSTOR,JKINE ,'L')
      IsubEv=0; Ier=0;  GOTO :e:
 } }
 
 If LKAGEV>0
 { IsubEv += 1;
   If (JVERTX>0) call MZDROP(IxSTOR,JVERTX,'L')
   If (JKINE >0) call MZDROP(IxSTOR,JKINE ,'L')
   Call MZCOPY (IxCONS,LKAGEV,     IxDIV,JVERTX, 1,' ')
   call MZCOPY (IxCONS,LQ(LKAGEV), IxDIV,JKINE,  1,'L')
   IQ(JVERTX-5)=1;      IQ(JKINE -5)=1
   NVER=IQ(JVERTX+1);   NTRA=IQ(JKINE+1)
*
     itr1=N0*(IsubEV-1)+1;  itr2=min(N0*IsubEV,NTRA)
     if Itr1>Itr2 { Call MZDROP(IxSTOR,LKAGEV,  'L'); ier=1; GOTO :e: }
*
     do iv=1,NVER
     {  Lv=LQ(JVERTX-Iv);  Check Lv>0;  Call VZERO (Q(7+Lv),IQ(Lv-1)-6) }
*
     jtr=0; do itr=1,NTRA
     {  "===>"    if itr1<=itr&itr<=itr2   "<==="
        {  Lk=LQ(JKINE-itr);  check Lk>0;  Jtr+=1
           call ZSHUNT(IxSTOR,Lk,JKINE,-jtr,0)
           Iv=Q(6+Lk);   Lv=LQ(JVERTX-Iv)
           Nt=Q(7+Lv)+1; Q(7+Lv)=Nt;  Q(7+Lv+Nt)=jtr
        }
        else    { Call MZDROP(IxSTOR,LQ(JKINE-itr),' ') }
     }
*
     jv=0; do iv=1,NVER
     {  Lv=LQ(JVERTX-Iv);  Check Lv>0;  Nt=Q(7+Lv)
        If Nt>0  { jv+=1; Do itr=1,Nt { it=Q(7+Lv+itr); Q(6+LQ(JKINE-it))=jv }
                   Call ZSHUNT(Ixstor,Lv,JVERTX,-jv,0)
                 }
        else     { call MZDROP(IxSTOR,LQ(JVERTX-iv),' ') }
     }
     Ntrack=jtr; IQ(JKINE+1)=Jtr; NVERTX=Jv; IQ(JVERTX+1)=Jv; Ier=0
   }
:e:; PRIN1 IsubEv,Idevt,Nvertx,Ntrack
     (3x,'** GSPLIT: subevt=',i7,' idevt=',i7,' Vertex/Track =',i11,i12)
   end
 
 
 
+DECK,agspkine,T=geant. --------------------------------------------------------
*CMZ :          31/10/97  13.01.26  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  17.34.39  by  Pavel Nevski
*-- Author :    A. Rozanov  11/03/95
**********************************************************************
                Subroutine  A G S P K I N E
* Description:  Generates Kinematics for primary track               *
*    PtFlag:  <---collider mode--->   <-----fix target----->         *
*             <pdg>   <---geant--->   <-pdg->  <---geant--->         *
*             0   1   2 . . . . . 9   10   11  12 . . . . 20         *
*             E  PT........................................>         *
*                                                                    *
**********************************************************************
+CDE,TYPING,GCBANK,GCONST,GCFLAG,GCKINE,GCNUM,AgCKINE.
     REAL     Theta,Eta,Phi,Etot,Ptot,PT,P(3),vertex(4),RNDM
     integer  NVRT,NTRK,IParti
*
*  collider or fixed target datacard...         Ilia Iliych:
     if (ptflag<10) then                  "    collider mode     "
        Eta    = EtaMin+RNDM(-1.)*(EtaMax-EtaMin)
        Phi    = PhiMin+RNDM(-1.)*(PhiMax-PhiMin)
        etot   = PtMin +Rndm(-1.)*(PtMax - PtMin)
        Theta  = 2*ATAN(EXP(-Eta))
        If (ptflag==0)  { Ptot = Etot;    PT   = Ptot*SIN(Theta) }
        else            { PT   = Etot;    Ptot = PT / SIN(Theta) }
        P      = { PT*Cos(Phi), PT*Sin(Phi), PTOT*COS(Theta) }
     else                                 "  Fixed target mode   "
        P      = { Pxmin+RNDM(-1.)*(Pxmax-Pxmin),
                   Pymin+RNDM(-1.)*(Pymax-Pymin),
                   Pzmin+RNDM(-1.)*(Pzmax-Pzmin) }
     endif
*
     IParti = nint(ptype)                                            " *star "
     If (mod(nint(ptflag),10)<=1) Call aPDG2GEA (nint(ptype),IParti) " atlas "
*
     If (Iparti==0) "replace by muon"  Iparti=6
     Call VZERO   (vertex,4)
     Call aGSVERT (vertex, 0, 0, 0.,0,NVRT)
     Call aGSKINE (P,IParti,NVRT,0.,0,NTRK)
END
 
 
+DECK,agskine,T=geant. ---------------------------------------------------------
*CMZ :          05/09/97  09.20.35  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/06/97
***************************************************************************
                Subroutine  A G S K I N E (Plab,Iparti,Nv,UB,NB,Nt)
* Description:                                                            *
*              Save tracks in GEANT KINE bank                             *
***************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,GCKINE,AgCKINE.
   Real     Vertex(4),Plab(3),UB(*)
   Integer  Iparti,Nv,NB,Nt,Id/0/,Iprin,Irc,JV
 
      Iprin=Idebug;      Check JVERTX>0;
      Jv=0; IF (1<=NV & NV<=IQ(JVERTX-2)) Jv=LQ(JVERTX-Nv)
      if Jv<=0 { prin1 NV; (' aGSKINE: Vertex',I8,' does not exist'); return }
      Call UCOPY(Q(JV+1), Vertex, 4);     Irc=0;
 
      If (IKINE<=0) Call AgGZUFLT('AGSKINE',Ievent,Iparti,Id,vertex,Plab,Irc)
      If irc != 0
      {  prin4 Iparti,Plab,Irc
         (' AgSKINE: particle',i5,' Plab=',3f10.3,' rejected by filter',i3)
         return
      }
      Call GSKINE (Plab,IPARTI,Nv,UB,NB,Nt)
      if nt <= 0  { Prin1 Iparti; (' AgSKINE: unknown geant id: ',i6) }
   END
 
 
+DECK,agfopen,T=geant.
*CMZ :          28/07/97  20.58.07  by  Pavel Nevski
*-- Author :    Pavel Nevski   18/07/97
*************************************************************************
   subroutine   A g F O P E N (li,file,ier)
*
* Description: open a standard fortran formattted data file.            *
*************************************************************************
   Implicit   None
   Integer    LENOCC,Li,L,ier
   Character  file*(*)
+CDE,AgCKINE,GCKINE,GCFLAG,GCUNIT.
*
    ier=0;  close (Li,err=:o:)
:o: L=LENOCC(file);  Check L>0
*
    open (Li,file=file,form='FORMATTED',status='OLD',err=:e:)
    If (Idebug>=2) <w> file(1:L),Li;
       (' AgFOPEN: file ',a,' opened succesfully on unit',i3)
    IKineOld=IKine
    return
:e: <w> file(1:L); (' AgFOPEN error openning file ',a); ier=1
   end
 
 
 
+DECK,agfread,T=geant.
*CMZ :          19/07/97  12.41.07  by  Pavel Nevski
*-- Author :    Pavel Nevski   18/07/97
*************************************************************************
   Subroutine   A g F R E A D (ier)
*                                                                       *
* Description: loop over all files opened by USER/INPUT                 *
*              and call the corresponding readout routine               *
*************************************************************************
   Implicit   None
   Integer    LENOCC,Igate,Ier,I
   Character  C*1
*
+CDE,AgCKINE,GCNUM,GCFLAG,GCUNIT.
*
   Ier = 0
   Do i=1,LENOCC(Ccommand)
     C=CCOMMAND(i:i); Igate=i
     if  C=='e'  { Call AGZREAD('P',ier) }
     if  C=='t'  { call AgReadTXT(Igate) }
     If Igate<=0 { Ier=1;        return  }
     If (Idebug>0 & (C=='e'|C=='t'))  <w>  C,Ntrack,Nvertx
        (' AgFREAD mode ',a,': # of particles in GEANT=',i6,' vertices=',i6)
   enddo
   End
 
 
+DECK,AgReadTXT,T=geant.
*CMZ :          21/11/97  01.26.41  by  Pavel Nevski
*-- Author :    Pavel Nevski   18/07/97
*************************************************************************
   Subroutine   A g R E A D T X T (Igate)
*                                                                       *
* Description: read both NEW and OLD gstar event generator text formats *
Replace [READ[DIGIT](#)#;] with [READ(#2,ERR=:E:)#3;IF(Idebug>=#1)<W>#3;]
*************************************************************************
   implicit      none
   character*120 line
   integer       li,Ieven,Ntrac,Nvert,itr,ivt,nv,nt,Igate,i,
                 LabelTr,LabelVx,ge_pid,eg_pid,StartVx,StopVx,
                 eg_proc,parent
   Real          version,east_z,east_a,west_z,west_a,sqrts,b_max,
                 PP(3),vert(4),UBUF(10),a,b
*
+CDE,GCUNIT,GCFLAG.
*
   Li=21-Igate
 { Ntrac,Nvert } = 999;
 { itr, ivt    } =  0;
*
 WHILE itr<Ntrac | ivt<Nvert
 { line='end-of-file';  read5 (li,'(a)') Line; (1x,a)
 
   If Line(1:5)=='GENER'
   {
     read1 (line(11:),*) version,east_z,east_a,west_z,west_a,sqrts,b_max
                       (' AgReadNew: GENER :',F8.3,4F8.0,F8.1,F8.3)
   }
   else If Line(1:5)=='EVENT'
   {
     read2 (line(7:),*) Ieven,Ntrac,Nvert,a,b;(' AgReadNew: EVENT :',3i8,2f8.3)
     if (Ieven<=-999) goto :e: " end of data "
   }
   else If Line(1:5)='TRACK'
   {
     read5 (line(7:),*) ge_pid,PP,LabelTr,StartVx,StopVx,eg_pid
                        (16x,'TRACK :',i6,3F9.3,4i6)
     Call VZERO(Vert,4);   Call AgSVERT(vert,-StartVx,-Igate,Ubuf,0,nv)
     Itr += 1;  call AgSKINE(PP,ge_pid,nv,Ubuf,0,nt)
   }
   else If Line(1:6)=='VERTEX'
   {
     read5 (line(8:),*) Vert,LabelVx,eg_proc,parent; (16x,'VERTEX:',4F10.6,3i6)
     ivt += 1;  call AgSVERT(vert,-LabelVx,-Igate,Ubuf,0,nv)
   }
   else If Index(Line,'event')>0 & itr+ivt==0       " old format "
   { i=Index(Line,'event');  Line(i:i+6)='  ';
     read1 (line,*) Ntrac,Ieven;  (' AgReadOld: ',i8,' event# ',i6)
     call VZERO(vert,4);  call AgSVERT(vert,-1,-Igate,Ubuf,0,nv)
     do itr=1,Ntrac
        read5 (li,*) ge_pid,PP; (16x,i6,3F8.3)
        call AgSKINE(PP,ge_pid,nv,Ubuf,0,nt)
     enddo
     break
   }
 } return
*
:e:<w> line; (' AgReadTXT error in line '/1x,a);  Igate=-1
   end
 
 
+PATCH,GENZ. ==================================================================
*CMZ :  1.30/00 25/11/96  22.13.58  by  Pavel Nevski
+deck,zebcom,T=geant. ---------------------------------------------------------
*CMZ :          09/10/97  20.09.11  by  Pavel Nevski
*CMZ :  1.30/00 03/12/96  12.52.49  by  Pavel Nevski
*-- Author :     Pavel Nevski
"**************************************************************************"
"*                                                                        *"
"**************************************************************************"
Replace[+ZEBCOM] with [" Zebra memory access "
   Integer            Len,Nuh,ifce,Links,Linkr,store,Iquest,Ihead,jmp
   Integer            IxCons,IxDiv,IxSTOR,IsDIVL,IsDIVS
   Parameter          (Len=4000 000,Nuh=1000)
   COMMON   /BANKS/   ifce(10),links(20),linkr(20),store(len)
   Common   /STORE/   IXstor,ISDIVL,ISDIVS
   common   /QUEST/   iquest(100)  /QHEAD/  IHead (Nuh)
   Integer            LQ(999),IQ(999);     Real  Q(999);
   Equivalence        (links(9),LQ(9),IQ(1),Q(1)),  (Iquest(1),jmp)
   Equivalence        (IXCONS,ISDIVL),(IXDIV,ISDIVS)
   Integer            Lout/6/, %Iprin/0/, Iprin/0/
]
Replace[TRACE#;] with [ print *,' #1=',#1;]
*********************************************************************************
 
+deck,genz,T=geant. -------------------------------------------------------------
*CMZ :          09/10/97  20.19.57  by  Pavel Nevski
*CMZ :  1.30/00 18/02/97  01.48.04  by  Pavel Nevski
*-- Author :     Pavel Nevski
_p_  G E N Z;                                                         +ZEBCOM;
Integer   KEYS(10),LENOCC,Nfound,Jcont,MinCon,MaxCon,Ier,Irc,Jrc,Lc,Icycle,K,L
Character GEName*255,FName*255,Fzop*4;
Logical   First/.true./;   Integer ierr;
 
 call GETARG(1,GEName); LC = LENOCC(GEName)
 Call MZEBRA (-3);
 JCont=0;  L=Len/4;    MinCon=2000;  MaxCon=.8*Len;
 Call MZSTOR(IXSTOR,'/BANKS/',' ',ifce,links,linkr,store,store(L),store(Len))
* Call FMSTRT(1,2,'//CERN/ATLAS',ier);      Call FMLOGL(-5)
 Call MZDIV(IxSTOR,IxCONS,'Constants',MinCon,MaxCon,'LRC')
 IxDIV=IxSTOR+2;  Call MZXREF(IXCONS,IXDIV,'C');  Call MZXREF(IXDIV,IXCONS,'C')
 Call Htuple;     Call HERMES(0);  Call MZLOGL(0,+1)
"  -> open FZ file :"
Loop
{  FName=' '; Nfound=0;
   If (Gename(1:2)=='//') Call FMLFIL(GEName(:LC),FName,KEYS,NFound,1,JCont,JRC)
   If NFound>0
   {  IQUEST(10)=3;      Call FMFILE(21,FName,'F',Irc);  If (Irc>1) Break;  K=1}
   else
   { " try first the old variable record length format "        Fzop='XIF'; K=2
     ier=100;
     OPEN(21,FILE=GENAME(1:LC),STATUS='OLD',FORM='UNFORMATTED',err=:e:)
     ier=0;
     :e: print *,' trying format 2,ier=',ier
 
     " if it fails, try the new fixe length record format "     Jmp=0;    Jrc=0
     If Ier!=0 { Fzop='XIL'; print *,' calling CFOPEN '
                 CALL CFOPEN(IQUEST,0,0,'r ',0,GENAME,ier);
                 print *,' CFOPEN done';  K=3
               }
     IF Ier!=0 { print *,' all open fails IER=',Ier;  Break; }
     print *,' doshli do fzfile '
     Call FZFILE(21,8100,Fzop);  " 0 means 900 "
     IF Jmp#0 { Print *,' FZFILE IER=',Jmp; Break; }
     Call FZLOGL(21,1);          " 3 is verbose "
   }
   print *,' accessing file type,ier =',K,ier
   Call READRZ(21);                                      JCont=1
   Call FMCLOS(FName,'IOFILE21',0,'DE',Irc); IF (Jrc==0) Break
}
 call hprint(4); call hrout(4,icycle,' '); call hrendc('TEST'); close(4)
 
End
 
+deck,readrz,T=geant. -----------------------------------------------------------
*CMZ :          09/10/97  19.21.01  by  Pavel Nevski
*CMZ :  1.30/00 03/12/96  13.53.40  by  Pavel Nevski
*CMZ :          21/08/95  17.33.23  by  Pavel Nevski
*-- Author :     Pavel Nevski
_s_   R E A D R Z (LUN);                                         +ZEBCOM;
Integer     Lun,Jbias,Nrec,Iev,Nhead,Lsup,ifl,nw,i;
Character*8 DELTIM;  Real t;  Parameter(JBIAS=2);
Character*4 HEAD,MYSET(15);
Data MYSET/'RUNG','MATE','TMED','ROTM','VOLU','SETS','DETM',
    'HEAD','KINE','VERT','HITS','EVNT','RUNT','DIGI','RECB'/;
Iprin=2
Nrec=0; Call FMRTIM(DELTIM); Call TIMED(T);  Iev=-1;
Loop
{  NHEAD=400; Call FZIN(LUN,IXDIV,LSUP,JBIAS,'S',NHEAD,IHEAD); Nrec+=1;
   Ifl=iquest(11);  Nw=Iquest(14);
   If   jmp<0     {  prin0 ifl; (' error, try again',I6);     Next; }
   If   jmp==0    {  if ifl>0   { Iev+=1; prin2 Iev; (' new event ',I6);} }
   else If jmp==1 {  prin1 ifl; (' zebra sor, run ',i6);      Next; }
   else If jmp==2 {  prin1 ifl; (' zebra eor, run ',i6);      Break;}
   else If jmp>=3 {  prin1 jmp,ifl; (' zebra err, run ',2i6); Break;}
   prin2 Nhead,(ihead(i),i=1,3),NW;  (3i8,2x,A4,'  len=',I8);
   If   jmp==0
   { if (ifl>0) Call MZWIPE(Ixdiv);  Call UHTOC(Ihead(3),4,HEAD,4);
     Do i=1,15  {  If (Head==MYSET(i)) goto :done:; }
     prin0 HEAD; (' READRZ: unknown structure ',A,' skipped'); Next;
     :done:
     If i<=8 { Call FZIN(LUN,IXCONS,Links(i),Jbias,'A',Nhead,Ihead); }
     else    { Call FZIN(LUN,IXDIV ,Links(i),Jbias,'A',Nhead,Ihead); }
     IF Jmp#0 { prin0 jmp,head; (' FZIN error',i5,' entering ',A); Next; }
     IF (Head='HITS') Call HITS (i)
     IF (Head='EVNT') Call EVNT (i)
     IF (head='RECB') call dzsurv('atlas reconstruction bank',Ixdiv,Links(i))
   }
   if (Nrec>1000) break;
}  Call FMRTIM(DELTIM); Call TIMED(T); Call MZWIPE(IXCONS);
   prin1 Nrec,Jmp,deltim,t;
   (' READFZ ends after ',I5,' records, IQUEST=',I5,'  time=',A,F8.3);
End
 
+deck,hits,T=geant.
*CMZ :          09/10/97  19.21.01  by  Pavel Nevski
*CMZ :  1.30/00 21/08/95  17.33.23  by  Pavel Nevski
*-- Author :     Pavel Nevski
_s_  H I T S (ii);                                          +ZEBCOM;
Integer ii,NSET,JSF,ISF,JDF,IDF,ISET,IDET,JD,NWH,JHD,NLA,K,L,M,N,is;
Character*4 Cset; DATA "sets" is/6/;
 
JSF(L) = LQ(LINKs(L)-ISET);    JDF(L) = LQ(LQ(LINKs(L)-ISET)-IDET);
ISF(L) = IQ(LINKs(L)+ISET);    IDF(L) = IQ(LQ(LINKs(L)-ISET)+IDET);
 
NSET=IQ(LINKS(is)-2);  prin2 Nset; (3x,'HITS: Nset=',i5);
 
Do Iset=1,Nset
{  Call UHTOC(ISF(is),4,CSET,4);  " IF CSET(1:3)=='ACC' "
   {  Idet=1; JD=JDF(is);  NWH=IQ(JD+1)+IQ(JD+3)+1;  Check JSF(ii)>0;
      JHD=JDF(ii); Check JHD>0;  NLA=IDF(ii); Check NLA>0;  M=1; N=0;
      DO k=1,NLA,NWH  { If (IQ(JHD+k+4)>IQ(JHD+m+4)) m=k; N+=1; }
      prin3 Cset,NLA,N,m; (3x,'set=',A,' Nw,Nh=',2i7,'  w4m=',i8);
}  }
End
 
+deck,evnt,T=geant. -----------------------------------------------------------
*CMZ :          09/10/97  19.21.01  by  Pavel Nevski
*CMZ :  1.30/00 19/02/96  03.40.02  by  Pavel Nevski
*CMZ :          21/08/95  17.33.23  by  Pavel Nevski
*-- Author :    Pavel Nevski
_s_   E V N T (ii);                                                    +ZEBCOM;
Integer ii,JobId,NjRun,Ngate,NgRun,Nevnt,HgNam,IwFlg,Istat,Ipdg,Imo1,Imo2,Idau;
Integer Levnt,Lgene,Lgenp,Modul,ND,Npart,Ioffs,i;
Real    VMOD,Gvert,Weight,Pp,Xm,Tof,Pvert,Esum;
Common  /COMevnt/ JobId,NjRun,Ngate
common  /COMgene/ NgRun,Nevnt,HgNam,Gvert(4),IwFlg,Weight
common  /COMgenp/ Istat(1),Ipdg,Imo1,Imo2,Idau,Pp(3),Xm,Tof,Pvert(3);
 
Integer MxTr;            parameter (MxTr=2000);
Integer idrun,ntrack,Itype;  Real vxyz,pp4;
common/event/idrun,vxyz(3),ntrack,itype(MxTr,5),PP4(MxTr,8);
 
 Levnt=Links(ii);    Call Ucopy(IQ(Levnt+4),JobId,3);
 Lgene=LQ(Levnt-2);  While Lgene>0
 {  Call Ucopy(IQ(Lgene+4),NgRun,9);  Call VSCALE(Gvert,100.,Gvert,3);
    Idrun=Ngrun;  Call Ucopy(Gvert,vxyz,3);
    Lgenp =LQ(Lgene-1);  ND=IQ(Lgenp-1);  Npart=0;  Esum=0;
    Ntrack=Mod(IQ(Lgenp+2),100000);  Modul=Mod(IQ(Lgenp+3),100000);
    Do Ioffs=1,Nd-Modul,Modul
    {  If (Npart>=Ntrack) Break; Npart+=1;
       Call Ucopy(IQ(Lgenp+Ioffs+3),Istat,13); Call VSCALE(Pvert,100.,Pvert,3);
       If (Istat(1)=1 & Idau=0) Esum+=Vmod(Pp,3);
       do i=1,5 { Itype(Npart,i)=Istat(i);}; do i=1,8 { PP4(Npart,i)=PP(i);}
    }
   Lgene=LQ(Lgene);  Ntrack=Npart;  call hfnt(4);
   prin1 Ntrack; (3x,'EVNT: Ntrack=',i5);
   prin1 (itype(i,5),i=1,100); (20i4)
 }
end
 
+deck,htuple,T=geant. -----------------------------------------------------------
*CMZ :          09/10/97  19.21.01  by  Pavel Nevski
*CMZ :  1.30/00 21/08/95  17.33.23  by  Pavel Nevski
*-- Author :     Pavel Nevski
_s_  Htuple
      Integer NwPaw,Paw;  Parameter (nwpaw=1000000); common/pawc/paw(nwpaw);
      Integer MxTr;   Parameter (MxTr=2000);
      Integer idrun,ntrack,Itype,Is;  Real vxyz,pp4;
      common/event/idrun,vxyz(3),ntrack,itype(MxTr,5),PP4(MxTr,8);
 
      call hlimit(-Nwpaw);  call HRopen (4,'TEST','hcwn.hbook','N',1024,is);
      call HBSet  ('BSIZE',4096,is);  call HBNT(4,'HCWN',' ');
      call HBName (4,'Block1',IDRUN, 'idrun,vvx,vvy,vvz');
      call HBName (4,'Block2',NTRACK,'ntrack[0,2000],istat(ntrack)[-1,3],'  //_
       'ipdg(ntrack)[-8000,8000],imo1(ntrack)[0,2000],imo2(ntrack)[-2000,1],'//_
       'idau(ntrack)[0,2000],px(ntrack),py(ntrack),pz(ntrack),'             //_
       'mass(ntrack):R:12:[-1.,10.],tof(ntrack):R:10:[0.,1.e-6],'           //_
       'vx(ntrack):R:16:[-50.,50.],vy(ntrack):R:16:[-50.,50.],'             //_
       'vz(ntrack):R:16:[-500.,500.]');
end
 
 
 
 
+PATCH,$KUMACS.
*CMZ :          08/07/97  12.52.27  by  Pavel Nevski
+DECK,install,T=TEXT.
*CMZ :          27/12/97  15.21.55  by  Pavel Nevski
*-- Author :    Pavel Nevski   08/07/97
MACRO INSTALL   1=$MACHINE the rest is optional keys
ASYS=$upper([1])
FILE=$CMZFILE( )
message system - [ASYS]
message  file  - [FILE]
SEL  [FILE] UNIX [ASYS] SHL TYPE DZDOC NONEWL HIGZ [2] [3] [4] [5] [6] [7]
* possible options are:      gcalor shift motif cc staf
* Non standard systems are:  SGI5/SGI6, NOVOSIBISRK
if     [ASYS]='NOVOSIBIRSK'  then
SEL            LINUX  F77
elseif [ASYS]='LINUX' then
SEL            F77
elseif [ASYS]='SGI6' then
SEL            SGI
elseif [ASYS]='SGI5' then
SEL            SGI
elseif [ASYS]='SOLARIS' then
SEL            SUN
elseif [ASYS]='SOLARISPC' then
SEL            SOLARIS MSDOS
elseif [ASYS]='IBMRT' then
SEL            AIX F77
elseif [ASYS]='ALPHA' then
SEL            ALPHA_OSF DECS
endif
*     SEL  GCALOR
SEL
trace
*     FILE [FILE] -R
FILE  geant321     -R
file  zebpack      -R
SEQ   //
file  comis        -R
pilot *COMIS
file  zebra        -R
if    [ASYS]='NOVOSIBIRSK' then
pilot QCDE
endif
pilot *ZEBRA
rel
*     compilation language
set   f77 C CC kuip geant -lan
set   *   -com   geant
*    parser
SET   geant3.f     -f
CTOF  //[FILE]/geant3/*
SET   geant3.def   -f   text
CTOT  //[FILE]/geant3/geant3
SET   dzdoc.bank   -f   text
CTOT  //[FILE]/dzdoc/banks
SET   geom.kumac   -f   text
CTOT  -s //[FILE]/$kumacs/geom
SET   makefile     -f   text
CTOT  -s //[FILE]/$kumacs/makefile
SET   agdummy.g    -f   text
CTOT  //[FILE]/main/agdummy
*    comis
set   comisf.f  -f  F77
set   comisc.c  -F  C
CTOF  //[FILE]/COMIS/* //[FILE]/DECCC/*
*    cernlib
set   ggsim.f   -f  f77
*    AGI stuff
CTOF  //[FILE]/geant/* //[FILE]/dzdoc/*
set   agsim.g   -f  geant
set   fgsim.f   -f  f77
set   ccsim.cc  -f  CC
set   kgsim.cdf -f  kuip
CTOF  //[FILE]/main/*  //[FILE]/atgeant/* //[FILE]/agzio/*  _
                       //[FILE]/util/*    //[FILE]/rebank/*
+DECK,geom,T=text.
*CMZ :          08/07/97  15.19.28  by  Pavel Nevski
*-- Author :    Pavel Nevski   08/07/97
macro geom
on error exitm
call  csrmsl($quote([1]))
shell make [1].sl
call  [1].csl
exitm
+DECK,makefile,T=TEXT.
*CMZ :          15/03/98  14.09.37  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/07/97
CMDS  = atlsim starsim gstar staf staf+ staf++ staf+++
SIZE  = 1 2 4 6 8 10 12 14 16 18 20 22 24 28 32 34 36
#INCL = -I$(STAR_LIB)/SL97a/sys/inc/
INCL  = -I$(STAR)/asps/staf/inc
+IF,MSDOS. -------------------------------------------------------------------
SHELL = /usr/bin/ksh
GEA   = f77  -g
FOR   = f77  -g
CC    = cc   -g
CPP   = CC   -g -DDEBUG
GST   = f77  -g -t -z muldefs
GSC   = CC   -g -t -z muldefs
FSL   = f77  -w -pic -Nq1500 -Nl100
LDS   = /usr/ccs/bin/ld -G
RMF   = /usr/bin/rm     -f
LIB   = -L/opt/SUNWspro/SC4.2/lib/libp -lM77 -lF77 -lsunmath -lmalloc
LIBSL = -L/opt/SUNWspro/SC4.2/lib/libp -lsunmath
+ELSEIF,LINUX. ---------------------------------------------------------------
SHELL = /bin/sh
RMF   = /bin/rm  -f
FOR   = g77  -w -O2 -fno-second-underscore
GEA   = g77  -w -g
# Fedunov: GST   = g77 -fPIC ? -fno-underscoring
GST   = g77  -w -O2 -export-dynamic -fno-second-underscore
LIB   = -ldl -L/usr/X11R6/lib/ -lX11 -lXm -lXt
FSL   = g77  -w -O2
LDS   = ld   -ldl -shared
CC    = cc
CPP   = g++
LIBSL =
+ELSEIF,SGI5. -----------------------------------------------------------------
SHELL = /usr/bin/ksh
FOR   = f77  -Nn20000  -Nq20000   -O2
GEA   = f77  -static    -O2
GST   = f77             -O2
FSL   = f77  -Nn20000  -Nq20000   -O2
CC    = cc
CPP   = CC   -g -DDEBUG
LDS   = ld   -shared
GST   = f77             -O2
GSC   = CC   -g -DDEBUG
RMF   = /usr/bin/rm     -f
LIB   = -lftn -lm -lc -lmalloc
LIBSL =
+ELSEIF,SGI6. ----------------------------------------------------------------
SHELL = /usr/bin/ksh
FOR   = f77  -32 -Nn20000 -O2
GEA   = f77  -32 -static  -O2
FSL   = f77  -32 -Nn20000 -O2
CC    = cc   -32
CPP   = CC   -32  -g  -DDEBUG
LDS   = ld   -32      -shared
GST   = f77  -32          -O2
GSC   = CC   -32  -g  -DDEBUG
RMF   = /usr/bin/rm     -f
LIB   = -lftn -lm -lc -lmalloc
LIBSL =
+ELSEIF,HPUX. -----------------------------------------------------------------
SHELL = /bin/ksh
GEA   = fort77 +ppu     -g -K -w
FOR   = f77    +ppu     -g
FSL   = f77    +ppu  +z +O2
GST   = fort77 +ppu     -g -Wl,-E
GSC   = aCC    -w -z +Z -g +DAportable -Wl,-E
CC    = cc     +z -Aa      -D_HPUX_SOURCE
CPP   = aCC    -w -z +Z -g +DAportable
LDS   = ld     -b
LDC   = aCC    -b -z
RMF   = /bin/rm   -f
LIB   = -lCsup -lstream
LIBSL =
#LIB  = /opt/fortran/lib/libU77.a
LIBCC =  -L/opt/CC/lib -lC.ansi -lcxx -lcl -lc
+ELSEIF,ALPHA. ---------------------------------------------------------------
SHELL = /bin/ksh
FOR   = f77 -v -fpe2
GEA   = f77    -fpe2
GST   = f77 -g -D 40000000 -T 20000000 -taso -fpe2
FSL   = f77    -fpe2
CC    = cc
CPP   = cxx -g
LDS   = ld -shared -expect_unresolved "*"
LIBSL =  -lUfor -lfor -lFutil -lm -lm_4sqrt -lots -lc
RMF   = /bin/rm -f
LIB   =
+ELSEIF,IBMRT. ---------------------------------------------------------------
SHELL = /bin/ksh
GEA   = xlf -O -q maxmem=-1 -q extname -q source
FSL   = xlf -O -qextname    -qrndsngl
FOR   = xlf -O -q maxmem=-1 -q extname -q source
GST   = xlf -NQ20000 -bnoquiet -bkeepfile:fgsim.o -bkeepfile:agsim.o
CC    = cc  -g
CPP   = xlC -g
LDS   = ld  -bnoentry -bE:$*.exp import.map -bh:8 -T512 -H512
LIBSL = -lxlf90 -lxlf -lm -lc
LIB   =  -lld
RMF   = /bin/rm     -f
FLT   = egrep ' [BAD] '|cut -f1 -d' '|sed -e 's/^#/ #/'|sort|uniq
+ELSEIF,SOLARIS. -------------------------------------------------------------
SHELL = /bin/ksh
LANG  = /opt/SUNWspro/bin
FOR   = $(LANG)/f77
GEA   = $(LANG)/f77
GST   = $(LANG)/f77
FSL   = $(LANG)/f77 -PIC -Nl100 -Nx1000 -Nq1500
CC    = $(LANG)/cc  -g
CPP   = $(LANG)/CC  -g -DDEBUG
GSC   = $(LANG)/CC  -g -t -z muldefs
LDS   = /usr/ccs/bin/ld -G
LIBSL =
RMF   = /bin/rm     -f
LIB   = -L/usr/dt/lib -L/usr/SUNWspro/lib -ldl  -lM77 -lF77 -lsunmath -lmalloc
+ENDIF. ----------------------------------------------------------------------
.SILENT:
.SUFFIXES:
.SUFFIXES: .sl .o .g .f .c .cc .cdf .rz
#
.g.sl:; geant3    $*
	$(FSL) -c $*.f -o  $*.o
+IF,AIX.
	nm        $*.o|egrep ' [BAD] '|cut -f1 -d' '|sed -e 's/^#/ #/'|sort|uniq > $*.exp
	$(RMF)    ../sl/$*.sl
#	$(RMF)          $*.sl
+ENDIF.
	$(LDS)    $*.o -o  $*.sl    $(LIBSL)
	$(RMF)    $*.f     $*.o
#
.f.sl:; $(FSL) -c $*.f -o  $*.o
	$(LDS)    $*.o -o  $*.sl    $(LIBSL)
	$(RMF)             $*.o
#
.c.sl:; $(CC)  -c $*.c -o  $*.o     $(INCL)
+IF,AIX.
	nm        $*.o|egrep ' [BAD] '|cut -f1 -d' '|sed -e 's/^#/ #/'|sort|uniq > $*.exp
	$(RMF)    ../sl/$*.sl
#	$(RMF)          $*.sl
+ENDIF.
	$(LDS)    $*.o -o  $*.sl    $(LIBSL)
	$(RMF)    $*.o
#
.cc.sl:;$(CPP) -c $*.cc -o $*.o     $(INCL)
	$(LDS)    $*.o -o  $*.sl    $(LIBCC)
	$(RMF)    $*.o
#
.cdf.o:;kuipc     $*
	$(FOR) -c $*.f -o  $*.o
	$(RMF)    $*.f
.g.o:;  geant3    $*
	$(FOR) -c $*.f -o  $*.o
	$(RMF)    $*.f
#
.f.o:;  $(FOR) -c $*.f -o  $*.o
.c.o:;  $(CC)  -c $*.c -o  $*.o
.cc.o:; $(CPP) -c $(INCL)  $*.cc -o $*.o
#
#
geant3: geant3.f; $(GEA) -o geant3 geant3.f `cernlib kernlib`
#
$(CMDS):ccsim.o fgsim.o agsim.o kgsim.o ggsim.o comisf.o comisc.o agdummy.o
+IF,CC.
	$(GSC) -o /tmp/$@              \
+IF,STAF.
                      -DSTAF $(INCL)   \
+endif.
                      ccsim.cc fgsim.o \
+else.
	$(GST) -o $@  fgsim.f  ccsim.o \
+endif.
	agsim.o kgsim.o ggsim.o comisf.o comisc.o agdummy.o \
+IF,GCALOR.
     -L/afs/cern.ch/atlas/offline/@sys/pro/lib -lgcalor \
+endif.
+IF,STAF
     -L./ -ltdm -lspx -lsoc -lasu -ltop -ltnt -lami -ldio -ldui -ldsl -ldsu \
+ENDIF.
+IF,Motif.
	`cernlib geant321 pawlib graflib/Motif \
+ELSE.
	`cernlib geant321 pawlib graflib/X11   \
+ENDIF.
+IF,Shift.
         packlib-shift mathlib kernlib-shift` /usr/local/lib/libshift.a  \
+ELSE.
         packlib mathlib kernlib`  \
+ENDIF.
        $(LIB)
#
	echo '#!'$(PWD)'/$@'  > import.map
+IF,IBMRT.
	nm $@|egrep ' [BAD] '|cut -f1 -d' '|sed -e 's/^#/ #/'|sort|uniq>>import.map
	xlf $@ -o $@  -bE:import.map -lX11 -lXm -lXt
+ENDIF.
	cp  /tmp/$@  ./$@
 
$(SIZE):
	sed -e '5,15s/8 000/$@ 000/; 5,15s/2 000/500/' fgsim.f > simsize.f
	$(FOR) -c simsize.f -o  fgsim.o
normal:
	$(FOR) -c fgsim.f   -o  fgsim.o
detm:
	$(RMF) detm.rz; echo "createdoc dzdoc.bank detm.rz; quit;" | dzedit
cleanup:
	/bin/rm -f *.o *.f last* *~ *.lst *.exp
	/bin/rm -f agsim.g agdummy.g kgsim.cdf comisc.* ccsim.cc
	/bin/rm -f cmzsave.dat paw.metafile dzedit.las
	ls -ltr
atlas:	geant3 atlsim detm cleanup
star:	geant3 gstar  detm cleanup
setup:
 
 
 
 
 
+PATCH,HADR,if=hadr.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
+KEEP,MXGKGH.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      PARAMETER (MXGKGH=100)
+KEEP,/BLANKP.       *** NVE 09-FEB-1988 ***
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      PARAMETER (MXGKPV=MXGKGH)
      COMMON /VECUTY/ PV(10,MXGKPV)
+KEEP,/CONSTS.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      COMMON/CONSTS/ PI,TWPI,PIBTW,MP,MPI,MMU,MEL,MKCH,MK0,SMP,SMPI,
     $               SMU,CT,CTKCH,CTK0,
     $               ML0,MSP,MS0,MSM,MX0,MXM,CTL0,CTSP,CTSM,CTX0,CTXM,
     $               RMASS(35),RCHARG(35)
C
                     REAL MP,MPI,MMU,MEL,MKCH,MK0,
     *                    ML0,MSP,MS0,MSM,MX0,MXM
C
+KEEP,/EVENT.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      PARAMETER (MXEVEN=12*MXGKGH)
      COMMON/EVENT / NSIZE,NCUR,NEXT,NTOT,EVE(MXEVEN)
C
+KEEP,/PRNTFL.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
      COMMON/PRNTFL/INBCD,NEWBCD,INBIN,NEWBIN,NPEVT,NEVTP,LPRT,NPRT(10)
                    LOGICAL LPRT,NPRT
+KEEP,PCODIM.
*CMZ :          16/12/97  14.12.59  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
C --- DIMENSION STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DIMENSION KIPART(48),IKPART(35)
C
+KEEP,PCODAT.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.37  by  S.Giani
*-- Author :    *** NVE 09-FEB-1988 ***
C --- DATA STMTS. FOR GEANT/GHEISHA PARTICLE CODE CONVERSIONS ---
C --- KIPART(I)=GHEISHA CODE CORRESPONDING TO GEANT   CODE I ---
C --- IKPART(I)=GEANT   CODE CORRESPONDING TO GHEISHA CODE I ---
C
      DATA KIPART/
     $               1,   3,   4,   2,   5,   6,   8,   7,
     $               9,  12,  10,  13,  16,  14,  15,  11,
     $              35,  18,  20,  21,  22,  26,  27,  33,
     $              17,  19,  23,  24,  25,  28,  29,  34,
     $              35,  35,  35,  35,  35,  35,  35,  35,
     $              35,  35,  35,  35,  30,  31,  32,  35/
C
      DATA IKPART/
     $               1,   4,   2,   3,   5,   6,   8,   7,
     $               9,  11,  16,  10,  12,  14,  15,  13,
     $              25,  18,  26,  19,  20,  21,  27,  28,
     $              29,  22,  23,  30,  31,  45,  46,  47,
     $              24,  32,  48/
C
+KEEP, DIMPAR
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*                                                                     *
*=== dimpar ==========================================================*
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*      DIMPAR: included in any routine                                *
*                                                                     *
*          Mxxrgn = maximum number of regions                         *
*          Mxxmdf = maximum number of media in Fluka                  *
*          Mxxmde = maximum number of media in Emf                    *
*          Mfstck = stack dimension in Fluka                          *
*          Mestck = stack dimension in Emf                            *
*          Nallwp = number of allowed particles                       *
*          Mpdpdx = number of particle types for which EM dE/dx pro-  *
*                   cesses (ion,pair,bremss) have to be computed      *
*          Icomax = maximum number of materials for compounds (equal  *
*                   to the sum of the number of materials for every   *
*                   compound )                                        *
*          Nstbis = number of stable isotopes recorded in common iso- *
*                   top                                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
      PARAMETER ( MXXRGN = 500  )
      PARAMETER ( MXXMDF = 50   )
      PARAMETER ( MXXMDE = 18   )
      PARAMETER ( MFSTCK = 1000 )
      PARAMETER ( MESTCK = 100  )
      PARAMETER ( NALLWP = 39   )
      PARAMETER ( MPDPDX = 8    )
      PARAMETER ( ICOMAX = 120  )
      PARAMETER ( NSTBIS = 304  )
+KEEP, PAPROPT
*CMZ :          16/12/97  14.05.33  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
      DOUBLE PRECISION AM, AMDISC, THALF,BIASDC, BIASIN
 
+KEEP, PAPROP
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== paprop ===========================================================*
*
*----------------------------------------------------------------------*
*     include file: paprop copy                   created 26/11/86 by p*
*     changes: on  16 december 1992 by Alfredo Ferrari                 *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /paprop/ contains particle properties                            *
*        btype  = literal name of the particle                         *
*        am     = particle mass in gev                                 *
*        ichrge = electric charge of the particle                      *
*        iscore = explanations for the scored distribution             *
*        genpar = names of the generalized particles                   *
*        ijdisc = list of the particle types to be discarded           *
*        thalf  = half life of the particle in sec                     *
*        biasdc = decay biasing factors                                *
*        biasin = inelastic interaction biasing factors                *
*        lhadro = flag for hadrons                                     *
*        jspinp = particle spin (in units of 1/2)                      *
*        lbsdcy = logical flag for biased decay: if .true. the biasing *
*                 factor is used as an upper limit to the decay length *
*        lprbsd = logical flag for biased decay: if .true. the biasing *
*                 factor is applied only to primaries                  *
*        lprbsi = logical flag for inelastic interaction biasing: if   *
*                 .true. the biasing factor is applied only to prima-  *
*                 ries                                                 *
*                                                                      *
*----------------------------------------------------------------------*
*
      LOGICAL LHADRO, LBSDCY, LPRBSD, LPRBSI
      CHARACTER*8 BTYPE,GENPAR
      COMMON / FKPAPR / AM  (NALLWP), AMDISC (NALLWP), THALF  (NALLWP),
     &               BIASDC (NALLWP), BIASIN (NALLWP), ICHRGE (NALLWP),
     &               ISCORE     (10), IJDISC (NALLWP), LHADRO (NALLWP),
     &               JSPINP (NALLWP), LBSDCY (NALLWP), LPRBSD, LPRBSI
      COMMON / FKCHPR / BTYPE  (NALLWP), GENPAR (30)
 
 
+KEEP, FINUCT
*CMZ :          16/12/97  14.01.37  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
      DOUBLE PRECISION CXR, CYR, CZR, TKI, PLR, WEI, TV, TVCMS,
     &                 TVRECL, TVHEAV, TVBIND
+KEEP, FINUC
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== finuc ============================================================*
*
*----------------------------------------------------------------------*
*     Last change on 5 april 1990     by Alfredo Ferrari, INFN Milan   *
*     include file: finuc copy                   created 26/11/86 by pa*
*     note: if changed change finuc2 copy also                         *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /finuc/ is the storage for secondaries created in event          *
*        np        = number of secondaries                             *
*        kpart(ip) = type of the secondary ip                          *
*        cxr(ip)   = direction cosine of the secondary ip              *
*                    with respect to x-axis                            *
*        cyr(ip)   = direction cosine of the secondary ip              *
*                    with respect to y-axis                            *
*        czr(ip)   = direction cosine of the secondary ip              *
*                    with respect to z-axis                            *
*        tki(ip)   = kinetic energy of secondary ip                    *
*        plr(ip)   = momentum of the secondary ip                      *
*        wei(ip)   = weight of the secondary ip                        *
*        tv        = excitation energy                                 *
*        tvcms     = actual excitation energy of the residual nucleus  *
*        tvrecl    = recoil kinetic energy of the residual nucleus     *
*        tvheav    = recoil kinetic energies of heavy (2-H, 3-H, 3-He, *
*                    4-He) fragments after evaporation                 *
*        tvbind    = approximate energy wasted in nuclear binding      *
*                    effects
*----------------------------------------------------------------------*
*
      PARAMETER (MXP=999)
      COMMON / FKFINU / CXR (MXP), CYR (MXP), CZR (MXP), TKI (MXP),
     &                 PLR (MXP), WEI (MXP), TV, TVCMS, TVRECL, TVHEAV,
     &                 TVBIND, NP0, NP, KPART (MXP)
 
+KEEP, COMCONT
*CMZ :          16/12/97  14.15.27  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
      DOUBLE PRECISION AOCMBC, CONTNT, SUMACN, CABINX, CABELX,
     &                 ANXNOR, ELXNOR, CONA13, SUMZMF
*-- Author :    A. Ferrari
+KEEP, COMCON
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== comcon ===========================================================*
*
*----------------------------------------------------------------------*
*                                                                      *
*     include file: comcon copy                 created 26/11/86 by pa *
*                                                                      *
*     Last change  on  30-oct-92   by   Alfredo Ferrari, INFN - Milan  *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*                                                                      *
*     /comcon/ contains information about compounds                    *
*         icompl(imat) = number of materials in a compound             *
*         matnum(i)    = material numbers (compounds consist of the    *
*                        materials)                                    *
*         aocmbc(i)    = atomic densities in barn**-1 cm**-1           *
*                        (Atoms Over Cm times Barn for Compounds)      *
*         cona13(i)    = A^1/3 of the constituents                     *
*         sumzmf(i)    = cumulative z^2 for multiple scattering        *
*         contnt(i)    = partial densities                             *
*         sumacn(i)    = cumulative atom contents of the compounds     *
*         cabinx(i)    = cumulative at.cont.*inelastic cross section   *
*         cabelx(i)    = cumulative at.cont.*  elastic cross section   *
*         anxnor       = total inelastic cross section                 *
*         elxnor       = total   elastic cross section                 *
*----------------------------------------------------------------------*
*
      COMMON /FKCOMC/ AOCMBC (ICOMAX), CONA13 (ICOMAX), SUMZMF (ICOMAX),
     &                CONTNT (ICOMAX), SUMACN (ICOMAX), CABINX (ICOMAX),
     &                CABELX (ICOMAX), ANXNOR, ELXNOR,  ICOMPL (MXXMDF),
     &                MATNUM (ICOMAX)
+KEEP, FHEAVYT
*CMZ :          16/12/97  14.01.37  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
      DOUBLE PRECISION CXHEAV, CYHEAV, CZHEAV, TKHEAV, PHEAVY,
     &                 WHEAVY, AMHEAV
+KEEP, FHEAVY
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.41  by  S.Giani
*-- Author :    A. Ferrari
*
*=== fheavy ===========================================================*
*
*----------------------------------------------------------------------*
*     Last change on 9 March 1993     by Alfredo Ferrari, INFN Milan   *
*     include file: fheavy copy       created 5/4/90 by A. Ferrari     *
*     changes: none                                                    *
*     included in the following subroutines or functions: not updated  *
*                                                                      *
*     description of the common block(s) and variable(s)               *
*                                                                      *
*     /fheavy/ is the storage for heavy secondaries created in the     *
*              nuclear evaporation                                     *
*        npheav     = number of secondaries                            *
*        kheavy(ip) = type of the secondary ip                         *
*                   ( 3 = deuteron, 4 = 3-H, 5 = 3-He, 6 = 4-He,       *
*                     7-12 = "Heavy" fragment specified by Ibheav and  *
*                     Icheav )                                         *
*        cxheav(ip) = direction cosine of the secondary ip             *
*                     with respect to x-axis                           *
*        cyheav(ip) = direction cosine of the secondary ip             *
*                     with respect to y-axis                           *
*        czheav(ip) = direction cosine of the secondary ip             *
*                     with respect to z-axis                           *
*        tkheav(ip) = kinetic energy of secondary ip                   *
*        pheavy(ip) = momentum of the secondary ip                     *
*        wheavy(ip) = weight of the secondary ip                       *
*        amheav(ip) = atomic masses of the six types of evaporated     *
*                     particles                                        *
*        anheav(kp) = name of the kp-type heavy particle               *
*        icheav(kp) = charge of the kp-type heavy particle             *
*        ibheav(kp) = mass number of the kp-type heavy particle        *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*   !!! There is now the possibility to produce up to 6 "heavy" !!!!   *
*   !!! fragments besides the residual nucleus recorded in      !!!!   *
*   !!! Resnuc: they are identified by indeces 7-12, of course  !!!!   *
*   !!! the corresponding physical properties (Z,A,m..) must be !!!!   *
*   !!! updated every time they are produced                    !!!!   *
*   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   *
*----------------------------------------------------------------------*
*
      PARAMETER ( MXHEAV = 100 )
      CHARACTER*8 ANHEAV
      COMMON / FKHEAV / CXHEAV (MXHEAV), CYHEAV (MXHEAV),
     &                  CZHEAV (MXHEAV), TKHEAV (MXHEAV),
     &                  PHEAVY (MXHEAV), WHEAVY (MXHEAV),
     &                  AMHEAV  ( 12 ) ,
     &                  KHEAVY (MXHEAV), ICHEAV  ( 12 ) ,
     &                  IBHEAV  ( 12 ) , NPHEAV
      COMMON / FKHEAC / ANHEAV  ( 12 )
 
+KEEP, PART2T
*CMZ :          16/12/97  14.01.37  by  Pavel Nevski
*-- Author :
      DOUBLE PRECISION AAM, GA, TAU, AAMDSC
+KEEP, PART2
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*-- Author :
*
*=== part2 ============================================================*
*
*----------------------------------------------------------------------*
*     Include file: part2 copy        Revised on 20-7-90 by A. Ferrari *
*     Note: see also part copy and part3 copy                          *
*     Changes: none                                                    *
*     Included in the following subroutines or functions: not updated  *
*                                                                      *
*     Description of the common block(s) and variable(s)               *
*                                                                      *
*         Kptoip = conversion from part to paprop numbering            *
*         Iptokp = conversion from paprop to part numbering            *
*                                                                      *
*----------------------------------------------------------------------*
*
      PARAMETER (IDMAX8=183)
      CHARACTER*8  ANAME
      COMMON / FKPART / AAM  (IDMAX8), GA     (IDMAX8), TAU    (IDMAX8),
     &                AAMDSC (IDMAX8), IICH   (IDMAX8), IIBAR  (IDMAX8),
     &                K1     (IDMAX8), K2     (IDMAX8), KPTOIP (IDMAX8),
     &                IPTOKP (39)
      COMMON / FKCHPA / ANAME (IDMAX8)
+KEEP,camass.
*CMZ :          16/12/97  13.47.10  by  Pavel Nevski
*-- Author :    Christian Zeitnitz
      REAL*4 XMASS(0:11)
      COMMON/CMASS/XMASS
+KEEP,CERRCM
*CMZ :          16/12/97  13.48.36  by  Pavel Nevski
*-- Author :    Christian Zeitnitz
      LOGICAL CERRF
      COMMON/CERRCM/CERRF,IERRU
+KEEP,CALGEA
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  1.04/02 13/02/95  11.09.49  by  Christian Zeitnitz
*-- Author :   Christian Zeitnitz
C***************************************************************
C
C       CALOR-GEANT Interface common
C
C parameters of incident particle :
C                   IPinc   = particle type a la CALOR
C                   Einc    = kinetic energy
C                   Uinc(3) = direction cosines
C material parameters:
C                   NCEL    = number of elements in mixture (NMTC)
C                             GEANT material no. for MICAP
C                   Amed(I) = mass number
C                   Zmed(I) = charge number
C                   Dmed(I) = Atoms/cm**3 * 1E-24
C                   Hden    = Atoms/cm**3 * 1E-24
C                             of H-Atoms in mixture
C
C particle stack:
C            NPHETC           = number of particles
C            Ekinet(1:NPHETC) = kinetic energy of part.
C            IPCAL(1:NPHETC)  = particle type a la CALOR (extended)
C            UCAL(1:NPHETC,3) = direction cosines
C            CALTIM(1:NPHETC) = age of particle (nsec)
C
C            ATARGT = A no. of target nucleus
C            ZTARGT = Z no. of target nucleus
C
C return of residual nucleus information
C            NRECOL  = no. of heavy recoil products
C            Amed(I) = mass number of residual nucleus
C            Zmed(I) = charge number "          "
C            EXmed   = exitation energy of nucleus
C            ERmed(I)= recoil energy of nucleus
C            IntCal  = type of interaction (GEANT NAMEC index)
C return of cross section of hadronic interaction (CALSIG called)
C            SIG =  x-section
C
C set by CALSIG:
C            ICPROC = -1   undefined
C                   =  0   NMTC called for cross-section
C                   =  1   MICAP called for cross-section
C                   =  2   SKALE(NMTC at 3 GeV) called for cross-section
C                   =  3   FLUKA called for cross-section
C            KCALL : same coding as ICPROC, but is only valid after a
C                    call to GCALOR
C       18/8/92  C.Zeitnitz University of Arizona
C****************************************************************
C
      PARAMETER(EMAXP  = 3.495)
      PARAMETER(EMAXPI = 2.495)
C transition upper limit (GeV) NMTC-FLUKA
      PARAMETER(ESKALE = 10.0)
      PARAMETER(MXCP = 300)
C
      COMMON/ CALGEA / IPINC  , EINC       , UINC(3)   ,NCEL        ,
     +                 HDEN   , AMED(100)  , ZMED(100) ,DMED(100)   ,
     +                 NPHETC ,EKINET(MXCP),IPCAL(MXCP),UCAL(MXCP,3),
     +                 INTCAL , EXMED      , ERMED(100),SIG         ,
     +                 CALTIM(MXCP), ICPROC, NRECOL    ,KCALL       ,
     +                 ATARGT , ZTARGT
C
+DECK,FLUFIN.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 19/05/94  13.35.12  by  S.Ravndal
*-- Author :
      SUBROUTINE FLUFIN
+SEQ,GCBANK.
+SEQ,GCCUTS.
+SEQ,GCJLOC.
+SEQ,GCFLAG.
+SEQ,GCKINE.
+SEQ,GCKING.
+SEQ,GCMATE.
+SEQ,GCPHYS.
+SEQ,GCTRAK.
+SEQ,GSECTI.
+SEQ,GCTMED.
+SEQ,GCUNIT.
+SEQ,DIMPAR.
 
+SEQ,FINUCT,IF=-SINGLE
+SEQ,FINUC.
      REAL RNDM(1)
+SELF, IF=-SINGLE
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
+SELF
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
+SEQ,PART2T,IF=-SINGLE
+SEQ,PART2.
+SEQ,COMCONT,IF=-SINGLE
+SEQ,COMCON.
+SEQ,FHEAVYT,IF=-SINGLE
+SEQ,FHEAVY.
+SEQ,PAPROP.
+SEQ,PAPROPT,IF=-SINGLE
+SEQ,GFKDIS.
+SELF, IF=-SINGLE
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
+SELF
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
      NP = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF ((IGF.EQ.1).OR.
     +      (GEKIN.EQ.0..AND.ITRTYP.EQ.3.AND.IPART.NE.25)) THEN
         CALL GHEISH
         IGF = 0
         GOTO 999
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         LMEC(NMEC)=30
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
      ELSE
         ISTOP=1
         NSTAK1 = MIN(NP,MXGKIN-NGKINE)
         IF(NP.GT.NSTAK1) THEN
            WRITE(CHMAIL,10000) NP-NSTAK1
            CALL GMAIL(0,0)
         ENDIF
         DO 90  K=1,NSTAK1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NSTAK2 = MIN(NPHEAV,MXGKIN-NGKINE)
         IF(NPHEAV.GT.NSTAK2) THEN
            WRITE(CHMAIL,10100) NPHEAV-NSTAK2
            CALL GMAIL(0,0)
         ENDIF
         DO 100 K=1,NSTAK2
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
         KCASE=NAMEC(12)
      END IF
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
10000 FORMAT(' **** FLUFIN: Stack overflow, ',I6,' particles lost')
10100 FORMAT(' **** FLUFIN: Stack overflow, ',I6,
     +' heavy particles lost')
  999 END
+DECK,GHEISH.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.38  by  S.Giani
*-- Author :
      SUBROUTINE GHEISH
C
C *** MAIN STEERING FOR HADRON SHOWER DEVELOPMENT ***
C *** NVE 15-JUN-1988 CERN GENEVA ***
C
C CALLED BY : GUHADR (USER ROUTINE)
C ORIGIN : F.CARMINATI, H.FESEFELDT
C                       ROUTINES : CALIM  16-SEP-1987
C                                  SETRES 19-AUG-1985
C                                  INTACT 06-OCT-1987
C
+CDE,GCBANK.
+CDE,GCJLOC.
+CDE,GCCUTS.
+CDE,GCFLAG.
+CDE,GCKINE.
+CDE,GCKING.
+CDE,GCMATE.
+CDE,GCPHYS.
+CDE,GCTMED.
+CDE,GCTRAK.
+CDE,GSECTI.
+CDE,GCUNIT.
C --- GHEISHA COMMONS ---
+CDE,MXGKGH.
+CDE,/BLANKP.
+CDE,/CONSTS.
+CDE,/EVENT.
+CDE,/PRNTFL.
C
C --- "NEVENT" CHANGED TO "KEVENT" IN COMMON /CURPAR/ DUE TO CLASH ---
C --- WITH VARIABLE "NEVENT" IN GEANT COMMON ---
C
      PARAMETER (MXGKCU=MXGKGH)
      COMMON /CURPAR /WEIGHT(10),DDELTN,IFILE,IRUN,NEVT,KEVENT,SHFLAG,
     $                ITHST,ITTOT,ITLST,IFRND,TOFCUT,CMOM(5),CENG(5),
     $                RS,S,ENP(10),NP,NM,NN,NR,NO,NZ,IPA(MXGKCU),
     $                ATNO2,ZNO2
C
C --- "IPART" CHANGED TO "KPART" IN COMMON /RESULT/ DUE TO CLASH ---
C --- WITH VARIABLE "IPART" IN GEANT COMMON ---
C
      COMMON /RESULT/ XEND,YEND,ZEND,RCA,RCE,AMAS,NCH,TOF,PX,PY,PZ,
     $                USERW,INTCT,P,EN,EK,AMASQ,DELTN,ITK,NTK,KPART,IND,
     $                LCALO,ICEL,SINL,COSL,SINP,COSP,
     $                XOLD,YOLD,ZOLD,POLD,PXOLD,PYOLD,PZOLD,
     $                XSCAT,YSCAT,ZSCAT,PSCAT,PXSCAT,PYSCAT,PZSCAT
                      REAL NCH,INTCT
C
C --- "ABSL(21)" CHANGED TO "ABSLTH(21)" IN COMMON /MAT/ DUE TO CLASH ---
C --- WITH VARIABLE "ABSL" IN GEANT COMMON ---
C
      COMMON /MAT/ LMAT,
     $             DEN(21),RADLTH(21),ATNO(21),ZNO(21),ABSLTH(21),
     $             CDEN(21),MDEN(21),X0DEN(21),X1DEN(21),RION(21),
     $             MATID(21),MATID1(21,24),PARMAT(21,10),
     $             IFRAT,IFRAC(21),FRAC1(21,10),DEN1(21,10),
     $             ATNO1(21,10),ZNO1(21,10)
C
      DIMENSION IPELOS(35)
      SAVE IDEOL
C
C --- TRANSFER GEANT CUT-OFFS INTO GHEISHA VALUES ---
      DIMENSION CUTS(5)
      EQUIVALENCE (CUTS(1),CUTGAM)
      DIMENSION RNDM(1)
C
+CDE,PCODIM.
+CDE,PCODAT.
C
C --- DENOTE STABLE PARTICLES ACCORDING TO GHEISHA CODE ---
C --- STABLE : GAMMA, NEUTRINO, ELECTRON, PROTON AND HEAVY FRAGMENTS ---
C --- WHEN STOPPING THESE PARTICLES ONLY LOOSE THEIR KINETIC ENERGY ---
      DATA IPELOS/
     $             1,   1,   0,   1,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   0,   0,
     $             0,   0,   0,   0,   0,   0,   0,   0,
     $             0,   0,   0,   0,   0,   1,   1,   1,
     $             0,   0,   1/
C
C --- LOWERBOUND OF KINETIC ENERGY BIN IN N CROSS-SECTION TABLES ---
      DATA TEKLOW /0.0001/
C
C --- KINETIC ENERGY TO SWITCH FROM "CASN" TO "GNSLWD" FOR N CASCADE ---
      DATA SWTEKN /0.05/
C
      DATA IDEOL/0/
C
C --- INITIALIZE RELEVANT GHEISHA VARIABLES IN CASE NOT DONE ALREADY ---
      IF (IFINIT(4) .EQ. 0) CALL GHEINI
C
C --- SET THE INTERACTION MECHANISM TO "HADR" ---
      KCASE=NAMEC(12)
C
C --- SET GHEISHA PRINTING FLAGS ACCORDING TO "DEBUG" STEERING CARD --
      IF (IDEOL .EQ. IDEBUG) GO TO 9000
C
      IF (IDEBUG .NE. 1) GO TO 9001
C
C --- SET SELECTED DEBUGGING FLAGS ---
      DO 9002 LL=1,10
      IF ((ISWIT(LL) .LE. 100) .OR. (ISWIT(LL) .GT. 110)) GO TO 9002
      JJ=ISWIT(LL)-100
      NPRT(JJ)=.TRUE.
 9002 CONTINUE
      GO TO 9000
C
C --- NO DEBUGGING SELECTED ---
 9001 CONTINUE
      DO 9003 LL=1,10
      NPRT(LL)=.FALSE.
 9003 CONTINUE
      IDEOL=IDEBUG
C
 9000 CONTINUE
C
C --- SET THE GHEISHA PARTICLE TYPE TO THE ONE OF GEANT ---
      IF(IPART.GT.48) THEN
         IF(ISTOP.EQ.0) GOTO 9999
         JPA = LQ(JPART-IPART)
         AMAS=Q(JPA+7)
         NCH =Q(JPA+8)
         KPART=-IPART
         GOTO 107
      ENDIF
      NETEST=IKPART(KPART)
      IF ((NETEST .EQ. IPART) .OR. (ISTOP .NE. 0)) GO TO 9004
C
      PRINT 8881,IPART,KPART,ISTOP
 8881 FORMAT(' *GHEISH* IPART,KPART = ',2(I3,1X),' ISTOP = ',I3/
     $ ' *GHEISH* ======> PARTICLE TYPES DO NOT MATCH <=======')
      STOP
C
 9004 CONTINUE
      KPART=KIPART(IPART)
      KKPART=KPART
      AMAS=RMASS(KPART)
      NCH=RCHARG(KPART)
C
C --- TRANSPORT THE TRACK NUMBER TO GHEISHA AND INITIALISE SOME NUMBERS
 107  NTK=ITRA
      INTCT=0.0
      NEXT=1
      NTOT=0
      TOF=0.0
C
C --- FILL RESULT COMMON FOR THIS TRACK WITH GEANT VALUES ---
C --- CALIM CODE ---
      XEND=VECT(1)
      YEND=VECT(2)
      ZEND=VECT(3)
      PX=VECT(4)
      PY=VECT(5)
      PZ=VECT(6)
      USERW=UPWGHT
C --- SETRES CODE ---
      P=VECT(7)
      AMASQ=AMAS*AMAS
      EN=SQRT(AMASQ+P*P)
      EK=ABS(EN-ABS(AMAS))
      ENOLD=EN
C
      SINL=0.0
      COSL=1.0
      SINP=0.0
      COSP=1.0
C
      IF (ABS(P) .LE. 1.0E-10) GO TO 1
      SINL=PZ
      COSL=SQRT(ABS(1.0-SINL**2))
C
 1    CONTINUE
      CALL GRNDM(RNDM,1)
      PHI=RNDM(1)*TWPI
      IF ((PX .EQ. 0.0) .AND. (PY .EQ. 0.0)) GOTO 3
      IF (ABS(PX) .LT. 1.E-10) GOTO 2
      PHI=ATAN2(PY,PX)
      GOTO 3
C
 2    CONTINUE
      IF (PY .GT. 0.0) PHI=PI/2.0
      IF (PY .LE. 0.0) PHI=3.0*PI/2.0
C
 3    CONTINUE
      SINP=SIN(PHI)
      COSP=COS(PHI)
C
C --- SET GHEISHA INDEX FOR THE CURRENT MEDIUM ALWAYS TO 1 ---
      IND=1
C
C --- TRANSFER GLOBAL MATERIAL CONSTANTS FOR CURRENT MEDIUM ---
C --- DETAILED DATA FOR COMPOUNDS IS OBTAINED VIA ROUTINE COMPO ---
      ATNO(IND+1)=A
      ZNO(IND+1)=Z
      DEN(IND+1)=DENS
      RADLTH(IND+1)=RADL
      ABSLTH(IND+1)=ABSL
C
C --- SETUP PARMAT FOR PHYSICS STEERING ---
      PARMAT(IND+1,5)=0.0
      PARMAT(IND+1,8)=IPFIS
      PARMAT(IND+1,9)=0.0
      PARMAT(IND+1,10)=0.0
      JTMN=LQ(JTM)
      IF (JTMN .LE. 0) GO TO 4
      PARMAT(IND+1,5)=Q(JTMN+26)
 4    CONTINUE
C
C --- CHECK WHETHER PARTICLE IS STOPPING OR NOT ---
      IF (ISTOP .EQ. 0) GO TO 5
C
      IF (NPRT(9)) PRINT 1000,KPART
 1000 FORMAT(' *GHEISH* STOPPING GHEISHA PARTICLE ',I3)
      CALL GHSTOP
C --- IN CASE OF DECAY OF PARTICLE OR USER PARTICLE ==> RETURN ---
      IF (LMEC(NMEC) .EQ. 5 .OR. KPART .LT. 0) GO TO 9999
C --- IN CASE OF HAD. INT. WITH GENERATION OF SEC. ==> GO TO 40 ---
      IF (IHADR .NE. 2) GO TO 40
C --- ALSO DEPOSIT REST MASS ENERGY FOR IN-STABLE PARTICLES ---
      IF (IPELOS(KPART) .EQ. 0) DESTEP=DESTEP+ABS(RMASS(KPART))
      GO TO 9999
  5   CONTINUE
C
C --- INDICATE LIGHT (<= PI) AND HEAVY PARTICLES (HISTORICALLY) ---
C --- CALIM CODE ---
      J=2
      TEST=RMASS(7)-0.001
      IF (ABS(AMAS) .LT. TEST) J=1
C
C *** DIVISION INTO VARIOUS INTERACTION CHANNELS DENOTED BY "INT" ***
C THE CONVENTION FOR "INT" IS THE FOLLOWING
C
C INT  = -1 REACTION CROSS SECTIONS NOT YET TABULATED/PROGRAMMED
C      =  0 NO INTERACTION
C      =  1 ELEASTIC SCATTERING
C      =  2 INELASTIC SCATTERING
C      =  3 NUCLEAR FISSION WITH INELEASTIC SCATTERING
C      =  4 NEUTRON CAPTURE
C
C --- INTACT CODE ---
      KK=ABS(Q(JMA+11))
      ALAM1=0.0
      CALL GRNDM(RNDM,1)
      RAT=RNDM(1)*ALAM
      NMEC=NMEC+1
      ATNO2=A
      ZNO2 =Z
C
      DO 6 K=1,KK
      IF (KK .LE. 0) GO TO 6
C
      IF (KK .EQ. 1) GO TO 7
      ATNO2=Q(JMIXT+K)
      ZNO2 =Q(JMIXT+K+KK)
C
 7    CONTINUE
C
C --- TRY FOR ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
      ALAM1=ALAM1+AIEL(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR INELASTIC SCATTERING ---
      INT=2
      LMEC(NMEC)=20
      ALAM1=ALAM1+AIIN(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NUCLEAR FISSION WITH INELASTIC SCATTERING ---
      INT=3
      LMEC(NMEC)=15
      ALAM1=ALAM1+AIFI(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
C --- TRY FOR NEUTRON CAPTURE ---
      INT=4
      LMEC(NMEC)=18
      ALAM1=ALAM1+AICA(K)
      IF (RAT .LT. ALAM1) GO TO 8
C
 6    CONTINUE
C --- NO REACTION SELECTED ==> ELASTIC SCATTERING ---
      INT=1
      LMEC(NMEC)=13
C
C *** TAKE ACTION ACCORDING TO SELECTED REACTION CHANNEL ***
C --- FOLLOWING CODE IS A TRANSLATION OF "CALIM" INTO GEANT JARGON ---
C
 8    CONTINUE
      IF (NPRT(9)) PRINT 1001,INT
 1001 FORMAT(' *GHEISH* INTERACTION TYPE CHOSEN INT = ',I3)
C
C --- IN CASE OF NO INTERACTION OR UNKNOWN CROSS SECTIONS ==> DONE ---
      IF (INT .LE. 0) GO TO 40
C
C --- IN CASE OF NON-ELASTIC SCATTERING AND NO GENERATION OF SEC. ---
C --- PARTICLES DEPOSIT TOTAL PARTICLE ENERGY AND RETURN ---
      IF ((INT .EQ. 1) .OR. (IHADR .NE. 2)) GO TO 9
      ISTOP=2
      DESTEP=DESTEP+EN
      NGKINE=0
      GO TO 9999
C
 9    CONTINUE
      IF (INT .NE. 4) GO TO 10
C
C --- NEUTRON CAPTURE ---
      IF (NPRT(9)) PRINT 2000
 2000 FORMAT(' *GHEISH* ROUTINE CAPTUR WILL BE CALLED')
      ISTOP=1
      CALL CAPTUR(NOPT)
      GO TO 40
C
 10   CONTINUE
      IF (INT .NE. 3) GO TO 11
C --- NUCLEAR FISSION ---
      IF (NPRT(9)) PRINT 2001
 2001 FORMAT(' *GHEISH* ROUTINE FISSIO WILL BE CALLED')
      ISTOP=1
      TKIN=FISSIO(EK)
      GO TO 40
C
 11   CONTINUE
C
C --- ELASTIC AND INELASTIC SCATTERING ---
      PV( 1,MXGKPV)=P*PX
      PV( 2,MXGKPV)=P*PY
      PV( 3,MXGKPV)=P*PZ
      PV( 4,MXGKPV)=EN
      PV( 5,MXGKPV)=AMAS
      PV( 6,MXGKPV)=NCH
      PV( 7,MXGKPV)=TOF
      PV( 8,MXGKPV)=KPART
      PV( 9,MXGKPV)=0.
      PV(10,MXGKPV)=USERW
C
C --- ADDITIONAL PARAMETERS TO SIMULATE FERMI MOTION AND EVAPORATION ---
      DO 111 JENP=1,10
         ENP(JENP)=0.
 111  CONTINUE
      ENP(5)=EK
      ENP(6)=EN
      ENP(7)=P
C
      IF (INT .NE. 1) GO TO 12
C
C *** ELASTIC SCATTERING PROCESSES ***
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C --- NORMAL ELASTIC SCATTERING FOR LIGHT MEDIA ---
      IF (ATNO2 .LT. 1.5) GO TO 35
C
C --- COHERENT ELASTIC SCATTERING FOR HEAVY MEDIA ---
      IF (NPRT(9)) PRINT 2002
 2002 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED')
      CALL COSCAT
      GO TO 40
C
C *** NON-ELASTIC SCATTERING PROCESSES ***
 12   CONTINUE
C
C --- ONLY NUCLEAR INTERACTIONS FOR HEAVY FRAGMENTS ---
      IF ((KPART .GE. 30) .AND. (KPART .LE. 32)) GO TO 35
C
C *** USE SOMETIMES NUCLEAR REACTION ROUTINE "NUCREC" FOR LOW ENERGY ***
C *** PROTON AND NEUTRON SCATTERING ***
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=4.5*(EK-0.01)
      IF ((KPART .EQ. 14) .AND. (TEST1 .GT. TEST2)) GO TO 85
      IF ((KPART .EQ. 16) .AND. (TEST1 .GT. TEST2)) GO TO 86
C
C *** FERMI MOTION AND EVAPORATION ***
      TKIN=CINEMA(EK)
      PV( 9,MXGKPV)=TKIN
      ENP(5)=EK+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=FERMI(ENP(5))
      ENP(5)=ENP(5)+TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
      TKIN=EXNU(ENP(5))
      ENP(5)=ENP(5)-TKIN
C --- CHECK FOR LOWERBOUND OF EKIN IN CROSS-SECTION TABLES ---
      IF (ENP(5) .LE. TEKLOW) ENP(5)=TEKLOW
      ENP(6)=ENP(5)+ABS(AMAS)
      ENP(7)=(ENP(6)-AMAS)*(ENP(6)+AMAS)
      ENP(7)=SQRT(ABS(ENP(7)))
C
C *** IN CASE OF ENERGY ABOVE CUT-OFF LET THE PARTICLE CASCADE ***
      TEST=ABS(CHARGE)
      IF ((TEST .GT. 1.0E-10) .AND. (ENP(5) .GT. CUTHAD)) GO TO 35
      IF ((TEST .LE. 1.0E-10) .AND. (ENP(5) .GT. CUTNEU)) GO TO 35
C
C --- SECOND CHANCE FOR ANTI-BARYONS DUE TO POSSIBLE ANNIHILATION ---
      IF ((AMAS .GE. 0.0) .OR. (KPART .LE. 14)) GO TO 13
      ANNI=1.3*P
      IF (ANNI .GT. 0.4) ANNI=0.4
      CALL GRNDM(RNDM,1)
      TEST=RNDM(1)
      IF (TEST .GT. ANNI) GO TO 35
C
C *** PARTICLE WITH ENERGY BELOW CUT-OFF ***
C --- ==> ONLY NUCLEAR EVAPORATION AND QUASI-ELASTIC SCATTERING ---
 13   CONTINUE
C
      ISTOP=3
C
      IF (NPRT(9)) PRINT 1002,KPART,EK,EN,P,ENP(5),ENP(6),ENP(7)
 1002 FORMAT(' *GHEISH* ENERGY BELOW CUT-OFF FOR GHEISHA PARTICLE ',I3/
     $ ' EK,EN,P,ENP(5),ENP(6),ENP(7) = ',6(G12.5,1X))
C
      IF ((KPART .NE. 14) .AND. (KPART .NE. 16)) GO TO 14
      IF (KPART .EQ. 16) GO TO 86
C
C --- SLOW PROTON ---
 85   CONTINUE
      IF (NPRT(9)) PRINT 2003,EK,KPART
 2003 FORMAT(' *GHEISH* ROUTINE NUCREC WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL NUCREC(NOPT,2)
C
      IF (NOPT .NE. 0) GO TO 50
C
      IF (NPRT(9)) PRINT 2004,EK,KPART
 2004 FORMAT(' *GHEISH* ROUTINE COSCAT WILL BE CALLED',
     $ ' EK = ',G12.5,' GEV  KPART = ',I3)
      CALL COSCAT
      GO TO 40
C
C --- SLOW NEUTRON ---
 86   CONTINUE
      IF (NPRT(9)) PRINT 2015
      NUCFLG=0
      CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- OTHER SLOW PARTICLES ---
 14   CONTINUE
      IPA(1)=KPART
C --- DECIDE FOR PROTON OR NEUTRON TARGET ---
      IPA(2)=16
      CALL GRNDM(RNDM,1)
      TEST1=RNDM(1)
      TEST2=ZNO2/ATNO2
      IF (TEST1 .LT. TEST2) IPA(2)=14
      AVERN=0.0
      NFL=1
      IF (IPA(2) .EQ. 16) NFL=2
      IPPP=KPART
      IF (NPRT(9)) PRINT 2005
 2005 FORMAT(' *GHEISH* ROUTINE TWOB WILL BE CALLED')
      CALL TWOB(IPPP,NFL,AVERN)
      GOTO 40
C
C --- INITIALISATION OF CASCADE QUANTITIES ---
 35   CONTINUE
C
C *** CASCADE GENERATION ***
C --- CALCULATE FINAL STATE MULTIPLICITY AND LONGITUDINAL AND ---
C --- TRANSVERSE MOMENTUM DISTRIBUTIONS ---
C
C --- FIXED PARTICLE TYPE TO STEER THE CASCADE ---
      KKPART=KPART
C
C --- NO CASCADE FOR LEPTONS ---
      IF (KKPART .LE. 6) GO TO 9999
C
C *** WHAT TO DO WITH "NEW PARTICLES" FOR GHEISHA ?????? ***
C --- RETURN FOR THE TIME BEING ---
      IF (KKPART .GE. 35) GO TO 9999
C
C --- CASCADE OF HEAVY FRAGMENTS
      IF ((KKPART .GE. 30) .AND. (KKPART .LE. 32)) GO TO 390
C
C --- INITIALIZE THE IPA ARRAY ---
      CALL VZERO(IPA(1),MXGKCU)
C
C --- CASCADE OF OMEGA - AND OMEGA - BAR ---
      IF (KKPART .EQ. 33) GO TO 330
      IF (KKPART .EQ. 34) GO TO 331
C
      NVEPAR=KKPART-17
      IF (NVEPAR .LE. 0) GO TO 15
      GO TO (318,319,320,321,322,323,324,325,326,327,328,329),NVEPAR
C
 15   CONTINUE
      NVEPAR=KKPART-6
      GO TO (307,308,309,310,311,312,313,314,315,316,317,318),NVEPAR
C
C --- PI+ CASCADE ---
 307  CONTINUE
      IF (NPRT(9)) PRINT 2006
 2006 FORMAT(' *GHEISH* ROUTINE CASPIP WILL BE CALLED')
      CALL CASPIP(J,INT,NFL)
      GO TO 40
C
C --- PI0 ==> NO CASCADE ---
 308  CONTINUE
      GO TO 40
C
C --- PI- CASCADE ---
 309  CONTINUE
      IF (NPRT(9)) PRINT 2007
 2007 FORMAT(' *GHEISH* ROUTINE CASPIM WILL BE CALLED')
      CALL CASPIM(J,INT,NFL)
      GO TO 40
C
C --- K+ CASCADE ---
 310  CONTINUE
      IF (NPRT(9)) PRINT 2008
 2008 FORMAT(' *GHEISH* ROUTINE CASKP WILL BE CALLED')
      CALL CASKP(J,INT,NFL)
      GO TO 40
C
C --- K0 CASCADE ---
 311  CONTINUE
      IF (NPRT(9)) PRINT 2009
 2009 FORMAT(' *GHEISH* ROUTINE CASK0 WILL BE CALLED')
      CALL CASK0(J,INT,NFL)
      GO TO 40
C
C --- K0 BAR CASCADE ---
 312  CONTINUE
      IF (NPRT(9)) PRINT 2010
 2010 FORMAT(' *GHEISH* ROUTINE CASK0B WILL BE CALLED')
      CALL CASK0B(J,INT,NFL)
      GO TO 40
C
C --- K- CASCADE ---
 313  CONTINUE
      IF (NPRT(9)) PRINT 2011
 2011 FORMAT(' *GHEISH* ROUTINE CASKM WILL BE CALLED')
      CALL CASKM(J,INT,NFL)
      GO TO 40
C
C --- PROTON CASCADE ---
 314  CONTINUE
      IF (NPRT(9)) PRINT 2012
 2012 FORMAT(' *GHEISH* ROUTINE CASP WILL BE CALLED')
      CALL CASP(J,INT,NFL)
      GO TO 40
C
C --- PROTON BAR CASCADE ---
 315  CONTINUE
      IF (NPRT(9)) PRINT 2013
 2013 FORMAT(' *GHEISH* ROUTINE CASPB WILL BE CALLED')
      CALL CASPB(J,INT,NFL)
      GO TO 40
C
C --- NEUTRON CASCADE ---
 316  CONTINUE
      NUCFLG=0
      IF (EK .GT. SWTEKN) THEN
         CALL CASN(J,INT,NFL)
         IF (NPRT(9)) PRINT 2014
 2014 FORMAT(' *GHEISH* ROUTINE CASN WILL BE CALLED')
      ELSE
         CALL GNSLWD(NUCFLG,INT,NFL,TEKLOW)
         IF (NPRT(9)) PRINT 2015
 2015 FORMAT(' *GHEISH* ROUTINE GNSLWD WILL BE CALLED')
      ENDIF
      IF (NUCFLG .NE. 0) GO TO 50
      GO TO 40
C
C --- NEUTRON BAR CASCADE ---
 317  CONTINUE
      IF (NPRT(9)) PRINT 2016
 2016 FORMAT(' *GHEISH* ROUTINE CASNB WILL BE CALLED')
      CALL CASNB(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA CASCADE ---
 318  CONTINUE
      IF (NPRT(9)) PRINT 2017
 2017 FORMAT(' *GHEISH* ROUTINE CASL0 WILL BE CALLED')
      CALL CASL0(J,INT,NFL)
      GO TO 40
C
C --- LAMBDA BAR CASCADE ---
 319  CONTINUE
      IF (NPRT(9)) PRINT 2018
 2018 FORMAT(' *GHEISH* ROUTINE CASAL0 WILL BE CALLED')
      CALL CASAL0(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + CASCADE ---
 320  CONTINUE
      IF (NPRT(9)) PRINT 2019
 2019 FORMAT(' *GHEISH* ROUTINE CASSP WILL BE CALLED')
      CALL CASSP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 ==> NO CASCADE ---
 321  CONTINUE
      GO TO 40
C
C --- SIGMA - CASCADE ---
 322  CONTINUE
      IF (NPRT(9)) PRINT 2020
 2020 FORMAT(' *GHEISH* ROUTINE CASSM WILL BE CALLED')
      CALL CASSM(J,INT,NFL)
      GO TO 40
C
C --- SIGMA + BAR CASCADE ---
 323  CONTINUE
      IF (NPRT(9)) PRINT 2021
 2021 FORMAT(' *GHEISH* ROUTINE CASASP WILL BE CALLED')
      CALL CASASP(J,INT,NFL)
      GO TO 40
C
C --- SIGMA 0 BAR ==> NO CASCADE ---
 324  CONTINUE
      GO TO 40
C
C --- SIGMA - BAR CASCADE ---
 325  CONTINUE
      IF (NPRT(9)) PRINT 2022
 2022 FORMAT(' *GHEISH* ROUTINE CASASM WILL BE CALLED')
      CALL CASASM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 CASCADE ---
 326  CONTINUE
      IF (NPRT(9)) PRINT 2023
 2023 FORMAT(' *GHEISH* ROUTINE CASX0 WILL BE CALLED')
      CALL CASX0(J,INT,NFL)
      GO TO 40
C
C --- XI - CASCADE ---
 327  CONTINUE
      IF (NPRT(9)) PRINT 2024
 2024 FORMAT(' *GHEISH* ROUTINE CASXM WILL BE CALLED')
      CALL CASXM(J,INT,NFL)
      GO TO 40
C
C --- XI 0 BAR CASCADE ---
 328  CONTINUE
      IF (NPRT(9)) PRINT 2025
 2025 FORMAT(' *GHEISH* ROUTINE CASAX0 WILL BE CALLED')
      CALL CASAX0(J,INT,NFL)
      GO TO 40
C
C --- XI - BAR CASCADE ---
 329  CONTINUE
      IF (NPRT(9)) PRINT 2026
 2026 FORMAT(' *GHEISH* ROUTINE CASAXM WILL BE CALLED')
      CALL CASAXM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - CASCADE ---
 330  CONTINUE
      IF (NPRT(9)) PRINT 2027
 2027 FORMAT(' *GHEISH* ROUTINE CASOM WILL BE CALLED')
      CALL CASOM(J,INT,NFL)
      GO TO 40
C
C --- OMEGA - BAR CASCADE ---
 331  CONTINUE
      IF (NPRT(9)) PRINT 2028
 2028 FORMAT(' *GHEISH* ROUTINE CASAOM WILL BE CALLED')
      CALL CASAOM(J,INT,NFL)
      GO TO 40
C
C --- HEAVY FRAGMENT CASCADE ---
 390  CONTINUE
      IF (NPRT(9)) PRINT 2090
 2090 FORMAT(' *GHEISH* ROUTINE CASFRG WILL BE CALLED')
      NUCFLG=0
      CALL CASFRG(NUCFLG,INT,NFL)
      IF (NUCFLG .NE. 0) GO TO 50
C
C *** CHECK WHETHER THERE ARE NEW PARTICLES GENERATED ***
 40   CONTINUE
      IF ((NTOT .NE. 0) .OR. (KKPART .NE. KPART)) GO TO 50
C
C --- NO SECONDARIES GENERATED AND PARTICLE IS STILL THE SAME ---
C --- ==> COPY EVERYTHING BACK IN THE CURRENT GEANT STACK ---
      NGKINE=0
      TOFG=TOFG+TOF*0.5E-10
C --- In case of crazy momentum value ==> no change to GEANT stack ---
      IF (P .LT. 0.) GO TO 41
      VECT(4)=PX
      VECT(5)=PY
      VECT(6)=PZ
      VECT(7)=P
      GETOT=EN
      GEKIN=EK
C --- CHECK KINETIC ENERGY ---
      CALL GEKBIN
      EDEP=ABS(ENOLD-EN)
      RMASSI=EN-EK
      IF (NPRT(9) .AND. (EN .GT. ENOLD))
     $ PRINT 8888,EDEP,ENOLD,EN,EK,RMASSI
 8888 FORMAT(' *GHEISH* EDEP,ENOLD,EN,EK,M = ',5(G12.5,1X)/
     $ ' *GHEISH* =======> EDEP WOULD BE NEGATIVE <========')
      IF (ISTOP .EQ. 0) DESTEP=DESTEP+EDEP
C
C --- RE-INITIALIZE THE PROBABILITY FOR HADRONIC INTERACTION ---
 41   CONTINUE
      CALL GRNDM(RNDM,1)
      IF ((RNDM(1) .LE. 0.) .OR. (RNDM(1) .GE. 1.)) GO TO 41
      ZINTHA=-LOG(RNDM(1))
      SLHADR=SLENG
      STEPHA=1.0E10
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1003,NTOT,IPART,KPART,KKPART,NVEDUM
 1003 FORMAT(' *GHEISH* NO SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X)/
     $ ' CURRENT PARTICLE ON THE STACK AGAIN')
      GO TO 9999
C
C *** CURRENT PARTICLE IS NOT THE SAME AS IN THE BEGINNING OR/AND ***
C *** ONE OR MORE SECONDARIES HAVE BEEN GENERATED ***
 50   CONTINUE
C
      NVEDUM=KIPART(IPART)
      IF (NPRT(9)) PRINT 1004,NTOT,IPART,KPART,KKPART,NVEDUM
 1004 FORMAT(' *GHEISH* SEC. GEN. NTOT,IPART,KPART,KKPART,KIPART = ',
     $ 5(I3,1X))
C
C --- INITIAL PARTICLE TYPE HAS BEEN CHANGED ==> PUT NEW TYPE ON ---
C --- THE GEANT TEMPORARY STACK ---
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((KPART .NE. 11) .AND. (KPART .NE. 12)) GO TO 52
      CALL GRNDM(RNDM,1)
      KPART=11.5+RNDM(1)
C
 52   CONTINUE
      ITY=IKPART(KPART)
      LNVE=LQ(JPART-ITY)
      IF (LNVE .LE. 0) PRINT 1234,NTOT,ITY,LNVE
 1234 FORMAT('0*GHEISH* 1234 NTOT,ITY,LNVE = ',3(I10,1X))
      IF (LNVE .LE. 0) STOP
      IF (ISTOP .EQ. 0) ISTOP=1
C
C --- IN CASE THE NEW PARTICLE IS A NEUTRINO ==> FORGET IT ---
      IF (KPART .EQ. 2) GO TO 60
C
C --- PUT PARTICLE ON THE STACK ---
      GKIN(1,1)=PX*P
      GKIN(2,1)=PY*P
      GKIN(3,1)=PZ*P
      GKIN(4,1)=SQRT(P*P+RMASS(KPART)**2)
      GKIN(5,1)=ITY
      TOFD(1)=TOF*0.5E-10
      NGKINE = 1
      GPOS(1,1) = VECT(1)
      GPOS(2,1) = VECT(2)
      GPOS(3,1) = VECT(3)
C
      IF (NPRT(9)) PRINT 1005,ITY,NGKINE
 1005 FORMAT(' *GHEISH* GEANT PART. ',I3,' PUT ONTO STACK AT POS. ',I3)
C
C *** CHECK WHETHER SECONDARIES HAVE BEEN GENERATED AND COPY THEM ***
C *** ALSO ON THE GEANT STACK ***
 60   CONTINUE
C
C --- ALL QUANTITIES ARE TAKEN FROM THE GHEISHA STACK WHERE THE ---
C --- CONVENTION IS THE FOLLOWING ---
C
C EVE(INDEX+ 1)= X
C EVE(INDEX+ 2)= Y
C EVE(INDEX+ 3)= Z
C EVE(INDEX+ 4)= NCAL
C EVE(INDEX+ 5)= NCELL
C EVE(INDEX+ 6)= MASS
C EVE(INDEX+ 7)= CHARGE
C EVE(INDEX+ 8)= TOF
C EVE(INDEX+ 9)= PX
C EVE(INDEX+10)= PY
C EVE(INDEX+11)= PZ
C EVE(INDEX+12)= TYPE
C
      IF (NTOT .LE. 0) GO TO 9999
C
C --- ONE OR MORE SECONDARIES HAVE BEEN GENERATED ---
      DO 61 L=1,NTOT
      INDEX=(L-1)*12
      JND=EVE(INDEX+12)
C
C --- MAKE CHOICE BETWEEN K0 LONG / K0 SHORT ---
      IF ((JND .NE. 11) .AND. (JND .NE. 12)) GO TO 63
      CALL GRNDM(RNDM,1)
      JND=11.5+RNDM(1)
C
C --- FORGET ABOUT NEUTRINOS ---
 63   CONTINUE
      IF (JND .EQ. 2) GO TO 61
C
C --- SWITH TO GEANT QUANTITIES ---
      ITY=IKPART(JND)
      JTY=LQ(JPART-ITY)
      IF (JTY .LE. 0) PRINT 1235,NTOT,ITY,JTY
 1235 FORMAT('0*GHEISH* 1235 NTOT,ITY,JTY = ',3(I10,1X))
      IF (JTY .LE. 0) STOP
*     ITRT=Q(JTY+6)
      PLX=EVE(INDEX+9)
      PLY=EVE(INDEX+10)
      PLZ=EVE(INDEX+11)
      ELT=SQRT(PLX*PLX+PLY*PLY+PLZ*PLZ+Q(JTY+7)**2)
C
C --- ADD PARTICLE TO THE STACK IF STACK NOT YET FULL ---
      IF (NGKINE .GE. MXGKIN) THEN
          WRITE(CHMAIL,1236) NTOT, L
 1236     FORMAT(' *** GHEISH: ',I9,' particle produced but only ',
     +           I9,' put on the GEANT stack!')
          CALL GMAIL(1,1)
          GO TO 9999
      ENDIF
      NGKINE=NGKINE+1
      GKIN(1,NGKINE)=PLX
      GKIN(2,NGKINE)=PLY
      GKIN(3,NGKINE)=PLZ
      GKIN(4,NGKINE)=ELT
      GKIN(5,NGKINE)=ITY
      TOFD(NGKINE)=EVE(INDEX+8)*0.5E-10
      GPOS(1,NGKINE) = VECT(1)
      GPOS(2,NGKINE) = VECT(2)
      GPOS(3,NGKINE) = VECT(3)
C
      IF (NPRT(9)) PRINT 1006,ITY,NGKINE,L,(EVE(INDEX+J),J=1,12)
 1006 FORMAT(' *GHEISH* GEANT PART. ',I3,' ALSO PUT ONTO STACK AT',
     $ ' POS. ',I3/
     $ ' EVE(',I2,') = '/12(1H ,12X,G12.5/))
C
 61   CONTINUE
C
 9999 CONTINUE
C --- LIMIT THE VALUE OF NGKINE IN CASE OF OVERFLOW ---
      NGKINE=MIN(NGKINE,MXGKIN)
      END
+DECK,GCALOR.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  1.04/08 31/08/95  12.01.02  by  Christian Zeitnitz
*-- Author : Christian Zeitnitz
      SUBROUTINE GCALOR
********************************************************************
*                                                                  *
* PURPOSE: GEANT interface to CALOR                                *
*                                                                  *
* CALLED BY : GUHADR                                               *
*                                                                  *
* INPUT :  particle, material, and probabilities via GEANT common  *
*                                                                  *
* OUTPUT : COMMON GCKING, DESTEP                                   *
*          KCALL  = -1  : Nothing done                             *
*                 =  0  : NMTC has been called                     *
*                 =  1  : MICAP has been called                    *
*                 =  2  : HETC/SKALE has been called               *
*                 =  3  : FLUKA has been called                    *
*                                                                  *
* AUTHOR : C.Zeitnitz (University of Arizona)                      *
*                                                                  *
********************************************************************
C.
C. --- GEANT Commons
+SEQ,GCBANK
+SEQ,GCJLOC
+SEQ,GCKINE
+SEQ,GCKING
+SEQ,GCMATE
+SEQ,GCPHYS
+SEQ,GCTRAK
+SEQ,GSECTI
+SEQ,GCONST
+SEQ,GCCUTS
+SEQ,GCFLAG
C --- CALOR - GEANT Interface common
+SEQ,CALGEA
+SEQ,CERRCM
+SEQ,CAMASS
C
C  Avogadro number multiplied by 1.E-24
      PARAMETER(XNAVO = 0.60221367)
C
      DIMENSION NNPART(12)
      LOGICAL INIT,GOFLUK,DOSKAL,FMICAP,SKALEF,NABSOR,FSTOP
      DOUBLE PRECISION DECIN,DMASS
C
      DATA INIT /.TRUE./
      SAVE INIT
C
      IF ( INIT ) THEN
C
C     initialize CALOR
         CALL CALINI
C
         INIT = .FALSE.
C
      ENDIF
      KCALL = -1
C
C get CALOR particle type
      IPINC = -1
      IF(IPART .LE. 48 )  IPINC = IGECAL(IPART)
+SELF,IF=CDEBUG1
C
      PRINT *,' GCALOR: Call CALOR - IPART=',IPART,' GEKIN=',GEKIN
+SELF.
C
C energy in MeV
 
      EINC   =GEKIN * 1000.0
      UINC(1)=VECT(4)
      UINC(2)=VECT(5)
      UINC(3)=VECT(6)
      KCASE=NAMEC(12)
      NGKINE = 0
      NABSOR = .FALSE.
      FSTOP = .FALSE.
C ----- particle has to be stopped ? -------
      IF(GEKIN.LT.CUTHAD.AND.ITRTYP.EQ.4) THEN
+SELF,IF=CDEBUG
C          particle = Pi- => Pi- capture marked by energy of 1 MeV
         IF(IPART.EQ.9) PRINT *,' GCALOR: PI- capture selected '
+SELF.
         FSTOP = .TRUE.
         ISTOP = 2
         IF(IPART .EQ. 9) THEN
            NABSOR = .TRUE.
            ISTOP = 1
            EINC = 1.0
            IF(GEKIN.GT.EINC/1000.) DESTEP = DESTEP + GEKIN - EINC/
     +      1000.0
            GEKIN = 0.0
            VECT(7) = 0.0
            KCASE = NAMEC(18)
            NMEC = NMEC + 1
            LMEC(NMEC) = 18
         ELSE
            DESTEP = DESTEP + GEKIN
            GEKIN = 0.0
            VECT(7) = 0.0
            IF(IPART.EQ.8.OR.IPART.EQ.11.OR.IPART.EQ.12) THEN
              CALL GDECAY
              KCASE = NAMEC(5)
              NMEC = NMEC + 1
              LMEC(NMEC) = 5
            ENDIF
            RETURN
         ENDIF
      ELSE IF(GEKIN.LT.CUTNEU.AND.IPART.EQ.13) THEN
         IF(GEKIN.LT.1.E-14) EINC=1.E-11
         ISTOP = 1
         NABSOR = .TRUE.
      ENDIF
      IF(ISTOP.EQ.2.OR.GEKIN.EQ.0.0) RETURN
C
C ------------- check if FLUKA has to be called ---------
C ------------------------------------------------- Goto FLUKA ?
C
      DOSKAL = (IPINC.EQ.0 .OR. IPINC.EQ.1) .AND. GEKIN.GT.EMAXP
      DOSKAL = DOSKAL .OR. (GEKIN .GT. EMAXPI .AND. (IPINC .GT. 1))
      IF(ICPROC.GE.0) THEN
         GOFLUK = ICPROC.EQ.3 .OR. IPINC.EQ.-1
         DOSKAL = DOSKAL .AND. ICPROC.EQ.2
      ELSE
         GOFLUK = IPINC .EQ. -1 .OR. GEKIN .GE. ESKALE
         DOSKAL = DOSKAL .AND. .NOT.GOFLUK
         GOFLUK = GOFLUK .OR. (DOSKAL.AND.SKALEF(IPINC,GEKIN,ESKALE))
         GOFLUK = GOFLUK .AND. .NOT.FSTOP .AND. .NOT.NABSOR
      ENDIF
      ICPROC = -1
C ------------------------------------------- call FLUKA
      IF(GOFLUK) THEN
+SELF,IF=CDEBUG1
         PRINT *,' CALL FLUKA '
+SELF.
         CALL FLUFIN
         KCALL = 3
         RETURN
      ENDIF
      CERRF = .FALSE.
      IF(IPINC .EQ. 1 .AND. EINC .LE. 20.0) THEN
C MICAP needs only GEANT material number
         NCEL = NMAT
C --- low energetic neutron -> call micap
+SELF,IF=MDEBUG
         PRINT *,' CALL MICAP '
+SELF.
         CALL MICAP
         KCALL = 1
      ELSE
         NCEL = 1
         AMED(1) = A
         ZMED(1) = Z
         DMED(1) = DENS/A*XNAVO
         IF(INT(A) .EQ. 1) THEN
            HDEN = DMED(1)
         ELSE
            HDEN = 0.0
         ENDIF
C ------- get material parameter for a mixture---------------------
         KK=MIN1(ABS(Q(JMA+11)),100.)
         NCEL = 1
         IF(KK.GT.1) THEN
            HDEN = 0.0
            NCEL = 0
            AMOL = Q(LQ(JMIXT-1) + 2)
            DO 10 K=1,KK
               IF(NINT(Q(JMIXT+K)).EQ.1) THEN
C                           hydrogen density
                  XMOLCM = DENS/AMOL*XNAVO
                  WI = Q(JMIXT+K+2*KK)*AMOL/Q(JMIXT+K)
                  HDEN = HDEN + XMOLCM * WI
               ELSE
                  NCEL = NCEL + 1
                  AMED(NCEL) = Q(JMIXT+K)
                  ZMED(NCEL) = Q(JMIXT+K+KK)
C                                        molekuls/cm^3
                  XMOLCM = DENS/AMOL*XNAVO
C                                     number of atoms per molecule
                  WI = Q(JMIXT+K+2*KK)*AMOL/AMED(NCEL)
C                                        atoms/cm^3
                  DMED(NCEL) = XMOLCM * WI
               ENDIF
+SELF,IF=CDEBUG
               PRINT '('' GCALOR: A('',I5,'')='',F7.2,'' Z='',F7.2,    '
     +         //'                '' WI='',F7.3,'' DEN='',F7.3,'' Hden='
     +         //''',F7.3)', K,AMED(K),ZMED(K),WI,DMED(K),HDEN
+SELF.
   10       CONTINUE
         ENDIF
+SELF,IF=CDEBUG1
C --- call hetc -----
         PRINT *,' CALL HETC '
+SELF
         CALL CHETC(DOSKAL)
         KCALL = 0
         IF(DOSKAL) KCALL = 2
      ENDIF
C error ocurred in CALOR ?
      IF(CERRF) THEN
         WRITE(IERRU,'('' NEVT,IPART,Ek,NMED,ISTOP,NABSOR,FSTOP :'',   '
     +   //'          I10,I5,G15.6,2I6,2L6)') IEVENT,IPART,GEKIN,NMAT,
     +   ISTOP,NABSOR,FSTOP
      ENDIF
+SELF,IF=CDEBUG1
C
C ---------------- store secondaries ---------------
C
      PRINT *,' AFTER CALOR NPART=',NPHETC
+SELF.
      ESUM =0.
      EKSUM = 0.
      PX = 0.
      PY = 0.
      PZ = 0.
      NGKINE = 0
      PSUM = 0.
C
      ZINTHA=GARNDM(6)
      SLHADR=SLENG
      STEPHA=BIG
C
      IF(NPHETC.EQ.0.AND.NABSOR) ISTOP = 2
C neutron has been absorbed -> INTCAL=18
      IF(INTCAL.EQ.18) ISTOP = 1
      IF(NPHETC.LE.0) GOTO 160
C
C too many particles in the CALOR array for GEANT
C happens sometimes with deexitation gammas and evaporation neutrons
C simple approach to combine particles and sum up their energies, but
C forget about momentum conservation
C
      IF(NPHETC.GT.MXGKIN) THEN
   20    CONTINUE
         DO 30 I=1,12
            NNPART(I)=0
   30    CONTINUE
         NNTOT = 0
         DO 40 I=1,NPHETC
            IF(IPCAL(I).NE.-1) THEN
               NNPART(IPCAL(I)+1)=NNPART(IPCAL(I)+1)+1
               NNTOT = NNTOT + 1
            ENDIF
   40    CONTINUE
         IF(NNTOT.LE.MXGKIN) GOTO 100
         JMAX=0
         IMAX=0
         DO 50 I=1,12
            IF(JMAX.LT.NNPART(I)) THEN
               JMAX=NNPART(I)
               IPI=I-1
            ENDIF
   50    CONTINUE
         DO 60 I=1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 70
   60    CONTINUE
   70    I1=I
         DO 80 I=I1+1,NPHETC
            IF(IPCAL(I).EQ.IPI) GOTO 90
   80    CONTINUE
   90    I2=I
         ECINI = EKINET(I1)
         DMASS = DBLE(XMASS(IPI))*1.D3
         DECIN = DBLE(ECINI)
         PPI = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         IPJ = IPCAL(I2)
         ECINJ = EKINET(I2)
         DECIN = DBLE(ECINJ)
         PPJ = SNGL(DSQRT(DECIN*DECIN + 2.D0*DECIN*DMASS))
         ECIN = SNGL(DBLE(ECINI)+DBLE(ECINJ)+DMASS)
         EKINET(I1) = ECIN
         PP = SNGL(DSQRT(DBLE(ECIN*ECIN) + 2.D0*DBLE(ECIN)*DMASS))
C determine new direction cosines
         UCAL(I1,1) = (PPI*UCAL(I1,1)+PPJ*UCAL(I2,1))/PP
         UCAL(I1,2) = (PPI*UCAL(I1,2)+PPJ*UCAL(I2,2))/PP
         UCAL(I1,3) = (PPI*UCAL(I1,3)+PPJ*UCAL(I2,3))/PP
         USUM = SQRT(UCAL(I1,1)**2+UCAL(I1,2)**2+UCAL(I1,3)**2)
C normalize direction cosines
         IF(USUM.LT.0.0001) THEN
C direction is isotropic distributed
            CALL AZIRN(SINA,COSA)
            COSP = SFLRAF(DUM)
            SINP = SQRT(1.0-COSP*COSP)
            UCAL(I1,1) = SINP * COSA
            UCAL(I1,2) = SINP * SINA
            UCAL(I1,3) = COSP
         ELSE
            UCAL(I1,1) = UCAL(I1,1)/USUM
            UCAL(I1,2) = UCAL(I1,2)/USUM
            UCAL(I1,3) = UCAL(I1,3)/USUM
         ENDIF
C particle I2 vanished
         IPCAL(I2)=-1
         GOTO 20
C end of particle combination
  100    CONTINUE
C sort particles
         I2=NPHETC
         DO 120 I = 1,NPHETC
            IF(I.GE.I2) GOTO 130
            IF(IPCAL(I).EQ.-1) THEN
               DO 110 J = I2,I,-1
                  IF(IPCAL(J).NE.-1) THEN
                     IPCAL(I) = IPCAL(J)
                     EKINET(I) = EKINET(J)
                     UCAL(I,1) = UCAL(J,1)
                     UCAL(I,2) = UCAL(J,2)
                     UCAL(I,3) = UCAL(J,3)
                     I2 = J-1
                     GOTO 120
                  ENDIF
  110          CONTINUE
            ENDIF
  120    CONTINUE
  130    CONTINUE
         NPHETC=MXGKIN
      ENDIF
C
      IF(INTCAL.LT.1.OR.INTCAL.GT.30) INTCAL=12
      KCASE = NAMEC(INTCAL)
      IF(INTCAL.NE.12) THEN
        NMEC = NMEC + 1
        LMEC(NMEC) = INTCAL
      ENDIF
      DO 140 I=1,NPHETC
         IP=IPCAL(I)
         IGPART=ICALGE(IP)
         IF ( IGPART.EQ.0 ) THEN
            PRINT*,'>>> ERROR GCALOR: Particle type ',IP, ' not '
     +      //'implemented in GEANT'
            GOTO 140
         ENDIF
+SELF,IF=CDEBUG1
         PRINT *,' GCALOR after CALOR: IP=',IGPART,' Ekin=',EKINET(I)
+SELF.
C
C store particle
         ECIN = EKINET(I)/1000.0
         IF(ECIN.LT.1.E-15) GOTO 140
         DECIN = DBLE(ECIN)
         DMASS = DBLE(XMASS(IP))
         PP = SNGL(DSQRT(DECIN*DECIN + 2.0D0*DECIN*DMASS))
+SELF,IF=CDEBUG,MDEBUG
         IF(IP.GE.2.AND.IP.LE.4) THEN
           ESUM = ESUM + ECIN + XMASS(IP)
         ELSE
           ESUM = ESUM + ECIN
         ENDIF
         EKSUM = EKSUM + ECIN
+SELF.
         PX = PX + PP*UCAL(I,1)
         PY = PY + PP*UCAL(I,2)
         PZ = PZ + PP*UCAL(I,3)
+SELF,IF=CDEBUG,MDEBUG
         PRINT '('' IP,Ek,Px,Py,Pz ='',I4,4(1X,E15.7))',
     +          IGPART,ECIN,PX,PY,PZ
+SELF.
C generated particle eq incoming
         IF(NPHETC.EQ.1 .AND. IGPART.EQ.IPART) THEN
            VECT(4) = UCAL(I,1)
            VECT(5) = UCAL(I,2)
            VECT(6) = UCAL(I,3)
            VECT(7) = PP
            GEKIN = ECIN
            GETOT = SNGL(DECIN + DMASS)
            TOFG = TOFG + CALTIM(I)
            ISTOP = 0
            IF(NABSOR) ISTOP = 2
            GOTO 160
         ENDIF
C
         NGKINE=NGKINE+1
         GKIN(1,NGKINE) = PP*UCAL(I,1)
         GKIN(2,NGKINE) = PP*UCAL(I,2)
         GKIN(3,NGKINE) = PP*UCAL(I,3)
C the total energy is critical for ECIN below 1.E-8 GeV because of
C single precision of GKIN (normalization when mass is added)!!
C luckely GEANT does use only the momentum components when storing the
C particle on the stack.
         GKIN(4,NGKINE) = SNGL(DECIN+DMASS)
         GKIN(5,NGKINE) = FLOAT(IGPART)
         TOFD(NGKINE)   = CALTIM(I)
         GPOS(1,NGKINE) = VECT(1)
         GPOS(2,NGKINE) = VECT(2)
         GPOS(3,NGKINE) = VECT(3)
         IF(NGKINE.GE.MXGKIN) GOTO 150
C
  140 CONTINUE
  150 CONTINUE
C particle lost its identity
      ISTOP=1
  160 CONTINUE
+SELF,IF=CDEBUG,MDEBUG
      EPREC = AMED(1)*0.93149432
      PIX = VECT(4)*VECT(7)
      PIY = VECT(5)*VECT(7)
      PIZ = VECT(6)*VECT(7)
      ESUM = ESUM + ERMED(1)/1000. + AMASS
      PSUM = SQRT((PX-PIX)**2 + (PY-PIY)**2 + (PZ-PIZ)**2)-
     +       SQRT((EPREC+ERMED(1)/1000.)**2 -EPREC**2)
      PRINT '('' AFTER INTERACTION: Einc,Pinc = '',2F7.3,
     + '' Ediff,Pdiff='',2F7.3)',GETOT,VECT(7),
     + GETOT-ESUM,  PSUM
+SELF.
C
C
      NGKINE = MIN(NGKINE,MXGKIN)
C
C score kinetic energy of recoil nucleus (given in MeV)
CZ      DESTEP = DESTEP + ERMED * 1.E-3
  170 RETURN
      END
+DECK,GFMFIN.
*CMZ :          16/12/97  14.29.01  by  Pavel Nevski
*CMZ :  3.21/02 29/03/94  15.41.47  by  S.Giani
*-- Author :
      SUBROUTINE GFMFIN
+SEQ,GCBANK.
+SEQ,GCCUTS.
+SEQ,GCJLOC.
+SEQ,GCFLAG.
+SEQ,GCKINE.
+SEQ,GCKING.
+SEQ,GCMATE.
+SEQ,GCPHYS.
+SEQ,GCTRAK.
+SEQ,GSECTI.
+SEQ,GCTMED.
+SEQ,GCUNIT.
+SEQ,DIMPAR.
 
+SEQ,FINUCT,IF=-SINGLE
+SEQ,FINUC.
      REAL RNDM(1)
+SELF, IF=-SINGLE
      DOUBLE PRECISION AOCMBM, AMSS , ZTAR, RHO , ZLIN, ZLEL, ZLRAD,
     +ZUL
+SELF
      COMMON / FKMAPA / AOCMBM (MXXMDF), AMSS (MXXMDF), ZTAR   (MXXMDF),
     +                  RHO    (MXXMDF), ZLIN (MXXMDF), ZLEL   (MXXMDF),
     +                  ZLRAD  (MXXMDF), ZUL  (MXXMDF), MEDIUM (MXXRGN),
     +                  MULFLG (MXXMDF),IFCOMP(MXXMDF), MSSNUM (MXXMDF),
     +                  NREGS, NMATF, MTBSNM
+SEQ,PART2T,IF=-SINGLE
+SEQ,PART2.
+SEQ,COMCONT,IF=-SINGLE
+SEQ,COMCON.
+SEQ,FHEAVYT,IF=-SINGLE
+SEQ,FHEAVY.
+SEQ,PAPROP.
+SEQ,PAPROPT,IF=-SINGLE
+SEQ,GFKDIS.
+SELF, IF=-SINGLE
      DOUBLE PRECISION POO,EKE,TXI,TYI,TZI,AMM,WE,ONE,PGEANT,DMOD
+SELF
      PARAMETER (ONE=1)
      DIMENSION IGTOFL(49),IFLTOG(39),IHVTOG(6),ZSAMP(50)
      DATA IGTOFL / 0, 0, 0, 0, 0, 0,23,13,14,12, 15,16, 8, 1, 2,19, 0,
     +17,21,22, 20, 34, 36, 38, 9,18, 31, 32, 33, 35, 37, 39, 17*0/
 
      DATA IFLTOG /14,15, 3, 2, 4, 4, 1,13,25, 5, 6,10, 8, 9,11,12,18,
     +26,16,21, 19,20, 7, 7*0, 27, 28, 29, 22, 30, 23, 31, 24, 32/
      DATA IHVTOG /13,14,45,46,49,47/
*
      NP = 0
      NPHEAV = 0
*
*    Stopped particles:
*    o Neutral particles are sent to GHSTOP
*    o pi+ and K+/K- are forced to decay
*    o pi-, antiprotons and antineutrons are sent to FLUKA
*      for annihilation (not here but later in this routine)
      IF (IGF.EQ.2.OR.(GEKIN.EQ.0.0.AND.IPART.EQ.13)) THEN
         IF (GEKIN.LT.CUTNEU) THEN
            GEKIN = MAX(GEKIN,1E-14)
* should kinetic energy be deposited?
            ISTOP = 2
            IGF = 0
            GOTO 110
         ENDIF
         CALL GMICAP
         IGF = 0
         GOTO 110
      ELSE IF (GEKIN.EQ.0..AND.
     +        (IPART.EQ.8.OR.IPART.EQ.12.OR.IPART.EQ.11)) THEN
         CALL GDECAY
         NMEC=NMEC+1
         LMEC(NMEC)=5
         ISTOP=1
         GOTO 999
      ENDIF
*
      IF (IFINIT(5) .EQ. 0) CALL FLINIT
      INT=0
      IJ=IGTOFL(IPART)
      IF(IJ.EQ.0) GOTO 110
      NMEC = NMEC + 1
      EKE = GEKIN
      TXI = VECT(4)
      TYI = VECT(5)
      TZI = VECT(6)
      DMOD = ONE/SQRT(TXI**2+TYI**2+TZI**2)
      TXI = TXI*DMOD
      TYI = TYI*DMOD
      TZI = TZI*DMOD
      WE  = 1.
      JMA = LQ(JMATE-NMAT)
      NCOMP = ABS (Q(JMA+11))
      AMM = Q(JMA+6)
      JMIXT = LQ(JMA-5)
 
*    Antiprotons, antineutrons and pi- are sent to
*    eventv for annihilation
      IF (GEKIN.EQ.0..AND.
     +         (IPART.EQ.15.OR.IPART.EQ.9.OR.IPART.EQ.25)) THEN
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            ZSAMP(1) = 0.
            DO 10 I=1,NCOMP
               ZSAMP(I+1) = ZSAMP(I) + Q(JMIXT+NCOMP+I)
   10       CONTINUE
            CALL GRNDM(RNDM,1)
            ZCONT=ZSAMP(NCOMP+1)*RNDM(1)
            DO 20 I=1,NCOMP
               IF(ZCONT.LE.ZSAMP(I+1)) GO TO 30
   20       CONTINUE
            I = NCOMP
   30       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         EKE = 1E-9
         POO=SQRT(EKE*(EKE+2*AM(IJ)))
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
         GOTO 80
      ELSE IF (GEKIN.LE.CUTHAD .AND. ITRTYP.EQ.4) THEN
         DESTEP = DESTEP + GEKIN
         GEKIN  = 0.
         GETOT  = AMASS
         VECT(7) = 0.
         ISTOP = 1
         GO TO 110
      ENDIF
*
      CALL GRNDM(RNDM,1)
      RNDEVT=RNDM(1)
      IF ( RNDEVT .GE. SINE/FSIG) THEN
 
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            GO TO 110
         END IF
         INT=1
         LMEC(NMEC)=13
         IF(NCOMP.LE.1) THEN
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,AMM,WE)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ELXNOR*RNDM(1)
            DO 40  I=1,NCOMP
               IF(RCONT.LE.CABELX(I)) GO TO 50
   40       CONTINUE
            I=NCOMP
   50       CONTINUE
            CALL NUCREL(IJ,POO,EKE,TXI,TYI,TZI,ONE*Q(JMIXT+I),WE)
         END IF
      ELSE
         LMEC(NMEC)=20
         IF (IHADR.EQ.2) THEN
            ISTOP = 2
            DESTEP = DESTEP + GETOT
            GO TO 110
         ENDIF
         IF (GEKIN .GT. 0.02) THEN
            POO=SQRT(EKE*(EKE+2*AM(IJ)))
         ELSE
            IF ((IJ.EQ.2 .OR. IJ.EQ.9 .OR. IJ.EQ.14 .OR. IJ.EQ.16)
     +            .AND. GEKIN .GT. 0.0) THEN
               POO=SQRT(EKE*(EKE+2*AM(IJ)))
            ELSE
               NMEC=NMEC-1
               GO TO 110
            END IF
         END IF
         INT=2
         IF(NCOMP.LE.1) THEN
            AMSS(1) = Q(JMA+6)
            ZTAR(1) = Q(JMA+7)
            MSSNUM(1) = 0
            RHO(1) = Q(JMA+8)
         ELSE
            CALL GRNDM(RNDM,1)
            RCONT=ANXNOR*RNDM(1)
            DO 60  I=1,NCOMP
               IF(RCONT.LE.CABINX(I)) GO TO 70
   60       CONTINUE
            I=NCOMP
   70       CONTINUE
            AMSS(1)   = Q(JMIXT+I)
            MSSNUM(1) = 0
            ZTAR(1)   = Q(JMIXT+NCOMP+I)
            RHO(1)    = Q(JMIXT+2*NCOMP+I)*DENS
         END IF
         CALL EVENTV(IJ,POO,EKE,TXI,TYI,TZI,WE,1)
      END IF
*
   80 IF(NP.EQ.1.AND.NPHEAV.EQ.0.AND.KPART(1).EQ.IJ) THEN
         VECT(4)=CXR(1)
         VECT(5)=CYR(1)
         VECT(6)=CZR(1)
         VECT(7)=SQRT(TKI(1)*(TKI(1)+2*AMASS))
         GETOT=TKI(1)+AMASS
         GEKIN=TKI(1)
      ELSE
         ISTOP=1
         NSTAK1 = MIN(NP,MXGKIN-NGKINE)
         IF(NP.GT.NSTAK1) THEN
            WRITE(CHMAIL,10000) NP-NSTAK1
            CALL GMAIL(0,0)
         ENDIF
         DO 90  K=1,NSTAK1
            NGKINE = NGKINE + 1
            IF (KPART(K) .EQ. 24 .OR. KPART(K) .EQ. 25) THEN
               KPART(K) = 19
               CALL GRNDM(RNDM,1)
               IF (RNDM(1) .GT. 0.5) KPART(K) = 12
            END IF
            IGEPAR = IFLTOG(KPART(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKI(K)*(TKI(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXR(K)*PGEANT
            GKIN(2,NGKINE)=CYR(K)*PGEANT
            GKIN(3,NGKINE)=CZR(K)*PGEANT
            GKIN(4,NGKINE)=TKI(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
   90    CONTINUE
*
         NSTAK2 = MIN(NPHEAV,MXGKIN-NGKINE)
         IF(NPHEAV.GT.NSTAK2) THEN
            WRITE(CHMAIL,10100) NPHEAV-NSTAK2
            CALL GMAIL(0,0)
         ENDIF
         DO 100 K=1,NSTAK2
            NGKINE = NGKINE + 1
            IGEPAR = IHVTOG(KHEAVY(K))
            JPA = LQ(JPART-IGEPAR)
            AGEMAS = Q(JPA+7)
            PGEANT = SQRT(TKHEAV(K)*(TKHEAV(K)+2*AGEMAS))
            GKIN(1,NGKINE)=CXHEAV(K)*PGEANT
            GKIN(2,NGKINE)=CYHEAV(K)*PGEANT
            GKIN(3,NGKINE)=CZHEAV(K)*PGEANT
            GKIN(4,NGKINE)=TKHEAV(K)+AGEMAS
            GKIN(5,NGKINE)=IGEPAR
            TOFD(NGKINE)=0.0
            GPOS(1,NGKINE) = VECT(1)
            GPOS(2,NGKINE) = VECT(2)
            GPOS(3,NGKINE) = VECT(3)
  100    CONTINUE
*
         KCASE=NAMEC(12)
      END IF
  110 CONTINUE
      ZINTHA = GARNDM(DUMMY)
      SLHADR = SLENG
      STEPHA = 1.0E10
10000 FORMAT(' **** FLUFIN: Stack overflow, ',I6,' particles lost')
10100 FORMAT(' **** FLUFIN: Stack overflow, ',I6,
     +' heavy particles lost')
  999 END
