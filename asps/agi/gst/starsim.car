+PATCH,ATGEANT. ================================================================
*CMZ :  1.00/00 19/12/95  09.59.57  by  G. Poulard
+DECK,AxCOMPONENT,T=geant. ====================================================
*CMZ :  1.30/00 16/07/96  23.30.40  by  Pavel Nevski
*CMZ :  1.00/00 12/04/95  19.53.08  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x C o m p o n e n t
*                                                                    *
*  Description:  introduce a componenet of a new mixture             *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCUNIT.
 Integer LENOCC
 " check %W>0; "
 If (%z>0) %Za=%z;
 IF %NLmat>=10 { error('NO more place to store a component of the mixture') }
 %NLmat+=1; %AA(%NLmat)=%A; %ZZ(%NLmat)=%Za; %WW(%NLmat)=%W;
   END
 
+DECK,AxMIXTURE,T=geant. -------------------------------------------------------
*CMZ :  1.30/00 21/07/96  15.36.42  by  Pavel Nevski
*CMZ :  1.00/00 05/05/95  20.15.51  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x M i x t u r e
*                                                                    *
*  Description:  introduce a new mixture, reset medium number   	     *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
  Integer      AgSMATE,LENOCC,Imixt,N,i,jma;
  Real         SW,a(20),z(20),w(20),Par(10);
  Character*4  Cmate,Cmodu;
 
  Call Vzero(Par,10);
  %Material=%Title;  Imixt=AgSMATE(%Material,JMATE,Par);
  Cmate=%Material;   Cmodu=%Module;
 
  N=0;  do i=1,%Nlmat  { if (%WW(i)>0) N+=1; };   Par={0,0,%Dens,0,0,N};
  if Imixt<0 & Cmate#Cmodu & Cmodu#' '
  {  %Material=Cmodu//'_'//%Title; Imixt=AgSMATE(%Material,JMATE,Par); }
 
  %Medium=%Material;   %Imed=-1;   %Imat=abs(Imixt);
  If Imixt<0
  {  SW=0; N=0;  do i=1,%Nlmat
     {check %WW(i)>0; N+=1; SW+=%WW(i); a(N)=%aa(i); z(N)=%ZZ(i); W(N)=%WW(i)}
     If SW<=0 {error('Mixture undefined')};   if (SW>1.5)  N=-N;
     prin1  %L(%Material),%Imat,%Dens,N,(%aa(i),%zz(i),%ww(i),i=1,%NLmat);
     (' GSMIXT   for mixture ',A,' used Imat=',I3,
      ' Density=',F5.2,' NLmat=',i2/(10x,'A,Z,W =',3F10.3));
     Call GSMIXT (%Imat, %Material, A, Z, %Dens, N, W);
  }
  Jma=LQ(JMATE-%Imat);  %A   = Q(Jma+6);     %Z  = Q(Jma+7);
                       %RadL = Q(Jma+9);    %AbsL = Q(Jma+10);
                       %NLMAT= 0;
   END
 
+DECK,AxMATERIAL,T=geant. ------------------------------------------------------
*CMZ :  1.00/00 23/02/95  01.10.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x M a t e r i a l
*                                                                    *
*  Description:  introduce a new material, reset medium number       *
*  New material in a module is always prefixed by the module name    *
*  A request without parameters does not introduce new material      *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
    Integer     AgSMATE,LENOCC,Im;
    Character   Cmate*4,Cmodu*4,Material*20;
    Real        PAR(10);
 
 If(%z>0) %Za=%z;     Call Vzero(Par,10);
 %Material=%Title;    Cmate=%Material;   Cmodu=%Module;
 If %ParList#'NONE'  { PAR={%A,%Za,%Dens,%Radl,%ABSL}; }
 
 Im=AgSMATE (%Material,JMATE,Par);           " first check for a global "
 if Im<0 & Cmate#Cmodu & Cmodu#' '           " then for a local material"
 {  %Material=Cmodu//'_'//%Title;  Im=AgSMATE(%Material,JMATE,Par); }
 
 %Medium=%Material;   %Imed=-1;   %Imat=abs(Im);
 if Im<0
 { If %Parlist='NONE'  {error('Undefined material requested',%Title)}
   prin1  %L(%Material),%Imat,%A,%Za,%Dens,%RADL,%ABSL;
   (' GSMATE   called with for material ',A,' produces Imat =',I3/,
      10x, 'A,Z,D,x0,l0 =',5E11.4);
    Call GSMATE(%Imat,%Material,%A,%Za,%Dens,%RADL,%ABSL,%UBUF,%NWBUF);
 }
 Else If %Parlist='NONE'
 {  Call GFMATE(%Imat, Material,%A,%Za,%Dens,%RADL,%ABSL,%UBUF,%NWBUF); }
  END
 
+DECK,AxMEDIUM,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 02/04/97  15.00.54  by  Pavel Nevski
*CMZ :  1.00/00 27/02/95  15.31.04  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x M e d i u m
*                                                                    *
*  Description:  introduce parameters of a new GEANT tracking medium *
*  Direct call always sets the medium name and fetchs its parameters *
*  In the STANDARD module it can introduce a new media in the table  *
*  The real medium is introduced at the SHAPE operator only,         *
*  otherwise initial medium inherits a wrong material (tested!)      *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
    Integer      AgSMATE,LENOCC,Im,Imed,Imat,Ifield
    Character    Medium*20,Cmedi*4,Cmodu*4
    Real         Par(10)
*
 %Medium=%Title;     Cmedi=%Medium;   Cmodu=%Module;  Ifield=%Ifield*%Imfld
 PAR={0,%IsVol, Ifield,%Fieldm,%TmaxFD, %SteMax,%DeeMax,%Epsil,%Stmin, 0};
 
 Im=AgSMATE (%Medium,JTMED,Par);              " first check for a global "
 If Im<=0 & Cmedi#Cmodu & Cmodu#' '           " then for a local medium  "
 {  %Medium=Cmodu//'_'//%Title;  Im=AgSMATE(%Medium,JTMED,Par);  }
 
 Imed=abs(Im); %Imed=-1;
 If Im<0
 {  %Imed = Imed
    " If %Parlist='NONE' {error('Undefined medium requested',%Title)} "
    prin1       %L(%MEDIUM), %Imed, %Imat, %ISVOL,   IFIELD, %FIELDM, %TMAXFD,
                                           %STEMAX, %DEEMAX, %EPSIL,  %STMIN
                (' AGSTMED  for medium ',A,' med,mat,sen,fld =',2i4,2i2/,
                               10x ,'Field = ',2F5.1,'  steps = ',4F8.5)
    Call GSTMED (%Imed, %MEDIUM, %IMAT,   %ISVOL,  IFIELD, %FIELDM, %TMAXFD,
                        %STEMAX, %DEEMAX, %EPSIL, %STMIN,  %UBUF,   %NWBUF)
 }
 else if %Parlist='NONE'
 {  Call GFTMED ( Imed,  Medium,  Imat,   %Isvol, %IFIELD, %FIELDM, %TMAXFD,
                        %STEMAX, %DEEMAX, %EPSIL, %STMIN,  %UBUF,   %NWBUF)
 }
  END
 
+DECK,AxSHAPE,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 06/01/95  22.24.20  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x S H A P E
*                                                                    *
*  Description:  a dispatch routine to do GSDIV, GSVOLU              *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM.
 
    %Shape=%Title;  %Ishape=0;
    if %Imed<=0        {   Call AgSMedi;   check %Imed    >0; }
    If %Shape = 'DIVI' {   Call AgSDIVI;   Check %Ivolume >0; }
    else               {   Call AgSHAPE;   Check %Ishape  >0;
                           Call AgSVOLU;   Check %Ivolume >0; }
    %Istatus=1;            Call AxATTRIBUTE;
   END
 
+DECK,AxATTRIBUTE,T=geant. -----------------------------------------------------
*CMZ :  1.30/00 28/04/96  20.12.52  by  Pavel Nevski
*CMZ :  1.00/00 21/03/95  22.40.41  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x A T T R I B U T E
*                                                                    *
*  Description:  set volume attributes for GEANT                     *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCFLAG.
 character*4 ATTname(6) /'WORK','SEEN','LSTY','LWID','COLO','FILL'/; Integer i;
 Integer     is,ig;
 Check  %Istatus>0;
 Do i=1,6
 {  if (%attribute(i)#%MAGIC) Call GSATT (%Cnick,ATTname(i),%attribute(i)); }
 If %IGRAP>1
 {  is=1;  Ig=%IGRAP-%LEVEL;
    if(Ig<0) is=-1; if(Ig>2) is=0; Call GSATT(%Cnick,'SEEN',is);
 }
 END
 
+DECK,AxPOSITION,T=geant. ------------------------------------------------------
*CMZ :  1.30/00 21/11/96  19.48.44  by  Pavel Nevski
*CMZ :  1.00/00 06/08/95  14.04.27  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A x P O S I T I O N
*                                                                    *
*  Description:  make GSPOS or GSPOSP                                *
*  Modifications:                                     28.07.95 - PLN *
*  - Start with the mother volume checking to allow fake positioning *
*    divisions.   No checks are done yet for an errenious            *
*    normal volume positioning at the same level as divisions ...    *
*  - 14.11.96 PN+SB: Ncopy can be passed throu AGECOM in both ways   *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM.
  Character*4 Daughter,Daught;            Real Vdist,D,V
  Integer  LENOCC,Idaught,Ivd,Jvd,Ivo,Jvo,Ign,Ir,Jvm,Ivm,
           Npo,Npa,Jmo,in,nin,Ncopy,Id,Jd,Jg,IDH,IDM
 
* search for the mother, if it is explicitely defined, and check it.
  If %Ivolume<=0 | %Mother!=%Volume
  {  %Cnick=%Mother;  Call GLOOK(%Mother,IQ(JVOLUM+1),Nvolum,%Ivolume);
     If %Ivolume<=0
     {  If %Level>0  {error('mother volume does not exist')};
        <w> %Mother; (' Warning: Volume ',a4,' does not exist'); Return;
     }
     Jvm=LQ(JVOLUM-%Ivolume); Ivm=IQ(Jvm-5); IDM=IQ(Jvm-4);
     IF IDM==IQ(JVOLUM+%Ivolume) & 1<=Ivm&Ivm<=Nvolum
     { %Ivolume=Ivm; call UHTOC(IQ(JVOLUM+Ivm),4,%Cnick,4); }
  }  Jmo=LQ(JVOLUM-%Ivolume); nin=Q(Jmo+3);
  Check "that it has no divisions " nin>=0
 
* get Active volume number from the generic bank IDN word;
  Daughter=%Title;  Call GLOOK (Daughter,IQ(JVOLUM+1),Nvolum,Ivd);
  If Ivd<=0   {error('daughter ',Daughter,' does not exist ')};
  " generic daughter "  IDH=IQ(JVOLUM+Ivd); Jvd=LQ(JVOLUM-Ivd);
  Ivo=IQ(Jvd-5);  If Ivo<=0 {error('Actual daughter does not exist ')};
  " its nickname "  Idaught=IQ(JVOLUM+Ivo); Jvo=LQ(JVOLUM-Ivo);
  " and number   "  Ign=0;    If (Ivd#Ivo)  Ign=IQ(Jvo-5);
 
* get actual rotation and may be shape parameters
  %Ishape=Q(Jvo+2);  Npo=Q(Jvo+5);  Npa=0;
  Call AgSROTM " - it may cause bank relocation, links should be reaccessed !"
  If Npo=0
  {  Call AgSHAPE;      Npa=%Npar;
     If %Npar=0  {error('Can not position undefined Volume ',Daughter)}
  }
 
* set copy number(generic) and avoid content (actual name!) dublication
  Ncopy=1;  Jmo=LQ(JVOLUM-%Ivolume);
  do in=1,abs(nin)
  {  Jd=LQ(Jmo-in); "its content"Id=Q(Jd+2); "and address"Jg=LQ(JVOLUM-Id);
     "count copies of generic name"    Check IDH=IQ(Jg-4); Ncopy+=1;
     " dont position same volumes "    Check Idaught=IQ(JVOLUM+Id);
     " at the same place and angle"    Ir=Q(jd+4); d=Vdist(%x,Q(Jd+5),3); v=0;
                                       if (Npo=0) V=Vdist(%Par,Q(jd+10),Npa);
                                       if (d=0 & V=0 & Ir=%Irot)  Return;
  }
  If (%Ncopy>0) Ncopy=%Ncopy;  %Ncopy=Ncopy;
  Call UHTOC(Idaught,4,Daught,4);   Call CLTOU (%KONLY);
  If Npo>0 { Call GSPOS (Daught,Ncopy,%CNick,%X,%Y,%Z,%Irot,%KONLY); }
  else     { Call GSPOSP(Daught,Ncopy,%CNick,%X,%Y,%Z,%Irot,%KONLY,
                                                         %PAR, %NPAR);  }
  prin1 Daught,Daughter,%CNick,%Volume,%x,%y,%z,
        %Level,Ncopy,Npa,%IROT,Ivd,Ivo,nin;
  (' POSITION',2(1x,A4),'  into',2(1x,A4),' at x,y,z=',3f9.3/_
  10x,'level',i3,'  Ncopy',i4,' with Npar,Irot=',2i4,' Ivdau,Ivact=',3I5);
   END
 
 
+DECK,AgSVOLU,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 02/04/97  15.21.45  by  Pavel Nevski
*CMZU:  1.00/01 30/11/95  19.31.02  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S V O L U
*                                                                    *
*  Description: On SHAPE returns Ivolume, actual Npar and Npo of the *
*  existing GEANT volume or creates and returns the new volume number*
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM,GCONST.
Integer     Name,LENOCC,Ivo,Jvo,IDH,Npo,Npa,i,JATTF,Jj,Jat
real        eps/1.e-6/,P(50),Tth,Phi,Ph
JATTF(Jj) = Jj+int(Q(Jj+5))+6
*
* Toggle the actual Npa = 0 | NPar
  Npa=0;  Do I=1,%Npar { if (%Par(i)#0) Npa=%Npar; }
  Call UCTOH(%Volume,Name,4,4);  %Ignum=-1;
  If %IMED<=0 {error(' Medium  in  ',%Volume,' not defined')};
 
* if the top level volume has a hole, its inner radius(radii) is reset to 0:
   if Nvolum==0
   {  If %Ishape==5 | %Ishape==6 | %Ishape==9 { %Par(1)=0 " - TUBE,TUBS,SPHE"}
      If %Ishape==7 | %Ishape==8   { %Par(2)=0; %Par(4)=0 " - CONE,CONS     "}
      If %Ishape==11  {  do i=1,nint(%PAR(4)) { %Par(3*i+3)=0 }  " - PGON   "}
      If %Ishape==12  {  do i=1,nint(%PAR(3)) { %Par(3*i+2)=0 }  " - PCON   "}
   }
* If the volume has been defined with the same dimensions, return %Ivolume;
  :volume: Do %Ivolume=1,NVOLUM
  { "take next volum's IDs "       Jvo=LQ(JVOLUM-%Ivolume);   IDH=IQ(Jvo-4);
    "Select same generic names"  check IDH==Name;   "and count them" %Ignum+=1;
    "Now check that parameters are the same, otherwise search for another copy"
    "Undefined volumes with Npa=0  will fit any other volume "
     Npo=Q(Jvo+5);     Jat=JATTF(Jvo);
     If %Ishape=4 | %Ishape=10      "      special cases in Geant 3.21     "
     {  Call Ucopy(%Par,P,min(%Npar,30));
        IF %ISHAPE=4                "        Trapezoid    "
        {  TTH =TAN(P(2)*DEGRAD);   PHI  =P(3)*DEGRAD;
           P(2)=TTH*COS(PHI);       P(3) =TTH*SIN(PHI)
           P(7)=TAN(P(7)*DEGRAD);   P(11)=TAN(P(11)*DEGRAD)
        }
        ELSE IF %ISHAPE=10   " Parallelepiped - change angles to tangents. "
        {  P(4)=TAN(P(4)*DEGRAD);   TTH=TAN(P(5)*DEGRAD);  PH=P(6)*DEGRAD;
           P(5)=TTH*COS(PH);        P(6)=TTH*SIN(PH)
        }
        Do I=1,min(Npo,Npa)
        {  If (abs(P(i)-Q(Jvo+6+i))>eps*abs(P(i)+Q(Jvo+6+i))) Next :volume:; }
     }  Else
     {  Do I=1,min(Npo,Npa)        { If (%Par(i)#Q(Jvo+6+i))  Next :volume:; }
     }
    "Do I=1,6             { If(%Attribute(i)#nint(Q(Jat+i)))  Next :volume:; }"
    "This is an existing volume, use it! If Npo==0, we will need to GSPOSP it"
     if (%Serial=nint(Q(Jat+10)) & %Imed=nint(Q(Jvo+4)))      goto :done:
  }
 
* make a new volume always at the end of the volume list
   %Ignum+=1;  Call AgSNAME(%Volume,%Ignum,%Cnick)
   Call GSVOLU(%Cnick, %Shape, %Imed, %Par, Npa, %Ivolume)
   prin1 %Volume,%Cnick,%Shape,%Imed,%Ivolume,Npa,(%Par(i),i=1,Npa)
  (' AGSVOLU: Name/shape ',3(A4,2x),' Imed,Iv,Np=',3I5/(10x,'Par=',10F8.2))
   If %Ivolume<NVOLUM {error(' error defining GEANT volume ',%Volume)}
*
  "set also volume generic name and number in IDH & IDN , Idtype "
   Jvo=LQ(JVOLUM-%Ivolume); IQ(Jvo-4)=Name; IQ(Jvo-5)=%Ignum;
   Jat=JATTF(Jvo);  Q(Jat+9)=%IdType;  Q(Jat+10)=%Serial;
:done:
* save Active volume number in the generic bank status word;
  Call GLOOK (%Volume,IQ(JVOLUM+1),Nvolum,Ivo);  Jvo=LQ(JVOLUM-Ivo);
  IQ(Jvo-5)=%Ivolume;  Call UHTOC(IQ(JVOLUM+%Ivolume),4,%CNICK,4);
   END
 
+DECK,AgSDIVI,T=geant. ---------------------------------------------------------
*CMZU:  1.00/01 30/11/95  23.54.58  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S D I V I
*                                                                    *
*  Description: make volume division according to actual parameters  *
*                                                                    *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM.
 Character   Fun*6,Mother*4
 Integer     LENOCC,Name,Nick,Nin,Jmo,Jvd,Ndm,JATTF,Jj,Jat
 JATTF(Jj) = Jj+int(Q(Jj+5))+6
*
 Call UCTOH(%Volume,Name,4,4)
 Call UHTOC(IQ(JVOLUM+%Imother),4,Mother,4)
 Jmo=LQ(JVOLUM-%Imother);  nin=Q(Jmo+3);
 If nin>0  { error('Volume has daughters, division impossible')}
 If nin<0  { %Ivolume=Q(LQ(Jmo-1)+2);       Jvd=LQ(JVOLUM-%Ivolume);
             If IQ(Jvd-4)#NAME  { error('bad name of an existing division')}
             Call UHTOC(IQ(JVOLUM+%Ivolume),4,%CNICK,4)
             %Ignum=IQ(Jvd-5);              Return;
           }
 %Ignum=0;
 Do %Ivolume=1,NVOLUM { If(IQ(LQ(JVOLUM-%Ivolume)-4)=Name) %Ignum+=1; }
 Call AgSNAME (%Volume,%Ignum,%CNick)
*
  Ndm=%NdvMax;
  If      %C0=0 & %Ndiv#0
  { Fun='GSDVN';  Call GSDVN (%Cnick,Mother,%Ndiv,%Iaxis )}
  else If %C0=0 & %Step#0
  { Fun='GSDVT';  Call GSDVT (%Cnick,Mother,%Step,%Iaxis,%Imed,Ndm)}
  else If %C0#0 & %Ndiv#0 & %Step#0
  { Fun='GSDVX';  Call GSDVX (%Cnick,Mother,%Ndiv,%Iaxis,%Step,%C0,%Imed,Ndm)}
  else If %C0#0 & %Ndiv#0
  { Fun='GSDVN2'; Call GSDVN2(%Cnick,Mother,%Ndiv,%Iaxis,%C0,%Imed)}
  else If %C0#0 & %Step#0
  { Fun='GSDVT2'; Call GSDVT2(%Cnick,Mother,%Step,%Iaxis,%C0,%Imed,Ndm)}
  else { error('missing parameters to make a division ')}
*
  Call UCTOH(%Cnick,Nick,4,4)
  If IQ(JVOLUM+Nvolum)#Nick {error('can not find newly created division ')}
  "set also volume generic name and number in IDH & IDN, and IdType "
  %Ivolume=NVOLUM; Jvd=LQ(JVOLUM-%Ivolume)
  IQ(Jvd-4)=NAME;  IQ(Jvd-5)=%Ignum;
  Jat=JATTF(Jvd);  Q(jat+9)=%IdType;  Q(jat+10)=%Serial;
  prin1 Mother,%Cnick,%L(%Volume),%Ignum,Fun
  (' AGSDIVI: mother ',A4,' divided into ',A4,2x,A4,'(',i3,') using ',A6)
  END
 
 
+DECK,AgSHAPE,T=geant. ---------------------------------------------------------
*CMZ :          02/12/97  18.46.06  by  Pavel Nevski
*CMZ :  1.00/00 12/12/94  22.30.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S H A P E
*                                                                    *
*  Description: given SHAPE or ISHAPE  returns its code/name and     *
*               parameters                                           *
*  Modifications:                                                    *
*  A.Dellacqua 27.02.97: CTUB parameters introduced                  *
**********************************************************************
+CDE,TYPING,AGECOM,GCUNIT.
Replace[;#?#;]    with  [[SETR a=0];    IF %Shape=='#1' {;#2=>Par;};          ]
Replace[;#,#=>#;] with  [{IF} [EXIST 1] {[INCR a]; %#3([COPY a])=%#1; #2,=>#3;}
                         {ELSE} {; %Npar=[COPY a]; }            ]
 
 Integer  LENOCC,Is,I,K; Character*4  ShapS(30);
 Data ShapS /'BOX ','TRD1','TRD2','TRAP','TUBE','TUBS','CONE','CONS','SPHE',
      'PARA','PGON','PCON','ELTU','HYPE',  13 * '    ','GTRA','CTUB','    '/;
 
 If %Ishape<=0  { Do Is=1,30 { IF %SHAPE==ShapS(Is)  { %Ishape=Is; Break;} } }
 If %Ishape<=0  { error(' Undefined shape ',%SHAPE)}   %Shape=ShapS(%Ishape);
 
 Box  ?  dx,dy,dz;
 Trd1 ?  dx1,dx2, dy,dz;
 Trd2 ?  dx1,dx2, dy1,dy2, dz;
 Trap ?  dz,thet,phi, h1,bl1,tl1,alp1, h2,bl2,tl2,alp2;
 Tube ?  Rmin,Rmax,Dz;
 Tubs ?  Rmin,Rmax,Dz, Phi1,Phi2;
 Cone ?  Dz, Rmn1,Rmx1, Rmn2,Rmx2;
 Cons ?  Dz, Rmn1,Rmx1, Rmn2,Rmx2, phi1,phi2;
 Sphe ?  Rmin,Rmax, The1,The2, Phi1,Phi2;
 Para ?  Dx,Dy,Dz,  Alph,Thet,Phi;
 Pgon ?  Phi1,Dphi,Npdiv,Nz;
 Pcon ?  Phi1,Dphi,      Nz;
 Eltu ?  P1, P2, Dz;
 Hype ?  Rmin,Rmax,Dz,Thet;
 Gtra ?  Dz,Thet,Phi,Twis, h1,bl1,tl1,alp1, h2,bl2,tl2,alp2;
 Ctub ?  Rmin,Rmax,Dz, Phi1,Phi2, Lx,Ly,Lz,Hx,Hy,Hz;
 
 If %Shape=='PGON' | %Shape=='PCON'
 { k=%Npar; %Npar+=3*%Nz;  do i=1,%Nz
   { %Par(3*i+k-2)=%zi(i); %Par(3*i+k-1)=%rmn(i); %Par(3*i+k)=%rmx(i);}
 }
   END
 
+DECK,AgSROTM,T=geant. ---------------------------------------------------------
*CMZ :          05/06/97  12.19.59  by  Pavel Nevski
*CMZ :  1.30/00 13/03/96  21.37.15  by  Pavel Nevski
*CMZ :  1.00/00 12/12/94  22.30.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
************************************************************************
*                                                                      *
                    Subroutine   A g S R O T M
*                                                                      *
* Description:  Given the rotation parameters returns matrix number    *
  Replace [;#,#=>#;] with [;rot(#3)=%#1; IF(abs(rot(#3)-#2)>eps) k+=1; ]
************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
  Real Rrot,Rot(6),Rota(6),eps/1.e-5/
  Integer k,Im,i,Nlink,JTM,ii
  rrot(ii)=rot(mod(2*%OrtI+ii-1,6)+1)
*
  k=0;  %Irot=0;
  Thetax+%Alfay,90 => 1;   Thetay+%Alfax,90 => 3;   Thetaz+%Alfax+%Alfay,0 => 5;
  Phix + %Alfaz, 0 => 2;   Phiy + %Alfaz,90 => 4;   Phiz                ,0 => 6;
        " correct for phi uncertainty "  If  %Alfax#0  { %Phiz=90; rot(6)=90; }
  check  k>0 | %Orti>0
  %Irot=1;   Do i=1,6 { Rota(i)=RRot(i) }
  IF JROTM>0    " find an old matrix or the first free slot (or the end) "
  {  Nlink=IQ(JROTM-2);  :matrix: DO  Im=1,Nlink+1
     {  %Irot=Im;  JTM=LQ(JROTM-Im);   IF (JTM<=0 | Im>Nlink)  Break
        Do i=1,6 { If (Rota(i)#Q(JTM+10+i)) Next :Matrix:; };  Return
  }  }
        " Free slot for a new rotation matrix"
  Call GSROTM(%IRot,Rota(1),Rota(2),Rota(3),Rota(4),Rota(5),Rota(6))
  prin1 (Rota(i),i=1,6); (' NEW ROTM theta,phi=',3(F8.1,F6.1))
  END
 
 
 
+DECK,AgSMATE,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 03/02/95  14.29.31  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
              Function     A g S M A T E (CNAME,LINK,Par)
*                                                                    *
*  Description: find the media or the first free slot (or the  end)  *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
     Integer       AgSMATE,NAME(5),LINK,Nlink,Im,JTM,i,Np;
     Character*20  CNAME;
     Real          Par(10);
 
 IF LINK<=0  { AgSMATE =-1;  Return "book first medium at slot 1"; }
;
 Call UCTOH(CNAME,NAME,4,20);  Nlink=IQ(LINK-2);
 NP=6; If (LINK=JTMED) NP=5;
 :Media: DO  Im=1,Nlink+1
 {  JTM=LQ(LINK-Im);    IF (JTM<=0 | Im>Nlink)  Break;
    Do i=1,5  { If ( NAME(i) # IQ(JTM+i) )      Next :Media:; };
    Do i=1,Np { If (0#PAR(i)&Par(i)#Q(JTM+5+i)) Next :Media:; };
    AgSMATE=+Im; " <W> IM; (10x,'ITMED of existing medium ', I3);" return;
 }  AgSMATE=-Im; " <W> IM; (10x,'Free slot for a new medium',I3);" return;
   END
 
+DECK,AgSNAME,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.30.12  by  Pavel Nevski
*CMZU:  1.00/01 30/11/95  19.17.48  by  Pavel Nevski
*CMZ :  1.00/00 24/12/94  15.06.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
          Subroutine   A g S N A M E   (Volume,Ign,CNick)
*                                                                    *
*  Description:  generate a NickName for (Volume,Ign) instance       *
**********************************************************************
+CDE,TYPING,GCUNIT.
  Character*1 Symb
  Character*4 Volume,Cnick
  Integer     Ign,ii,i,j,k
 
 Cnick=Volume;  Unless 0<=Ign & Ign <=1368
{<W> Ign,Volume;(' AgSNAME: Bad volume number ',I5,' for Volume ',A); Return;}
  ii=Ign; do k=4,3,-1
  {  i=mod(ii,37);   ii=ii/37;   check i>0
     j=i+48;   If(i==10) j=48;   If(i>10) j=96+(i-10)
*     Cnick(k:k)=char(j)
     Call ITOCH(j,Symb,*:err:);   Cnick(k:k)=Symb
  }  :err:
   END
 
+DECK,AgSMEDI,T=geant. --------------------------------------------------------
*CMZ :  1.00/00 07/03/95  21.07.41  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A g S M e d i
*                                                                    *
*  Description:  introduce parameters of a new GEANT tracking medium *
*  Called from   AxSHAPE on a new material or medium parameters      *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
    Integer      AgSMATE,LENOCC,Imede,Ifield;
    Character    Cmedi*4,Cmodu*4;
    Real         Par(10);
 
 Cmedi=%Medium;   Cmodu=%Module;  Ifield=%Ifield * %IMFLD;
 if (Cmedi#Cmodu & Cmodu#' ')  %Medium=Cmodu//'_'//%Medium;
 PAR={%Imat,%IsVol,Ifield,%Fieldm,%TmaxFD,%SteMax,%DeeMax,%Epsil,%Stmin,0};
 
 Imede=AgSMATE(%Medium,JTMED,Par);  %IMED=abs(Imede);
 If Imede<0
 {  prin1       %L(%MEDIUM), %IMED, %Imat, %ISVOL,   IFIELD, %FIELDM, %TMAXFD,
                                           %STEMAX, %DEEMAX, %EPSIL,  %STMIN;
                (' AGSTMED  for medium ',A,' med,mat,sen,fld =',2i4,2i2/,
                               10x ,'Field = ',2F5.1,'  steps = ',4F8.5);
    Call GSTMED (%IMED, %MEDIUM, %IMAT,   %ISVOL,  IFIELD, %FIELDM, %TMAXFD,
                        %STEMAX, %DEEMAX, %EPSIL, %STMIN,  %UBUF,   %NWBUF);
 }
  END
 
+DECK,AgSDETV,T=geant. ---------------------------------------------------------
*CMZ :          28/03/98  23.09.07  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  15.03.50  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                Subroutine   A g S D E T V (title)
*                                                                    *
*  Description: for a given (SET,DET) create GEANT sensetive         *
*  detector with corresponding DETU user structure filled later.     *
* In a Geometry module global %iset,%idet are set only for the call  *
* when this set is created to allow next routine (Agsdetu) to store  *
* hit or digi definitions in DETU bank, otherwise they are set to 0. *
* Local Iset,Idet are save in attributes of each calling Nick volume.*
*    In a Digitisation module global %iset,%idet are set always,     *
*    to allow not only set creation, but a modification as well.     *
***GsDETv definition for DIGI erases Iset,Idet,Idtype in the volume. *
*  this is corrected by saving them in sdt and then restoring attrib.*
***If %Type is changed, a new copy of DETU bank is created and       *
* %iset/%idet are set to allow DETU filling in AgsDETH/AgSDETU       *
*                                                                    *
*  Called from users code at the beginning of the hit definition     *
* 16/05/96 PN: bug corrected in %JDU selection for USER bank change  *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCNUM.
   Character title*(*),Cdet*4,Cset*4,Cbank*4,T*1,Cpar*4
   Integer   LENOCC,JATTF,JV,J,Iset,Idet,Jdet,Iv,Js,Jd,JDN,JDU,
             NWHI/1000/,NWDI/1000/,Lcumu/15/
   Real      Sdt(3),Upar(%LDETU)" up to 15 levels of volumes and hits "
   JATTF(JV) = JV+int(Q(JV+5))+6
                            * * *
 " Set is always the same as 3 letters of the module name plus H or D "
 T=%EXNAME;  Cset=%Module(1:3)//T;  Cdet=Title;
 { %iset,%idet,Iset,Idet,Jdet,Iv }=0;
 If (Jset > 0)  Call GLOOK(Cset,IQ(JSET+1),IQ(JSET-1),Iset)
 If (Iset > 0)  JDET =LQ(JSET-ISET)
 If (Jdet > 0)  Call GLOOK(Cdet,IQ(JDET+1),IQ(JDET-1),Idet)
                            * * *
 If Iset<=0 | Idet<=0
 {  "              for digi, save previous volume set/det reference       "
    If (T='D') Call GLOOK (Cdet,IQ(JVOLUM+1), Nvolum, Iv)
    If (iv>0)  Call UCopy (Q(JATTF(LQ(JVOLUM-Iv))+7),sdt,3)
    Call GsDETv (Cset,Cdet,%Idtype,NWHI,NWDI,Iset,Idet)
    If Idet<=0|Iset<=0 {error(' can not define sensitive detector ',Title)}
    "              set empty hit or digi bank with maximum size           "
    Call Vzero (Upar,%LDETU)
    If (T='H') Call GsDETH (Cset,Cdet,Lcumu,Cpar,Upar,Upar,Upar)
    If (T='D') Call GsDETD (Cset,Cdet,Lcumu,Cpar,Upar)
    "              now set users bank - also with max.size                "
    Upar(1)=10;  Upar(8)=%Type;   Upar(9)=%Idtype;  Upar(10)=-1;
    Call GsDETU (Cset,Cdet,%LDETU,Upar); %Iset=Iset; %Idet=Idet;
*pn: 16/03/96 - to get nice bank NID reset it for the first bank
    JDU=LQ(LQ(LQ(Jset-Iset)-Idet)-3); Cbank=' ';
    If (JDU>0) Call UHTOC(IQ(JDU-4),4,Cbank,4)
    If Cbank!='SJDU' {error('can not create User Hit/Digi bank for',Cset,Cdet)}
    IQ(JDU-5)=1
 }
                            * * *
 If      %Module(5:5)='G' & T='H' " mark each volume with its HIT set/detector"
 {  j=JATTF(LQ(JVOLUM-%Ivolume)); Q(j+7)=Iset; Q(j+8)=Idet; Q(j+9)=%IdType; }
 else If %Module(5:5)='D' & T='D' " only digitisation re-definition accepted "
 { if(Iv>0) Call UCopy(sdt,Q(JATTF(LQ(JVOLUM-Iv))+7),3);%iset=Iset;%idet=Idet;}
 else       {error('HITS or DIGI can not be redefined for ',Cset,Cdet)}
 
                            * * *
 " find DETU bank with corresponding serial number and keep its link in %JDU "
 JS=LQ(JSET-Iset);  JD=LQ(JS-Idet);  JDU=LQ(JD-3);  %JDU=JDU;
 While Q(JDU+8)!=%Type & LQ(JDU)>0 { JDU=LQ(JDU);   %JDU=JDU; }
 If %Type!=Q(JDU+8)       " make a new user bank "
 {  Call MZBOOK(IxCons,JDN,JDU,0,'SJDU',0,0,%LDETU,3,0)
    If JDN<=0  {error(' cant create new copy of DETU bank ',%Type)}
    Call Ucopy (Q(JDU+1),Q(JDN+1),%LDETU);    Q(JDN+8)=%Type;
    %iset=Iset;  %idet=Idet;  %JDU=JDN;
 }
   END
 
 
+DECK,AgSDETH,T=geant. ---------------------------------------------------------
*CMZ :          15/02/98  12.51.45  by  Pavel Nevski
*CMZ :  1.30/00 16/04/96  19.12.28  by  Pavel Nevski
*CMZ :  1.00/00 02/06/95  02.20.02  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
***************************************************************************
*                                                                         *
                  Subroutine   A g S D E T H (IEXT)
*                                                                         *
*  Description:  fill the description of a new hit element in DETU.       *
*  In a digitization module a modification mode is also possible.         *
*  Final analyse is done by AggDETV and AggDETU called from AggCLOS.      *
*  This is done on the exit from a geometry module, when all volume       *
*  positionning is finished, or at the end of the DIGI operator           *
*  in a digitization module where positionning is already done.           *
*                Called from users code on each hit element               *
*  Possible hit options are:  C,H,X,R,S - see comments in the code        *
*  If hit code is undefined, an attempt is made to find 'codehit' routine *
*  It is supposed to have same arguments as any user step routine-(j,hit) *
*  Modifications:                                                         *
*  15feb97, PN: Allow less then 4 letters for a 'chit'HIT  routine        *
*                                                                         *
***************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCONST.
 Integer     CSADDR,LENOCC,IEXT,Ltab,Ioption,Jdu,Ia,N,Ja,i1,i2,Ifun,k,i,new
 Real        ARFROMC
 Parameter   (Ltab=27)
 Character   T*1, Hit*4, Ctab(Ltab)*4 _
            /'X','Y','Z','R','RR','PHI','THE','ETA','TDR','CT',
             'CX','CY','CZ','ETOT','ELOS','BIRK','STEP','LGAM',
             'TOF','USER','XX','YY','ZZ','PX','PY','PZ','SLEN'/
 
  Check %Idet>0 & %Iset>0 & %Jdu>0;
  " save next hit in DETU bank for a new structure marked by negative U(10) "
  JDU=%Jdu;  Ia=Q(Jdu+1);    N=Q(jdu+2);      Ja=Jdu+Ia+%NwuHit*N;
             Hit=%Parlist;   new=Q(Jdu+10);   T=%EXNAME;
                               * * *
  If new<0                                            " a new hit element "
  {  Ia=Q(Jdu+1);   N=Q(jdu+2);    Ja=Jdu+Ia+%NwuHit*N;
     If (N>=14)    {error('Can not store more hit elements ',N)};
     N+=1;          Q(jdu+2)=N;    Q(jdu+3)=Ia+%NwuHit*N;
     Call  Vzero(Q(Ja+1),10);
     Q(Ja+1)=ARFROMC(%ParList);    Q(Ja+2)=ARFROMC(%Option);
     Q(Ja+3)=%Nbits;   Q(Ja+4)=%FhMin;   Q(Ja+5)=%FhMax;
     If (%bin>0)       Q(Ja+7)=1/%bin;
     If (HIT='USER')   IQ(Ja+9)=IEXT;                " not exportable...   "
     Ifun=0;      k=Lenocc(Hit)                      " hit function code   "
     do i=1,Ltab  { Check Hit(1:k)==Ctab(i)(1:k);    Ifun=i;   break;      }
     If Ifun==0   { IQ(Ja+9)=CSADDR(HIT(1:k)//'HIT') }
*
     Q(Ja+10)=Ifun;  Ioption=Q(Jdu+7);               " global option setup "
     "option H used in AggDETU to mark the start of 'hit' field a la GEANT "
     "option R                 to require bin rounding up to 2 digits      "
     if (Index(%Option,'S')>0) Call SBIT1(Ioption,1) " single step option  "
     if (1 <=Ifun & Ifun<= 10) Call SBIT1(Ioption,2) " local coordinate rq "
     if (Index(%Option,'X')>0) Call SBIT1(Ioption,2) " same explicitly     "
     if (11<=Ifun & Ifun<= 13) Call SBIT1(Ioption,3) " local direction rq  "
     if (Index(%Option,'X')>0) Call SBIT1(Ioption,3) " same explicitly     "
     if (Index(%Option,'C')>0) Call SBIT1(Ioption,4) " Calorimeter option  "
     Q(Jdu+7)=Ioption
  }
  else                               " update an existing hit/digi element "
  {  i1=Q(Jdu+1); i2=Q(Jdu+3);
     do ia=i1,i2-1,%NwuHit
     {  Ja=Jdu+ia;   check Q(Ja+1)=ARFROMC(%ParList)
        If (%Option # '*') Q(Ja+2)=ARFROMC(%Option)
        If (%Nbits#%Magic) Q(ja+3)=%Nbits;  Q(Ja+4)=%FhMin;  Q(Ja+5)=%FhMax;
        If (%bin>0)      { Q(Ja+7)=1/%bin;  Q(Ja+3)=%Magic; }
  }  }
  END
 
 
 
+DECK,AgSDETU,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 01/06/95  18.40.03  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                  Subroutine   A g S D E T U (Title)
*                                                                    *
*  Description: in a digitisation module make changes in SET param-s *
*  called from users code at the end of a digi structure description *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT.
  Character Title*(*),Cdet*4;   Integer Js,Jd,Jdu,new;
 
  Check  %Idet>0 & %Iset>0 & %Jdu>0;      Cdet=Title;
  Jdu=%Jdu;  new=Q(Jdu+10);  Q(Jdu+10)=max(0,%Iprin);
  If (%Module(5:5)='D')
  {  Js=LQ(JSET-%Iset);  Jd=LQ(Js-%Idet);
     if (IQ(JD+9)<0)     IQ(Jd+9)=0;
     if (new<0)   call AgGDETV(Cdet,Jdu);
     call AgGDETU(%Iset,%Idet,JDU,%Iprin);
  }
  { %Iset,%Idet }=0;
  END
 
 
+DECK,AgSRESET,T=geant. --------------------------------------------------------
*CMZ :          25/03/98  16.44.21  by  Pavel Nevski
*CMZ :  1.30/00 14/11/96  17.24.24  by  Pavel Nevski
*CMZ :  1.00/00 06/08/95  14.00.59  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g S R E S E T
*                                                                    *
*  Description: Before each processor call reset WORK2 area to allow *
*               recognition of actual parameters
*               and set some (KONLY,ROTM) defaults                   *
**********************************************************************
+CDE,TYPING,AGECOM.
  Integer LOCF
  Call VZERO(%Reset1,LOCF(%Reset2)-LOCF(%Reset1)+1)
  Call VZERO(%code,  LOCF(%eCode) -LOCF(%Code)  +1)
  %Mother=%Volume; %Konly='ONLY'
  {%Thetax,%Thetay,%Phiy}=90
  END
 
+DECK,AgSPUSH,T=geant. ---------------------------------------------------------
*CMZ :          30/05/97  15.31.01  by  Pavel Nevski
*CMZ :  1.30/00 07/08/96  15.08.41  by  Pavel Nevski
*CMZU:  1.00/01 01/12/95  02.07.10  by  Pavel Nevski
*CMZ :  1.00/00 01/06/95  13.09.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                     Subroutine   A g S P U S H
*                                                                    *
*  Description:  Push the stack at the start-of-block                *
*                redefine parents and set default attributes etc     *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,SCLINK.
 Integer       LOCF,LENOCC,L,Iv,IL,NUM/0/
 Real          Volume
 Equivalence   (%Volume,Volume)
 
 If %Mark!='V00'
 { print *,'     ***********************************************************'
   print *,'     ***           FATAL ERROR in ',%Module,'       ***'
   print *,'     *** geant3.def file was changed, delete your *.sl files ***'
           STOP '***********************************************************'
 }
 If (%Level=0) NUM=0
 If %Level>=15 {error('Number of nesting levels is more than 15')}; %Level+=1;
 L=LOCF(%EndSave)-LOCF(%BegCom)
 if (L>%LSTACK) stop 'AgsPUSH Fatal error: lack of stack dimension'
 Call UCOPY (%BegCom, %Stack(1,%Level), L)
 CALL VZERO (%BegScr, LOCF(%EndScr)-LOCF(%BegScr))
 
 %Mother=%Volume;  %Imother=%Ivolume;  %Volume=%Title;
 {%Ivolume,%Istatus,%NLmat,%Isvol}=0;
 Iv=LOCF(Volume)-LOCF(%Begcom)+1;
 Do IL=1,%Level-1
 { IF %Stack(iv,il)=VOLUME {error('Recursive block call not accepted')} }
 Iprin=max(%Iprin-%Level-1,0);   Num+=1;  Prin1 NUM,%level,%L(%Title)
       (/' **',i5,' ** we are at level ',i3,' in block ',A/)
   END
 
+DECK,AgSPOPB,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 05/08/96  13.22.16  by  Pavel Nevski
*CMZ :  1.00/00 26/12/94  01.37.43  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                     Subroutine   A g S P O P B
*                                                                    *
*  Description:  pop stack at the end-of-block                       *
*                at upper level close hit structure                  *
**********************************************************************
+CDE,TYPING,AGECOM,GCUNIT.
 Integer LOCF,LENOCC;
 
 If %Istatus==0 {error('block is empty')};
 If %Level<=0   {error('Stack underflow: nesting level is wrong')};
 Call UCOPY (%Stack(1,%Level), %BegCom, LOCF(%EndSave)-LOCF(%BegCom));
 %Level-=1;  Iprin=max(%Iprin-%Level-1,0);  if (%level>0) return;
   END
 
+DECK,AgSBEGM,T=geant. ---------------------------------------------------------
*CMZ :          10/04/98  18.37.13  by  Pavel Nevski
*CMZ :  1.30/00 13/05/97  14.31.40  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
************************************************************************
*                                                                      *
            Subroutine   A g S B E G M (Module,IPR)
*                                                                      *
*  Description: open a module execution part and control execution     *
*  Print flag is set to the production of both module and stage print  *
*  In a standalone mode all geomtry structures are dropped             *
*  Modifications:                                                      *
*  13/05/97 PN: default FILL (att6) is 0 to cope with 97a black edges  *
*  10.01.98 PN: detm.rz has to be made 'old format' for built in dzdoc *
************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCFLAG,SCLINK,QUEST.
   Integer           AgPFLAG,LENOCC,n,m;   parameter   (n=100)
   Character         Module*(*),Stage*4,Cmother*4,Cs*1,Chdir0*6/' '/
   Integer           IPR,i,Idet,Lrecl,Istat,Itry,Lun/61/
   Character*8       CHTAG(2)/'Bank-ID','Bank-ID'/,CHDIR(n)
   Real              Xtime,XXtime
   Common /AgCMTIME/ Xtime,XXtime
   Logical           EXST,Opnd,First/.true./
+CDE,STAFUNC.
                            * * *
   Check %Module != Module;
   %Module=Module; Cs=Module(5:5);
   If Cs='G' {Stage='GEOM'} else if Cs='D' {Stage='DIGI'} else {Stage='RECO'}
   Cmother=' ';    If (JVOLUM>0) CALL UHTOC(IQ(JVOLUM+1),4,CMother,4);
   If Cs='G' { do i=1,5 { %attribute(i)=1; };  %attribute(6)=0 }
                               * * *
   Call AsbDETE (Module,Idet)
   %IdType=Idet;         %Iprin=AgPFLAG(Module,Stage);
   %IMFLd=LVMFLD(Idet);  %Ihist=LVHIST(Idet);  %IGrap=LVGRAP(idet);
   %Igeom=LVGEOM(Idet);  IF (Stage=='RECO')    %Igeom=LVRECO(Idet);
   IPR=%Iprin; Iprin=%Iprin;
*
   "Make a standalone clean up"
   If Cs='G' & Cmother=%Module(1:4) & %Standalone>0
   {  Call AGDROP('*'); If (Idebug>0) Iprin+=1; }
*
   "Make sure minimal GEANT structures are present for G stage "
   If (Cs=='G' ) Call Agstand
*
   prin1 %Module,%Igeom,%Iprin;
   (' Module ',a8,'  running for geometry',i5,'  print level=',i3);
  " try to reduce the amount of prints:" if (Iprin>0) Iprin=Iprin-1;
   if (%Iprin>1)  Call TIMEX(Xtime);
   If %IHIST>0
   {  CALL HCDIR('//PAWC',' ');   CALL HRDIR(n,CHDIR,m)
      Do I=1,m  { Check CHDIR(i)==Module(1:LENOCC(CHDIR(i)))
                  CALL HCDIR(CHDIR(i),' ');  Break;
   }            }
                              * * *
   INQUIRE(FILE='detm.rz',OPENED=opnd)
   If .not.opnd & LVGEOM(1)>=0
   {  Lrecl=256;   INQUIRE(FILE='detm.rz',EXIST=EXST);  %ChDir='RZDOC'
      If !EXST { Call RZOPEN (Lun,%CHdir,'detm.rz','NWX', Lrecl,Istat)
                 Call RZMAKE (Lun,%CHdir,2,'HH',CHTAG,5000,'XO')
                 call RZCLOS (%Chdir,' ')
               }
      Call RZOPEN (Lun,%ChDir, 'detm.rz','UWXD',Lrecl,Istat);
*
* from pawrop:
*--- bug in RZOPEN with C I/O, TOPDIR is not returned correctly ---
*     IF (IOPTC!=0 & LUN <10) WRITE(TOPDIR,'(3HLUN,i1)') LUN
*     IF (IOPTC!=0 & LUN>=10) WRITE(TOPDIR,'(3HLUN,i2)') LUN
*
      Call RZLOGL (Lun,-3);    "  Call RZCDIR (ChDir0,'P') "
      Do Itry=1,2
      {  Call RZFILE(Lun,%ChDir,'UDX'); if (Iquest(1)==0) Break
         Call Rzfree('RZFILE');         Call RZEND(%Chdir)
      }
      If Istat!=0     { <w>; (' detm.rz absent - no documentation available');}
      If Iquest(1)!=0 { <w>Iquest(1);(' problem opening detm.rz, IQUEST=',i6);}
*     Chdir0=%Chdir
   }
   END
 
 
+DECK,AgSENDM,T=geant. ---------------------------------------------------------
*CMZ :          04/03/98  23.44.07  by  Pavel Nevski
*CMZ :  1.30/00 17/04/97  17.59.21  by  Pavel Nevski
*CMZ :  1.00/00 29/11/95  08.55.19  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                   Subroutine   A g S E N D M
*                                                                    *
*  Description: close the module. In the interactive debug mode      *
*               show documentation banks and draw the detector       *
**********************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,GCFLAG,SCLINK.
   Integer      LZFID,L1,Iv,I,Npar,Key(2)
   Character*4  Cmother
   Real         c,d, Xtime,XXtime,XXi
   Common /AgCMTIME/ Xtime,XXtime
+CDE,STAFUNC.
 
   Check %Module#' '; Call TIMEX(XXi)
   If %Module(5:5)=='G'                                " geometry module "
   {  Call AgGCLOS;
      Cmother=%Module; If (JVOLUM>0) Call UHTOC(IQ(JVOLUM+1),4,Cmother,4);
      If Cmother=%Module(1:4) & %STANDALONE>0 "Cmother!='ATLS'&Cmother!='CAVE'"
      {  Call GGCLOS;
         If Idebug>1                             " show documentation banks "
         {  Call UCTOH  ('DETMNONE',Key,4,8);
            L1=LZFID (IxCONS,Key(1),Key(2),0); If (L1>0) _
            call DZSURV ('Detector Master Banks',IxCONS,L1)
         }
         If JVOLUM>0 & LKDETM>0 & %IGRAP>=1 & Idebug>0  " draw the detector "
         {  Iv=1;    Npar=Q(LQ(JVOLUM-Iv)+5);
            d=1;     do I=1,min(Npar,3) { d=max(d,Q(LQ(JVOLUM-Iv)+6+i)); }
            c=10/d;  Call GDRAW (Cmother,120.,120.,0.,10.,10.,c,c);
      }  }
   }
*  if %Chdir!=' ' { call RZCLOS (%Chdir,' ');  %Chdir=' ' }
   if (%Chdir!=' ') call RZSAVE
   If %Iprin>1
   { Call TIMEX(XXtime); <W> %module,XXtime-Xtime,XXi-Xtime
     (' Module ',a,' done',11x,'Time=',F8.3,' (proper time=',F8.3,')')
   } %Module=' '
   END
 
 
+DECK,AgGCLOS,T=geant. ========================================================
*CMZ :          09/01/98  03.41.25  by  Pavel Nevski
*CMZ :  1.30/00 02/04/96  20.16.48  by  Pavel Nevski
*CMZ :  1.00/00 29/05/95  16.26.52  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Subroutine   A g G C L O S
*                                                                    *
*  Description:  Fill hit structures for all sensitive detectors     *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
  Character*4 Cset,Cdet
  Integer     IPRIN,Iset,Idet,JS,JD,Jdu
 
  Check Jset>0
  :set: DO Iset=1,IQ(Jset-1)                                 " Over Nset "
  {  JS=LQ(Jset-Iset);   Check JS>0;  Call UHTOC (IQ(Jset+Iset),4,Cset,4)
     :det: DO Idet=1,IQ(LQ(Jset-Iset)-1)                     " Over Ndet "
     {  JD=LQ(JS-Idet);  Check JD>0;  Call UHTOC (IQ(JS + Idet),4,Cdet,4)
        "Find unprocessed banks "     Check IQ(JD+9)=-1;       IQ(JD+9)=0
*      02/04/96: it is possible also to create GEANT multipath by keeping -1.
*      commented out 09.01.98
*      CALL GGDETV(Iset,Idet);
       JS=LQ(Jset-Iset);    JD=LQ(JS-Idet)
*
        JDU=LQ(JD-3);    While JDU>0
        {  Iprin=Q(JDU+10);
           " get  path  "   Call AgGDETV (Cdet,JDU);
           " fill banks "   Call AgGDETU (Iset,Idet,JDU,IPRIN);
           " take next  "   JDU=LQ(JDU);
        }
  }  }
  END
 
+DECK,AgGDETV,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.30.48  by  Pavel Nevski
*CMZ :  1.00/00 01/01/95  16.58.06  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A g G D E T V (Cdet,JDU)
*                                                                    *
*  Description: given a sensitive detector make a description of     *
*               path (NAMESV,NBITSV) for the hit definition          *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCNUM.
  Character*4 Cdet
  Integer   Nchild,Ifamily(1000),Level,Idet,Ivol1,Iv,Jv,nin,in,Jd,Id,ip,N1,N2,
            Iprin/9/,Nhisch,Ncopy,Nr,Jp,L,m,Jdu,Ia,N,Ja,Name(20),GName(20),
            NumV(20),Numb(20),Mask(20),NumP(20),NumH(20),Ivol(20)
 
call UCTOH(Cdet,Idet,4,4); call UCTOH('VOL1',Ivol1,4,4);
Level=1;                 {Name(1),Gname(1)}=Idet;
{N1,N2,Mask(1),NumV(1),NumP(1),NumH(1),Nchild}=0;
if (JVOLUM<0) Return;
Do Iv=1,Nvolum
{  Jv=LQ(JVOLUM-Iv);  Check JV>0;  Check IQ(JV-4)=Idet;
   Nchild+=1; Ifamily(Nchild)=Iv;  If (IQ(JVOLUM+Iv)=Idet) Ivol(1)=Iv;
}
If Nchild=0 { <w> Cdet; (' AgGDETV: detector ',a,' not found'); return; }
"<w> cdet,Nvolum,Nchild; (' *** in aggdetv: cdet,nvol,nchild = ',a4,2i6);"
 
Until "Ifamily(Nchild)==0 \" N1>N2  \ Level==20
{  " previous level children are in (N1,N2) range on family "
   N1=N2+1;  N2=Nchild;  Level+=1;  L=Level;
   {Name(L),Gname(L),NumV(L),Numb(L),NumH(L),Mask(L),NumP(L),Ivol(L)}=0;
 
  " select family parents: Iv is parent of Id, Nr is copy number or Ndiv  "
  " Nhisch is the number if his direct counted children (previous level !)"
  " Ncopy is the higher copy number, used for NVL if more than one copy ! "
  " NumP contains total number of found new parents at that level         "
 
   Do Iv=1,NVOLUM                                      " Iv is a parent "
   {  Jv=LQ(JVOLUM-Iv);  nin=Q(Jv+3); Check nin#0;     " He has a child "
      Nhisch=0; Ncopy=0;
      do in=1,max(nin,1)
      {  Jd=LQ(Jv-in); Id=Q(Jd+2); Nr=Q(Jd+3);         " - is his child "
         do ip=N1,N2                                   " in the family? "
         {  Check Id==Ifamily(ip);                     "   Yes !        "
            Nhisch+=1; Ncopy=max(Ncopy,Nr);
            "mark this parent as a next level child (If not marked yet) "
            Do jp=n2+1,Nchild { If (Ifamily(jp)==Iv) go to :known:; }
            if Nchild<1000    { Nchild+=1;  Ifamily(Nchild)=Iv; }
            else {<W> Cdet;(' AgGDETV error: too many parents of ',a);Return;}
            :known:        " -  find its generic name ";
            If IQ(Jv-4)#Ivol1 { Gname(Level)=IQ(Jv-4); }
            else              { Gname(Level)=IQ(JVOLUM+iv); };
            " make XOR name and mask - and select NameSV name "
            Name(Level)=IOR(Name(Level),IQ(JVOLUM+Iv));
            Mask(Level)=IOR(Mask(Level),IEOR(Name(Level),IQ(JVOLUM+Iv)));
            If (Name(level)==Gname(Level)) Ivol(Level)=Iv;
            If  (Iv=1)  NumV(Level)=1;
      }  }  L=Level-1;
 
      " skip counting if one child only is positioned "
      Unless (Nin>0 & Nhisch<=1) NumH(L)=max(NumH(L),Ncopy)
      NumV(L)=max(NumV(L),Ncopy) " but remember anyway its copy number "
      NumP(Level)=Nchild-N2      " and count how many branches we have "
   }
   If Ivol(Level)==0 " active daughters are positioned NOT in the first copy "
   { Do Iv=1,Nvolum  { If (Gname(Level)==IQ(JVOLUM+iv)) Ivol(Level)=Iv;  } };
   Numb(L)=0; If (NumH(L)>0) { m=NumV(L)-1; while m>0 { m/=2; Numb(L)+=1; }};
   If (Jdu>0) Iprin=Q(Jdu+10);
   Prin5  L,NumP(L),Name(L),Gname(L),NumH(L),NumV(L),Numb(L),Mask(L),Ivol(L);
         (2i6,2(2x,A4),3i6,1x,Z8,i8);
}  Level=Level-2;
   If Jdu>0
   {  Do L=Level,1,-1
      {  Ia=Q(Jdu+3);      N=Q(jdu+4);       Ja=Jdu+Ia+N*3;   "<<start<<"
         Q(Ja+1)=Ivol(L);  Q(Ja+2)=NumV(L);  Q(Ja+3)=Numb(L); " 3 words "
         N+=1;             Q(jdu+4)=N;       Q(jdu+5)=Ia+N*3; "<< stop<<"
   }  }
   END
 
+DECK,AgGDETU,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 09/09/96  16.45.51  by  Pavel Nevski
*CMZ :  1.00/00 06/06/95  00.08.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
              Subroutine   A g G D E T U (Iset,Idet,Jdu,IPRIN)
*                                                                    *
*  Description: calculate Nbit,Origin and Factors for hit/digi sets  *
*               and fill DET,DETH/DETD banks starting from DETU bank *
*  ->           Parameters NwuHit,NwuVol,Magic are hardwired here    *
*  ->31.8.96:   Nbit option use full 2**Nbit range,                  *
*               Bin option has its range symmetrise around the center*
**********************************************************************
Replace[ERR(#)] with _
       [<W> Cset,Cdet; (' AgGDETU error for set,det=',2(1x,a));
         Write (Lout,*) ' ******> ',#1; RETURN;              ];
+CDE,TYPING,GCBANK,GCUNIT,GCONST.
 
 Character*4 ACFROMR,Cset,Cdet,Chit,Copt
 Integer     INDEX,IPRIN,Iset,Idet,Js,Jd,Jdu,Jx,i,i1,i2,J,K,L,M,N,X,Mode,Node,
             Nbit,Nbin,Nb,Nam,iv,Kv,Nv,Nn,Nh,Nw,Nwo,Lf,Ifun,Ld,Lx,Ldu,Jds,Lex,
             JL,NameV(20),NbitV(20),LL(2)/10,3/,Magic/-696969/
 Real        Lfact,Fmin,Fmax,Orig,Fact,Range,ofs,
             Log2/.30103/,safety/0.02/
 
  Check  Jset>0 & Idet>0 & Iset>0;
  JS=LQ(Jset-Iset);  Check JS>0;  Call UHTOC (IQ(Jset+Iset),4,Cset,4);
  JD=LQ(JS - Idet);  Check JD>0;  Call UHTOC (IQ(JS + Idet),4,Cdet,4);
  If Cset(4:4)='H'  {X=1}  else  If Cset(4:4)='D'  {X=2}
  else              {err('can not decode set type ')};       Ld =IQ(JD-1);
  JX =LQ(JD-X); If JX <=0 {err('hit/digi bank not found ')}; Lx =IQ(JX-1);
 "Jdu=LQ(JD-3)" If Jdu<=0 {err('No  user bank  defined  ')}; Ldu=IQ(Jdu-1);
  Prin2  Cset,Cdet; (/' *** ',2(1x,A4),' *** ');
 
  "reset volumes and hit counters " {Nn,Nv,Nw,K,Kv,Nh,Nwo,Mode,Node} =0;
  Do M=2,0,-2
  {  i1=Q(Jdu+M+1); i2=Q(Jdu+M+3); N=Q(Jdu+M+2); Check N>0; L=(i2-i1)/N;
     If L#LL(1+M/2) | 1>N|N>15 | i2>Ldu | i1<10
        {err('Bad format of DETU bank, M,i1/2,N=',M,I1,I2,N)}
     do i=i1,i2-1,L
     {  j=Jdu+i; If M==2   " - - - - - - - volumes - - - - - - - - "
        {  iv=Q(j+1); Nam=IQ(JVOLUM+iv); {Nbit,Nb}=Q(j+3); Check Nb>0; Kv+=1; }
        else               " - - - - - - - - hits  - - - - - - - - "
        {  Chit=ACFROMR(Q(j+1)); Copt=ACFROMR(Q(j+2)); Call UCTOH(Chit,nam,4,4)
          " Limits will be re-calculated If Q(4)>=Q(5), ifun is not redefined "
           Ifun=Q(j+10); Call AgGFLIM(Chit,Cdet,Q(j+4),Q(j+5),Ifun);
                                  * * *
          " mode=1 means commulative part, node=1 - users request for hit part"
           Nbit=Q(j+3);  Fmin=Q(j+4);   Fmax=Q(J+5);   Fact=Q(J+7);
           If Index(Copt,'H')>0             { K=0;    Node=1;  }
           If -32<=Nbit&Nbit<=0 & Mode=0    { K=0;    Mode=1;  }
           If Fmin==Magic & Fmax==Magic & Nbit>0
           {  ofs=0;  if (i==i1 & Q(LQ(JD-3)+8)>Magic) ofs=Q(LQ(JD-3)+8)
              Fmin=ofs-0.5; if (Index(Copt,'F')>0) Fmin=ofs; Fmax=Fmin+2**Nbit;
           }
           "   Define Range (for a cumulative mode Origin is always 0)    "
           Orig=0;  If (mode=0) Orig =-Fmin;  Range=Orig+Fmax;
           If (Range<=0) <w> Cset,Cdet,Chit,Fmin,Fmax; (' Error in',2(1x,a4),
             ': HITS/DIGI element ',a4,' has invalid range',2E12.3/,
             ' *** Probably this shape is still absent in GFLCAR/RAD/etc ***'/,
             ' *** You should set limits for this element explicitely !! ***')
                                  * * *
           If Nbit>=-32                                        " Nbit option "
           {  "             Nb is always from 1 to 32                   "
              Nb=min(32,abs(Nbit));  If (Nb=0) Nb=32;
              " 31.08.96:  use all bit combination without last spare   "
              Fact=1;  If (Range>0)  Fact=2.**min(31,Nb)/Range;
              "     if rounding option, factors mantissa is 2 digits    "
              If Index(Copt,'R')>0 & Range>0
              {  Lfact=Log2*min(Nb,31)-log10(Range)-safety;
                 Lf=nint(Lfact-1.5); Fact=nint(10.**(Lfact-Lf))*10.**Lf;
           }  }
           else                                              " fix bin option "
           {  Nbin=Range*Fact+0.99; Range=Nbin/Fact;         " ? to continue? "
              Nb=0;  while Nbin>0 { Nbin/=2; Nb+=1; };
              Nb=min(max(1,Nb),32);
           }
           if (Mode=0) Orig=-(Fmax+Fmin-Range)/2         "  - symmetrise  "
           Q(J+5)=Fmax;  Q(J+6)=Orig;  Q(J+7)=Fact;  Q(J+8)=Nb;
           Prin3 Chit,Ifun,Nb,Fmin,Fmax,Orig,Fact;
           (' hit = ',A4,' cod,nb=',2i3,' min/max,orig,fact=',3F10.3,G12.3);
        }
        " count packed words and the remaining bits "
        If  Nb>K   { Nw+=1; K=32; };    K-=Nb;
        Nn=min(Nn+1,20); NameV(Nn)=Nam; NbitV(Nn)=Nb*(1-2*mode);
                                  * * *
        If Mode=0 & Node=0            " overwrite SEJD detector bank in SETS "
        {  if 2*(nv+1)+10>Ld | Nv>=20
              {err('unsufficient length of the detector bank in SETS',ld,nv)};
           Nv+=1;  IQ(Jd+2*nv+9)=Nam;   nwo=nw;
                   IQ(Jd+2*nv+10)=max(IQ(Jd+2*nv+10),Nb);
        }  else                       " overwrite SJDH or SJDD hit/digi bank "
        {  if (Nh+1)*(4/X)>Lx | Nh>=20
              {err('unsufficient length of DETH or DETD bank in SETS',lx,nh)};
           Nh+=1;  Jx=Jx+1; IQ(Jx)=Nam; Jx=Jx+1; IQ(Jx)=max(IQ(Jx),Nb);
           if X=1 {Jx=Jx+1; Q(Jx)=Orig; Jx=Jx+1;  Q(Jx)=Fact; }
        }
  }  }
  Prin2 (NameV(i),i=1,Nn); (/' NameV : ',20(2x,A4));
  Prin2 (NbitV(i),i=1,Nn); ( ' NbitV : ',20(i4,2x));
  Prin3   Cset,Cdet;       (' *** ',2(1x,A4),' *** '/);
 *                                          this is maximum number of:
 J=JD+2*X;   if  Jdu=LQ(JD-3)   {{IQ(JD+1),IQ(JD+2),IQ(J+1),IQ(J+2)}=0;}
 IQ(JD+1) = max(IQ(JD+1),Nwo)   " words to store packed volume numbers";
 IQ(JD+2) = max(IQ(JD+2),Nv)    " volume descriptors in detector bank ";
 IQ(J+1)  = max(IQ(J+1),Nw-Nwo) " words to store packed hits or digi  ";
 IQ(J+2)  = max(IQ(J+2),Nh)     " hit/digi descriptors in DETH/D bank ";
 Q(Jdu+6) = Kv      " number of geometry branchings - really volumes  ";
 *
 *                                          trim hit/digi/user banks
      Lex=IQ(Jdu-1)-nint(max(Q(Jdu+3),Q(Jdu+5)));
          If (Lex>0) Call MZPUSH(IxCons,Jdu,0,-Lex,'I')
      Lex=IQ(JD-1)-10-2*IQ(JD+2);
 *     original SEJD bank was 100, but GGDETV may change it - then leave it
          If (Lex>0 & IQ(JD-1)==100) Call MZPUSH(IxCons,JD, 0,-Lex,'I')
      JL=JX; JX =LQ(JD-X);  Lex=IQ(JX-1)-(JL-JX);
          If (Lex>0) Call MZPUSH(IxCons,JX, 0,-Lex,'I')
 
 Nv=IQ(JD+2); Do i=kv+1,nv
 { jds=LQ(JD-3); while Jds>0 { Q(Jds+10*(i-kv)+8)=IQ(JD+10+2*i); jds=LQ(jds)} }
 *
  END
 
+DECK,AGGFlIM,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.31.31  by  Pavel Nevski
*CMZ :  1.00/00 22/09/95  18.08.16  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
      Subroutine   A g G F L I M (CHit,Cdet,CLo,CHi,Ifun)
*                                                                    *
*  Description: set limits for a hit using GEANT volume dimensions   *
*  Modifications:                                                    *
*  12/11/96 - only if both limits are not defined explicitly.        *
**********************************************************************
+CDE,TYPING,GCUNIT,AGECOM,GCCUTS.
 
  Integer      Ifun,iax,Magic/-696969/
  Real         Clo,Chi,CL,CH,dens,Step2,Step3
  Character*4  Cdet,Chit
 
  Check (Clo==%Magic | Chi==%Magic)
If 1<=Ifun & Ifun<=9    "x,y,z,r,rr,phi,the,eta,tdr"
{  iax=Ifun; If (Ifun=8) iax=7; If (Ifun=9) iax=4;
   Call AgGFDIM (iax,Cdet,CL,CH,dens);
   If Ifun=8 { " instead of Rap(CL,CH)" CL=-5; CH=+5; }
}
If 15<=Ifun & Ifun<=17  "step and energy losses"
{  Step2=0; Step3=1; do iax=1,3
   { Call AgGFDIM (iax,Cdet,CL,CH,dens);
     Step2=Step2+(CH-CL)**2;  Step3=Step3*abs(CH-CL);
   } Step2=Sqrt(Step2);   If (Step3>0) Step3=Step3**0.333333;
}
*                               set measurement default limits
 If Ifun=10               "Cp"     { CL=-1;     CH=+1;      }
 If 11<=Ifun&Ifun<=13  "cx,cy,cz"  { CL=-1;     CH=+1;      }
 If Ifun=14              "ETOT"    { CL=0;      CH=1000;    }
 If Ifun=15 | Ifun=16    "ELOS"    { CL=0;      CH=.01*dens*step3; }
 If Ifun=17              "STEP"    { CL=0;      CH=Step2;   }
 If Ifun=18              "Lgam"    { CL=0;      CH=10;      }
 If Ifun=19              "TOF "    { CL=0;      CH=TOFMAX;  }
 If Ifun=20              "USER"    { CL=%Magic; CH=%Magic   }
 If 21<=Ifun&Ifun<=23  "XX,YY,ZZ"  { CL=-1000;  CH=1000;    }
 If 24<=Ifun&Ifun<=26  "PX,PY,PZ"  { CL=-1000;  CH=1000;    }
 If Ifun=27              "SLEN"    { CL=0;      CH=10000;   }
 If Ifun=28              "SHTN"    { CL=%Magic; CH=%Magic   }
 If Ifun>0  { If (Clo=%Magic) Clo=CL; If (Chi=%Magic) Chi=CH; }
   END
 
 
 
 
+DECK,AgGFDIM,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.32.11  by  Pavel Nevski
*CMZU:  1.00/01 27/01/96  22.06.24  by  Pavel Nevski
*CMZ :  1.00/00 04/09/95  14.29.15  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
          Subroutine   A g G F D I M (Iax,Cdet,Cl0,Ch0,dens)
*                                                                    *
*  Description: given a sensetive volume and axis, find its dimension*
*             Just a continuation of AgGFLIM splitted for convenience*
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCONST.
 
 Integer     Idet,Iax,Nvol,Iv,Jv,Ish,Imo,Jmo,Nin,In,Ida,NR,
             IDH,Jda,Npar,Natt,Ier,Numed,Nmat
 Real        CL0,CH0,CL,CH,dens,xyz(3),Par(100),Att(20)
 Character*4 Cdet
 Data        xyz/3*0/
 
 CL0=+1.e10; CH0=-1.e10;            Check 1<=Iax & Iax<=8;
 Check JVOLUM>0; NVOL=IQ(JVOLUM-1); Call UCTOH(Cdet,Idet,4,4);
Do Iv=1,Nvol
{  Jv=LQ(JVOLUM-Iv);               Check JV>0;
   Ish=Q(Jv+2);  IDH=IQ(Jv-4);     Check Idet==IDH;
   numed=Q(Jv+4);  if (numed>0 & JTMED>0) Nmat=Q(LQ(JTMED-numed)+6);
                   If (Nmat>0  & JMATE>0) dens=Q(LQ(JMATE-Nmat)+8);
   Do Imo=1,Nvol
   {  Jmo=LQ(JVOLUM-Imo); Check Jmo>0;  Nin=Q(Jmo+3);
      do In=1,Abs(Nin)
      {  Jda=LQ(Jmo-In);  Check Jda>0;  Ida=Q(Jda+2);
         NR=Q(Jda+3);     Check Ida=Iv; Npar=Q(Jv+5);
         Call GFIPAR(Jv,Jmo,In, Npar,Natt,Par,Att)
         IF Npar<=0 | Npar>50
         { <W> Cdet; (' AgGFDIM: still error in GFIPAR for volume ',a4/,
                      ' ***** PLEASE USE EXPLICIT HIT LIMITS *****')
           next
         }
         if      Iax<=3  {  call GFLCAR (Iax,Ish,0,    Par,CL,CH,ier);  }
         else if Iax<=5  {  call GFLRAD (Iax,Ish,0,xyz,Par,CL,CH,Ier);  }
         else if iax==6  {  call GFLPHI (    Ish,0,xyz,Par,CL,CH,Ier);
                            if (CL>CH) CL-=360; CL*=DegRad; CH*=DegRad; }
         else if iax==7  {  call GFLTHE (    Ish,0,xyz,Par,CL,CH,Ier);
                                                CL*=DegRad; CH*=DegRad; }
 
         CL0=min(CL0,CL);   CH0=max(CH0,CH);
}  }  }
   END
 
+DECK,AgGSTEP,T=geant. =========================================================
*CMZ :          11/01/98  19.20.57  by  Pavel Nevski
*CMZ :  1.30/00 16/03/97  14.27.55  by  Pavel Nevski
*CMZU:  1.00/01 29/01/96  13.26.30  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                  Subroutine   A g G S T E P (Iret)
*                                                                    *
*    Description: general gustep for any detector with auto-hits     *
*    Scan and fill the hit structure for all sensitive detectors     *
**********************************************************************
+CDE,TYPING,GCBANK,GCFLAG,GCONST,GCUNIT,GCVOLU,GCTMED,GCSETS.
+CDE,GCKINE,GCKING,GCTRAK,AGCSTEP,SCLINK,QUEST.
 Real      Org,Fct,Fmx,Hit,AgGHIT,Serial,xx,h1,Gold
 Integer   JBIT,JATTF,LWSTEP,LDETE,Jj,JS,JD,i,j,k,i1,i2,Nb,Ih,Jh,Jv,Idevt0,
           iv,iw,Nlev,Jat,Ihit,Ic,Iad,Id,Iopt,Iret,Itr,JDH,Jds,mode,mec,itry,
           Iprin,Isimu,bin,Nbr,Jdu/0/,Id0/-1/,NwuVol/3/,NwuHit/10/,Inpu/-1/
 Save      Jdu,iv,iw,Iprin,Isimu,Iopt,Id0,Serial,Gold,Idevt0
+CDE,STAFUNC.
 LWSTEP(IIIII) = IQ(LQ(LKDETM-IIIII)+13)
 LDETE (IIIII) = IQ(LQ(LKDETM-IIIII)-1)
 JATTF(Jj)     = Jj+int(Q(Jj+5))+6
 bin(xx)       = Ifix((xx+org)*fct)
*
* - - - - - - - - - - - - - print control - - - - - - - - - - - -
 If (Idevt!=Idevt0&LkDETM>0) Call GLOOK('TRAC',IQ(LKdetm+1),IQ(LKdetm-1),Id0);
 Idevt0=Idevt;  Jat=JATTF(LQ(JVOLUM-LVOLUM(Nlevel)));  Id=Q(Jat+9);  Iprin=0;
 If Idebug>0 & LkDETM>0
 {  If (Id>0)  Iprin = LVPRIN(Id)
    If (Id0>0) Iprin*= LVPRIN(Id0)
    Iprin = max(Iprin,Idebug)
    If (iw!=IQ(JVOLUM+LVOLUM(Nlevel))&Iprin>0 | Nlevel+Iprin>15) Call Gdebug
        iw= IQ(JVOLUM+LVOLUM(Nlevel))
 }
* - - - - - - - - - - - - - energy correction - - - - - - - - - -
 If LKDETM>0 & Id0>0
 {  if (sleng==0)  Gold=GeKin
    If Istop>0 & 2<=Ipart & Ipart<=3 & NGKINE<2 & LVSIMU(id0)>0
    {  Mec=0;  Do i=1,Nmec { If (Lmec(i)==30 | Lmec(i)==11) Mec=Lmec(i) }
       If (Ipart==3 & NGKINE==0 & Mec==30) dEstep=Gold
       If (Ipart==2 & NGKINE<=1 & Mec==11)
       {   dEstep=Gold+2*emass;  If (NGKINE==1) dEstep-=GKIN(4,1);    }
    }  Gold=Gekin
 }
* - - - - - - - - - - - - - - - - user - - - - - - - - - - - - - -
 AdEstep+=DeStep;     Astep+=Step;      Iret=Id;
 If LKDETM>0 & Id>0          " permanent user tracing routine needed "
 { Iad=0; If (LdetE(id)>12) Iad=LWSTEP(Id); If (Iad!=0) Call JUMPT0(Iad); }
 If (isvol<=0)  Go To :done:;           Iret=0;
* - - - - - - - - - - - - - - - - sensitive - - - - - - - - - - -
 If  InwVOL==1
 { " If sensitive detector, find it's description banks a la GFINDS "
   Do Nlev=Nlevel,1,-1
   { Jat=JATTF(LQ(JVOLUM-LVOLUM(Nlev))); If (Q(Jat+8)>0) goto :sens:; };
   { IHset,IHdet,Iset,Idet,IDtype,NVname,Jdu }=0;        goto :done:;
   :sens:                               " now fill GCSETS "
   Iset=Q(Jat+7);    Js=LQ(Jset-Iset);  IHset=IQ(Jset+Iset);
   Idet=Q(Jat+8);    Jd=LQ(Js - Idet);  IHdet=IQ(Js  +Idet);
   IdType=Q(Jat+9);  Serial=Q(Jat+10);  NVname=IQ(Jd+2);
   Jdu=LQ(Jd-3);     Iret=Jdu;
   If jdu>0
   { i1=Q(Jdu+3);  i2=Q(Jdu+5);  {jv,iv}=0;
     do i=i1,i2-1,NwuVol         " - - - - - - - volumes - - - - - - - - "
     {  jv+=1; Nb=Q(jdu+i+3); Check Nb>0; iv+=1; NUMBV(iv)=NUMBER(jv)-1;
        If (NUMBV(iv)<0) <w> IHset,IHdet,iv,NUMBER(jv)
        (' AgGSTEP error in ',2(1x,a4),' at level',i5,' NUMBER=',i6)
     }
     Isimu=1;  If (IdType>0 & LKDETM>0) Isimu=LVSIMU(IdType)
     Iopt=Q(Jdu+7);               {Astep,AdEstep}=0;
     Call UCOPY(vect,vect0,7);     Vloc0(7)=Vect(7)
     If (Jbit(Iopt,2)>0) Call GMTOD(vect,vloc0,1)
     If (Jbit(Iopt,3)>0) Call GMTOD(vect(4),vloc0(4),2)
 } }
* - - - - - - - - - - - - - -
 If STEP>0 & Jdu>0 & Isimu>0
 {  If (Charge=0 & AdEstep=0)                go to :done:;
    "  Single hit option - only entry and exit are registered by user  "
    If (Istop=0 & InwVol<2 & Jbit(Iopt,1)>0 & aStep<SteMax) go to :done:
    If (Isimu>1 & Istak>0)                   Call AgSKING
*
    If Jbit(Iopt,2)>0                     " calculate the middle position "
    { Call GMTOD(vect,vloc,1);       do i=1,3 { xloc(i)=(vloc(i)+vloc0(i))/2.}}
    If Jbit(Iopt,3)>0                     " calculate the middle cosines  "
    { Call GMTOD(vect(4),vloc(4),2); do i=4,6 { xloc(i)=(vloc(i)+vloc0(i))/2.}}
    Vloc(7)=Vect(7);                            xloc(7)=(vloc(7)+vloc0(7))/2.
*
    Itr=ITRA;  If (Jbit(Iopt,4)>0) Itr=1;  IhaveMore=0;
    Loop
    {"  reaccess Jdu, it might move since we entered the volume "
     Js=LQ(Jset-Iset);  Jd=LQ(Js-Idet);  JDU=LQ(Jd-3);  Iret=Jdu;
     i1=Q(Jdu+1);  i2=Q(Jdu+3);  jv=iv;  ih=0;  jh=0;  JDH=Jd+10+2*iv;
     K=0;
     do i=i1,i2-1,NwuHit        " - - - - - - - - hits  - - - - - - - - "
     {  j=jdu+i;  Fmx=Q(j+5); Org=Q(j+6); Fct=Q(j+7); Iad=IQ(j+9); ic=Q(j+10);
        hit=serial;
        If   Iad==0   { hit=AgGHIT(ic)           }
        else If ic>0  { Call JumpT2(Iad,j,hit)   }
        else          { Call CSJCAL(Iad,2,j,hit) }
 
        " special case for phi(0,2pi) and rapidity(0,max) -> Org=-Fmin "
        If "phi"  ic==6  { If (Org<=0 & Fmx>6.28 & hit<0) hit+=TwoPi;  }
        If "eta"  ic==8  { If (Org<=0 &            hit<0) hit=-hit;    }
        K+=1; Hits(k)=hit;
     }
     K=0;  Jds=Jdu;  h1=hits(1);  Mode=0
     do i=i1,i2-1,NwuHit        " - - - - - now make binning  - - - - - "
     {  j=jds+i;  Fmx=Q(j+5); Org=Q(j+6); Fct=Q(j+7); Nb=Q(j+8); Nbr=Q(j+3)
        " NB: Nb is always positive, only Nbr keeps track of REQUESTED Nb "
 
        K+=1;      hit=max(-Org,HITS(k))
        If jv<NVname        "  pseudo-volumes - may change SJDH content   "
        { jv+=1; NumBV(jv)=bin(min(hit,Fmx-.1/fct));
                 JDH+=2;IQ(JDH)=mod(Nb,32);              }
        else                " hit part - may be only partially comulative "
        { ih+=1; Hits(ih)=min(Hit,Fmx-1.1/fct);
                 if (-32<=Nbr&Nbr<=0) Mode=1; jh+=Mode;  }
 
        " select the appropriate hit descriptor using the first hit element "
        If K==1
        { while LQ(Jds)>0 & bin(Q(LQ(Jds)+8))<=NumBv(jv) {Jds=LQ(Jds)} }
     }
    " all non-comulative AGI hits before opt=H are stored in the volume part "
     If IEOTRI==0
     { do itry=1,2
       { Call GSCHIT(Iset,Idet,Itr,NumBV,Hits,jh,Ihit);    if (ihit>0) break
         If itry==1 { call mzgarb(2,0); call mzgarb(20,0); call mzdred(20);}
         else       { IEOTRI=1; IQUEST(1)=0;  Call GPCXYZ;
                      <w> IHset,IHdet;(' AGGSTEP cant store hits in',
                          2(1x,a4)/' **** event simulation abandoned ****');
     } }            }
    } while IhaveMore>0
    Call UCOPY(vect,vect0,7); call Ucopy(vloc,vloc0,7); {Astep,AdEstep}=0;
 }
 :done:; " If  NGKINE>0 { Call GSKinG (0); NGKINE=0; } - now in gustep "
   END
 
 
+DECK,AgGHIT,T=geant. ----------------------------------------------------------
*CMZ :          08/08/97  11.42.02  by  Pavel Nevski
*CMZ :  1.30/00 02/04/96  14.53.21  by  Pavel Nevski
*CMZ :  1.00/00 31/05/95  23.17.43  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                    Function     A g G H I T (ic)
*                                                                    *
*  Description:  general hit coding for any standard detector        *
*                                                                    *
**********************************************************************
+CDE,TYPING,GCUNIT,GCONST,GCVOLU,GCKINE,GCKING,GCTMED,GCTRAK,AGCSTEP.
 REAL             AgGHIT,VDOTN,VDOT,Hit,V(3),R,THE,VMOD,
                  a(2),c(2),dk,da,Vec(2)
 Integer          IC,JMP,i,IcMax/27/
 
 AgGHIT=-9999;    If (0>Ic | Ic>IcMax) Return;      hit=0;
 
 Case  IC of ( X  Y  Z   R    RR   PHI  THET ETA  TDR CP    _
               U  V  W   ETOT ELOS BIRK STEP LGAM TOF USER  _
               XX YY ZZ  PX   PY   PZ   SLEN                )
 {
  :X:;:Y:;:Z: hit=Xloc(ic);                                              Break;
  :R:         hit=VMOD(Xloc,2);                                          Break;
  :RR:        hit=VMOD(Xloc,3);                                          Break;
  :PHI:       If (xloc(1)#0|xloc(2)#0) hit=ATAN2(xloc(2),xloc(1));       Break;
  :THET:      R=VMOD(xloc,3); if (R>0) hit=ACOS(xloc(3)/R);              Break;
  :ETA:       Do i=1,3 { V(i)=(Vect(i)+Vect0(i))/2 }
              R=VMOD(V,3); if (R>0) THE=ACOS(V(3)/R)
              hit=-ALOG(TAN(min(max(1.e-6,THE),pi)/2));                  Break;
  :TDR:       " vector a=vloc-vloc0"   Call vsub(vloc,vloc0,a,2);
              da=vdot(a,a,2);  dk=-1;  if (da>0) dk=-vdot(a,vloc0,2)/da;
              If 0<= dk&dk <=1 "point is insided, vec=vloc+a*dk "
                   { Call Vlinco(vloc0,1.,a,dk,Vec,2); hit=VMOD(Vec,2);}
              Else { hit=min(VMOD(vloc0,2),VMOD(vloc,2)) };              Break;
  :CP:        " vector a=vloc-vloc0"   Call vsub(vloc,vloc0,a,2);
              Call Vlinco(vloc0,-1.,a,-0.5,c,2); hit=vdotn(a,c,2);       Break;
  :u:;:v:;:w: i=ic-10+3;   hit=Xloc(i);                                  Break;
  :ETOT:      hit=GETOT;                                                 Break;
  :ELOS:      hit=aDeStep;                                               Break;
  :BIRK:      hit=aDeStep; Call GBIRK(hit);                              Break;
  :STEP:      hit=aStep;                                                 Break;
  :LGAM: hit=-999; IF(AMass>0&GEKin>0&Charge#0) Hit=ALOG10(GEKin/AMass); Break;
  :TOF:       hit=TOFG;                                                  Break;
  :USER:      hit=aDeStep;                                               Break;
  :XX:;:YY:;:ZZ:  i=ic-20; Hit=(Vect(i)+Vect0(i))/2;                     Break;
  :PX:;:PY:;:PZ:  i=ic-20; Hit=(Vect(i)*Vect(7)+Vect0(i)*Vect0(7))/2;    Break;
  :SLEN:      hit= Sleng;                                                Break;
 }
2 AgGHIT=hit;
   END
 
+DECK,AgFHIT0,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 03/07/96  18.18.58  by  Pavel Nevski
*CMZ :  1.00/00 05/06/95  16.16.44  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
             Function     A g F H I T 0 (Cset,Cdet)
*                                                                    *
*  Description: only general digitization control here               *
**********************************************************************
+CDE,TYPING,GCUNIT,AGCRDIG,AGCBUFF.
Character*(*)  Cdet,Cset
Integer        AgFHIT0,AgFDIG0,AgsDIG0,AgPFLAG,I,J,L,ok/0/
*
   AgFHIT0=-1;   Cs=Cset(1:3)//'H';   Cd=Cdet
   IPRIN = AgPFLAG (Cset,'DIGI');     Check Iprin>=0
   If (IPRIN>=5) CALL AGPDIGI (Cs,Cdet)
*
   AgfHIT0  = AgFDIG0 (Cs,Cdet)
   if AgFHIT0==ok { I = AgSDIG0 (Cset(1:3)//'D',Cdet) }
   else           { prin4 AgfHIT0,cs;(' AgFHIT0=',i3,': no hits found in ',a)}
   If Iprin>=15
   {  <w>;  (' *** AGFHIT buffer  ***');  j=1;  while Ibuf(j)>0
      {  L=IBUF(j); if (L<=0) Break; <w> j,L,(Ibuf(j+i),i=1,L);
         (' adr=',i6,' L=',i4,2x,20i5/(20x,20i5));      j+=L+1;
   }  }
   END
 
 
+DECK,AgFHIT1,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 25/06/96  13.21.46  by  Pavel Nevski
*CMZ :  1.00/00 05/06/95  12.50.41  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
     Function     A g F H I T 1 (NHit,LTRA,ISC,HITS)
*                                                                    *
* Description:  only general digitization print control here         *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,AGCRDIG,AGCBUFF.
Integer      AgFHIT1,AgFDIG1,Nhit,LTRA,ISC(*),ok/0/
Real         HITS(*)
*
   AgFHIT1=AGFDIG1(NHit,LTRA,ISC,HITS); If (AgFHIT1==ok) Return;
*
   Prin2 Cs,Cd,nc1,nc2,iws(1)
   (' AGFHIT1: set/det=',2(1x,a),' hits analysed=',2i8,' digits done=',i8)
   if (Iprin>=4)  Call AGPDIGI(cs(1:3)//'D','*')
   END
 
 
+DECK,AgSDIG0,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 12/07/96  09.34.13  by  Pavel Nevski
*CMZ :  1.00/00 01/05/95  14.09.00  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
************************************************************************
*                                                                      *
                 Function  A G S D I G 0 (CSET,CDET)
*                                                                      *
*  Description:   store GEANT digits in the new dense format           *
*  Compared to the original GEANT routine a new SET/DET can be added   *
************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,AGCDIG,QUEST.
   Character*4    Cset,Cdet,cs
   Integer        AgSDIG0,NSET,NDET,NEED,ier
 
   AgSDIG0=-1;  Cs=Cset(1:3)//'D';
   "            Find if selected set, detector exists       "
   JDU=0;                                                   Check JSET> 0;
   NSET = IQ(Jset-1);                                       Check Nset> 0;
   Call GLOOK(Cs,IQ(Jset+1),Nset,Iset);                     Check Iset> 0;
   JS   = LQ(Jset-Iset);                                    Check Js  > 0;
   NDET = IQ(Js-1);                                         Check Ndet> 0;
   Call GLOOK(Cdet,IQ(JS+1),Ndet,Idet);                     Check Idet> 0;
   JD   = LQ(JS-Idet);                                      Check JD  > 0;
   JDX  = LQ(JD-2);                                         Check JDX > 0;
   NW   = IQ(JD+1)+IQ(JD+5)+1;                              Check Nw  > 0;
   JDU  = LQ(JD-3);                                         Check JDU > 0;
   NV   = IQ(JD+2);   ND   = IQ(JD+6);
   NVU  = Q(JDU+6);   NDU  = Q(JDU+2);
   IF (NV+ND # NVU+NDU)  { Print *,' AgSDIG0 error'; Return; }
 
   Ier=iquest(1); Iquest(1)=0;
   IF JDIGI==0                       "    Create DIGItisation master bank    "
   {  Call MZBOOK(IXDIV,JDIGI,JDIGI,1,'DIGI',NSET,NSET,0,2,0); IQ(JDIGI-5)=1;}
   else IF IQ(JDIGI-2)<NSET
   {  NEED=NSET-IQ(JDIGI-2);  Call MZPUSH(IXDIV,JDIGI,NEED,0,'I');   }
*
   JX=LQ(JDIGI-ISET);                "    Create DIGItiastion set bank       "
   IF  JX==0
   {   Call MZBOOK(IXDIV,JX,JDIGI,-ISET,'DIGI',NDET,NDET,NDET,2,0);  }
   else IF min(IQ(JX-1),IQ(JX-2))<Ndet
   {   NEED=NDET-min(IQ(JX-1),IQ(JX-2)); Call MZPUSH(IXDIV,JX,NEED,NEED,'I');}
*
   JXD=LQ(JX-IDET);                  "    Create DIGItisation bank           "
   IF (JXD==0) Call MZBOOK(IXDIV,JXD,JX,-IDET,'SJDX',0,0,IQ(JD+8),1,0);
*
   If IQUEST(1)!=0 {<W> Ier,IQuest(1);(' AgSDIG0 Memory problem ',2i6); Return}
   AgSDIG0 = 0;  IQ(JX+IDET)=0;
 
  END
+DECK,AgSDIG1,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 01/12/96  23.50.41  by  Pavel Nevski
*CMZ :  1.00/00 03/10/95  23.10.08  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
**********************************************************************
*                                                                    *
                 FUNCTION A G S D I G 1 (LTRA,NUMBV,DIGI)
*                                                                    *
*  Description:   store GEANT digits in the new dense format         *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT,AGCDIG,QUEST.
  Integer   AgSDIG1,Last,Kdigi,Nk,Nb,I,J,K,N,i1,i2,i3,Ltra,j1,num,bin,jds,
            NUMBV(*),NwuHit/10/
  REAL      DIGI(*),Org,fct,fmx,xx
  bin(xx) = (xx+org)*fct
 
  AgSDIG1=-1;  Check Jdu>0;  Jds=Jdu;
  LAST=IQ(JX+IDET)     "  Check if enough space. If not increase bank size  "
  If IQ(JXD-1)<=LAST+Nw             "    one attempt should be enouph       "
  {  N=MAX(100,NW,IQ(JD+8)/2);   CALL MZPUSH(IXDIV,JXD,0,N,'I');
     If IQUEST(1)#0 { <W>; (' Lack of Memory in AgSDIG1');  Return; } }
 
  " ========>    Store tracks numbers, volumes numbers and digits  <========"
  " Nbit is taken from the SEJD/SJDD banks not to dublicate option analysis "
  " Org&Fct are taken from SJDU - the only place containing all variables   "
  j=JXD+LAST+1; IQ(j)=max(0,LTRA);  NK=1; K=1; i3=0;
 
  DO I=1,NVU           "           Store packed volume numbers              "
  {  Nb=IQ(JD+2*I+10);     num=max(0,NUMBV(i)-1);
     IF Nb>0  { K+Nb>33 ?; CALL MVBITS(NUM,0,Nb,IQ(j+NK),K-1);   K+=Nb; }
     else     { K>1     ?; IQ(j+Nk)=NUM;                         Nk+=1; }
  }
  Do I=1,NDU           "               Store packed digits                  "
  {  i1=JDS+i*10;   org=Q(i1+6);  fmx=Q(i1+5);  fct=Q(i1+7);
     KDIGI=(org+min(DIGI(i),fmx))*fct;   KDIGI=max(0,KDIGI);
     i2=I+Nvu;  i3=i2-Nv;  i3==1 & K>1 ?;
     If i3<=0 { Nb=IQ(Jd+2*i2+10) } else { Nb=IQ(Jdx+2*i3) };
     IF Nb>0  { K+Nb>33 ?; CALL MVBITS(KDIGI,0,Nb,IQ(j+Nk),K-1); K+=Nb; }
     else     { K>1     ?; IQ(j+Nk)=KDIGI;                       Nk+=1; }
     "   select the appropriate hit descriptor using first hit element  "
     If I==1  { while LQ(Jds)>0 & bin(Q(LQ(Jds)+8))<=KDIGI {Jds=LQ(Jds)}}
  }
  K=1+IQ(JD+1); N=Nw;
  If   i3>0            "               cumulative digits                    "
  {:D: Do j1=JXD+Last,JXD+1,-Nw
       {                  if (IQ(j1)  !=IQ(j)  ) Break :D:;
          do i=1,K-1    { if (IQ(j1+i)!=IQ(j+i)) Next  :D:; }
          do i=K,Nw-1   {     IQ(j1+i)+=IQ(j+i); }
          N=0; Break :D:;
  }    }
  " if (N=0) <W> (DIGI(i),i=1,NDU); ( ' AGSDIG1 digi added: ',10F10.3);     "
  Last+=N;   IQ(JX+IDET)=Last;  IWS(1)=Last/Nw;
  AgSDIG1=0;
   END
 
 
 
+DECK,AgDOCUM,T=geant. =========================================================
*CMZ :          30/04/98  14.43.32  by  Pavel Nevski
*CMZ :  1.30/00 17/11/96  22.43.56  by  Pavel Nevski
*CMZU:  1.00/01 21/12/95  22.19.56  by  Pavel Nevski
*CMZ :  1.00/00 14/11/95  02.46.06  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A g D O C U M  _
     (Module,MTitle,Author,Created,Btit,Bank,Bpath,num,Lb,
                   Map,Names,Comment,Par,LL,LL1,Link,Flag)
*                                                                    *
*  Description: store a bank in DETM or RECB structure with          *
*               corresponding documentation bank for DZDOC           *
* - AgDOCU is the FILL processor. It may be called in MODULEs only.  *
* - There may be 3 forms of Bpath: short relative (one word),        *
*   long relative (words separated by /), absolute (starts with /).  *
* - If the first call in a MODULE has a short Bpath, the latest is   *
*   kept as a CTOP bank, attached to //DETM/MODULE.                  *
* - If the first call in a MODULE has a long Bpath, the latest is    *
*   attached to //RECB.                                              *
*   CTOP bank or any absolutely addressed bank remain a DEFAULT bank *
* - All documetation banks are created lineary in DOCU/MODULE bank   *
* - Flag controls the I/O format, Link - access methode              *
* Modifications:                                                     *
* 16/04/96 PN: flag list changed as in AsFLAGS                       *
**********************************************************************
REPLACE [ERR#{#}] with _
        [; IF (#1) {<W>%L(Module),Bank; (' AgDOCUM error for module ',A,
                    ' for bank ',A/ 10x,'*** #2 ***');    Istat=-100;
                     "no doc mode" {L1Doc,L2Doc,Ldoc}=0;  Return   }; ]
REPLACE [SWAP(#,#)] with [;iw=#1;#1=#2;#2=iw;]
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,SCLINK,AGCDOCL,QUEST,RBBANK.
Integer       LENOCC,OK,Lb,LL,LL1,LvL,ns1,ns2,Need,Ndm,i,j,k,l,M/1000000/,
              Idat,Itim,Link,Ia,Lk,L1,L2,Flag,IDYN,INEW,JOX,iw,idd/0/,X,IC,
              map(2,LL1),num(Lb),key(3),ID/0/,Iform/0/,Jform/0/,Istat/0/
Character*(*) Module,MTitle,Author,Created,Bank,Bpath,Btit,
              Names(LL1),Comment(LL1)
Character*12  Ddoc,nam
Character*4   Ctop,Cbank,C1,C2
Character*8   Flags(15),Dmodule,Dmodu,Dbank,Dbanu,Dup,Ddef,Bname,dash/'-'/
Character*24  Descr(15),Tshort
Character     Cform*80,Cforn*80,C*1
Parameter     (OK=0)
Save          Id,Dmodule,Dbank,Dup,Ddef,Ctop
Logical       First/.true./,start
Real          Par(LL)
Integer iprin/1/
* - - - - - - - - - - - - - - - dete bank - - - - - - - - - - - - - - - - - - -
Data Flags  /'PNOW', 'PRIN', 'DEBU', 'GEOM', 'HIST', 'GRAP', 'SIMU', 'DIGI',
             'RECO', 'MFLD', 'ANAL', 'BACK', 'resa', 'resb', 'resc'/
Data Descr  _
      /'current print level  ','system print level   ','GEANT debug level    ',
       'geometry version     ','system histogram flag','system graphics level',
       'store GEANT hits flag','digitisation flag    ','reconstruction flag  ',
       'magnetic field flag  ','user analysis level  ','pile-up bunch select.',
       'reserve              ','reserve              ','reserve              '/
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
 
If First
{  First=.false.;   Istat=0;
   Call MZFORM('DETP',  '-F'  ,Iform);   Call MZFORM('DDOC','1H 19I -S',Jform);
  "this part may be re-executed only after recompilation(standalone debugging)"
  "-in this case make sure that link areas are not initialized twice (commons)"
  " If (L1Doc>0)     call MZDROP(IxCONS,L1Doc,' ')  Standalone debugging mode "
*
*  it was a structural link area, now it becomes a reference one
*  If (LdArea(1)=0) call MZLINT(IxCONS,'AGCDOCL',LDarea,Lpar,LDarea)
   If (LdArea(1)=0) call MZLINT(IxCONS,'AGCDOCL',LDarea,L1Doc,Lpar)
   L1Doc=0;
}
If L1Doc<=0
{  Call AsbDETE('DOCU',I);  L=0;  If (LKDETM>0 & I>0)  L=LQ(LQ(LKDETM-I)-1);
   If L>0 { CALL UHTOC(IQ(L-5),4,bname,8); if (bname=='NONEDETM') L1doc=L; }
}
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* - - - - - -          create the information bank itself           - - - - - *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
 
" trace module changes - a module may have only ONE default Ctop bank "
IOX=Flag; If IOX==0
{ call AgDForm(Names,map,LL1,LL,Cform,Cforn);  Call MZFORM(Cbank,CForm,IOX) }
*
Cbank=Bank;  Dmodu=Module;  start=.false.
If Dmodu != Dmodule { Dmodule=Dmodu; Ctop=Cbank; Ddef=' '; start=.true.}
*
If Lb==1                              "  default directories in the DETM bank "
{  If Cbank==Ctop
   { Call AsBDETE(Dmodu,ID); Err Id<=0 {detector not found in DETM bank}
     IrBDIV=IxCONS;  LkArP2=LQ(LkDETM-Id);  LvL=3;  Dup=Dmodu(1:4)//'DETM'}
   else                                   { LvL=4;  Dup=Ddef }
   Call ReBANK (Cbank,Num,LL,LK,Ia)
}
else                                 "     explicit directory setting if /    "
{  J=1;  While Bpath(j:j)=='/' {J=J+1};
   If  J>1                            { Lvl=3;  C2='NONE'}
   else
   {  If Cbank==Ctop
      {  If (LKAR P1==0) Call MZBOOK(IxDIV,LKAR P2,LKAR P1,1,'RECB',2,2,10,2,0)
         IrBDIV=IxDIV;  LkArP2=LkArP1;  Lvl=3;  C2='RECB'}
      else                            { Lvl=4;  C2= Ddef }
   }
   J=J+5*(lb-2)-1; C1=Bpath(J+1:J+4); If (lb>2) C2=Bpath(J-4:J-1); Dup=C1//C2;
   Call ReBANK (Bpath,num,LL,LK,Ia)
}
   JOX=IOX;
   Call UCOPY (PAR,Q(LK+1+Ia),LL);    Call SBIT0(IQ(Lk),1)
   LkArP3=Lk  "temporary save bank address"
   If Lvl==3  { "RbCDir"  LkArP2=Lk;  Ddef=Cbank//Dup }
*
IDYN=0; INEW=LL;             " dependant dynamic banks now - if any required "
DO i=1,LL1
{  if (map(1,i)>0 & map(2,i)>0)       { INEW-=map(1,i)*map(2,i); Next; }
   INEW-=1;                               " dynamic array found here "
   If (Link==0) Link=-1                   " force link to be secured "
   L1=map(1,i); If L1<0
   { L1=-L1;    if L1<M { Call Ucopy(Par(L1),L1,1)} else { L1=nint(Par(L1-M))}}
   L2=map(2,i); If L2<0
   { L2=-L2;    if L2<M { Call Ucopy(Par(L2),L2,1)} else { L2=nint(Par(L2-M))}}
   L=Lenocc(Names(i));  Nam=Names(i)(3:L)//'xxxx';  Nam(5:)='*';
   C=Names(i)(1:1); If C=='I' {IOX=2} else If C=='H' {IOX=5} else {IOX=3}
   swap(LkArP2,LkArP3)
   CALL ReBANK (Nam,1,2+L1*L2+3,Lk,Ia)
   swap(LkArP2,LkArP3)
}
* LkArP3 keeps the current bank adress now
Dmodule=Module;  Call AGDLINK(Module,Bank,Link,LkArP3)
Check Flag==0;   Flag=JOX;
 
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* - - - - -   new bank: make sure that detector documentation exists  - - - - *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
 
If Start
{ "-------------------       level 1  -  DETM bank       -------------------"
  Call AsBDETE(Dmodu,ID);     Err Id<=0 {detector does not exist in DETM bank}
  Dbanu='DETMNONE';  Call UCTOH(Dbanu,Key,4,8);  IQUEST(1)=0;
  If Istat=0 & L1Doc<=0
  { Call AsBDETE('DOCU',idd)
    Call RZIN (IxCONS,LQ(LKDETM-idd),-1,Key,0,' ')
    If (Iquest(1)==0) L1Doc=LQ(LQ(LkDETM-idd)-1)
    If L1Doc<=0               " main documentation bank does not exist "
    { IQuest(1)=0
      Call MZBOOK(IxCONS,L1Doc,LQ(LkDETM-idd),-1,'DETM',2,2,300,Jform,0)
*      if (idebug>0) print *,'DETM/DOCU/DETM done '
      Err L1Doc<=0 | Iquest(1)#0 { Cant create main documentation bank }
      IQ(L1Doc-5)=key(2)
      Call AgDOCBA(L1Doc,Dbanu,'Detector main bank', Author,Created,'-H',
                         0, 1, 'detector','subsystem or faculty name ',X)
      Err L1Doc<=0 | Iquest(1)#0 { Cant write main documentation bank }
  } }
  "-------------------       level 2  -  DETE bank      -------------------"
  If Istat==0 & L1Doc>0
  { "        first add link description in DETM bank                       "
    Call AgDTIT (MTitle,Tshort)
    Call AgDOCBA (L1Doc,Dbanu,'*','*','*','*',1,0,Module(1:4),Tshort,X)
    " insure that links in doc DETM coincides with the main DETM "
    Ns1=IQ(LkDETM-2);  Ns2=IQ(L1Doc-2);  Need=ns1-ns2
    If (Need>0) Call MZPUSH (IxCONS,L1Doc,Need,0,' ')
    L2Doc=LQ(L1Doc-Id)
    If L1Doc>0 & L2Doc<=0
    { Dbank=DModu(1:4)//'DETM';   Call UCTOH(Dbank,Key,4,8);
      Call RZIN (IxCONS,L1Doc,-ID,Key,0,' ');  L2Doc=LQ(L1Doc-Id);
      If Iquest(1)#0|L2Doc<=0 "Documentation does not exist for THIS detector"
      { IQuest(1)=0; Call MZBOOK(IxCONS,L2Doc,L1Doc,-ID,Dbank,2,2,300,Jform,0)
        Err L2Doc<=0 | Iquest(1)#0  { Can not create DETE documentation bank }
        IQ(L2DOC-5)=key(2)
        Call AgDOCBA(L2Doc,Dbank,Tshort,Author,Created,'-I',0,15,Flags,Descr,X)
        Err L2Doc<=0 | Iquest(1)#0  { Can not write DETE documentation bank  }
  } } }
  Err IQuest(1)#0|L2Doc<=0|L1Doc<0{cannot find top level documentation banks}
}
"---   level 3/4  -  the bank itself: all documentation is linear in DETE  ---"
Ldoc=0; Lkdoc=0;
If L2Doc>0
{  * first, update links in upper level bank
   Ddoc=Cbank//Dup; Call UCTOH(Ddoc,Key,4,12);
   Ndm=60+LL*16;    Ns1=IQ(L2doc-2)
   if IQ(L2doc-4)==Key(2) & IQ(L2doc-5)==Key(3)  " - for level 3 doc "
   {  "link" Call AgDOCBA (L2doc,Dup,'*','*','*','*',1,0,Cbank,Btit,X) }
   do i=1,Ns1
   {  Ldoc=LQ(L2Doc-i);   If (Ldoc<=0) go to :f:
      * if this is a previus description of the same bank - drop it
      if IQ(Ldoc-4)==Key(1) & IQ(Ldoc-5)==Key(2)
      {  Call MZDROP (IxCons,Ldoc,' ');   goto :f:;  }
      * if this is a description of the parent bank - insert links
      if IQ(Ldoc-4)==Key(2) & IQ(Ldoc-5)==Key(3)   " - for level 4 doc "
      { Lkdoc=Ldoc; Call AgDOCBA (Ldoc,Dup,'*','*','*','*',1,0,Cbank,Btit,X) }
   }  i=Ns1+1;  Call MZPUSH(IxCONS,L2DOC,5,0,' ')
 
   :f: Ldoc=LQ(L2Doc-i)
   If (Ldoc==0)  Call MZBOOK (IxCONS,Ldoc,L2doc,-i,Cbank,2,2,Ndm,Jform,0)
   Call AGDTIT (Btit,Tshort)
   If (INEW>1)
   {  Call AgDOCBA(Ldoc,Ddoc,Tshort,Author,Created,cform,0,1,dash,
                                                   'usage counter',X)
      Call AgDOCBA(Ldoc,Ddoc, '*' , '*' , '*' , '*' ,0,1,dash,
                                                   'system version',X)
   }
   Err LDoc<=0 | Iquest(1)#0 { Can not create documentation bank }
   DO i=1,LL1
   {  k=1; if (map(1,i)>0 & map(2,i)>0) k=map(1,i)*map(2,i)
      L=Lenocc(Names(i));   Nam=Names(i)(3:L);  if IDEBUG>0&L>10
      { <W>%L(Module),Bank,Names(i)(3:L);
       (' AgDOCUM/DZDOC warning in module ',a,', bank ',a,', variable ',a,':'/,
        ' -name too long, will be trucated in documentation and include files')
      }
      Call AgDOCBA(Ldoc,Ddoc,Tshort,Author,Created,cform,0,-k,Nam,Comment(i),X)
   }
   If X==0 & Ldoc>0
   { CALL RZCDIR('//LUN61',' ')
     CALL aRZOUT (IXCONS,L1doc,Dbanu,IC,'SN')
     CALL aRZOUT (IXCONS,L2doc,Dbank,IC,'SN')
     CALL aRZOUT (IXCONS,Lkdoc,Dup , IC,'SN')
     CALL aRZOUT (IXCONS,Ldoc, Ddoc, IC,'SN')
     call RZPURG (1)
}  }
if INEW>1
{  Call DATIME (Idat,Itim);  Par(1)=Idat+Itim/2401.;  Q(LkArP3+1+Ia)=Par(1)
                             Par(2)=IC;               Q(LkArP3+2+Ia)=Par(2)
}
END
 
 
****************************************************************************
          subroutine  ARZOUT(Idiv,Lo,CKey,IC,opt)
*                                                                          *
* Description: same functionality as RZOUT is supposed with few additions: *
*            - consistence between Bank at Lo and Ckey is checked          *
*            - previous bank with simular Ckey is read and compaired,      *
*              new bank is writtent only if it differs from the old one.   *
*            - very crude version , to be developed later (?). Therefore   *
*              intermediate input bank is kept on a free Link=1 of L1Doc   *
****************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,QUEST,AgCDOCL.
 Integer        Ie,Iprin,Idiv,Lo,Li,Key(2),Nc,IC,i,k,New,Old,Mn,Mo;
 Character*(*)  Ckey,Opt,status*10,Copt*4
*
 New(k)=IQ(Lo+k)
 Old(k)=IQ(Li+k)
*
*
 check Lo>0;  Nc=0;  Iprin=Idebug-1; Ie=0; Li=0;
 
* read the highest cycle, return data + cycle info
  Call UCTOH(Ckey,key,4,8); if (key(1)!=IQ(Lo-4) | key(2)!=IQ(Lo-5))
  {  prin3 key,IQ(Lo-4),IQ(Lo-5); (' ARZOUT error: key=',2a4,' bank=',2a4)
     IC=0; Return;
  }
 
* drop previous input - should later be done at the end
  if (L1DOC>0 & LQ(L1DOC-1)>0) Call MZDROP(IxSTOR,LQ(L1DOC-1),' ')
  CALL RZIN (IxCons,L1DOC,-1,Key,999999,'CD');   Li=LQ(L1DOC-1);
* CALL RZIN (IxDIV,Li,2,Key,999999,'CD')
 
  IC=0; Nc=IQUEST(50); if (IQUEST(1)==0 & 0<Nc&Nc<20) Ic=IQUEST(50+Nc)
 
  ie=1; status='written';  if (Li<=0)
  { prin3 key; (' ARZOUT error: key=',2a4,' not found '); go to :w: }
 
  ie=2; "data"   if (New(15)!=Old(15)) goto :w:
  mn=new(3)+new(11)+new(12);  mo=old(3)+old(11)+old(12);
  do i=1,New(15) { If (New(mn+i)!=Old(mo+i)) go to :w: }
 
  ie=3; "links"  if (New(12)> Old(12)) goto :w:
 
  ie=4; "header" if (New(11)> Old(11)) goto :w:;
  mn=new(3);  mo=old(3);
* do i=1,New(11) { If (New(mn+i)!=Old(mo+i)) go to :w: }
 
  ie=9; status='found'
 
  :w: Copt='SN'; " If (ie>2) Copt='SNR' "
  if (status!='found') CALL RZOUT(Idiv,Lo,Key,IC,Copt)
  prin4  status,key,ie,nc,ic; (' aRZOUT status - ',a,' - ',2a4,' cycles ',3i6)
 
* if (Li>0) Call MZDROP(IxSTOR,Li,' ')
 
 end
 
 
+DECK,AgDOCBA,T=geant. ---------------------------------------------------------
*CMZ :          30/04/98  15.29.51  by  Pavel Nevski
*CMZ :  1.30/00 26/04/96  19.30.43  by  Pavel Nevski
*CMZU:  1.00/01 16/01/96  00.31.26  by  Pavel Nevski
*CMZ :  1.00/00 25/08/95  23.30.46  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/95
**********************************************************************
*                                                                    *
                 subroutine       A g D O C B A _
            (Link,Bank,Tit,au,ve,io,NL,ND,Cvar,Comment,i)
*                                                                    *
*  Description:  fill a documentation bank                           *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
Character*(*) Bank,Tit,au,ve,io,Cvar(*),Comment(*),NN*4,Cv*8,Cbuf*80;
Integer       AgDocRd,AgDocWr,Lenocc,Link,NL,ND,Lb,key(2),
              i,j,k,L,Lk,N,N0,ioff,M,ok;
Parameter      (ok=0);
 
I=-1;  Check Link>0;  Lb=IQ(Link-1)
If Bank(1:1)#'*'
{  Call UCTOH(Bank,key,4,8); If IQ(Link-4)#key(1)
   { <w> Bank,IQ(LINK-4); (' AgDOCBA wrong bank: request ',a8,' found ',a4/,
    ' *********************************************************************'/,
    ' * Probably this means that the documentation RZ file is currupted.  *'/,
    ' * This is often fatal and program may crash imediately afterword !  *'/,
    ' * To solve the problem simply remove detm.rz, it will be re-created *'/,
    ' *********************************************************************')
     Link=0;  stop ' too dangerous to continue, re-make detm.rz ! ';
   }
   If IQ(Link+1)=0               " create new bank "
   {  Call Vzero(IQ(Link+1),Lb);  IQ(Link-5)=key(2);
      IQ(Link+1)=key(1);  IQ(Link+2)=20;  IQ(Link+3)=20;
      Cbuf = Bank(1:4)//Tit(1:LENOCC(Tit))
      i    = AgDocWr(Link,'..',0,0,Cbuf)
      i    = AgDocWr(Link,'up',0,0,Bank(5:8))
 
      if (au(1:1)#'*') i=AgDocWr(Link,'au', 0,0,au );
      if (ve(1:1)#'*') i=AgDocWr(Link,'ve', 0,0,ve );
                       i=AgDocWr(Link,'nl', 0,0,' ');
                       i=AgDocWr(Link,'ns', 0,0,' ');
                       i=AgDocWr(Link,'nd', 0,0,' ');
      if (io(1:1)#'*') i=AgDocWr(Link,'io', 0,0,io );
}  }
do k=1,NL                               " links can not be doubled "
{  Lk=Lenocc(Comment(k));
   if AgDocRd(Link,'Link',Cvar(k)(1:4), N,ioff,L) > Ok
   {  if (AgDocRd(Link,'nl',' ', M,Ioff,L)=Ok) IQ(Link+Ioff+3)=N+1;
      if (AgDocRd(Link,'ns',' ', M,Ioff,L)=Ok) IQ(Link+Ioff+3)=N+1;
      Cbuf = Cvar(k)(1:4)//'    - '//Comment(k)(1:Lk)
      i    = AgDocWr(Link,'Link',N+1,0,Cbuf)
}  }
N0=1;
do k=NL+1,NL+abs(ND)                    "    data can be doubled   "
{  j=k; if (ND<0) j=NL+1;  Lk=max(Lenocc(Comment(j)),1);  if (k>j) Lk=0;
   if    AgDocRd(Link,'Data','. . . next free place . . . ',N,ioff,L)>Ok
   { If  Lk=0  { N0+=1; write(NN,'(i3)') N0; }  else  { N0=1; NN=' '; }
     if (AgDocRd(Link,'nd',' ', M,Ioff,L)=Ok)    IQ(Link+Ioff+3)=N+1;
     Cv = Cvar(j);  Cbuf = Cv//' - '//Comment(j)(1:Lk)//NN
     i  = AgDocWr(Link,'Data',N+1,0,Cbuf)
}  }
END
 
 
+DECK,AgDOCRD,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 06/01/95  01.38.29  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/95
**********************************************************************
*                                                                    *
          Function   A g D O C R D (Link,Cf,Ckey, N,ioff,L)
*                                                                    *
* Description: get a record with the Ckey content in the Ctype field *
*              Ckey may be a record type or a content of a DD record *
* Output: N - record number if found, else number of scanned records *
*        id - offset of the record in bank, IQ(link+id+1) first word *
*             of  [3*16+2,'cf',i1,i2,L*16+5,'text data (1-L)']       *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
   character      Cf*(*),Ckey*(*), C*5/'GLSUD'/;
   Integer        AgDOCRD,LENOCC,Link,ioff,N,L,id,if,
                  key(10),Lk,Lt,id1,id2,NW,I,J,IW;
   Integer        mask(9)/1,1024,16384,8192,9216,10240,15361,19456,17410/;
   Character*2    ask (9)/'..','au','ve','nd','nl','ns','up','io','dd'/;
 
   {N,ioff,L,Lk}=-1;                       " check bank format "  AgDocRd =-1;
   Lt=20; do i=1,5 { Lt+=IQ(Link+10+i); };
   Unless (IQ(Link+3)==20 & IQ(Link+2)==Lt & IQ(Link-1)>=Lt)      go to :E:;
 
   Id1=20; if=1;                           " decode request Cf "  AgDocRd =-2;
   do id=1,8 { If (Cf(1:2)=ask(id)) goto :F:; };
   Lk=LENOCC(Ckey); Call UCTOH(Ckey,key,4,min(Lk,40)); Lk=(Lk+3)/4;
   do if=1,5 { if (Cf(1:1)=C(if:if)) goto :F:; Id1+=IQ(Link+10+if); }
                                                                  goto :E:;
   :F: Ioff=id1; id2=0; N=0; Nw=IQ(Link+10+if);
   :N: while id2<NW
   {  Ioff=Id1+Id2; J=Link+Ioff; N+=1;   " check record format"   AgDocRd =-3;
      If (IQ(J+1)#50) Break;            L=0;     Id2+=4;
      Iw=IQ(J+5); IF (Mod(Iw,16)=5)   { L=Iw/16; Id2+=1+L; }
      IF (IQ(J+2)#Mask(Id) | Lk>L)      Next :N:;
      Do i=1,Lk { If (IQ(J+i+5)#Key(i)) Next :N:; }               AgDocRd = 0;
                                                                  goto :E:;
:L:}                                                              AgDocRd = 1;
:E:"<w>AgDOCRD,Cf,Ckey,N,ioff,L;(' AgDocRd=',i2,' at ',a,1x,a,' N,of,L=',3i6)";
END;
 
+DECK,AgDOCWR,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 06/01/95  01.39.27  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/01/95
**********************************************************************
*                                                                    *
            Function   A g D O C W R (Link,Cf, I1,I2, TEXT)
*                                                                    *
* Description:  Insert a new record at the end(!) of the Cf field    *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT.
   character    Cf*(*),TEXT*(*), C*5/'GLSUD'/;
   Integer      AgDOCWR,LENOCC,Link,I1,I2,If,Id,Lk,Need,Lt,Li,L,iof,I,N;
   Integer      mask(9)/1,1024,16384,8192,9216,10240,15361,19456,17410/;
   Character*2  ask (9)/'..','au','ve','nd','nl','ns','up','io','dd'/;
 
                                           " check bank format "  AgDocWr =-1;
   Lt=20; do i=1,5 { Lt+=IQ(Link+10+i); };
   Unless (IQ(Link+3)==20 & IQ(Link+2)==Lt & IQ(Link-1)>=Lt)      goto :E:;
 
   Iof=20+IQ(Link+11);  If=1;             " decode request "      AgDocWr =-2;
   do id=1,8 { If (Cf(1:2)=ask(id)) goto :N:; };  Id=9;
   do if=2,5 { Iof+=IQ(Link+10+if); if (Cf(1:1)=C(if:if)) goto:N:; }
                                                                  goto :E:;
   :N: Lk=LENOCC(Text);  Li=4; N=0;   If (Lk>1) { N=(Lk+3)/4; Li=5+N;}
   Need=Lt+Li-IQ(Link-1);  If (need>0) Call MZPUSH(IxCons,Link,0,Need+10,' ');
   L=Link+Iof;     Call UCOPY2(IQ(L+1),IQ(L+Li+1),Lt-Iof);
   IQ(L+1)=16*3+2; IQ(L+2)=Mask(Id); IQ(L+3)=i1; IQ(L+4)=i2;
   If  Li>4  { IQ(L+5)=16*N+5; Call UCTOH (Text,IQ(L+6),4,Lk); }
   " increase length "  IQ(Link+2)+=Li;  IQ(Link+10+If)+=Li;      AgDocWr = 0;
:E:"<w> AgDOCWR,Cf,I1,I2,TEXT;(' AgDocWr=',i2,' at ',a,' i1,i2,T=',2i5,2x,a)";
END;
 
+DECK,AgDGETP,T=geant. ---------------------------------------------------------
*CMZ :          24/04/98  21.24.51  by  Pavel Nevski
*CMZ :  1.30/00 09/02/97  21.15.43  by  Pavel Nevski
*CMZU:  1.00/01 22/12/95  21.50.31  by  Pavel Nevski
*CMZ :  1.00/00 15/11/95  01.03.24  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                     Subroutine   A g D G E T P  _
          (Module,Oper,istat,Bank,Name,Value,Bpath,Num,Lb,
                             Map,Names,Par,LL,LL1,Link,Flag)
*               - - -    USE processor    - - -                      *
* Description: Given the module and the bank name returns the        *
*    instance of the bank containing a selected parameter value      *
*    If the Name is blank, select the first (default) bank           *
*    Flag is 0 only at the first call, allowing more checks on it    *
* Modifications:                                                     *
*  PN, 03/06/96:                                                     *
*  default module/bank is saved in stack as suggested by Ulrik Egede *
*  selected DETM branch becomes Unique only in GEO or by Oper=UNIQ   *
**********************************************************************
+CDE,TYPING,QUEST,GCBANK,GCUNIT,SCLINK,AGCLINK,RBBANK.
     INTEGER          Nbp,IP1STACK,    IP2STACK,    IEND,IDSTACK
     COMMON /RBSTACK/ Nbp,IP1STACK(20),IP2STACK(20),IEND,IDSTACK(20)
REPLACE [ERR#{#}] with [;    IF (#1) {  IQUEST(1)=0;
    IF (istat!=-999) { Istat=Jstat; Return; }
    <W> %L(Module),Ctop,%L(Bank),LL,%L(Name),Value,%L(Bpath),(num(i),i=1,lb)
    (' error in USE operator called from ',A,' for bank ',A,'/',A,' L =',i3/ _
         10x,'Looking for variable ',A8,' =',F10.3/10x, '***** #2 *****'  / _
         10x,'The path is ',A,' with IDN =',10i5 );  Return; }
  ]
   Integer       LENOCC,LOCF,JBIT,Iname,Ns,LL,IL,Ia,Ib,Id,LP,JP,La,Lb,Lc,i,J,L,
                 Lvl,LL1,Link,Lk,Flag,Num(Lb),Map(2,LL1),Nch,IDYN,istat,jstat
   Character*(*) Module,Bank,Bpath,Name,Names(LL1),Oper
   Character*4   Ctop,Cbank,C1,C2
   Character*8   Dmodu,Dmodule,Dup,Ddef
   Character*80  Cform,Cforn,Bform
   Real          Value,Val,Par(LL)
   Save          Ctop,Dmodule,Ddef,Dup,ID
 
" trace module changes - a module may have only ONE default Ctop bank "
Cbank=Bank;  Jstat=-1;
if Oper(1:1)=='N' & (Istat==0 | Istat=-999) " this is a NEXT request "
{ Err LINK<0 { Bank was not selected };       Lk=%LINK(LINK);
  Err Lk<=0  { Previous bank desappeared };   Lk=LQ(Lk);
}
else
{ If Nbp==0  { Dmodu=Module; If Dmodu!=Dmodule
               { Dmodule=Dmodu; Ctop=Cbank; Ddef=' '; ID=0;
             } }
*
 If Lb==1                             "  default directories in the DETM bank "
 { :M: If Cbank==Ctop
   { Call ASLDETN(Dmodu,ID);    Err Id<=0 {detector not found in DETM bank}
     IrBDIV=IxCONS;  LkArP2=LQ(LkDETM-Id);  LvL=3;  Dup=Dmodu(1:4)//'DETM'}
   else                                   { LvL=4;  Dup=Ddef }
   If Name!=' '                    " - we need IL. Num(1) is not used at all "
   {  Lk=0;  Err LKARP2<=0 {default bank undefined}
      Call UCTOH (Cbank,Iname,4,4);    NS=IQ(LKARP2-2)
      Do IL=1,NS { Lk=LQ(LKARP2-IL); If(Lk>0&IQ(Lk-4)==Iname) Break; Lk=0}
   }
   else  { Call ReBANK (Cbank,Num,-LL,Lk,Ia) }
   " this may not be a good solution, try it however "
   If  Lk<=0 & LvL==4  { Ctop=Cbank; Go to :M:; }
 }
 else                               "     explicit directory setting if /    "
 { J=1;  While Bpath(j:j)=='/' {J=J+1};
   If J==1   " - relative address "
   {  If Cbank==Ctop
      {  IrBDIV=IxDIV;  LkArP2=LkArP1;  Lvl=3;  C2='RECB'; ID=0}
      else                            { Lvl=4;  C2= Ctop       }
   }
   else      " - absolute address "   { Lvl=3;  C2='NONE'; ID=0}
   IF (LvL==3 & Bpath(J:J+3)=='DETM') Call AsBDETE(Bpath(J+5:J+8),ID)
   J=J+5*(lb-2)-1; C1=Bpath(J+1:J+4); If (lb>2) C2=Bpath(J-4:J-1); Dup=C1//C2;
   Call ReBANK (Bpath,num,-LL,Lk,Ia)
}}
*
 Err Lk<=0 {No bank exists for this path}
*                                            explicit parameter request
 If Name!=' '
 { Ib=LOCF(Value)-LOCf(Par)+1;    Err 1>Ib|Ib>LL {variable is not in the bank}
   Ia=0;  Until Q(Lk+Ib+Ia)==Value
   { * scan a chain or block of banks
     if  IQ(Lk-5)=>0  { Lk=LQ(Lk) } else { Ia=Ia+LL }
     Err Lk<=0 | Ia>=IQ(Lk-1)  {No bank exists with this value}
   }
   " for top level make this bank default and shunt it at 1st position "
   If Cbank==Ctop & ID>0 & IrBDIV==IxCONS & (Module(5:7)='GEO'|OPER(1:1)='U')
   {  Call ZSHUNT(IxCONS,Lk,LkArP2,-IL,0)
      If (LQ(Lk)>0) Call MZDROP(IxSTOR,LQ(Lk),'L')
 } }
" CHECK LL>0   finish processing for dummy calls "
*
*                                        bank Validation
*                       If user requires the status, dont check length here
 IF istat=-999
 { Err mod(IQ(Lk-1),LL)>0 {Bank length does not correspond to the structure} }
 If Flag==0
 { LkArP3=Lk  "temporary save bank address"
   call AgDForm(Names,map,LL1,LL,Cform,Cforn);  Call MZFORM(Cbank,CForm,Flag)
    " If (LkArP3!=Lk)  print *,' popalsia gad ',LkArP3,Lk; "
   Lk=LkArP3;  Call MZIOTC (IxStor,Lk,Nch,Bform);
   If Cform!=Bform & Cform!=Bform(2:) & Cforn!=Bform
   {  print *,' wrong bank ',Cbank,' : '
      print *,' required format is = ',cform(1:Lenocc(cform)),'***'
      print *,' found bank format  = ',bform(1:Nch),          '***'
      Err Nch>=0 {Bank formats are not the same}
   }
   "    force link to be secured for banks with dymanic arrays  "
   IDYN=0; Do I=1,LL1 { If (map(1,i)<0 | MAP(2,I)<0) IDYN=1; }
   IF (IDYN>0 & LINK==0) LINK=-1
 }
*  Update once DETM family banks with datacards stored in DETP
*  Bit one of the banks status is SET after update is done
If IrBDIV==IxCONS & ID>0 & JBIT(IQ(Lk),1)==0
{
   LP=LQ(LKDETM-ID); Ns=IQ(LP-2); Call UCTOH('DETP',Iname,4,4);
   Do IL=1,Ns
   {  JP=LQ(LP-IL);  Check JP>0;  Check IQ(JP-4)=Iname;  L=IQ(JP-1);
      "   <w> bank; (' detp bank found for bank ',a4)         "
      "  if bank was selected with ISEQ, transmit it as value "
      La=IQ(Lk-1); Lc=IQ(lk-5);  Val=Value;
      if (Lc<0)    La=IQ(lk-1)/abs(Lc)
      If (Name==' ' & Lc>=0)  Val=Lc
      If (Name==' ' & Lc <0)  Val=Ia/La+1
 
      Call AgDatCar (Bank,Name,Val,Names,map,LL1,Q(Lk+1+ia),La,Q(JP+1),L)
      if (Ia+La>=IQ(Lk-1))  Call SBIT1(IQ(Lk),1)
}  }
*
 Call Ucopy (Q(Lk+1+ia),Par,min(LL,IQ(Lk-1)))
 if (Oper(1:1)=='Z') call VZERO(IQ(Lk+1),IQ(Lk-1))
 if (Oper(1:1)=='D') call MZDROP(IxSTOR,Lk,' ')
 Call AGDLINK (Module,Bank,Link,Lk)
 If  LVL == 3    { " print *,' default bank set ' "; LkArP2=Lk; }
*                                      check length once more
 If  istat!=-999 { Istat=0;  Jstat=min(LL,IQ(Lk-1)); }
 Err mod(IQ(Lk-1),LL)>0 {Bank length does not correspond to the structure}
 IQUEST(1)=0
END
 
 
+DECK,AgDATCAR,T=geant. --------------------------------------------------------
*CMZ :          23/07/97  01.10.41  by  Pavel Nevski
*CMZ :  1.30/00 15/04/97  17.02.23  by  Pavel Nevski
*CMZ :  1.00/00 07/10/95  19.31.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/01/95
****************************************************************************
*                                                                          *
                 Subroutine   A g D A T C A R _
          (Bank,Name,Value,names,map,LL1,vars,LL,Buf,Lbuf)
*                                                                          *
*  Description: datacard input, stored in BUF by FFREAD, is assumed to be  *
*        a sequence of text addresses 'bank(sel).variable(ind)=' and some  *
*        amount of real numbers. All parts of the address are optional.    *
*        Type of the selector Value corresponds to the first letter of Name*
****************************************************************************
+CDE,TYPING,GCUNIT,GCFLAG.
Integer       ND,NE,NF,NG,NUM,   Dummy;     Real Anum(2);
Common/slate/ ND,NE,NF,NG,NUM(2),Dummy(34);
Equivalence              (num,                   anum);
Integer       LL,LL1,LBUF,LENOCC,ICLOCU,ICFIND,Isel,i,j,N,ia,ib,map(2,LL1),
              ie,iv,ii,i0,i1,i2,Lt,Lb,Lv,jv,kv,ind,jb,kb,ia1
Character     Bank*4,Name*(*),Names(LL1)*(*),Line*80,C*1,EQ*1/'='/
Real          Value,Rind,vars(LL),Buf(Lbuf),Blank/-989898.e-17/
Replace[ERR(#)]  with [;<W>;(' AgDatCar error : ','#1'); Isel=0; Ia=0; NEXT;]
Replace[DEBUG#;] with [;IF (IDEBUG>=7) print *,#1;]
 
{i1,i2,Ia,Isel}=0
While i2<Lbuf
{  " get new field " i0=i2;  Call AgDatAdr(Buf,i1,i2,Lbuf);
   if Isel>0 & Ia>0      " fill the previous address field with data "
   {  do i=i0+1,i1
      {  j=ia+i-i0-1;  if 1<=j&j<=LL
         {  if Names(N)(1:1)=='I'
            {  Call Ucopy(Nint(Buf(i)),Vars(j),1)
               <w> Names(N),j-ia1+1,Nint(Buf(i)),Bank,Value
               (' ===> Datacard assign ',a,'(',i2,') =',i10,' in ',a,
               ' bank selected with ',F10.3)
            }
            else
            {  Call Ucopy(Buf(i),Vars(j),1)
               <w> Names(N),j-ia1+1,Buf(i),Bank,Value
               (' ===> Datacard assign ',a,'(',i2,') =',F10.4,' in ',a,
               ' bank selected with ',F10.3)
   }  }  }  }
*                          transform the next address field into characters
   Lt=4*(i2-i1);     If Lt>80   {err(address field is too long)}
   Lt=min(lt,80);    Line=' ';   Call UHTOC(Buf(i1+1),4,line,Lt)
   Lb=Lenocc(Bank);  Lt=Lenocc(Line(1:Lt));   Iv=0 "- already used characters "
*
   Jb=ICLOCU(Bank,Lb,Line,1,LT);               " look for this bank reference "
   debug ' looking for ',bank,' in ',line(1:lt),' LT,JB=',lt,jb
   if jb>0
   {  ib=jb+lb; C=Line(ib:ib);  Rind=blank;   Iv=ib;  Isel=1; Ia=0;
      if C='('                                 " check for index in brackets  "
      {  kb=ICFIND(')',Line,ib,Lt); if kb<=0 {err(no closing bracket)};
         call CKRACK(Line,ib+1,kb-1,-1);      Iv=kb+1;
         if Nf=2 {Rind=NUM(1)} else if Nf>2 {Rind=Anum(1)}
         else    {err(index is not a number)}
      }
      if C=EQ                                  " or direct select assignement "
      {  if ib#Lt {err(equal sign is not the last one)}
         Rind=Buf(i2+1);  Iv=Lt+1;
      }                                        " there was a selection done   "
      If (Rind!=blank & Rind!=value)  Isel=0
   }  If (Isel=0 | Iv>Lt) Next
*
   Ia=3; jv=0; do N=1,LL1                      " now check variable reference "
   {  Lv=Lenocc(Names(N));       Jv=ICLOCU(Names(N)(3:Lv),Lv-2,Line,Iv+1,LT)
                                 C=line(jv+Lv-2:jv+Lv-2)
      debug ' ...now for ',names(n)(3:lv),' in ',line(Iv+1:LT),' iv,lt,jv,C=',
      iv,lt,jv,C
      Ia1=Ia;   If (jv>0 & (C=='('|C==EQ)) break;
      Ia=Ia1+1; If (Map(1,N)>0&Map(2,N)>0) Ia=Ia1+Map(1,N)*Map(2,N)
   }
* variable name should imediatly follow - otherwise it may be another bank name
   If jv!=Iv+1 { Isel=0; Next; }
*
   ii=jv+(lv-2);  C=Line(ii:ii);  Ind=1;  Ie=ii;
   If C='('
   {  kv=ICFIND(')',Line,ii,Lt);      if kv<=0 {err(closing bracket lost)}
      call CKRACK(Line,ii+1,kv-1,-1); Ie=kv+1;
      If Nf=2 {Ind=Num(1)} else {err(Index must be integer)}
   }
   debug ' ........ isel,ia,ind=',isel,ia,ind
   Ia+=Ind-1;  If Line(Ie:Ie)#EQ {err(bad assignement termination)}
}
   END
 
+DECK,AgDATADR,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 26/04/96  17.32.50  by  Pavel Nevski
*CMZ :  1.00/00 07/10/95  18.49.25  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/01/95
**********************************************************************
*                                                                    *
          Subroutine  A g D A T A D R (Itemp,I1,I2,L)
*                                                                    *
*  Description: compensate the lack of info provided by FFREAD(!)    *
*  Find an address field starting with a letter and ending with a =  *
*  Accept everything in (). All other combinations are data fields.  *
*  ICtype is 0-unseen, 1-anything, 2-numeric, 3-low/4-up characters. *
*  PN,26/04/96 change L0 to 2(!) - will see if it is ambigious       *
**********************************************************************
+CDE,TYPING,GCUNIT.
    Integer       L,Itemp(L),I1,I2,i,j,M,N,jx,nb,mb,ICTYPE,Lid,L0/2/
    character     Ctemp*4,c*1,eq*1/'='/
;
  { Lid,Nb,Mb,M }=0;
  do I=I2+1,L
  {  Call UHTOC(Itemp(i),4,Ctemp,4)
     Do j=1,4
     { C=Ctemp(j:j); jx=ICTYPE(C);
       If jx=0                        { Nb=1;         Lid =0;  Break;}
       If Lid=0 & j=1 & jx<=2         { Nb=1;         Lid =0;  Break;}
       If Lid<L0 & jx>=3              { Nb=2;         Lid+=1;  Next; }
       If Lid>=L0	
       {  If jx>=2|C='/'|C='.'|C=' '  { Nb=2;         Lid+=1;  Next; }
          If Mb=0  & C='('            { Nb=2; Mb+=1;  Lid+=1;  Next; }
          If Mb>0  & C=')'            { Nb=2; Mb-=1;  Lid+=1;  Next; }
          If Mb>0  & jx>0             { Nb=2;         Lid+=1;  Next; }
          If C=EQ                     { Nb=3;                  Break;}
       }                                Nb=9;         Lid =0;  Break;
     }   "  print *,' I,Ctemp,nb,lid=',I,Ctemp,nb,lid  "
          If Nb=3                   { N=Lid/4+1; I1=I-N; I2=I; Return; }
  }       I1=L; I2=L;
  End
 
 
+DECK,ASBDETE,T=geant. ---------------------------------------------------------
*CMZ :          08/12/97  13.55.36  by  Pavel Nevski
*CMZ :  1.30/00 23/05/96  14.03.56  by  Pavel Nevski
*CMZ :  1.00/00 22/08/95  04.05.46  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Subroutine   A S B D E T E (Cdet,ID)
*                                                                    *
*  Description:  Book a new subdetector into DETM system description *
*                (SBDETE analog)                                     *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,SCLINK,ASFLAGS.
CHARACTER   Cdet*(*)
INTEGER     I,ID,LDETE,NEED,IUCOMP,Iprin,ND/10/,NL/10/,
            FLAGS(NFLAGS)/3*0, 8*1, 4*0/
 
Iprin=Idebug
If Cdet(1:4)=='flag' " really OO action - only ASBDETE has access to defaults "
{ Do i=1,NFLAGS
  {  check Cdet(5:8)==CFLAG(i); FLAGS(i)=ID;
     Prin2 i,CFLAG(i),ID; (' ASBDETE: change default flag',i3,1x,a,' to',i4)
  }; Return;
}
 
" Check if top level bank exists at all. If not book it:  "
" Occupy first link for the documentation tree            "
 IF LKDETM<=0
 { Call MZBOOK (IxCONS,LKDETM,LKDETM, 1,'DETM',ND,ND,ND, 5,0)
   Call MZBOOK (IxCONS,LDETE, LKDETM,-1,'DOCU',NL,NL,NFLAGS,2,0)
   Call UCTOH  ('DOCU',IQ(LKDETM+1),4,4)
 }
" now check if the detector already exists, If not - find free place "
 ND=IQ(LKDETM-1);   Call GLOOK (Cdet,IQ(LKDETM+1),ND,ID);  If (Id>0) Return;
 ID=IUCOMP (0,IQ(LKDETM+1),ND)
 If ID==0 { ID=ND+1; NEED=10; Call MZPUSH (IxCONS,LKDETM,NEED,NEED,' ') }
 
" Hang the DETector Data bank "
 Call MZBOOK (IxCONS,LDETE,LKDETM,-ID,Cdet,NL,NL,NFLAGS,2,0)
 Call UCTOH  (Cdet,IQ(LKDETM+ID),4,4);      IQ(LDETE-5)=1
 Call Ucopy  (Flags,IQ(LDETE+1), Nflags)
   END
 
 
+DECK,AgSTAND,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 20/11/96  13.38.13  by  Pavel Nevski
*-- Author :    Pavel Nevski   01/01/95
******************************************************************************
*                                                                            *
                          SUBROUTINE   A G S T A N D
*                                                                            *
*  Description: tables of the obvious standard materials and media           *
******************************************************************************
+CDE,TYPING,AGECOM,GCBANK.
  Character*20 Modulo
*
* make sure that minimal GEANT structures exist
  If (Jpart==0) Call GPART
  IF (Jmate==0) Call GMATE
  Check JTMED==0
  call UCTOH('no  ',IQ(LQ(JPART-48)+3),4,4)
  call UCTOH('otti',IQ(LQ(JPART-48)+2),4,4)
  call UCTOH('gian',IQ(LQ(JPART-48)+1),4,4)
  Modulo = %Module;  %Module = ' '
*
*    More simple materials from PDG (july 1994)
  Material  Silicon       z=14  A=28.09  Dens=2.33 RadL=9.36 AbsL=106.0/2.33
  Material  Liquid_argon  z=18  A=39.95  Dens=1.40 RadL=14.0 AbsL=117.2/1.40
  Material  Argon_gas     z=18  A=39.95  Dens=1.78e-3,
                                         RadL=14.*1.4/%Dens  AbsL=117.2/%Dens
  Material  Nitrogen_gas  z=7   A=14.01  Dens=1.25e-3,
                                         RadL=37.99/%Dens    AbsL=87.8/%Dens
  Material  Oxigen_gas    z=8   A=16     Dens=1.43e-3,
                                         RadL=23944          AbsL=90./%Dens "?"
*
*    Some organic composites from PDG (july 1994)
  Component C             Z=6   A=12  w=1
  Component H             Z=1   A=1   w=1
  Component O             Z=8   A=16  w=1
  Mixture   Polystyren    NlMat=2  ww={1,1}   Dens=1.032    "scintillator"
  Mixture   Polyethylene  NlMat=2  ww={1,2}   Dens=0.93
  Mixture   Mylar         NlMat=3  ww={5,4,2} Dens=1.39
*
*    now standard tracking medium (filled here with air)
  Material Air
  Medium   Standard  Ifield=1 FieldM=20 TmaxFd=20 Epsil=0.01,
                     SteMax=10.0   DeeMax=-0.02   StMin=-0.01
  Medium   Atlas     Ifield=1 FieldM=20 TmaxFd=20 Epsil=0.01,
                     SteMax=10.0   DeeMax=-0.02   StMin=-0.01
  %Module = Modulo
  End
 
 
 
 
+DECK,AgPFLAG,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 26/11/96  23.11.18  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
             Function     A G P F L A G (Cdet,Stage)
*                                                                    *
*  Description:  get a standard SLUG-like control Print Flag         *
**********************************************************************
+CDE,TYPING,GCBANK,GCFLAG,SCLINK,AGECOM.
  Integer        AGPFLAG,Idet/0/,Ista/0/
  Character      Cdet*4,Stage*4,Cdeto*4/'.'/,Stageo*4/'.'/
+CDE,STAFUNC.
*                                     requested detector does not exist
      AgPFLAG=-1;
      If (Cdet!=Cdeto) CALL GLOOK(Cdet, IQ(LKDETM+1),IQ(LKDETM-1),Idet)
      Cdeto=Cdet;  Check Idet>0
*                                     attempt to reconsile with DICE
      If      Stage='RECO'  { Check LVRECO(Idet)>0; }
      Else If Stage='ANAL'  { Check LVANAL(Idet)>0; }
      Else                  { Check LVGEOM(Idet)>0; }
*
      AgPFLAG = max(LVPRIN(Idet),LWPRIN(Idet),IDEBUG)
      If (stage!=stageo) CALL GLOOK(Stage,IQ(LKDETM+1),IQ(LKDETM-1),Ista)
      If (Ista>0) AgPFLAG*=max(LVPRIN(Ista),LWPRIN(Ista),IDEBUG)
*     print *,' AFPFLAG: module,stage,flag=',cdet,stage,agpflag
      stageo=stage
   END
 
 
+DECK,AgDROP,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 17/04/97  16.06.21  by  Pavel Nevski
*CMZ :  1.00/00 09/08/95  15.18.33  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
****************************************************************************
*                                                                          *
                 subroutine   A g D R O P (Title)
*                                                                          *
****************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,SCLINK,AGCDOCL,GCNUM,GCVOLU.
 character*(*) Title;  Character*1 Com;
 com=title;  If (Title=='ALL') Com='*';
 if (com='G'|com='G') & JRUNG >0  { Call MZDROP(IxStor,JRUNG ,'L');           }
 if (com='A'|com='-') & JMATE >0  { Call MZDROP(IxStor,JMATE ,'L');  NMATE=0; }
 if (com='M'|com='-') & JTMED >0  { Call MZDROP(IxStor,JTMED ,'L');  NTMED=0; }
 if (com='P'|com='-') & JPART >0  { Call MZDROP(IxStor,JPART ,'L');  NPART=0; }
 if (com='V'|com='*') & JROTM >0  { Call MZDROP(IxStor,JROTM ,'L');  NROTM=0; }
 if (com='V'|com='*') & JVOLUM>0  { Call MZDROP(IxStor,JVOLUM,'L');  NVOLUM=0;}
*if (com='V'|com='*') & JGPAR >0  { Call MZDROP(IxStor,JGPAR, 'L');  JGPAR=0; }
*if (com='V'|com='*') & JGPAR2>0  { Call MZDROP(IxStor,JGPAR2,'L');  JGPAR2=0;}
 if (com='S'|com='*') & JSET  >0  { Call MZDROP(IxStor,JSET  ,'L');           }
 if (com='S'|com='*') & JHITS >0  { Call MZDROP(IxStor,JHITS ,'L');           }
 if (com='S'|com='*') & JDIGI >0  { Call MZDROP(IxStor,JDIGI ,'L');           }
 if (com='D'|com='*') & LKDETM>0  { Call MZDROP(IxStor,LKDETM,'L');           }
 if (com='D'|com='*') & L1Doc >0  { Call MZDROP(IxStor,L1Doc, 'L');           }
 if (com='R'|com='*') & LKRUNT>0  { Call MZDROP(IxStor,LKRUNT,'L');           }
 if (com='R'|com='*') & LKEVNT>0  { Call MZDROP(IxDiv, LKEVNT,'L');           }
 if (com='R'|com='*') & LKARAW>0  { Call MZDROP(IxDiv, LKARAW,'L');           }
 if (com='R'|com='*') & LKARP1>0  { Call MZDROP(IxDiv, LKARP1,'L');           }
 if (com='E'|com='*')             { Call MZWIPE(IxDiv); NTRACK=0; NVERTX=0;   }
 if  com='*'        { call MZGARB(20,0); <w>;(' *** all banks DROPPED *** '); }
 NLEVEL = 0
    END
 
+DECK,ARFROMC,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 03/08/96  17.13.04  by  Pavel Nevski
*CMZ :  1.00/00 04/12/94  14.38.39  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Function     A R F R O M C (Cvar)
*                                                                    *
*  Description:  4-character  to a real number conversion            *
**********************************************************************
Real ARFROMC;  Character Cvar*(*),C*4,S*64;  Integer I,K;
Data S/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz '/;
     C=Cvar;  k=0;
     Do i=1,4 { k=ISHFT(k,6); k+=Index(s(2:64),c(i:i)); }
     ARFROMC=k;
   END
 
+DECK,ACFROMR,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 03/08/96  16.52.41  by  Pavel Nevski
*CMZ :  1.00/00 04/12/94  14.38.39  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
**********************************************************************
*                                                                    *
                 Function     A C F R O M R (R)
*                                                                    *
*  Description: real to 4-character conversion                       *
**********************************************************************
Real R;   Character ACFROMR*4,C*4,S*64;  Integer I,J,K;
Data S/' 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ '/;
     C=' ';   k=R;
     Do i=4,1,-1  { j=IAND(k,63)+1; k=ISHFT(k,-6); C(i:i)=S(j:j); }
     ACFROMR=C;
   END
 
 
+DECK,agphits,T=geant.
*CMZ :  1.00/00 03/02/95  01.15.24  by  Pavel Nevski
*-- Author :    Pavel Nevski   22/01/95
**********************************************************************
*                                                                    *
              SUBROUTINE A G P H I T S (CSET,CDET)
*                                                                    *
*  Description:   print GEANT hits summary in the ATLAS dense format *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT.
      INTEGER       IBITS,JS,JD,JDX,JX,JXD,JDU,Nw,Nd,Nv,Nk,Nb,ii,I,J,K,
                    Nset,Ndet,Last,Kdigi,Iset,Idet,Ltra,i1,Nvu,Ndu,IHIT,
                    ITRA,Nhits,Ind,Mind,NUMBV(15),NHIT(100);
      REAL          Sumt,DIGI(20),SUM(100);
      CHARACTER*4   CSET,CDET,CS,CD;
 
   Check JhitS>0;  NSET=IQ(JSET-1);   " first make selection using SETS "
   DO ISET=1,Nset     "             Loop on all selected sets        "
   {  CALL UHTOC(IQ(JSET+ISET),4,CS,4);  Check CSET(1:1)='*' | CSET=CS;
      JS = LQ(JSET-ISET);   Check Js>0;  Ndet=IQ(JS-1);
      Do IDET=1,NDET  "         Loop on selected detectors for this set "
      {  CALL UHTOC(IQ(JS+IDET),4,CD,4); Check CDET(1:1)='*' | CDET=CD;
 
                                      " now check the HITS structure "
         JX   = LQ(JhitS-ISET);        Check JX>0;
         JXD  = LQ(JX-IDET);           Check JXD>0;
         LAST = IQ(JX+IDET);           Check LAST>0;
         JD   = LQ(JS-IDET);           Check Jd>0;
         JDX  = LQ(JD-1);              Check JDX>0;
         NW   = IQ(JD+1)+IQ(JD+3)+1;   Check Nw>0;
         NV   = IQ(JD+2);              ND  = IQ(JD+4);
         JDU  = LQ(JD-3); If JDU>0   { NVU = Q(JDU+6);  NDU = Q(JDU+2); }
 
         { Mind,Sumt,Nhits,ITRA,NUMBV(1),DIGI(1) } = 0;
         Call Vzero(Sum,100);  Call Vzero(Nhit,100);
         " loop on all hits to get track numbers, volume numbers and info "
         Do ii=1,LAST,NW
         {  j=JXD+ii;  LTRA=IQ(j);   NK=1; K=1;
            DO I=1,min(1,NV)  "      get unpacked volume numbers              "
            {  Nb=IQ(JD+2*I+10);
               IF Nb>0  { K+Nb>33 ?; NUMBV(i)=IBITS(IQ(j+Nk),K-1,Nb); K+=Nb; }
               else     { K>1     ?; NUMBV(i)=IQ(j+Nk);               Nk+=1; }
            }
                                     Nk=1+IQ(JD+1); K=1;
            Do I=1,min(1,ND)  "      get unpacked cumulative hits             "
            {  i1=Jdx+4*(I-1); Nb=IQ(i1+2);  Ihit=IQ(i1+1);
               IF Nb>0  { K+Nb>33 ?; KDIGI=IBITS(IQ(j+Nk),K-1,Nb); K+=Nb; }
               else     { K>1     ?; KDIGI=IQ(j+Nk);               Nk+=1; }
               DIGI(i)=KDIGI/Q(i1+4)-Q(i1+3);
            }
            Ind=min(max(1,NUMBV(1)+1),100);  Nhit(Ind)+=1;  Sum(Ind)+=Digi(1);
            Nhits+=1; Sumt+=Digi(1);  Mind=Max(Mind,Ind); ITRA=max(ITRA,LTRA);
         }
         <W> Cd,Cs,ITRA;
         (/' HITS summary in detector ',A4,' of SET ',A4,' on',i6,' tracks');
         <w> Nhits,    (Nhit(i),i=1,Mind); ('  Hits: ',11I10  /(18x,10i10));
         <w> Ihit,Sumt,(Sum(i) ,i=1,Mind); (2x,a4,': ',11G10.3/(18x,10G10.3));
   }  }
   END
 
 
+DECK,agsflag,T=geant.
*CMZ :  1.30/00 28/04/96  19.59.55  by  Pavel Nevski
*CMZ :  1.00/00 21/03/95  15.01.57  by  Pavel Nevski
*-- Author :    Pavel Nevski   21/03/95
****************************************************************************
*                                                                          *
                SUBROUTINE   A G S F L A G (CflagI,Iflag)
*                                                                          *
****************************************************************************
+CDE,TYPING,AGECOM.
     character*4 CflagI,Cflag
     Integer     Iflag
     Cflag=CflagI;       Call CLTOU(Cflag)
     If (Cflag='PRIN')   %Iprin=Iflag
     If (Cflag='GRAP')   %Igrap=Iflag
     If (Cflag='HIST')   %Ihist=Iflag
     If (Cflag='GEOM')   %Igeom=Iflag
     If (Cflag='MFLD')   %Imfld=Iflag
     If (Cflag='DEBU')   %Idebu=Iflag
     If (Cflag='SIMU')   %Isimu=Iflag
     CALL AsbDETE('flag'//CFLAG,Iflag)
END
 
 
+DECK,AGFPATH,T=geant. ---------------------------------------------------------
*CMZ :          27/08/97  14.26.21  by  Pavel Nevski
*CMZ :  1.00/00 06/06/95  15.09.02  by  Pavel Nevski
*-- Author :    Pavel Nevski   07/02/95
**********************************************************************
*                                                                    *
         subroutine     A g F P A T H (ISC)
*                                                                    *
* Description:  build geant path to a sensitive element ISC          *
*              Set/det should be already selected - only JDU is used *
* Modifications:                                                     *
* 27.08.97,  PN: zero in an ISC means the last possible copy number  *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,AGCRDIG.
  Integer  ISC(*),nam,nom,nick,Ier,I,J,K,L,N,Nb,i1,i2,Jm,Imo,Ivo,nin,
           in,jn,Nr,NwuVol/3/
  Integer  Lnam(20),Lnom(20),Lnum(20),Ivol(20)
  Save     Lnam,Lnom,Lnum,Ivol
*
  Check Jdu>0;
  i1=Q(Jdu+3);  i2=Q(Jdu+5);  N=Q(Jdu+4);  {L,K,Imo}=0;
  :L: Do i=i1,i2-1,NwuVol
  {  j=Jdu+i;         Nb=Q(j+3);    IF (Nb>0) K+=1;    L+=1;
     Ivo=Q(j+1);      nam=IQ(Jvolum+Ivo);    {Lnam(L),Lnom(L)}=nam;
     Lnum(L)=Q(j+2);  IF (Nb>0) Lnum(L)=ISC(K);
     If  L=1          { Ivol(1)=Ivo;  Next :L:; }
     Imo=Ivol(L-1);   Jm=LQ(JVOLUM-Imo);
     nin=Q(jm+3);     If L<N & nin=0
     { <w> nam,L,N; (' AGFPATH: empty ',a4,' at level',2i5);    Break; }
*
     " find copy with the same generic name as NameSH element "
     do in=1,max(nin,1)   " over number of contents "
     {  jn=LQ(Jm-in); Ivo=Q(jn+2); Nr=Q(jn+3);
        Nom=IQ(LQ(JVOLUM-Ivo)-4);  Nick=IQ(JVOLUM+Ivo);
        Check nam=nom | nam=Nick;
        " special request - last copy "
        If k>0 & ISC(k)==0 & Nr>Lnum(L)
        { Lnum(L)=Nr; Lnam(L)=IQ(JVOLUM+Ivo); IVOL(L)=Ivo; Next; }
        " normal request - selected copy "
        Check nin>0 & Lnum(L)=Nr | nin<0 & 0<Lnum(L)&Lnum(L)<=Nr
        Lnam(L)=IQ(JVOLUM+Ivo);    IVOL(L)=Ivo;        Next :L:;
     }
     if k>0 & ISC(k)==0  { ISC(k)=Lnum(L); Next :L:; }
 
     if (Idebug>0) <w> nam,L
     (' AGFPATH: can not find ',a4,' at level',i5); L-=1; Break;
  }  CALL GLVOLU (L,Lnam,Lnum,IER);
*
  END
 
 
+Deck,agsstep,T=geant.
*CMZ :  1.30/00 18/04/96  17.09.45  by  Pavel Nevski
*CMZ :  1.00/00 07/05/95  00.09.13  by  Pavel Nevski
*-- Author :    Pavel Nevski
*************************************************************************
      subroutine     A G S S T E P (ext)
*************************************************************************
+CDE,TYPING,AGECOM,GCBANK,GCUNIT,SCLINK.
   external ext;   Integer JUMPAD,Ldete,L,Id;
   call AsbDETE(%Module,Id);
   If (Id != %IdType) print *,'Id inconsistent - ',Id,%Idtype
   Ldete=LQ(LKDETM-Id);   L=IQ(Ldete-1);
   If L>12 {  IQ(Ldete+13)=JUMPAD(ext) }   else    {  <W>;
   (' AgSSTEP warning: you need a modified DETM format to run this option')}
      end
 
+DECK,aggetdig,T=geant. --------------------------------------------------------
*CMZ :  1.30/00 02/04/97  18.53.55  by  Pavel Nevski
*CMZ :  1.00/00 04/06/95  23.36.31  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
**********************************************************************
*                                                                    *
                SUBROUTINE A g G E T D I G  (JD,JJ,NBV,DIGI)
*                                                                    *
*  Description: Common hit/digi unpacking for any AGI routine        *
*          JD is the link to SEJD bank, JJ is link to a hit/digi     *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK.
   integer            idigi
   Common   /AgCdigi/ idigi(15)
*
   INTEGER     JD,JJ,JDS,Nv,Nk,No,Nb,I,J,K,L,j1,j2,Idig,Ihitf,bin,mode,
               JBYT,NBV(15),NwuVol/3/,NwuHit/10/
   REAL        Org,Fct,Fmx,xx,D,DIGI(15)
   bin(xx)  =  IFIX((xx+org)*fct)
*
*                            get SJDU link and set common counters
     NK=jj+1;  K=1;  D=0.5;  Jds=LQ(JD-3);  Nv=IQ(JD+2);
*                            get unpacked branching volume numbers
     j1=Q(Jds+3);  j2=Q(Jds+5)-1;  i=0;
     Do j=j1,j2,NwuVol
     {  L=Jds+j;  Nb=Q(L+3);  Check Nb>0;
        I+=1;  K+Nb>33?;  NBV(i)=JBYT(IQ(Nk),K,Nb)+1; K+=Nb;
     }
     Ihitf=Nv-I;  mode=0;  I=0;    " Ihitf - start of geant HIT field        "
     j1=Q(Jds+1);  j2=Q(Jds+3)-1;
     Do j=j1,j2,NwuHit             "         unpacked digits                 "
     {" No - requested Nbit (if not MAGIC), Nb - allocated (always positive) "
        L=Jds+j;  No=Q(L+3); Org=Q(L+6); Fct=Q(L+7); Fmx=Q(L+5); Nb=Q(L+8);
        If I==Ihitf               {" geant HIT field "  K>1 ?;  D=0;    }
        If -32<=No&No<=0 & mode=0 {" comulative part "  K>1 ?;  Mode=1; }
        IF 0<Nb&Nb<32  { K+Nb>33 ?;  IDIG=JBYT(IQ(Nk),K,Nb);  K+=Nb; }
        else           { K>1     ?;  IDIG=IQ(Nk);             Nk+=1; }
        I+=1;      DIGI(i)=min((IDIG+D)/fct-Org,fmx);  idigi(i)=IDIG
        If I==1
        { while LQ(Jds)>0 & bin(Q(LQ(Jds)+8))<=IDIG { Jds=LQ(Jds) }}
     }
   END
 
 
+DECK,agfdigi,T=geant. ---------------------------------------------------------
*CMZU:  1.00/01 15/11/95  02.08.58  by  Pavel Nevski
*CMZ :  1.00/00 05/10/95  02.29.43  by  Pavel Nevski
*-- Author :    Pavel Nevski   17/01/95
**********************************************************************
*                                                                    *
   subroutine   A G F D I G I (Cset,Cdet,NVS,LTRA,NBV,DIGI,Iw,Iad)
*                                                                    *
* Returns the next digitisation for the physical volume, specified   *
* by NVS list with generic volume/set name Cdet/Cset,packed form     *
* INPUT:                                                             *
* Cset,Cdet - user set/detector identifiers (CHAR*4)                 *
* NVS - list of volumes identifying the path, ignored if nvs(1)<0    *
* OUTPUT:                                                            *
* LTRA the number of the track which has produced this digitisation  *
* NBV  the list of volume numbers which identify the physical volume *
* KDIGI       array that get the digitalisation elements             *
* ====>  User should take care of NVB and KDIGI real dimesions !     *
* Iw - Hit sequential number. It is negative, if SET/DET does not    *
*      exist at all, and 0 when hits are absent or all hits are done *
**********************************************************************
+CDE,TYPING,GCBANK,GCUNIT,AGCRDIG.
  CHARACTER*4 Cset,Cdet,Cset0/'****'/,Cdet0/'****'/
  Integer     Nvs(*),NBV(*),LTRA,NTRA,Iw,Iad,JH,Iset,Idet,I,J,ii,X
  Real        DIGI(*)
* - - - - - - - - - - - - - - - - - - - - - - - - -
IF Iw<=0 | Cset!=Cset0 | Cdet!=Cdet0
{  Check Jset>0;   {Jdu,Last}=0;   Iw=-1;
   Call  MZLINT(IxSTOR,'AGCRDIG',IWA,JS,Jdu);
   "  Find if digi in selected set & detector exist  "
   Call GLOOK(Cset,IQ(Jset+1),IQ(Jset-1),Iset);             Check Iset> 0;
   JS  = LQ(Jset-Iset);                                     Check Js  > 0;
   Call GLOOK(Cdet,IQ(JS + 1),IQ(JS - 1),Idet);             Check Idet> 0;
   JD  = LQ(JS-Idet);                                       Check JD  > 0;
   JDU = LQ(JD-3);    Cset0=Cset;    Cdet0=Cdet;     Iw=0;
   if Cset(4:4)=='H' {X=1; JH=JHITS} else {X=2; JH=JDIGI};  Check JH  > 0;
   Jx  = LQ(JH-Iset);                                       Check Jx  > 0;
   JXD = LQ(JX-Idet);                                       Check JXD > 0;
   Last= IQ(JX+Idet);                                       Check Last> 0;
   NW  = IQ(JD+1)+IQ(JD+2*X+1)+1
   Nvb = Q(JDU+6)
   if (IW<0) IW  = 0
}
If jdu<=0  { call GFDIG1(Cset,Cdet,1,NVS,LTRA,NTRA,NBV,DIGI,Iw,Ia); Return; }
*
:D: DO ii=Iw*Nw+1,Last,Nw
 {  j=JXD+ii;   LTRA=IQ(j);   Call AgGETDIG(Jd,J,NBV,DIGI)
    do i=1,Nvb  { If (NVS(i)>0 & NVS(i)!=NBV(i)) Next :D:; }
    iw=ii/Nw+1; Iad=J;                           Return;
 }
   {iw,iad,IWA(1)}=0;
   END
 
 
+DECK,agfdig0,T=geant. -------------------------------------------------------
*CMZ :          24/04/98  16.58.32  by  Pavel Nevski
*CMZ :  1.30/00 13/05/97  14.48.21  by  Pavel Nevski
*CMZ :  1.00/00 01/09/95  22.54.27  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
             Function     A g F D I G 0 (Cset,Cdet)
*                                                                    *
*  Prepare hits for digitization making chains in each element       *
*  modifications: 1.09.95 - protect agains 0 path     - PN           *
*  25.01.96 - invert hits order as suggested by Fred                 *
*  01.05.97 - check consistency between sets and hits/digi structure *
*  13.05.97 - on error keep Iv=-1 to stop AgFDIG1                    *
*  02.04.98 - accept wildcard (*) for Cdet (Idet=1)                  *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT,GCNUM,GCFLAG,AGCBUFF,AGCRDIG.
Character*(*)    Cdet,Cset;   Integer Lp,Lt;  Parameter (Lp=20,Lt=100);
Integer          AgFDIG0,JBYT,MSBYT,LENOCC,ICDECI,NVL(Lp),ISC(Lp),Itr,
                 Iset,Idet,X,Nv,Nr,Nb,Ja,i,j,k,L,Na,Ma,Jv,Nk,Ih,JH,Mbm,Ier
integer          nac,nas,iac,itc,jtr
common/agctrbuf/ nac,nas,iac(50000),itc(50000)
*
   Cs=Cset;  Cd=Cdet;  {AgFDIG0,Iv,Ia}=-1;  {Iset,Idet,Jdu}=0;
   CALL MZLINT (IXSTOR,'AGCRDIG',IWA,JS,JDU);
*
   "  Find if hits in selected set & detector exist  "
   Call GLOOK(Cs,IQ(Jset+1),IQ(Jset-1),Iset);               Check Iset> 0;
   JS  = LQ(Jset-Iset);                                     Check Js  > 0;
   Call GLOOK(Cd,IQ(JS + 1),IQ(JS - 1),Idet);
   if (Cd=='*' & IQ(JS-1)>0 & IQ(Js+1)!=0) Idet=1;          Check Idet> 0;
   JD  = LQ(JS-Idet);                                       Check JD  > 0;
   JDU = LQ(JD-3);                                          Check Jdu > 0;
   if Cset(4:4)=='H' {X=1; JH=JHITS} else {X=2; JH=JDIGI};  Check JH  > 0;
   Ier = 1;          If (Iset>IQ(JH-2))                     goto :e:
   Jx  = LQ(JH-Iset);                                       Check Jx  > 0;
   Ier = 2;          If (Idet>IQ(Jx-2)|Idet>IQ(Jx-1))       goto :e:
   JXD = LQ(JX-Idet);                                       Check JXD > 0;
   Last= IQ(JX+Idet);                                       Check Last> 0;
*
   Nw=IQ(JD+1)+IQ(JD+2*X+1)+1;  Nvb=Q(Jdu+6);  Nv=IQ(JD+2); Nc1=Last/Nw;
   Ier = 3;          If (mod(last,nw)!=0)                   go to :e:
   Nr=0;  if (LENOCC(Cdet)>=6)  Nr=ICDECI(Cdet,5,6);   Nvb=min(Nvb+Nr,Nv);
   Call VZERO(NVL,Lp);          Mb=0; i=Nc1; while i>0 {i/=2; Mb+=1;};
   If Mb>1  { Mbm=2**(32-Mb) } else { Mbm=2 000 000 000 "big positive" }
*
   Ier=0; last=Nc1+1; jtr=-1; Nac=0
   do ih=1,Nc1
   {  j=JXD+(Ih-1)*Nw+1; itr=IQ(J);
      If itr>Ntrack & ier<=Idebug
      { ier+=1; <w> Cset,Cdet,itr;(' AgFDIG0 error in',2a5,': bad ITRA=',i12)}
      if jtr!=itr { Nac+=1; jtr=itr; }
   }
   nas=Nac/Mbm+1; jtr=-1; Nac=0
   do ih=1,Nc1
   {  j=JXD+(Ih-1)*Nw+1; itr=IQ(J);
      if jtr!=itr { nac+=1; iac(nac)=ih; itc(nac)=itr; jtr =itr; }
      IQ(J)=(nac-1)/nas
   }  iac(nac+1)=Nc1+1
*
   "       ----------      associate hits in chains     ---------    "
   call VZERO(Ibuf,Lbuf); Na=1; Ma=0; ISC(1)=1; ier=0;
   Do Jv=1,max(1,Nvb)                      " for all higher levels   "
   {  Do Ih=Nc1,1,-1                       " rescan all hits to find "
      {  Nk=1; K=1; J=JXD+(Ih-1)*NW+1;     " the actual maximum of   "
         do Iv=1,min(Jv+1,Nvb)             " the volume number used  "
         { Nb=IQ(JD+2*Iv+10); K+Nb>33?; ISC(iv)=JBYT(IQ(j+Nk),K,Nb)+1; K+=Nb;}
         *                                   now get buffer address
         Ia=1; do i=1,Jv { Ja=Ia+ISC(i); Ia=IBuf(Ja);}  Ma=max(Ma,Ja);
         If Jv<Nvb { IBuf(Ja)=max(Ia,ISC(Jv+1)); }
         else
         {   itr=IQ(J);  IQ(J)=MSBYT(Ia,Itr,33-Mb,Mb);  IBuf(Ja)=Ih; }
      }  If (Jv=1) Ibuf(1)=Ma-1;
      *
      Ja=Ma+1;  "expand array"  While Ibuf(Na)>0 & Na<Ma & Jv<Nvb
      {  Do Ia=1,Ibuf(Na)
         {  L=Ibuf(Na+Ia); Check L>0; Ibuf(Na+Ia)=Ja; Ibuf(Ja)=L; Ja+=1+L;
            Check Ja>Lbuf; Ibuf(Na+Ia)=0;  <W> Cset,Cdet;
            (' AgFDIG0: NOT ENOUPH MEMORY FOR',2(1x,A),', HITS WILL BE LOST');
         }  Na+=1+Ibuf(Na);
   }  }
   {AgFDIG0,Iv,Ia,nc2}=0
   If (Last<Nc1)  <W> Cset,Cdet,Mbm,int(Q(LQ(Jkine-Mbm)+6))
   (' AgFDIG0 WARNING FOR',2(1x,a),': TRACKS ABOVE',2i12,' WILL BE chitted')
   return
   :e: <w> ier,Cset,Cdet
   (' AgFDIG0 FATAL ERROR:',i3,' Probably inconsistent geometry ',2(1x,a4))
   {AgFDIG0,Iv,Ia,nc2}=-1
   END
 
 
+DECK,agfdig1,T=geant. -------------------------------------------------------
*CMZ :          24/04/98  16.58.32  by  Pavel Nevski
*CMZ :  1.30/00 13/05/97  14.48.21  by  Pavel Nevski
*CMZ :  1.00/00 01/09/95  22.55.18  by  Pavel Nevski
*-- Author : Pavel Nevski
**********************************************************************
*                                                                    *
     Function     A g F D I G 1 (NHit,LTRA,ISC,HITS)
*                                                                    *
* Description:  make a loop over detector elements and give to user  *
*               all hits in the selected element sequentially        *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT,GCVOLU,GCNUM,AGCBUFF,AGCRDIG.
integer           nac,nas,iac,itc,jtr
common /agctrbuf/ nac,nas,iac(50000),itc(50000)
                 Integer Lp; Parameter (Lp=20);
Integer          AgFDIG1,ISC(*),NVL(Lp),JBYT,Nhit,LTRA,ja,Itr,Lev,i
Real             HITS(*);
Save             NVL;
*
   Lev=0     " will be set to the lowest Iv of the volume index been changed "
If Iv>=0     " Iv - the last changed level is saved in the AGCHIT common     "
{  If Ia==0
   {  Lev=LP; Nhit=0;
      :a:;If (Iv>0) NVL(Iv)+=1;  call UZERO(NVL,Iv+1,Lp);
          Lev=min(max(1,Iv),Lev);
          Ia=1; Iv=0; While Iv<max(1,Nvb)       " bootstrap index "
          {  IF NVL(Iv+1)>=Ibuf(Ia) { If (Iv==0) goto :e:; goto :a:; }
             Iv+=1;  Ia=IBuf(Ia+NVL(Iv)+1);   If (Ia=0) goto :a:;
   }      }
                               * * *
   "   getting a hit in the selected element and the address of the next "
   Ja=JXD+Nw*(Ia-1)+1;   call  AgGETDIG (JD,Ja,ISC,HITS);
   "   get track number, check for the track overlap, clear track number "
 
   jtr=JBYT(IQ(ja),1,32-Mb)*nas;
   do i=1,nas { itr=itc(jtr+i); if (iac(jtr+i+1)>Ia) break; }
*
   If (Nhit=0) LTRA=ITR;      If (LTRA#ITR) LTRA=-ITR
   Ia=JBYT(IQ(ja),33-Mb,Mb);  IQ(Ja)=Itr
                              * * *
   " Count hits in the same element, the last one get Nhit negative "
   Nhit+=1; If (Ia=0) Nhit=-Nhit; Nc2+=1;  AgFDIG1=0; "intermediate" Return;
}
   :e:   IWA(1)=0;                         AgFDIG1=-1; "  final  "   Return;
   END
 
 
+DECK,agfdpar,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 06/05/97  15.20.30  by  Pavel Nevski
*CMZU:  1.00/01 13/12/95  16.02.30  by  Pavel Nevski
*CMZ :  1.00/00 07/10/95  23.14.29  by  Pavel Nevski
*-- Author :    Pavel Nevski   03/06/95
************************************************************************
*                                                                      *
         SUBROUTINE A G F D P A R (hits,Chit,FHmin,FHmax,FHbin)
*                                                                      *
*  Description: provides user description of the hit/digi format       *
*               Set/det should be already defined - only JDU is used   *
*               First free element of CHIT is set to blank.            *
*               If No description is available at all, CHIT(1)=blank   *
*               For vectorised hits ONLY: CHIT(1) is also blank        *
*               if HITS(1) is outside any of the defined regions       *
************************************************************************
+CDE,TYPING,GCBANK,AGCRDIG.
     Real         HITS(*),FHmin(*),FHmax(*),FHbin(*),Org,fct,fmx,xx
     Integer      j1,j2,I,J,K,K2,L,Ju,Jn,bin,NwuHit/10/,%Magic/-696969/
     character*4  Chit(*),ACFROMR
     bin(xx)=IFIX((xx+org)*fct)
*
     Chit(1)=' ';  Check Jdu>0;  Ju=Jdu;  j1=Q(Ju+1);  j2=Q(Ju+3)-1;  i=0;
     Do j=j1,j2,NwuHit       "         unpacked digits                   "
     {  L=Ju+j;  Fmx=Q(L+5);  Org=Q(L+6);  fct=Q(L+7);
        If i==0 &  Q(Ju+8)>%Magic
        {  * only for vectorised hit definition
           if (Org>hits(1) | hits(1)>Fmx)   "outside all(a,b)"  Return
           K=bin(hits(1));  K2=bin(Q(ju+8));  If (K<K2) "below" Return
           While K>K2                       "find a valid region"
           { Jn=LQ(Ju); If (Jn<=0) Return; K2=bin(Q(Jn+8)); If (K>=K2) Ju=Jn }
        }
        I+=1; Chit(i)=ACFROMR(Q(L+1)); Fhmin(i)=-Org;  Fhmax(i)=Fmx;
        if (fct!=0) FHbin(i)=1.0/fct
     }  Chit(i+1)=' '
    END
 
 
+DECK,agpdigi,T=geant. ---------------------------------------------------------
*CMZ :          23/10/97  22.22.23  by  Pavel Nevski
*CMZ :  1.30/00 02/04/97  18.53.55  by  Pavel Nevski
*CMZ :  1.00/00 03/06/95  12.02.49  by  Pavel Nevski
*-- Author :    Pavel Nevski   13/12/94
**********************************************************************
*                                                                    *
                SUBROUTINE A G P D I G I (CSET,CDET)
*                                                                    *
*  Description: print GEANT hits or digits                           *
*  If USER bank is there this is the AGI dense format                *
*  FOR OTHER APPLICATION PLEASE TAKE CARE OF THE NAMING CONVENTION:  *
*  Nv,Nx(=h/d) for original geant counters, Nha,Nvb for AGI counters *
**********************************************************************
 Replace [;#?;]   With   [; IF #1 {" Take next word " K=1; Nk+=1; } ]
+CDE,TYPING,GCBANK,GCUNIT.
     INTEGER       JS,JD,JH,JX,JXD,JDU,Ip0,Ip1,Nw,NVb,Nha,Mv,Md,
                   Nset,Ndet,Last,Iset,Idet,Ltra,Idig,ii,jj,X,i,
                   JBYT,NBV(15)
     REAL          DIGI(20)
     CHARACTER     CBUF*400,T*6
     CHARACTER*4   ACFROMR,CSET,CDET,CS,CD,CDID
*
 NSET=IQ(JSET-1)    "           first make selection using SETS    "
 DO ISET=1,Nset     "             Loop on all selected sets        "
 { CALL UHTOC(IQ(JSET+ISET),4,CS,4);  Check CSET(1:1)='*' | CSET=CS;
   JS = LQ(JSET-ISET);   Check Js>0;  Ndet=IQ(JS-1);
   Do IDET=1,NDET  "         Loop on selected detectors for this set "
   { CALL UHTOC(IQ(JS+IDET),4,CD,4);  Check CDET(1:1)='*' | CDET=CD;
*
                                     " now check the DIGI structure "
     JD  = LQ(JS-IDET);           Check Jd>0;
     If LQ(JD-2)>0                { T='DIGITS'; JH=JDIGI; X=2;  }
     If LQ(JD-1)>0                { T=' HITS '; JH=JHITS; X=1;  }
                                  CHECK JH>0;
     JX   = LQ(JH-ISET);          Check JX>0;
     JXD  = LQ(JX-IDET);          Check JXD>0;
     LAST = IQ(JX+IDET);          Check LAST>0;
     JDU  = LQ(JD-3);
     IF JDU<=0
     {  CALL UHTOC(IQ(JXD-4),4,CDID,4);
        IF CDID=='DIGI' { CALL GPDIGI(CS,CD) } else { Call GPHITS(CS,CD) }
        Next;
     }
     " otherwise this are hits(SJHD) or new digits(SJDX) "
     NW = IQ(JD+1)+IQ(JD+2*X+1)+1;   Check Nw>0;
     " volumes "  Nvb = Q(JDU+6);  Mv = Min(Nvb,15);  Ip0 = 12+5*Mv;
     " all hits " Nha = Q(JDU+2);  Md = Min(Nha,20);  Ip1 = Ip0+10*Md+2;
*
     <W> T,Cd,Cs;
     (/' ====>',A6,' IN DETECTOR ** ',A4,' ** OF SET ** ',A4,' ** <===='/);
     Cbuf=' '                                   "  print header line ";
     WRITE(CBUF,'(1x,A5,6H TRACK,15(1x,A4))')  T,(IQ(JD+2*I+9),i=1,Mv);
     WRITE(CBUF(Ip0+1:),'(20(6x,A4))') (ACFROMR(Q(JDU+10*I+1)),i=1,Md);
     <W>  (CBUF(i:i),i=1,Ip1);     (122A1/(12x,110A1));
     IDIG=0;
     Do ii=1,LAST,NW
     {  jj=JXD+ii; IDIG+=1; LTRA=JBYT(IQ(jj),1,16);
        Call  AGGETDIG (Jd,jj,NBV,DIGI);
        WRITE(CBUF,        '(2i6,15i5)')     IDIG,LTRA,(NBV(i),i=1,Mv)
        WRITE(CBUF(IP0+1:),'(2x,1P,20G10.3)')         (DIGI(i),i=1,Md)
        <W>  (CBUF(i:i),i=1,Ip1);  (122A1/(12x,110A1));
     }
 } }
   END
 
 
+DECK,agdlink,T=geant.
*CMZ :  1.30/00 18/11/96  12.59.52  by  Pavel Nevski
*CMZU:  1.00/01 22/12/95  21.09.57  by  Pavel Nevski
*CMZ :  1.00/00 08/11/95  00.05.48  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/08/95
**********************************************************************
            subroutine  A G D L I N K (Module,Bank,Link,LK)
*            Register a new link for dynamic bank access             *
*  keep them names now in a common, but can be an internal array too *
**********************************************************************
+CDE,TYPING,GCBANK,GCFLAG,AGCLINK.
Character         Module*(*),Bank*(*),Cbank*8
Integer           NumLin,LinkName,Link,Lk,Key(2),LENOCC
Common /AGCDLINK/ NumLin,LinkName(2,NaLinkMax)
 
If Link<0  " allocate a new secured link "
{  Cbank=Bank(1:lenocc(Bank))//module;  Call UCTOH(CBank,Key,4,8)
   If (%Nlink==0) call MZLINK(IxCONS,'AGCLINK',%Link,%Link,%Link(NaLinkMax))
   Do Link=1,NumLin
   {  If (Key(1)==LinkName(1,link) & Key(2)==LinkName(2,link)) goto :fnd:; }
 
   If NumLin>=NaLinkMax
   {  Print *,'AGDLINK fatal error: NO more free links left for bank ',Bank;
      Link=NaLinkMax; Return
   }
   NumLin+=1; %NLink=NumLin; Link=NumLin; Call Ucopy(Key,LinkName(1,link),2)
   If (IDEBUG>0) Print *,'AGDLINK: new link for bank ',bank,' is ',link
}
:fnd: If (Link>=0)  %LINK(link)=Lk
End
 
 
+DECK,agdform,T=geant.
*CMZ :          13/03/98  22.56.27  by  Pavel Nevski
*CMZ :  1.30/00 01/07/96  15.35.02  by  Pavel Nevski
*CMZ :  1.00/00 07/09/95  13.27.40  by  Pavel Nevski
*-- Author :    Pavel Nevski   12/08/95
*************************************************************************
        Subroutine   A g D F O R M (Names,map,LL1,LL,Cformo,Cforma)
*                    encode bank format for zebra                       *
*   Both new (with 2 system words) and old (only users words) formats   *
*   PN,29-06-96: Make Cform different from Cformo due to AIX problem    *
*************************************************************************
Implicit      NONE
Integer       LL1,LL,map(2,LL1),i,j,k,L,N,NN,Ls
Character     Names(LL1)*(*),Cformo*80,Cforma*80,Cform*80,cf*8,T*1,S*1
Logical       NoTail/.true./
*
*                   count the total mapped bank length
Cformo='-F'; n=0; do i=1,LL1
{  k=1;  if (map(1,i)>0 & map(2,i)>0) k=map(1,i)*map(2,i);  n+=k; }
 
*          for 'old' format n should be the same as LL, the rest is a header
if  n==LL { T=' '; nn=0; }   else if  n+2=LL   { T='F'; nn=2; }
else      { print *,' AgDFORM error detected: N,L=',n,LL,LL1;
            do i=1,LL1 { print *,' i,map =',i,map(1,i),map(2,i),' ',names(i) }
            Return
          }
*
Cform='/';  L=1;
do i=1,LL1+1
{  If i<=LL1
   {  k=1;  if (map(1,i)>0 & map(2,i)>0) k=map(1,i)*map(2,i);
      S=Names(i); If (S!='I' & S!='H') S='F';  If S==T { nn+=k; Next; }
   }
   if T!=' '                   " write previous format element "
   {  L+=1;  write(cf,'(i8)') nn;  Ls=L+1;
      If L>70 { print *,' AgDFORM error: format too long for ',names; break;}
      do j=1,8 { if Cf(j:j)!=' ' { L+=1; Cform(L:L)=Cf(j:j) } }
                                   L+=1; Cform(L:L)=T;
   }  nn=k; T=S;
}
*
   if NoTail & Ls>3 { cformo=cform; cform(Ls:)='-'//T; cforma=cform(3:Ls+1) }
   else             { cforma=cform; cform(Ls:)='-'//T; cformo=cform(3:Ls+1) }
   " print *,' cformo,Ls = ',cformo(1:20),Ls "
*
end
 
 
+DECK,agdtit,T=geant. ---------------------------------------------------------
*CMZ :  1.00/00 14/08/95  03.36.26  by  Pavel Nevski
*-- Author :    Pavel Nevski   14/08/95
************************************************************************
                Subroutine    A g D T I T (MTitle,Tshort)
*      make reasonable title cut by rejecting some trivial words       *
************************************************************************
  Implicit      none
  Character*(*) MTitle,Tshort
  Integer       Lenocc,Ntriv,i,j,k,is
  Parameter     (Ntriv=11)
  Character*12  word,trivial(Ntriv)
  Data          Trivial/' ','THIS','IS','THE','DESCRIPTION','OF','A',
                        'GEOMETRY','DIGITISATION','DIGITIZATION','ROUTINE'/
*
    k=1; :syntax: Do i=1,Lenocc(MTitle)                  " skip trivial words "
    {  is=k;  If MTitle(i:i)==' '
       {  word=Mtitle(k:i);  k=i+1
          do j=1,Ntriv { If (word=trivial(j)) next :syntax:; };  Break
    }  }
    Tshort=MTitle(is:)
end
 
 
+DECK,agauto,T=geant.
*CMZ :  1.00/00 27/08/95  20.18.55  by  Pavel Nevski
*-- Author :    Pavel Nevski   27/08/95
***************************************************************************
                SUBROUTINE    A G A U T O  (IAUTO)
* Description - Interactive GEANT fails to do it now, temporary fix       *
***************************************************************************
+cde,typing,gctrak.
     Integer  Iauto
     print *,' igauto was=',igauto,',  set to ',Iauto
     Igauto=Iauto
end
 
+DECK,agdump,T=geant.
*CMZ :  1.30/00 24/03/96  21.59.47  by  Pavel Nevski
*CMZU:  1.00/01 21/01/96  20.18.19  by  Sasha Vanyashin
*CMZ :  1.00/00 24/11/95  00.28.56  by  Pavel Nevski
*-- Author :    Pavel Nevski   20/11/95
***************************************************************************
*                                                                         *
            Subroutine   A G D U M P (CpathI,NUM,Chopt)
*                                                                         *
* Description: Given a path, dump the whole structure below it with DZDOC *
*      NUM   :  If NUM(1) is zero, array of 1s is assumed                 *
*      Chopt : F - write output in a file with the name of the bank(.sgml)*
*            : C - dump values only (to be read by another program)       *
*            : U - dump also undocumented banks, otherwise they are skept *
*            : 1 - skip banks longer then 1000 words                      *
*            : S - SGML format                                            *
*            : H - HGML format                                            *
***************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,QUEST,RbBank.
  INTEGER    LENOCC,INDEX,IL(15),LK(15),Num(15),Nun(15)/15*1/,
             L,I,J,K/0/,Luu/6/,MOQUEQ/11/,Ierr/0/
  Character  CpathI*(*),Cpath*80,Chopt*(*),Chtop*8,Cbank*4,
             Ctop*4,Bank*8,Cold*8,Chop*4,Cfile*4
  Logical    Opnd
*
  INQUIRE (FILE='detm.rz',opened=opnd)
  If .not.opnd
  {  CALL RZOPEN(61,CHTOP,'detm.rz','UWX',256,Ierr)
     CALL RZFILE(61,CHTOP,' ')
  }
*                  convert to capitals
L=Lenocc(CpathI);  Cpath=CpathI(1:L);  Call CLTOU(CPATH(1:L))
*
If Num(1)>0 { Call ReBANK(Cpath,Num,0,L,J) }
else        { Call ReBANK(Cpath,Nun,0,L,J) }
Check L>0;  J=1;  Cold=' ';  Luu=Lout;
If Index(Chopt,'F')!=0
{  Luu=62;  Call UHTOC(IQ(L-4),4,Cfile,4)
   Open(Luu,File=Cfile//'.sgml',STATUS= 'UNKNOWN')
}
*
Loop
{   If L>0
    {  If LQ(L+1)<=0  { Ctop='NONE' }
       else           { Call UHTOC(IQ(LQ(L+1)-4),4,CTOP,4) }
       Call UHTOC(IQ(L-4),4,CBank,4);   Bank=Cbank//Ctop;
      *                                    print bank header
       Chop='PRZ'
       If (Index(Chopt,'H')!=0) Chop='PRZH'
       If (Index(Chopt,'S')!=0) Chop='PRZS'
       If Cold != bank                   " dump new bank header "
       {  IQUEST(MOQUEQ)=1; Call DzDOCO(Luu,Bank,Chop); IERR=IQUEST(MOQUEQ) }
      *                                    print the bank itself
       If (Index(Chopt,'C')==0) { Chop=' ' } else { Chop='C' }
       If ((Ierr==0|Index(Chopt,'U')>0) & (Index(Chopt,'1')==0|IQ(L-1)<1000))_
          Call DzDDOC(IrbDiv,L,Bank,Chop,1,IQ(L-1),Luu,'    ',K)
       Lk(j)=L;  IL(j)=0;  Cold=Bank;
    }
*    now navigate in the structure - first through links, then to next bank
    If IL(j)<IQ(LK(j)-2)  { IL(j)+=1; L=LQ(LK(j)-IL(j));  If (L >0) j+=1; }
    else   " brothers "   { If (j==1) Break; L=LQ(LK(j)); If (L<=0) j-=1; }
}
If Index(Chopt,'F')!=0
{ Close (Luu);  If (Index(Chopt,'H')!=0)
  {  L=Lenocc(CPath);  J=0;  Ctop='NONE'
     do i=1,L-14  { If (CPath(i:i)='/') J=i }
     If (J>0) Ctop=CPath(J+1:J+4)
     Open (Luu,  File=Cfile//'.sgml', STATUS= 'UNKNOWN')
     Call DZE2HT(Luu,Luu+1,3,Ctop)
     close (Luu)
} }
END
 
 
+DECK,agexist,T=geant. --------------------------------------------------
*CMZ :  1.30/00 12/02/96  15.17.30  by  Pavel Nevski
*-- Author :    Sasha Rozanov  06/02/96
**********************************************************************
*                                                                    *
                    Function   A g E X I S T (Ctest)
*                                                                    *
* Description: check if a GEANT volume exist                         *
**********************************************************************
+CDE,TYPING,GCBANK,GCNUM.
  Integer      AgEXIST
  Character*4  Ctest
*
  Call GLOOK  (Ctest,IQ(JVOLUM+1),IQ(JVOLUM-1),AgEXIST)
*
  END
 
 
+deck,AGPMATER,T=geant.
*CMZ :          13/07/97  23.26.30  by  Pavel Nevski
*CMZ :  1.30/00 05/08/96  11.35.22  by  Pavel Nevski
*-- Author :     Pavel Nevski
******************************************************************************
                 subroutine   A g P M A T E R (a,b)
******************************************************************************
   Implicit  none
   Real      ARGUM,HI,HIJ,a,b,x,y,s0,s1,s2,ax,bx,ay,by,aa,bb
   integer   id,jd,kind,ix,iy,nx,ny,nwt,loc/0/
   character tit*100
*
aa=ARGUM(a);  bb=ARGUM(b)
do Id=3000,4000,1000
{  Do Jd=1,7,2
   {  Call  HKIND (ID+jd,KIND,' ')
      If (Kind==1)  Call HOPERA(ID+jd,'/',ID,ID+2,1.,1.)
      If  Kind==2
      {  Call  Hgive (ID+jd,  tit,nx,ax,bx,ny,ay,by,nwt,loc)
         Call  Hbook1(ID+jd+1,tit,nx,ax,bx,0)
         do ix=1,nx
         {  x=ax+(ix-0.5)*(bx-ax)/nx;    {s0,s1,s2}=0;   s0+=HI(ID,ix)
            do iy=0,ny+1
            { y=ay+(iy-0.5)*(by-ay)/ny;
              check aa<=y&y<=bb; s1+=HIJ(ID+jd,ix,iy);
            }
            if (s0>0) call Hfill (ID+jd+1,x,y,s1/s0)
      }  }
      if (1<=Kind&Kind<=2) call HPLOT(ID+jd+1,' ',0,0)
}  }
*
   end
+DECK,agsmater,T=geant. -------------------------------------------------------
*CMZ :          29/07/97  16.38.30  by  Pavel Nevski
*CMZ :  1.30/00 10/02/97  15.01.26  by  Unknown
*-- Author :    Alexandre Rozanov 02.04.95
******************************************************************************
*                                                                            *
                      SUBROUTINE   A g S M A T E R
*                                                                            *
*  Description:  store material distribution while processing geant step     *
*                again a temporary solution before something more general    *
******************************************************************************
+CDE,TYPING,GCONST,GCUNIT,GCFLAG,GCKING,GCKINE,GCTRAK,GCMATE,GCNUM
    REAL               ALRADL,ALABSL
    COMMON /AMATERIAL/ ALRADL,ALABSL
*
      REAL      ptot,eta,x0,R,Za,phi,Vmod,AL
      Real      ax,bx,ay,by
      integer   nx,ny,nwt,loc/0/
      character tit*100
      logical   First/.true./
      save      tit,nx,ax,bx,ny,ay,by,nwt,loc,eta,phi
*
*    should be called for geantino run
      if (First) Call Hgive(3000,tit,nx,ax,bx,ny,ay,by,nwt,loc)
      First=.false.
      If (loc>0) Then
         If Nstep==0
         {  ptot = vmod(pvert,3);    phi  = atan2(pvert(2),pvert(1));
            eta  = -10;  If (ptot>0) eta  = -log(tan(acos(pvert(3)/ptot)/2))
            if (ax>=0) eta=abs(eta); ALRADL=0; ALABSL=0;
            call hfill(3000,eta,1,1.); call hfill(4000,phi,1,1.)
            call hfill(5000,eta,phi,1.)
         }
         R  = vmod(Vect,2);     Za = abs(vect(3))
         x0 = step/radl;        AL = step/AbsL
*
         if Ntmult==1 & NMAT!=15
         {  ALRADL+= x0; ALABSL+= AL;
            call hfill(3001,eta,R,x0);   call hfill(3003,eta,R,AL);
            call hfill(4001,phi,R,x0);   call hfill(4003,phi,R,AL)
* slices in z possible - never used until now.
            call hfill(3005,eta,Za,x0);  call hfill(4005,phi,Za,x0)
            call hfill(3007,eta,Za,AL);  call hfill(4007,phi,Za,AL)
* I dont remember what this was useful for - keep it as spare for a while
            call hfill(5001,eta,phi,x0); call hfill(5003,eta,phi,AL);
         }
      endif
 END
 
 
+DECK,agcheck,T=geant.
*CMZ :  1.30/00 17/04/97  17.28.45  by  Pavel Nevski
*-- Author :    Pavel Nevski   16/04/96
***************************************************************************
*                                                                         *
      SUBROUTINE   A G C H E C K
*
* description: closing of the geometry sometime is not done properly      *
*              due to users faults - try to fix it if posssible           *
***************************************************************************
+CDE,GCBANK,GCUNIT,GCFLAG.
      Integer      Iflag/0/,JNAME/0/
*
      Iflag=0;   If (JNAME==0) CALL UCTOH('GPAR',JNAME,4,4)
      If   JGPAR<=0 | JGPAR>=NZEBRA    {  Iflag=1  }
      else IF IQ(JGPAR-1)<=0           {  Iflag=2  }
      else If IQ(JGPAR-3)!=IQ(JGPAR-1) {  Iflag=3  }
      else If IQ(JGPAR-4)!=JNAME       {  Iflag=4  }
*
      If Iflag>=1
      {   <W> Iflag,Jgpar;  (' AGCHECK: GPAR error',i3,i9,', doing GGCLOS')
         CALL GGCLOS
      }
     END
 
 
+DECK,AgZINI,T=geant. ----------------------------------------------------------
*CMZ :  1.30/00 17/04/97  16.14.18  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/11/94
***************************************************************************
*                                                                         *
                Subroutine   A g Z I N I
*                                                                         *
***************************************************************************
+CDE,TYPING,GCBANK,SCLINK.
   Integer NLM/20/
*
   Call MZLINK (IxSTOR,'/SCLINK/',LKSLUG,LKSLUG(NSLINK),LKSLUG)
   CALL MZBOOK (IxCONS, JGPAR, JGPAR, 1,'GPAR', NLM,0,NLM, 2,0)
   CALL MZBOOK (IxCONS, JGPAR2,JGPAR2,1,'GPA2', NLM,0,NLM, 2,0)
*
   END
 
+DECK,gfdig1,T=geant.
*CMZ :  1.00/00 21/02/95  01.18.39  by  Pavel Nevski
*-- Author :    Pavel Nevski   26/01/95
**********************************************************************
*                                                                    *
                     subroutine   G F D I G 1                        _
         (IUSET,IUDET,NTDIM,NVS, LTRA,NTRA,NBV,KDIGI,Iw,Iacce)
*                                                                    *
*      Returns the next digitisation for the physical volume, spe-   *
*      cified by NVS list with generic volume/set name IUDET/IUSET   *
* INPUT:                                                             *
* IUSET,IUDET - user set/detector identifiers (CHAR*4)               *
* NTDIM       Max. number of associated tracks to return             *
* NVS         array that contains the path to the detector volume    *
* OUTPUT:                                                            *
* LTRA        array that get the list of tracks                      *
*             which have produced this digitalisation                *
* NTRA        total number of contributed tracks                     *
* NBV         the list of volume numbers which identify              *
*             the physical volume                                    *
* KDIGI       array that get the digitalisation elements             *
* ====>  User should take care of NVS,NVB,KDIGI real dimesions !     *
**********************************************************************
Replace[;#?;] With [; IF #1 {" Take next word " K=1; Nk+=1; } ]   ;
+CDE,GCBANK.
  CHARACTER*4 IUSET,IUDET;
  Integer   NVS(1),NBV(1),KDIGI(1),LTRA(NTDIM),NTDIM,JBYT,
            Iset,Idet,Js,Jd,Jdi,Jddi,Jdid,ILAST,Nv,Nd,Kd,
            I,Iw,Io,Iv,Id,NWDI,NTRA,K,Nk,Nb,Jv,It,Iacce;
  COMMON    /GFDIGLI/  JS,JD,JDI,JDDI,JDID;
  Save      ISET,IDET,ILAST,NV,ND,IO;
  LOGICAL   First/.TRUE./;
                           * * *
IF First { First=.FALSE.; Call MZLINK(IXSTOR,'GFDIGLI',JS,JS,JDID); }
IF Iw<=0
{  "      Find if selected set and detector exist    "      Check JDIGI>0;
   Call GLOOK(IUSET,IQ(JSET+1),IQ(JSET-1),ISET);            Check Iset>0;
   JS   = LQ(JSET-ISET);                                    Check Js>0;
   JDI  = LQ(JDIGI-ISET);                                   Check JDI>0;
   Call GLOOK(IUDET,IQ(JS + 1),IQ(JS - 1),IDET);            Check Idet>0;
   JDID = LQ(JDI-IDET);                                     Check JDID>0;
   ILAST= IQ(JDI+IDET);                                     Check ILAST>0;
   JD=LQ(JS-IDET);  JDDI=LQ(JD-2);  NV=IQ(JD+2);  ND=IQ(JD+6);
   Iw=1; Io=0;
}
"                 Loop Over remaining digits                         "
NWDI=0;
for I=Iw  to  ILAST  by  NWDI
{  NWDI=IQ(JDID+I);  If (NWDI<=0 | I>=ILAST) Break;
   If (I=Io & Iacce=Jdid+Io) Next;
   NTRA=JBYT(IQ(JDID+I+1),1,16)+1;  Nk=2+NTRA/2; K=1; Nb=0;
   "   Select volume (tracks are not selected)   "
   Do Iv=1,NV
   {  Nb=IQ(JD+2*Iv+10);
      IF Nb>0  { K+Nb>33 ?; Jv=JBYT(IQ(JDID+I+Nk),K,Nb); K+=Nb;}
      ELSE     { K>1     ?; Jv=IQ(JDID+I+Nk);            Nk+=1;}
      IF (0<NVS(Iv)&NVS(Iv)#JV) GOTO :E:;           NBV(iv)=JV;
   }  Nb>0 ?;
   "      Now fetch unpacked digits and track numbers   "
   Do Id=1,ND
   {  Nb=IQ(JDDI+2*Id);
      IF Nb>0  { K+Nb>33 ?; Kd=JBYT(IQ(JDID+I+Nk),K,Nb); K+=Nb;}
      ELSE     { K>1     ?; Kd=IQ(JDID+I+Nk);            Nk+=1;}
                                                  Kdigi(Id)=Kd;
   }
   "             Get track numbers                    "
   Nk=1;  K=17;  Nb=16;
   do It=1,min (NTRA,NTdim)
   {   K+Nb>33 ?;  LTRA(It)=JBYT(IQ(JDID+I+Nk),K,Nb); K+=Nb;}
   {Iw,Io}=I;      Iacce=JDID+I;  Return;      :E:
}   Iw=0;
END;
 
 
+DECK,agsking,T=geant.
*CMZ :  1.30/00 03/05/97  16.11.50  by  Pavel Nevski
*-- Author :    Pavel Nevski  01/02/97
****************************************************************************
*                                                                          *
                subroutine   A g S K I N G
*                                                                          *
* Description: Save a stack track in KINE bank, before it produces a hit   *
* Too late to get anything from stack, all should be extracted in GLTRAC   *
*                                                                          *
****************************************************************************
+CDE,typing,GCBANK,GCFLAG,GCSTAK,GCUNIT,GCKINE,GCNUM,GCTMED.
Integer  i,L,Ivn,Itn,IPRIN,MECATO,ITRO
Real     TOFO,Ubuf
COMMON   /GCKINE_CONT/ ITRO,TOFO,MECATO
*
Check Istak>0 & Isvol=1; Iprin=Idebug
 
* first hit by this particle, save it
   Do IVN=NVERTX,1,-1
   { L=LQ(JVERTX-IVN);     IF "generator vertices" (Q(5+L)<=0) Break;
     check Q(4+L)==TOFO    & Q(5+L)==ITRA    & Q(6+L)==Mecato
     check Q(1+L)==Vert(1) & Q(2+L)==Vert(2) & Q(3+L)==Vert(3)
     go to :track:
   }
   Call GsVERT (Vert,ITRA,0,Ubuf,0,IVN)
   If IVN<=0
   { <w> ITRA,MECATO; (' AgGSKING cannot set Vertex for ',2i8/,
         ' ****** event simulation abandoned ******');  IEOTRI=1; RETURN
   }
   * Correct TOF (GsVERT takes it from TOFG of /GCTRAK/), save History
   L=LQ(JVERTX-IVN);  Q(4+L)=TOFO;  Q(6+L)=Mecato
*
   :track: Call GsKINE (Pvert, Ipart, IVN, Ubuf, 0, ITN)
   prin4 ITRA,Ivert,(vert(i),i=1,3),Itn,Ivn,Mecato
   (' AgSKING:  T/V=',2i4,'  v=',3f9.3,'  t/v=',2i4,' Mecato=',i8)
   * Ivert is set in GLTRAC only for KINE entries, not for any Jstak
   * Ivert should still remains primary numbering and cant be used
   Istak=0;  ITRA=Itn;  " Bad: Ivert=Ivn "
 
end
 
 
+DECK,AgSsecond,T=geant.
*CMZ :  1.30/00 05/05/97  01.05.56  by  Pavel Nevski
*-- Author :    Pavel Nevski   02/04/97
****************************************************************************
       Subroutine    A g S S E C O N D
*                                                                          *
* Description:  default solution is to put secondaries onto JSTAK only     *
*   NA49:  descendents of tracks from stack go into stack                  *
*          in DENSE MEDIA:  write all vertices of showers in NEW media,    *
*          ie check medium at point origin of parent track and             *
*          if the same as current medium, do not write out vertex          *
****************************************************************************
+CDE,typing,GCBANK,GCTMED,GCVOLU,GCTRAK,GCKINE,GCKING,AGCKINE.
       CHARACTER    Cmedium*20
       EQUIVALENCE (Cmedium,NATMED)
       Integer      LgKINE, i, j, IV, IB, IT
*                   Med_Vertex, Med_Current
*
       If ( flag_secondaries  .lt.  2 )    Return
       If ( Ngkine.le.0.or.Istak.gt.0 )    Return
       IV = Q(6+LgKINE(J,ITRA))            ! production vertex
       IB = Q(5+LQ(JVERTX-IV))             ! beam   - geant parent
       IT = Q(6+LQ(JVERTX-IV))             ! target - medium & process
*      If (IB!=0)                          Return
       If ( Cmedium(6:10) .ne. 'DENSE')    Return
*      call GTMEDI( vert, Med_Vertex  )
*      call GTMEDI( vect, Med_Current )
*      If ( Med_Vertex.eq.Med_Current )    Return
       If (abs(IT)/100==LVOLUM(NLEVEL))    Return
*
***      put secondaries into both JSTAK and JVERTX/JKINE structures
*
       do I=1,NGKINE
          IFLGK(I) = 1
       enddo
 
       END
 
+DECK,agusecond,T=geant.
*CMZ :          16/07/97  22.01.24  by  Pavel Nevski
*CMZ :  1.30/00 03/05/97  16.15.42  by  Pavel Nevski
*-- Author :    Pavel Nevski
************************************************************************
*                                                                      *
                SUBROUTINE   A g U S E C O N D
*                                                                      *
* Description :                                                        *
*     Set users conditions for products saving into the KINE bank      *
*     It gets arguments from DETP  TRAC  datacard:                     *
*          Mechanism, Rmax, Zmax, Eparent, Esecondary                  *
************************************************************************
+CDE,TYPING,GCUNIT,GCKINE,GCKING,GCTRAK,GCFLAG.
*
      INTEGER      AGPFLAG,N,I,J,IPRIN/0/,NPAR/0/,ISEL/0/,IdEvt0/-1/,IPAR(21)
      LOGICAL      FIRST/.true./
      Real         VMOD,PAR(21)
      Save         PAR
      Character*4  Cproc
      Equivalence  (PAR,IPAR)
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF (IdEvt0 != IdEvt)  THEN
          Idevt0  = Idevt
          IPRIN=AGPFLAG('TRAC','SIMU')
          CALL ASLGETBA('TRAC','DETP',21,NPAR,PAR)
          If (Iprin>=Idevt & Idebug>0)  <w> (PAR(i),i=2,NPAR)
             (' SECONDARY SAVING : process   Rmax   Zmax    Eparent    Eprod',
                                   /(20x,a4,f10.1,f7.1,2f10.3))
          NPAR=((NPAR-1)/5)*5;  Isel=0
          Do N=1,NPAR,5
             Call UHTOC(PAR(N+1),4,CPROC,4)
             If (Cproc=='*' | Cproc=='ALL') Isel=1
          enddo
      ENDIF
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CHECK ISTAK==0
* Check Mechanism, R,Z,E0 and Ei
:Mech: DO N=1,NPAR,5
          Check GETOT>=PAR(N+4)
          Check ABS(VECT(3))<PAR(N+3)
          Check VMOD(VECT,2)<PAR(N+2)
          DO I=1,NGKINE
             IF (GKIN(4,I)<PAR(N+5)) Next :mech:
          enddo
 
          DO I=max(1,NMEC-1),NMEC
             Check (NAMEC(LMEC(I))==IPAR(N+1) | Isel>0)
             Prin5   NGKINE,(VECT(J),J=1,3),GETOT,(NAMEC(LMEC(J)),J=1,NMEC)
             (' AgUSECOND: SAVED',I3,' products at',4F10.3,' of',20(1X,A4))
             DO J = 1,NGKINE
                IFLGK(J) = 1
             ENDDO
             break :Mech:
          enddo
       enddo
*
      END
 
 
+DECK,agfhita,T=geant. ---------------------------------------------------------
*CMZ :  1.30/00 17/11/96  21.32.49  by  Pavel Nevski
*-- Author : Pavel Nevski
*************************************************************************
*                                                                       *
             Function     A g F H I T a (Cset,Cdet)
*                                                                       *
*  Description: this routine does not set DIGI - this allows add digits *
*************************************************************************
+CDE,TYPING,GCUNIT,AGCRDIG,AGCBUFF.
 Character*(*)  Cdet,Cset
 Integer        AgFHITa,AgFDIG0,AgPFLAG,I,J,L,ok/0/
*
   AgFHITa =-1;  Cs=Cset(1:3)//'H';  Cd=Cdet
   IPRIN = AgPFLAG (Cset,'DIGI');    Check Iprin>=0
   If (IPRIN>=5) CALL AGPDIGI (Cs,Cdet)
   AgfHITa = AgFDIG0 (Cs,Cdet)
*
****** if (AgFHIT0==ok)   I = AgSDIG0 (Cset(1:3)//'D',Cdet) **********
   If Iprin>=15
   {  <w>; (' *** AGFHITa buffer  ***');  j=1; while Ibuf(j)>0
      {  L=IBUF(j); if (L<=0) Break; <w> j,L,(Ibuf(j+i),i=1,L);
         (' adr=',i6,' L=',i4,2x,20i5/(20x,20i5));      j+=L+1;
   }  }
   END
 
 
+DECK,agkeeps,T=geant.
*CMZ :          03/05/98  16.30.24  by  Pavel Nevski
*-- Author :    Pavel Nevski   25/11/97
*************************************************************************
*                                                                       *
                subroutine  A G K E E P S (Request,Cdest)
*                                                                       *
* Description:                                                          *
* produce include files and update the documentation database           *
*     Request is a REBANK path, default root is DETM                    *
*     Cdest   is def, idl or memory (dui etc)                           *
*     IWr is generated according to request:                            *
*     0- global include file, 1 - subsystem files, 2 - separate structs *
*     Kw=0  - no prefix in keep name, not used                          *
*************************************************************************
+include,TYPING,GCBANK,SCLINK,GCUNIT,GCFLAG,AGCDOCL.
     integer     Iprin,i,i1,i2,il,id,ic,jl,L,L1,L2,Iwr,Kw/1/,Lu,Idl,Key(2)
     Integer     LENOCC,INDEX,TDM_MAP_TABLE
     Character*8 Sname, Bname, Ckey
     Character*4 Csys, Cban
     Character   Request*(*),Cdest*(*), Table*10
 
     character      ccc*12000
     common /agcstaftab/ ccc
 
     Call Agsbegm('DOCUM',Iprin); Call AsbDETE('DOCU',Id); Iprin=Idebug
 
     Idl = 0
     if (Index(Cdest,'idl')>0) Idl=1
     if (Index(Cdest,'dui')>0) Idl=2
 
*  request a la UNIX: sys/bank
     Iwr = 0
     i2=lenocc(request);    i1=index(request,'/');  if (i1<=0) i1=i2+1
     Csys='*'; if (i1>2)    Csys=request(1:i1-1);   if (i2>0)  Iwr=1
     Cban='*'; if (i1<i2) { Cban=request(i1+1:i2);             Iwr=2 }
     prin2 csys,cban,i1,i2,iwr,idl;(' in agkeep csys=',a,' cban=',a,' iwr=',4i2)
 
     i1=Lenocc(Csys);       Call CUTOL(Csys);
     i2=Lenocc(Cban);       Call CUTOL(Cban);
*
     If (LdArea(1)=0) call MZLINT(IxCONS,'AGCDOCL',LDarea,L1Doc,Lpar)
     Check LKDETM>0 & Id>0;  L=LQ(LQ(LKDETM-Id)-1); Check L>0;
     CALL UHTOC(IQ(L-5),4,Sname,8);
     if (Sname=='NONEDETM' | Sname=='ENONDETM')  L1doc=L;
     prin4 L1Doc;  (' ==> got L1Doc  ',i10);     Check L1Doc>0;
 
     Lu  = 0
     call agdprina(Iprin,Lu,L1doc,0,Iwr,Kw,Idl)
 
     do il=1,IQ(L1doc-2)
        L1=LQ(L1doc-il); check L1>0;
        CALL UHTOC(IQ(L1-5),4,Sname,8); Call CUTOL(Sname)
        Check csys='*' | Sname(5:4+i1)==csys(1:i1)
 
        call agdprina(Iprin,Lu,L1,1,Iwr,Kw,Idl)
 
        do jl=1,IQ(L1-2)
           L2=LQ(L1-jl); check L2>0; ccc=' '
           CALL UHTOC(IQ(L2-5),4,Bname,8); Call CUTOL(Bname)
           Check cban='*' | Bname(5:4+i2)==cban(1:i2)
           call agdprina(Iprin,Lu,L2,2,Iwr,Kw,Idl)
 
           Table=Sname(5:8)//'_'//Bname(5:8); Call CUTOL(Table)
           if (idl==2) i=TDM_MAP_TABLE(%L(Cdest),%L(Table),%L(ccc),0,0)
 
           Key(1)=IQ(L2-4);  Key(2)=IQ(L2-5);  Call UHTOC(Key,4,Ckey,8)
           CALL aRZOUT(IXCONS,L2,CKey,IC,'SN')
        enddo
     enddo
     If (Lu>6) close (Lu)
     Call Agsendm
     end
 
 
*************************************************************************
*                                                                       *
              subroutine agdprina(Iprin,Lu,L,Lev,Iwr,Kw,Idl)
*                                                                       *
* Description: Produce a copiler readable include files for structures  *
* Decoding part is tough, for format details see 2.16 MZFORM, page 44:  *
* a Bank consists of 3 types of blocks (P=1-3 -> tit)                   *
* each of blocks contains sectors (crec<=ask(1-9))                      *
* A useful dd sector contains type.variable + comments                  *
* Routine produce or a def file, or an idl file, or struct in memory    *
*************************************************************************
+include,TYPING,GCBANK,SCLINK,GCUNIT,AGCDOCL,QUEST.
   Integer      INDEX,LENOCC,NwDESC,Nwhead,NwGEN,Nwlink,Nwdata,Idl,lu,nc,MM
   Integer      Lev,Iwr,Kw,Iprin,i,j,k,l,m,n,is,nd,Nw,iw,iv,i1,j1,P,nn(3),x
   Integer      mask(9)/1,1024,16384,8192,9216,10240,15361,19456,17410/
   Character*2  ask (9)/'ba','au','ve','nd','nl','ns','up','io','dd'/
   character*1  Let,T,Sec(0:8)/'*','B','I','F','D','H','*','S','*'/
   character*6  tit (3)/'header','links','data'/
   character*80 Text,texto,Format,Header,Author,Create
   character*8  var,varo,dname,cn,type,typo
   character    crec*2,kname*16,blan*12/' '/
   character*4  Upper,Bname,Csys/' '/
   Equivalence  (text,var),(texto,varo)
 
   character           ccc*24
   common /agcstaftab/ ccc(500)
 
   nc=0; check L>0;
   prin3 (IQ(L-i),i=1,5);(' ***** doc bank =',3i10,2x,2a5,' *****')
   call UHTOC(IQ(L-5),4,dname,8); prin5 dname;  (' dname  = ',a)
   call UHTOC(IQ(L+1),4,bname,4); prin5 bname;  (' bname  = ',a)
   NwDesc = IQ(L+2);              prin5 NwDesc; (' Nwdesc = ',i4)
   NwHead = IQ(L+3);              prin5 Nwhead; (' Nwhead = ',i4)
   NwGen  = IQ(L+11);             prin5 NwGen;  (' Nwgen  = ',i4)
   NwLink = IQ(L+12);             prin5 NwLink; (' Nwlink = ',i4)
   NwData = IQ(L+15);             prin5 NwData; (' Nwdata = ',i4)
   i=Nwhead+1;  Call Vzero(NN,3); P=1; Format='-F'; MM=0;
 
   while i<=Nwdesc+1
   {  if i>=Nwhead+Nwgen+Nwlink+1 {P=3} else if i>=Nwhead+Nwgen+1 {P=2}
      Let='H'; Text=' '; if i<NwDesc
      {  i1=i; Is=IQ(L+i1); Nw=is/16; i=i+Nw;
         Let=Sec(min(mod(Is,16),8));
      }  i=i+1;
 
      If let=='I' & Nw==3
      {  iw=IQ(L+i1+1);  Iv=IQ(L+i1+2);
         crec='un';   do k=1,9 { If (iw==mask(k)) crec=ask(k); }
         if (crec(1:1)=='n') { prin5 crec,iv; (' sector ',a4,i5);}
      }
      else If let='H' & i<=NwDesc+1
      {  j1=1; if (crec=='ba') j1=2;
         Call UHTOC(IQ(L+i1+j1),4,text,4*(Nw-j1+1));
         If  NN(P)==0  { Nd=0; Texto=' '; Prin4 tit(p); (' ---  ',a,'  ---') }
         if (P==3 & nn(p)>=mm)  call agreforma(format,mm,type,idl)
         NN(P)+=1;  Prin6 crec,p,NN(p),Nd,type,text(1:Lenocc(text));
         (' sector ',A4,':  NN(',i1,')=',i4,'  ND=',i3,' t=',a,' : ',a)
      }
      else  { prin6 i,let,Nw; (' unknown sector at ',i6,2x,a1,i8); crec='dd';}
 
      If (crec=='ba' & Let='H')  Header = text
      If (crec=='au' & Let='H')  Author = text
      If (crec=='ve' & Let='H')  Create = text
      If (crec=='up' & Let='H')  Upper  = text
      If (crec=='io' & Let='H')  Format = text
      check P==3 & Let='H' & crec='dd'
*
* ----------------  unpacking done, now output stuff --------------
*
      If NN(P)==1
      {  prin4 lev,bname; ('===>  starting lev,bname=',i3,2x,a,' <===');
*         if (Lev<=1) Csys='sys'
         kname=%L(csys)//'_'//%L(bname)
         if (Lev<=1) kname=%L(bname)//'sys'
         if (Idl==0) kname=%L(kname)//'.def'
         if (Idl>0 ) kname=%L(kname)//'.idl'
         call CUTOL (kname); J=index(kname,'.')
         if (Lev==1) Csys=bname
 
         if Lev==Iwr
         {
            If (Lu>6) CLose(lu);  Lu=1 " pseudo-output - in memory only"
            if (idl<=1)
            { lu=62;  prin2 kname; (' AgDocPrin: open file ',a)
              Open (Lu, file=%L(kname), STATUS= 'UNKNOWN')
         }  }
 
         if (Lu>0 & Idl==0)
         { if (Lev=0) output kname(:j),%L(create)
              ('+PATCH,',a/'*Created: ',a/,
               '*This file is automatically generated by AGI'/,
               '*--------- DO NOT EDIT THIS FILE -----------'/'*')
           if (Lev=1) output kname(:j),%L(header),%L(author),%L(create)
              ('+DECK,',a,' describes the ',a/'*Author : ',a/'*Created: ',a/'*')
           if (Lev=2) output kname(:j),%L(header),%L(author),%L(create),
                                                                  bname,header
              ('+KEEP,',a,' - ',a/'*Author : ',a/'*Created: ',a/'*'/,
               '  structure  ',A4,'    { " ',a42, ' " _ ')
         }
         if (Lu>0 & Idl==1)
         {  if (Lev==Iwr) output %L(kname),%L(header),%L(author),%L(create)
            ('/* File ',a,/'** '/'** Description: ',a/,
             '** Author     : ',a/'** Created    : ',a/,
             '** This file is automatically generated by AGI'/,
             '** --------- DO NOT EDIT THIS FILE -----------'/'*/')
            if (Lev==2) output kname(:j-1);  ('  struct  ',a,'   { ')
         }
         if (Lu>0 & Idl==2 & Lev==2)
         {  nc+=1; CCC(nc)=' struct '//kname(:j-1)//' { '; }
      }
*
      nd+=1; check Lev==2 & var!=varo & lu>0
*
      If varo!='  '
      {  if (varo=='- ') varo='system'
*        fit rigid stic format - no extra spaces allowed
         call CUTOL(varo);     N=Lenocc(varo)
         if (idl>0 & typo=='char') ND=4*ND
         write(CN,'(i6)') ND;  M=Lenocc(CN)
         do K=1,M { if (CN(K:K)!=' ') Break; }
 
         if Idl==0
         {  T=','; if (text==' ') T='}'
            " hash in comments creates problems for AGI parser "
             do x=9,80  { if (texto(x:x)=='#') texto(x:x)='N' }
            if (ND==1) output typo,%L(varo),blan(N:),texto(9:),T
                    (4x,a4,1x,2a,' " ',a42,' " ',a)
            if (ND >1) output typo,%L(varo),CN(K:M),blan(M-K+N+3:),texto(9:),T
                    (4x,a4,1x,a,'(',a,')',a,' " ',a42,' " ',a)
            if (text==' ') output; ('*');
         }
         If Idl==1
         {  if (ND==1) output typo,%L(varo),blan(N:),texto(9:)
                    (4x,a5,1x,a,       ';',a,'/* ',a42,' */')
            if (ND >1) output typo,%L(varo),CN(K:M),blan(M-K+N+3:),texto(9:)
                    (4x,a5,1x,a,'[',a,'];',a,'/* ',a42,' */')
            if (text==' ') output; ('};');
         }
         If Idl==2
         {  NC+=1;
            if (ND==1) CCC(NC)='  '//typo//%L(varo)//'; '
            if (ND >1) CCC(NC)='  '//typo//%L(varo)//'['//CN(K:M)//']; '
            if (text==' ')  { NC+=1; CCC(NC)='}' }
         }
      }
      nd=0; Texto=Text; typo=type
   }
  end
 
 
****************************************************************************
  subroutine  agreforma (format,num,type,idl)
*                                                                          *
* Description: decode ZEBRA 'format' descriptor into a sequence of 'type's *
*              for format details see: 2.16 MZFORM, page 44                *
*              - num is the number of items already taken, should be saved *
*              - idl is an agi/c switch                                    *
****************************************************************************
 
  character   format*(*),type*8,List*14/'0123456789-IFH'/
  integer     Lenocc,idl,L,i/0/,k,n,num,big/9999999/
 
     L=Lenocc(format);  if (num==0) i=0;  N=0;
     Do i=i+1,L
     { k=index(list,format(i:i))-1;  check k>=0
       if  k<=9  "digit"  { N=N*10+k; Next; }
       if  k=10  "tail"   { N=big;    Next; }
       num=num+max(1,N);  Break;
     }
     if (idl==0) { type ='real';  if (format(i:i)=='I') type='int';  }
     else        { type ='float'; if (format(i:i)=='I') type='long'; }
     if (format(i:i)=='H') type='char'
     end
 
 
+DECK,agphysi,T=geant.
*CMZ :          31/03/98  19.05.30  by  Pavel Nevski
*-- Author :    Pavel Nevski   06/03/98
************************************************************************
*                                                                      *
                subroutine    A g P H Y S I
*                                                                      *
*  Description: make Cross-section calculations re-executable          *
*  Modified algorithm from GXPHYS. CKOV banks are not dropped          *
*                                                                      *
************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCCUTS,GCPHYS,GCFLAG.
*    provide index access to geant mechanism
     Integer       MECA(5,13)
     EQUIVALENCE  (MECA,IPAIR)
 
     Integer i,j,jtm,jma,Ival
 
     IF JTMED>0               " Extracted From GXPHYS "
     {  DO I=1,IQ(JTMED-2)
        {  JTM=LQ(JTMED-I);  Check JTM>0
           IF IQ(JTM-2)==0 { CALL MZPUSH(IXCONS,JTM,10,0,'I');     Next;}
           * drop only MUEL and MUMU banks
           DO J=1,2 { IF(LQ(JTM-J)>0) CALL MZDROP(IXCONS,LQ(JTM-J),' ');}
        }
        " copy tracking cuts from standard to special media "
        CALL UCOPY(CUTGAM,Q(JTMED+1),10)
        " copy mecanism flags (pair..rayl) to special media "
        DO I=1,13 { Q(JTMED+10+I)=MECA(1,I) }
     }
     IF JMATE>0               " Extracted From GXPHYS "
     {  DO I=1,IQ(JMATE-2)
        {  JMA=LQ(JMATE-I); Check JMA>0
           DO J=1,IQ(JMA-2)
           {  IF (J==4 | J==5) Break " strange !"
              IF (LQ(JMA-J)>0) CALL MZDROP(IXCONS,LQ(JMA-J),'L')
     }  }  }
     Ival=Lout;  If (Idebug==0) Lout=99;
     Call GPHYSI
     Lout=Ival
     end
 
 
+DECK,agstrut,T=geant.
*CMZ :          03/05/98  16.30.24  by  Pavel Nevski
*-- Author :    Pavel Nevski   25/11/97
***************************************************************************
*                                                                         *
            Subroutine   A G S T R U T (Source,Destin)
*                                                                         *
* Description: Given a path, dump the whole structure below into STAF     *
*     request a la UNIX: sys/bank - very combersome for the moment :      *
*     'standard' path form is [/DETM/]sys..., * at the end means 'all'    *
*     RECB alternative form is /RECB/....bank*sys
*                                                                         *
***************************************************************************
+CDE,TYPING,GCBANK,GCUNIT,GCFLAG,AgCDOCL,RbBank,QUEST.
  INTEGER       LENOCC,TDM_MAP_TABLE,Iprin,Nun(15),LK(15),IL(15),
                I,J,L,K,M,N,Ia,Lc,Lp,Mj
  Character     Cpath*80,Cdest*80,Csys*80,Table*10,Cbank*4
  Character*(*) Source,Destin
  EQUIVALENCE   (L,Lpar)
*
* reduce to the standard path and dest:
  Iprin=Idebug;         Cpath=Source;
  if (Cpath(1:1)!='/')
  { If Lenocc(Source)==4 { Cpath='/DETM/'//Source(1:4)//'/*'; }
    else                 { Cpath='/DETM/'//Source;            }
  }
  Call CLTOU(Cpath);
 
  Cdest='/dui/Run'; if (Cpath(2:5)!='DETM') Cdest='/dui/Event';
  if (Lenocc(Destin)>0) Cdest='/dui/'//Destin;
 
* Csys - prefix for AgKeeps
  Lc=Lenocc(Cpath); n=Index(Cpath,'@');  Csys=' ';
  if (Cpath(1:6)=='/DETM/' & Lc>=10) Csys=Cpath(7:Lc)
  if (0<n&n<Lc)  { Csys=Cpath(n+1:Lc); Lc=n-1 }
  Mj=2; if (Lenocc(Csys)>0) { Call Agkeeps(Csys,Cdest); Mj=0; }
*
* Rebank path does not accept / or /* at the end, truncate:
  m=Index(Cpath(1:Lc),'*'); Lp=Lc;
  if (m>0) Lp=min(Lp,m-1);  if (Cpath(Lp:Lp)='/') { Lp-=1; m=-1 }
  do i=1,Lp/5 { Nun(i)=1 }; Nun(Lp/5)=0;
  Call ReBANK(Cpath(:Lp),Nun,0,L,Ia)
  Call UHTOC(IQ(L-4),4,CBank,4)
 
  prin2  %L(Csys),Cpath(:lp),Cbank,lc,n,m,mj,lp
  (' AGSTRUT decoded Csys,Cpath,Cbank=',3(1x,a),' lc,n,m,mj,lp=',6i8)
 
  if L<=0 { <w> %L(Cpath); (' AGSTRU: Data source ',a,' not found '); Return; }
*
*
J=1; Loop
{  If L>0
   {  Call UHTOC(IQ(L-4),4,CBank,4);
      if     J==MJ
      { Csys=Cbank; If (Csys!='DOCU') Call AGKEEPs(%L(Csys),%L(Cdest)) }
      elseif J> MJ & Csys!='DOCU'
      { Table=Csys(1:4)//'_'//Cbank;  Call CUTOL(Table);
        K=1; if (IQ(L-5)<0) K=-IQ(L-5)
        i=TDM_MAP_TABLE(%L(Cdest),%L(Table),'\000',K,IQ(L+1))
        prin2 %L(Cdest),%L(Table),i,k,(Q(L+i),i=1,3)
              (' TDM_MAP_TABLE:',2(1x,a),2i5,3F8.1)
        " specific bank requested " if (m==0 & Mj==0) Break;
      } Lk(j)=L;  IL(j)=0;
   }
*    now navigate in the structure - first through links, then to next bank
   If IL(j)<IQ(LK(j)-2)  { IL(j)+=1; L=LQ(LK(j)-IL(j));  If (L >0) j+=1; }
   else   " brothers "   { If (j==1) Break; L=LQ(LK(j)); If (L<=0) j-=1; }
}
END
 
+DECK,axparticle,T=geant.
*CMZ :          25/03/98  16.16.21  by  Pavel Nevski
*-- Author :    Pavel Nevski   25/03/98
**********************************************************************
                subroutine   a x p a r t i c l e
**********************************************************************
+CDE,Agecom,GCFLAG.
    call gspart(%Code,%Title,%TrkTyp,%Mass,%Charge,%Tlife,0,0)
    if (%Mode(1)>0) call GSDK(%Code,%Bratio,%Mode)
    if (Idebug>1) Call GPPART(%Code)
    if (Idebug>2) Call GPDCAY(%Code)
 end
+DECK,agfvolu,T=geant.
*CMZ :          03/05/98  21.09.43  by  Pavel Nevski
*-- Author :    Pavel Nevski   03/05/98
*************************************************************************
      SUBROUTINE  aGFVOLU (Ivol,Cvol,Cshap,numed,par,npar)
*
* description: extract parameters of a give geant volume
*
*************************************************************************
+cde,typing,gcbank.
      integer   Ivol,numed,npar
*     integher  Ishap
      character Cvol*4,Cshap*4
      real      par(*)
 
*         make GFVOLU call... ? => CVOL,CSHAP
          Call GFVOLU (Ivol,CVOL,CSHAP)
*         Call UHTOC   (IQ(JVOLUM+IVOL),4,Cvol,4)
*         Ishap     = Q(LQ(JVOLUM-IVOL)+2)
*         Cshap     = Cshapes(Ishap)
          Numed     = Q(LQ(JVOLUM-IVOL)+4)
          Npar      = Q(LQ(JVOLUM-IVOL)+5)
*         Numat     = Q(LQ(JTMED-Numed)+6)
          Call Ucopy (Q(LQ(JVOLUM-IVOL)+7),par,min(50,Npar) )
       end
 
