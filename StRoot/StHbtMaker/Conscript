#!/opt/star/bin/perl
#use Env;
Import qw ( env INCLUDE LIB BIN  EXPORT BUILD OBJ);
(my $build = $OBJ) =~ s/\#//g;
$build =~ s/\\/\//g;# print "OBJ = $OBJ build = $build MAIN = $MAIN\n";
(my $ObjDir = DirPath '.') =~ s/\\/\//g;# print "ObjDir = $ObjDir\n";
(my $Dir = $ObjDir) =~ s/$build\///g; #print "Dir = $Dir\n";
$ObjDir = "#" . $ObjDir; #print "ObjDir = $ObjDir\n";
(my $obj_dir = $ObjDir) =~ s/^\#//g;# print "obj_dir = $obj_dir\n";
my $STAR_SYS = $env->{ENV}->{STAR_SYS};
my $pkg  = basename($Dir);# print "Run cons in $Dir for $PKG\n";
my $PKG = $pkg;
my @src  = qx (
	       cd StRoot/StHbtMaker; 
	       find ./ -name '*.cc';
	       find ./ -name '*.cxx';
	       find ./ -name '*.F';
	       find ./ -name '*.f';
	      ); 
print "src = @src\n";
my @h_files  = qx (cd StRoot/StHbtMaker; 
		   find ./ -name '*.h' | xargs grep -l ClassDef; 
		   find ./ -name '*.hh' | xargs grep -l ClassDef;);
print "h_files = @h_files\n";
printf ("Run Conscript  in %-30s  for %-20s\n",$Dir, $PKG) unless ($param::quiet);
my $obj  = $ObjDir;  #print "obj = $obj\n";
my $SO_PKG = $PKG . "." . $env->{SUFSOLIB}; #print "SO_PKG = $SO_PKG\n";
my $LIBS  = $env->{LIBS};
my $LIBPATH = $env->{LIBPATH};
(my $share = $EXPORT .  "/" . $Dir) =~ s/\/StRoot//g;
my $CPPP =  $INCLUDE . "/" . $pkg 
  .  ":" . $Dir  
  .  ":" . $Dir . "/Base" 
  .  ":" . $Dir . "/CorrFctn" 
  .  ":" . $Dir . "/Cut" 
  .  ":" . $Dir . "/Infrastructure"
  .  ":" . $Dir . "/Reader"
  .  ":" . $env->{CPPPATH};#  print "CPPP = $CPPP\n";
my $include = $INCLUDE . "/" . $pkg;
my $LIBPKG = "";
my $CXXFLAGS = $env->{CXXFLAGS};
if ($STAR_SYS =~ /^sun4x_5/) {$CXXFLAGS .= " -ptr" . $obj_dir;}
$env2 = $env->clone('CPPPATH'      => $CPPP,
		    'CXXFLAGS'     => $CXXFLAGS,
                    'LIBPATH'      => $LIBPATH,
                    'LIBS'         => $LIBS);
my $cscanner= find scan::cpp($env2->{_cwd}, $env2->{CPPPATH});
my $CPPPATH = $cscanner->iflags;#  print "CPPPATH = $CPPPATH\n";
my @cpps = split /:/,$env2->{CPPPATH};# print "@cpps\n";
my $ROOTCINT_CPP ="";
foreach my $cpp (@cpps) {
  if ($cpp =~ /cern/ ||
      $cpp eq "/usr/include"
     )  {next;}
  if ($ROOTCINT_CPP) {$ROOTCINT_CPP .= ":" . $cpp;}
  else               {$ROOTCINT_CPP .= $cpp;}
}
$cscanner= find scan::cpp($env2->{_cwd}, $ROOTCINT_CPP);# print "ROOTCINT_CPP = $ROOTCINT_CPP\n";
my $ROOTCINT_CPPPATH = $cscanner->iflags;# print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n";
my $DIR = cwd(); #print "DIR = $DIR\n";
if ($#h_files > -1) {
  my @CintFiles = 
  ($share . "/"  . $PKG . "_Cint.cxx", $share . "/"  . $PKG . "_Cint.h", $share . "/"  . "LinkDef.h"); 
  Command $env2 [@CintFiles], @h_files,  qq(RootCint.pl "%>" "%<" "$ROOTCINT_CPPPATH" );
  my $linkdef = pop @CintFiles;# print "ObjDir and Cints: $ObjDir => @CintFiles\n";
  Install $env2 $ObjDir, @CintFiles;
  (my $cint =  $CintFiles[0]) =~ s/$share/$obj/g;
  push @src, $cint;# print "+==========add $cint\n"; 
}
if ($#src > -1) {
  if ($LIBPKG) {
    Library      $env2 $LIBPKG, @src;  
    Install $env2 $LIB, $LIBPKG;# print "Install $env2 $LIB, $LIBPKG\n";
    my $libpkg = $LIB . "/" . basename($LIBPKG);
    Depends $env2 $SO_PKG, $libpkg;
  }
  LinkedModule $env2 $SO_PKG, @src;
  Install $env2 $LIB, $SO_PKG;
}  
