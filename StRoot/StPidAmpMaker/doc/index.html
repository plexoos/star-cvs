<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<body bgcolor="#ffffff">

  <head>
    <title>StPidAmpMaker</title>
  </head>

  <body>
   <center> <h1>StPidAmpMaker - STAR Particle Identification vi Amplitute Approach </h1></center>

<p>Please send questions to aihong@cnr.physics.kent.edu </p>
    <hr>

<ul>

<li><a href="#General">General</a>

<li><a href="#Algorithm">Algorithm</a>

<li><a href="#Infrastructure">Infrastructure</a>

<li><a href="#Performance">Performance</a>
<li><a href="#Tutorial">Tutorial</a>
<li><a href="#FAQ">FAQ</a>



</ul>


<hr>

<h2><a name="General">General</h2>

The StPidAmpMaker is designed to be used with StuProbabilityPidAlgorithm, which is a functor in StEventUtilities.
<p>
The StPidAmpMaker loop through StEvents, and output a bunch of   *.root files.
What those .root files contain are the parameters for describing the Bethe-Bloch curve, the statistic information for describing the amplitude and resolution's variation along p/z, which can be used to do the Particle Identification. Also this package generates  parameters for calibration of de/dx vs p/z.
</p>
<hr>
<h2><a name="Algorithm">Algorithm</h2>
<p>The de/dx~p plots for tracks consists of several individual bands, namely the pion band, the kaon band,the proton band and the electron band. Our task is, given a track with de/dx and rigidity(p/z), figure out wich individual band that track mostly likely belongs to.</p>
<p>To do so, we can try to establish the amplitude for each band. What is the amplitude here? Loosely speaking, the amplitude represents the density of dots  on the de/dx~p plot. If you fill de/dx and p into a 2D histogram and draw it as LEGO, the amplitude is the height of each cell on x-y plane. So you can imagine each band as a "ridge". See following graph of reconstructed "ridge" for pion band.</p>
<center><img src="ampRecoPionBand.gif"></a></center>
<p>Note that If we cut the "ridge" above at a given rigidity, we will get a gaussian curve. </p>
<p>The picture above shows only the pion band, we can reconstruct all other bands as such "ridge" as well. By putting them together, we have sth. like following(not very clear, but, you got the ideal):</p>

<center><img src="ampRecoAllBands.gif"></a></center>
<p>The blue ridge is pion band, the red ridge is kaon band, the green is for proton, the magenta is for electron(such color convention will be used through this document).</p>

<p>Then how to get the PID probability? Now surppose we have a track with rigidity(p/z)=0.68, de/dx=0.175e-05(Gev/cm). We make a vertical plane at rigidity=0.68 to cut the picture above, the cross-section we get is sth. like following:</p>
<center><img src="pidAlgo.gif"></a></center>
<p>On the plot, the color dash line represents amplitudes due to different band(The gaussian curve from electron band at this rigidity is so tiny that we can just see a flat line). Now we say:
<p>The probability of this track(de/dx=0.175e-05Gev/cm, rigidity=0.68) to be a kaon = height of red dash line / sum of heights from all dash lines </p>

<p>Sounds easy? But in the code we have to do thousands fittings to reach the goal!</p>

<p>Now we can do even better. Let's take a look at de/dx~p plot for different nhits range(nhits=# of tpc hits used in mean de/dx calculation):</p>

<center><img src="demoNHits.gif"></a></center>
<p>The blue area is the <a href="regions.gif">overlapping</a> area.The  blue areas show that a fuzzy semi-overlapping area in de/dx~p plot for low nhits tracks could come to be clearn area in plot for high nhits tracks. So if we do PID without nhits binning, some signal could be washed out by fuzzy low nhits tracks. The reasonable way is to let high nhits band compete with high nhits band, low nhits band compete with low nhits band, and that is the way we implemented in the package.</p>

<p>Now we included the nhits dependence for PID, in the code we consider the Dca dependence as well. Another PID dependence is pt dependence, which is not implemented in the package at the moment.</p>

<p>So you've got some ideal of the Probability PID algorithm. What the StPidAmpMaker does is to produce a set of parameters which can be used to reconstruct those "ridges". The parameters will be read in by StuProbabilityPIDAlgorithm, wich will be constructed in your analysis code. Then StuProbilityPIDAlgorithm reconstructe the expected amplitude and yield the probability PID for each track.</p>

<p> <a href="http://cnr2.kent.edu/~witt/pid/"> Wanna know more about the algorithm? Richard Witt, who wrote the initial Fortran version of amplitude PID, has a nice page describing the algorithm. Clickhereto go to his page. </a>

<hr>

<h2><a name="Infrastructure">Infrastructure</h2>
Currently we agree that PID depends on NHits, Pt, etc. Those dependences with their combinations make the infrastructure a little complicate.

<p>So let's carify some important concepts in this package first.</p>
<p> <font color=#EE1110> StPidAmpNet</font>
StPidAmpNet is a <a href="netShape.html">predefined "net" </a>on the de/dx~p/z plane:(from now on I will use net refer to an  instance of StPidAmpNet). Each particle type has a such net. All particles will be filled into those nets and build up statistic information by fitting.</p>
<p> <font color=#EE1110> StPidAmpChannel</font>

A channel is made up by a set of nets (electron net, pion net...) which can only be filled by the tracks that satisfy the channel confinement. For example, we have a channel with confinement NHits between 10,15, Pt between 0,0.5 Gev. then only those tracks with NHits between 10-15 and Pt between 0-0.5 can be filled into nets in this channel. (from now on I will use channel refer to an instance of StPidAmpChannel)</p>


<p> <font color=#EE1110> StPidAmpChannelCollection</font>

A ChannelCollection is made up of several channels. For example, channel NHits(0,10), NHits(10,20), NHits(20,45) build up a ChannelCollection. 

A ChannelCollection is a complete ensemble of channels. A ChannelCollection itself can generate all the information for PID.</p>


<p> <font color=#EE1110> StPidAmpManager</font>

The StPidAmpManager can hold multiple ChannelCollections. Thus if a user want compare results between two different ChannelCollections, all he needs to do is simply adding two ChannelCollections into StPidAmpManager.</p>
<p><font color=#EE1110> StPidAmpMaker </font>is a mediator between StEvent and StPidAmpManager. What ChannelCollection should be used to generate parameters is up to the user. </p>

<p>  <a href="StPidAmpMakerUML.html">Know more about the Infrastructure...</a></p>

<hr>

<h2><a name="Performance">Performance</h2>
<p> <font color=#EE1110>The current overall PID efficiency (correctly identified tracks / identified tracks) is 87.6% for global tracks, 88.9% for primary tracks (dca<2cm).</font> (I assume you run the option which consider both nhits and dca dependences. Number gotten is based on MDC3 data.</p>
<p>Following are some plots based on the result of StPidAmpMaker:</p>
<p>The Bethe-Bloch curve: (Bethe-Bloch fitting is a must-done in this package)</p>
<center><img src="bandCenter.gif"></center>

<p>Pid at different confidence level :</p>
<center><img src="5090pid.gif"></center>
<p>In the plots above, blue dots represent pion tracks, red -> kaons, green -> protons, magenta -> e+/-, black -> tracks whose probability of the most likehood type is less than 50%/90% (declared as non-identified). The light blue dots are pions in the overlapping area.The StuProbabilityPidAlgorithm can give out a warning flag if a track in the overlapping area is identified. The plots show that as our confidence requirement increase, more tracks becomes non-identified (black), which is as expected.</p>
<font size=5> <center> <a href="/star/starlib/doc/www/protected/spectra/aihong/PIDref/pidRef.html"> <i><strong><blink> click here to refer to plots for real data </blink></strong></i> </a> </center></font>

<hr>
<h2><a name="Tutorial">Tutorial</h2>
<p> <font size=5 color=#EE1110>How to do the PID?</font></p>
<p><a href="howtoEZPID.html">The EZ option (suggested for general user)</a></p>
<p><a href="howtoPID.html">The full option</a></p>


<hr>

<h2><a name="FAQ">FAQ</h2>

<li><a href="#howToCut">I wanna do a PID probability cut, how do I know my cut is tight or loose?</a>
<li><a href="#howToDrawInAnalysis">In the analysis code,How to read out the parameters from "Bands.root" file and draw the Bethe-Bloch curve?</a>
<li><a href="#howToDrawInMacro">In the macro,How to read out the parameters from "Bands.root" file and draw the Bethe-Bloch curve?</a>

<br>
<br>
<br>
<br><a name="howToCut"><img src="hand-right.gif"> <font size=4 color=#EE1110>I wanna do a PID probability cut, how do I know my cut is tight or loose?</font></p>

<br>The two plots below will answer the question.(plot are based on result from NHitsDca channel collection). You might also <a href="/star/starlib/doc/www/protected/spectra/aihong/PIDref/pidRef.html"> refer to plots for real dat </a>
<br>
<br>
<center><img src="globalRatioOfSurvival.gif"></a></center>
<br>
<center><img src="primaryRatioOfSurvival.gif"></a></center>


<p> <font size=5 color=#EE1110><a name="howToDrawInAnalysis"><img src="hand-right.gif"> How to read out the parameters from "Bands.root" file and draw the Bethe-Bloch curve?</font></p>
<br><font color=green>In your source code, the following lines of code will do the job. Later version will make it work at the command line.</font>
<br>
<br><font color=red>in your header file</font>

<br>#include "TF1.h"
<br>#include "TFile.h"
<br>#include "TCanvas.h"
<br>#include "StEventUtilities/BetheBlochFunction.hh" 
<br>#include "StEventUtilities/StPidAmpNetOut.h"     
<br><font color=red>in your implementation file</font>

<br> TFile f("nhitsBin_0_10_20_45_ptBin_0_Inf_dcaBin_0_2_50000_BGBands.root","READ","nhitsBin_0_10_20_45_ptBin_0_Inf_dcaBin_0_2_50000_BGBands.root"); <font color=green>//open a file produced by StPidAmpMaker.</font>

<br> StPidAmpNetOut*  electronNetOut=(StPidAmpNetOut *)f.Get("e-");<font color=green> //read in band parameters for electron band.</font>

<br> int NParameters=electronNetOut->GetNBandPars();

<br> TF1* electronBandCenter =new TF1("electronBandCenter",BetheBlochFunction, 0,5, NParameters);

<br> for ( int i=0; i<NParameters; i++)

<br>      electronBandCenter->SetParameter(i,(electronNetOut->GetBandParArray())->At(i)); <font color=green>//set parameters.</font>




<br>  c1=new TCanvas("e- de/dx~p/z curve","e- de/dx~p/z curve",20,10,700,500);
<br> c1->cd();

<br> electronBandCenter->Draw("L");<font color=green>//done.</font>

<br><font color=red> what if I want to draw a pure de/dx~beta*gamma curve?</font>
<br><font color=green>Just replace the line </font>
<br>StPidAmpNetOut*  electronNetOut=(StPidAmpNetOut *)f.Get("e-");
<br><font color=green>by</font>
<br>StPidAmpNetOut*  electronNetOut=(StPidAmpNetOut *)f.Get("betaGamma");
<br><font color=green>in the example above.</font>
<br>

<br>
<br><a name="howToDrawInMacro"><img src="hand-right.gif"> <font size=4 color=#EE1110>In the macro,How to read out the parameters from "Bands.root" file and draw the Bethe-Bloch curve?</font></p>
<br>Please refer to the example $STAR/StRoot/StPidAmpMaker/drawBetheBloch.C
<br><BR><BR>
<hr>
  <address><a href="mailto:aihong@cnr.physics.kent.gov">Aihong Tang</a></address>
<!-- Created: Mon Feb 14 12:52:08 EST 2000 -->
<!-- hhmts start -->
Last modified: Mon Aug 21 15:54:06 EDT 2000
<!-- hhmts end -->
  </body>
</html>
