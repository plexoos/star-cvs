%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% StEvent - User Guide and Reference Manual -- LaTeX Source 
%
% $Id: StEvent.tex,v 1.6 1999/03/16 00:49:23 ullrich Exp $
%
% Author: Thomas Ullrich, March 1999
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Notes to the authors:
% 
% - A template for a class reference is at the end of this file.
% - Wrap all names functions with \name{}
% - All code, examples, prototypes in \verb+ ... +\\
%   or /begin{verbatim} ... \end{verbatim}
% - Use \StEvent if you refer to the package itself (not the class)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% $Log: StEvent.tex,v $
% Revision 1.6  1999/03/16 00:49:23  ullrich
% Check in current status
%
% Revision 1.16  1999/03/31 19:03:50  ullrich
% Corrected typos in UML appendix
%
% Revision 1.15  1999/03/30 19:41:17  ullrich
% Added Torres 'how to' tutorial. Text pasted from web.
%
% Revision 1.14  1999/03/30 19:11:53  genevb
% Correct typo from last change
%
% Revision 1.13  1999/03/30 18:54:15  genevb
% Add Xi documentation
%
% Revision 1.12  1999/03/26 08:10:29  ullrich
% Corrected typos, text smoothed.
%
% Revision 1.11  1999/03/25 22:10:54  ullrich
% Added brief introduction to UML (appendix A).
%
% Revision 1.10  1999/03/25 14:05:41  ullrich
% Improved some explanation. More index entries.
%
% Revision 1.9  1999/03/24 19:03:43  ullrich
% Fixed bug in UML figure numbers.
%
% Revision 1.8  1999/03/23 23:10:05  ullrich
% Added latest changes to StEvent.
%
% Revision 1.7  1999/03/19 17:22:44  ullrich
% Save current version.
%
% Revision 1.6  1999/03/16 00:49:23  ullrich
% Check in current status
%
% Revision 1.5  1999/03/12 21:55:13  ullrich
% Save current status.
%
% Revision 1.4  1999/03/11 21:10:28  ullrich
% Update
%
% Revision 1.3  1999/03/11 16:11:19  ullrich
% Snapshot of work in progress.
%
% Revision 1.2  1999/03/09 21:49:25  ullrich
% Added class reference for EMC hits. New examples.
%
% Revision 1.1  1999/03/09 17:28:28  ullrich
% Initial Revision
%
% Revision 2.33  2000/05/22 22:04:07  ullrich
% Removed StRichPixelCollection ref section and added description
% of new RICH methods to class StEvent.
%
% Revision 2.45  2000/08/23 03:14:07  ullrich
% Improved (corrected) explanation of return value
% of chi2 methods of StVertex and StTrackFitTraits.
%
% Revision 2.44  2000/08/17 00:36:31  ullrich
% Added description of StTptTrack.
%
\newcommand{\StEvent}{\textsl{$\cal{S}$t$\cal{E}$vent}}
% Fixed wrong description of StZtbTriggerDetector::adc().
%
% Revision 2.42  2000/07/13 12:47:07  ullrich
% Added ZDC info provided by Clemens
%
% Revision 2.41  2000/06/29 18:00:37  ullrich
% Better description of StCtbTriggerDetector.
%
% Revision 2.40  2000/06/22 18:18:33  ullrich
% Fixed problem with page numbering. Increased textheight.
%
% Revision 2.39  2000/06/21 22:55:42  ullrich
% Added StEventInfo to ref section. Updated StEvent.
%
% Revision 2.38  2000/06/07 09:44:20  ullrich
% Modified StHit ref section.
%
% Revision 2.37  2000/06/01 21:36:17  ullrich
% Added new method flag() to StHit description.
%
% Revision 2.36  2000/06/01 16:46:23  ullrich
% Mods (add text) in StTrack and StTrackDetectorInfo.
%
% Revision 2.35  2000/05/31 14:26:26  lasiuk
% Add RICH classes and descriptions
%
% Revision 2.32  2000/05/17 17:20:01  ullrich
% Updates and improved description of StTrackTopologyMap.
% Revision 2.31  2000/05/16 13:22:39  ullrich
% More details on the second chi2 value in StTrackFitTraits.
%
% Revision 2.30  2000/05/09 11:09:30  ullrich
% Updated section on StMwcTriggerDetector and StCtbTriggerDetector.
%
% Revision 2.29  2000/04/26 21:01:44  ullrich
% Removed text for obsolete StBrowsableEvent.
%
% Revision 2.28  2000/04/20 13:31:25  ullrich
% Added description of changes to StTrackDetectorInfo.
%
% Revision 2.27  2000/04/10 19:59:34  genevb
  {\LARGE $ $Revision: 1.6 $ $}  \\[5mm] % replaced by cvs with current revision  
  {\LARGE $ $Date: 1999/03/16 00:49:23 $ $}  % replaced by cvs with current revision  
% Revision 2.26  2000/03/30 16:55:38  ullrich
% Modified reference section for StTrack::key().
%
% Revision 2.25  2000/03/29 16:55:48  ullrich
% Added reference section and emprt user guide page for StL3Trigger.
%
% Revision 2.24  2000/03/23 18:30:50  ullrich
% Added new EMC classes to reference section.
%
% Revision 2.23  2000/03/08 14:27:45  ullrich
% Added description of new method of StVertex.
%
% Revision 2.22  2000/03/02 12:40:40  ullrich
  {\LARGE $ $Revision: 1.6 $ $}  \\[5mm] % replaced by cvs with current revision
  {\LARGE $ $Date: 1999/03/16 00:49:23 $ $}  % replaced by cvs with current revision
% Revision 2.21  2000/02/28 19:37:26  ullrich
% Added the hypperref package to add bookmarks and hyperlinks
% tp pdf documents.
%
% Revision 2.20  2000/02/24 13:25:12  ullrich
% Added RICH and EMC to the reference section. Created
% (empty) section for EMC and RICH in User Guide.
  {\LARGE $ $Revision: 1.6 $ $}  \\[5mm] % replaced by cvs with current revision
  {\LARGE $ $Date: 1999/03/16 00:49:23 $ $}  % replaced by cvs with current revision
%
\section{Introduction} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
... missing
Global tracks are the essential backbone of the data model. They
    \caption{Data model for the vertices and related classes in \StEvent .}
contain references to their hits in the various detectors and keep
track of their start and stop vertices.  (see
fig.~\ref{fig:umlForVertices}).
This document is intended to serve the advanced users as well
as beginners. It is therefore divided in two parts, a user
guide and a reference manual. In the first part we rather concentrate
on basic questions and provide guidance to get started.
The reference section provides information on all available classes,
their member functions and related operators. Each class reference contains
one or more examples which demonstrates some features of the class
and how to use it.

New users should \textbf{not} start with the Reference section. It is meant
as a lookup when specific information is needed. Beginners should
study the User Guide and should make themself familiar only with those
classes which they will encounter most:
\name{StEvent} (sec.~\ref{sec:StEvent}),
\name{StGlobalTrack} (sec.~\ref{sec:StGlobatTrack}),
\name{StVertex} (sec.~\ref{sec:StVertex}),
and \name{StTpcHit} (sec.~\ref{sec:StVertex}).
Reading and understanding the various examples certainly is the
best way to get started. Note, however,
that the examples shown throughout this guide are often not complete
and are not guaranteed to compile. Their only purpose is to illustrate
a specific feature and not to provide a fully functional programming unit.

...


The name ``StEvent'' is somewhat misleading since it is \textit{(i)}
the name of the package and \textit{(ii)} the name of a class.
We therefore write \StEvent\ when we refer to the package
and \name{StEvent} for the class.

In this document the terms \textit{method} and \textit{member function}
are used synonymously.

\end{figure}

%
% Define multiline labels for class reference
%
with those classes which they will encounter most: \name{StEvent}
\section{How to read this document}

This document is intended to serve the advanced users as well as
beginners. It is therefore divided in two parts, a user guide and a
reference manual. In the first part we rather concentrate on basic
questions and provide guidance to get started.  The reference section
provides information on all available classes, their member functions
and related operators. Each class reference contains one or more
examples which demonstrates some features of the class and how to use
it.

New users should \textbf{not} start with the Reference section. It is
meant as a lookup when specific information is needed. Beginners
should study the User Guide and should make themself familiar only
with those classes they will encounter more frequently: \name{StEvent}
(sec.~\ref{sec:StEvent}), \name{StGlobalTrack}
(sec.~\ref{sec:StGlobalTrack}), \name{StVertex}
\section{Getting \StEvent Sources}  \index{Getting StEvent sources}
(sec.~\ref{sec:StVertex}).  Reading and understanding the various
examples certainly is the best way to get started. Note, however, that
the examples shown throughout this guide are often not complete and
are not guaranteed to compile. Their only purpose is to illustrate a
specific feature and not to provide a fully functional programming
unit.

  {\LARGE $ $Date: 1999/03/16 00:49:23 $ $}  % replaced by cvs with current revision
     \advance\leftmargin by \labelsep%
\section{Further documentation}
\label{sec:furtherdoc}

\StEvent\ makes use of various classes from the StarClassLibrary (SCL).
To obtain the SCL documentation perform the following steps:
\begin{enumerate}
  \item Obtain an \name{afs} token: \name{klog -cell rhic}.
  \item Make sure \name{\$CVSROOT} is set properly:\\
    (i.e.~\name{CVSROOT = /afs/rhic/star/packages/repository})
  \item Check-out the SCL into your current working directory:\\
\StEvent\ follows the STAR coding guidelines as described on the STAR web page: \\ 
  \item Create the PostScript document \name{StarClassLibrary.ps}:\\
All developers are encouraged to follow this small set of rules 
in order to create a homogeneous and coherent interface style.
Here we summarize the most relevant one concerning the programmable interface:
\section{Coding Standards}  \index{Coding Standards}
\item all classes, enumerations and functions start with the prefix \textbf{St}
\section{Getting \StEvent\ Sources}  \index{Getting StEvent sources}
\item header files have the extension \textbf{.hh},
    source files have the extension\textbf{ .cc}
and is therefore present in the actual STAR software releases. To access
\item classes, methods, and variables have self-explanatory English names
    and first letter capitalization to delineate words
\StEvent\ is under {\bf CVS} control at BNL.  It can
be accessed via \name{afs}: \index{afs} \index{CVS} \index{CVSROOT}
\begin{enumerate}
  \item Obtain an \name{afs} token: \name{klog -cell rhic}.
\item methods (member functions) which return a certain object have the same name as the referring object, i.e.,
    without a preceding \name{get} prefix (as in \name{StEvent::primaryVertex()})
\item methods which assign a value to a data member (or members) 
    carry the prefix \name{set} (as in  \name{StEvent::setPrimaryVertex()}).
\item integer variables which serve as counter or indices and never can take negative
    values are consistently of declared as \name{unsigned}. 
\section{Coding Standards}
\index{Coding Standards}
    \item const member functions are guaranteed to not alter data member
    \item const arguments are guaranteed to not be modified by the function
    \item const return values cannot be modified    
order to create a homogeneous and coherent interface style.  Here we
    \name{const}'ness implies a slightly higher compile time overhead but a faster execution
    time.
\item Objects which are returned by pointer are not guaranteed to exist in which case
    a null pointer is returned. It is users responsibility to check for the return value
    and make sure the pointer is valid (non-zero) before she dereference it.
    Objects which are granted to exist are returned by reference or by value.
\item the use of underscores in names is discouraged
\item classes, methods, and variables have self-explanatory English
    names and first letter capitalization to delineate words
\end{itemize}

In addition \StEvent\ defines a few rules which ease its usage
\begin{itemize}
\item methods (member functions) which return a certain object have
    the same name as the referring object, i.e., without a preceding
    \name{get} prefix \\ (as in \name{StEvent::primary\-Vertex()})
\item methods which assign a value to a data member (or members) carry
    the prefix \name{set} followed by the name of the member (as in \name{StEvent::set\-Primary\-Vertex()}).
\item integer variables which serve as counter or indices and never
    can take negative values are consistently of declared as
    \name{unsigned}.
\item the \name{const} identifier is used wherever possible. Remember:
    \begin{itemize}
    \item const member functions are guaranteed to not alter data
        member
    \item const arguments are guaranteed to not be modified by the
All quantities in \StEvent\ are stored using the official STAR
units: cm, GeV and Tesla.
In order to maintain a coherent system of units 
it is recommended to use the definitions in \name{SystemOfUnits.h}
from the StarClassLibrary. They allow to 'assign' a unit to a given variable
by multiplying it with a constant named accordingly (centimeter, millimeter,
kilometer, tesla, MeV, ...).
The value of the constants is thus that the result after the multiplication
follows always the STAR system of units.
\section{An extended example: doEvents.C}
\index{doEvents.C}
%    Introduction
... missing
%
    mkdir StRoot/StMyAnalysisMaker
    cp $STAR/StRoot/StAnalysisMaker/* StRoot/StMyAnalysisMaker/
    [edit]
    makel -C StRoot/StMyAnalysisMaker
    cp $STAR/StRoot/macros/doEvents.C ./  (and edit to use your maker)
    root4star doEvents.C
\end{verbatim}
Using some XDF files you will see messages about changed table
structures. The DST tables themselves are not affected.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                             kOtherVtxId};
\section{Units}
\index{units} \index{system of units}
enum StDedxMethod           {kUndefinedMethodId,

All quantities in \StEvent\ are stored using the official STAR units:
cm, GeV and Tesla.  In order to maintain a coherent system of units it
is recommended to use the definitions in \name{SystemOfUnits.h} from
the StarClassLibrary. They allow to 'assign' a unit to a given
variable by multiplying it with a constant named accordingly
(centimeter, millimeter, kilometer, tesla, MeV, ...).  The value of
the constants is thus that the result after the multiplication follows
always the STAR system of units.
}%footnotesize    
                             tpcOther,
{\footnotesize
                             ftpcConformal,
                             svtTpcSvm,
                             svtTpcEst,
                             svtTpcPattern};

enum StRichPidFlag          {eNoMip,
                             eFastEnough,
                             eLightOnPadPlane};
\end{verbatim}

Note that often the enumeration type names (e.g. \texttt{StTrackType})
are used as argument types. The strong C++ type checking rules ensures
the proper use of the enumeration constants already during
compilation.

Another important set of constants should be mentioned here as well,
namely the physical constants defined in \texttt{PhysicalConstants.h}.
There are too many to be listed here but you should make yourself
familiar with what constants are available. You will find the header
file in the \name{StarClassLibrary} (see Sec.~\ref{sec:furtherDoc}).
\index{StarClassLibrary} In order to define the units of the various
physical constants another set of constants defined in
\texttt{SystemOfUnits.h} is used (also from \name{StarClassLibrary}).
\StEvent\ is  continuously improved. In certain cases it might happen that the
documentation isn't up-to-date. In these cases the header file should
be visited.

Although \StEvent\ is updated frequently it might happen that it
lacks means of accessing some specific DST information
since the content of the DST changes considerably in time. We expect
a more stable situation as soon as experimental data comes in and
the DST format gets better defined.
\index{DST files} 
\label{sec:conventionsNumbering}

All numbering follows \emph{strictly} the C/C++ convention, i.e. the
first element in an array has the index 0. This is valid for all
container, collections and lists. Here it is important to remember
that many (but not all) official STAR numbering schemes start counting
at 1.  Examples are TPC sectors and padrows, SVT barrels, layers, ladders and
wafers. Do not forget to subtract 1 when using this scheme for
addressing elements in a container.

TPC, SVT and FTPC hits return their hardware address in STAR units.
In order to select the hit container in which a hit \texttt{h} is
stored you must write:
}%footnotesize
Further documentation can be found in the StarClassLibrary manual
(see sec.~\ref{sec:furtherdoc}).
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Known Problems} \index{known problems (\StEvent)}

\StEvent\ is continuously improved. In certain cases it might happen
that the documentation isn't up-to-date. In these cases the header
file should be visited.

Although \StEvent\ is updated frequently it might happen that it lacks
means of accessing some specific DST information since the content of
        
situation as soon as experimental data comes in and the DST format
gets better defined.  \index{DST files}
  \verb+#include "StEnumerations.hh"+ \\  
  
  
%
%    Reference Manual
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Reference Manual}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Global Constants, Enumerations and Definitions}

In addition to the constants defined in the two header files
    
\name{PhysicalConstants.h} which are part of the StarClassLibrary
    
\name{StEnumerations.hh}. The types defined therein are used
throughout \StEvent .

\subsection{Enumeration Types}
\index{enumerations}
\label{sec:StEnumerations}
    \begin{center}
\item[Summary]
  Global Enumeration types.
\end{figure}

\item[Synopsis]
    

typedef short          Short_t;     //Signed Short integer 2 bytes
\item[Description]
    \index{StBeamDirection|textbf}
    \index{StBeamPolarizationAxis|textbf}
    \index{StVertexType|textbf}
    \index{StTrackSign|textbf}
    The header file does not only define the enumerations and their values
    but also the \textit{type} of the enumeration set. This allows the
    different enumerations to be used as argument types where the strong C++ type
    checking rules ensures the proper use of the enumeration constants already
    during compilation.

\section{Collections and Iterators} \index{collection|textbf} \index{iterator}
    \verb+enum StVertexType {undefined, primary, kink,+\\
    \verb+                   twoBody, threeBody, nBody,+\\
    \verb+                   pileUpPrimary, V0, Xi};+\\

    \verb+enum StTrackSign {negativeTrack, positiveTrack};+\\

    Please remember that C++ starts the enumeration with 0 (zero) unless
    explicitly given otherwise. The definition of enumeration types allows
    to define the following function:\\
    \verb+myfunc(StBeamDirection d);+\\
    Any argument value other than \name{east} or \name{west} causes a compile
    time error. (Note, that even the integer values 0 and 1 would fail to compile.)

\end{Entry}

for (int i=0; i<theHits.size(); i++) {

\section{Collections and Iterators}
\label{sec:collections}
\label{sec:collections}
\index{collection|textbf}
\index{iterator}
\index{StEmcPreShowerHitCollection|textbf}
\index{StEmcTowerHitCollection|textbf}
\index{StFtpcHitCollection|textbf}
\index{StSmdEtaHitCollection|textbf}
\index{StSmdPhiHitCollection|textbf}
\index{StSvtHitCollection|textbf}
\index{StTpcHitCollection|textbf}
\index{StTrackCollection|textbf}
\index{StVecCtbCounter|textbf}
\index{StVecMwcSector|textbf}
\index{StVecPtrFtpcHit|textbf}
\index{StVecPtrGlobalTrack|textbf}
might change in future. The interface, however, will not change since
new implementations will also follow the standard syntax.
\index{StVertexCollection|textbf}
\index{StVecTH1F|textbf}
\index{StVecTH2F|textbf}

\StEvent\ defines various collection classes and their referring
iterators.  They differ in type -- collecting objects by pointer or by
value -- and by the underlying collection classes (sequence container, linked list, maps).
The latter, however, is always encapsulated in the implementation. All
type used users are encouraged to use \textit{iterators} instead of
standard, i.e.~the Standard Template Library (STL) \index{STL}. Most
containers are actually implemented as STL containers although this
might change in future. In case the container will get replaced with more
specialized versions we will
make sure the replacement provides methods which are compatible with those
of the standard to maintain the integrity of existing code.

All container are guaranteed to provide at least the following member functions:
\name{size()}, \name{begin()}, \name{end()}.  Most collection in
\StEvent\ have a referring iterator defined (see table \ref{tab:stcoll})
which is declared in the same header file as the
corresponding collection.
    
In order to keep your code independent of the underlying container
types users are encouraged to use \textit{iterators} instead of
indices. The higher degree of flexibility allows to change containers
without changing the application code using them. The following
examples demonstrates this:

Given an arbitrary \StEvent\ collection \name{anyColl} of type \name{StAnyColl}
which holds objects of type
\name{obj} the following code is not guaranteed to work:
\begin{verbatim}
     for (int i=0; i<anyColl.size(); i++)
         obj = anyColl[i];
\end{verbatim}
It should be replaced by:
\begin{verbatim}
     StAnyCollIterator iter;
     for (iter = anyColl.begin(); iter != anyColl.end(); iter++)
         obj = *iter;
\end{verbatim}

    \name{StVec} or \name{StVecPtr} in case the objects are collected
    via pointers followed by the name of the object they collect. All
\item Collections of general importance which are accessible through
    the \name{StEvent} class itself, i.e., \name{StEvent} provides member functions
    which return pointer or references to them.  There names are
    composed of the name of the objects they hold and the word
    \end{tabular}            
    table \ref{tab:stcoll}.  The hold the essential objects as hits,
    tracks and vertices.

\item Simple collection classes which are returned or used in various classes
    further down the tree.  Their naming scheme is different from
    the main collection classes. Without exception the
    underlying container is a sequence container, i.e., the
    \name{operator[]} can be used safely. Their names are all prefixed
    \name{StVec} or \name{StVecPtr} (in case the objects are collected
    via pointers) followed by the name of the object they collect. All
    available types are listed in table \ref{tab:stvec}
\end{enumerate}

\begin{table}[htb]
    \begin{center}
    \footnotesize\
    \begin{tabular}{|l|l|l|l|}
        \hline
        \textbf{Collection Class} & \textbf{Elements} & \textbf{Iterator} & \textbf{Header File} \\ \hline
\name{StEmcPreShowerHitCollection} & \name{StEmcPreShowerHit} & \name{StEmcPreShowerHitIterator} & \name{StEmcPreShowerHitCollection.hh}  \\ \hline
\name{StEmcTowerHitCollection}     & \name{StEmcTowerHit}     & \name{StEmcTowerHitIterator}     & \name{StEmcTowerHitCollection.hh}  \\ \hline
    \end{tabular}            
\name{StSmdPhiHitCollection}       & \name{StSmdPhiHit}       & \name{StSmdPhiHitIterator}       & \name{StSmdPhiHitCollection.hh}  \\ \hline
\name{StFtpcHitCollection}         & \name{StFtpcHit$*$}      & \name{StFtpcHitIterator}         & \name{StFtpcHitCollection.hh}  \\ \hline
\name{StSvtHitCollection}          & \name{StSvtHit$*$}       & \name{StSvtHitIterator}          & \name{StSvtHitCollection.hh}  \\ \hline
\name{StTpcHitCollection}          & \name{StTpcHit$*$}       & \name{StTpcHitIterator}          & \name{StTpcHitCollection.hh}  \\ \hline
\name{StTrackCollection}           & \name{StGlobalTrack$*$}  & \name{StTrackIterator}           & \name{StTrackCollection.hh}  \\
{}                                 & {}                       & \name{StTrackConstIterator}      & {}                     \\ \hline
\name{StVertexCollection}          & \name{StVertex$*$}       & \name{StVertexIterator}          & \name{StVertexCollection.hh}  \\ \hline
    \end{tabular}
    \caption{Main collection classes.}
    \label{tab:stcoll}
    \end{center}
\end{table}

\begin{table}[htb]
    \begin{center}
         hit = iter;                             // no dereference necessary
        \hline
        \textbf{Collection Class} & \textbf{Elements} & \textbf{Iterator} & \textbf{Header File} \\ \hline
\name{StVecCtbCounter}     & \name{StCtbCounter}   & \name{StVecCtbCounterIterator}     & \name{StVecCtbCounter.hh}  \\ \hline
Note, that some collections contain objects by value other by pointer. Container which collect objects
by pointer or reference are also often called \textit{polymorphic} container since they are not restricted
to collect objects of the base type only but of any object derived from it. This is especially
important when dereferencing the iterator to access the objects in the collection.
For a \textit{by-value} collection:
\name{StVecTH1F}     & \name{TH1F}   & \name{--}     & \name{StTHDefs.hh}  \\ \hline
\name{StVecTH2F}     & \name{TH2F}   & \name{--}     & \name{StTHDefs.hh}  \\ \hline
    \end{tabular}
    \caption{Utility collections classes based on sequence containers.}
    \label{tab:stvec}
    \end{center}
\end{table}

Note, that some collections contain objects by value other by pointer.
Container which collect objects by pointer or reference are also often
called \textit{polymorphic} container since they are not restricted to
collect objects of the base type only but of any type derived from
it. This is especially important when dereferencing the iterator to
access the objects in the collection.  For a \textit{by-value}
collection:
\begin{verbatim}
     StEmcPreShowerHitIterator iter;
Hint: Use pointers or references to collection elements wherever possible.
Making local copies is often time- and memory-intensive. For example the same
code above but written as:
     for (iter = hits->begin(); iter != hits->end(); iter++)
         hit = iter;             // no dereference necessary
\end{verbatim}
But for a \textit{by-pointer} collection:
\begin{verbatim}
     StVertexIterator iter;
     StVertexCollection* vertices = event->vertexCollection();
     StVertex *vertex;
     for (iter = vertices->begin(); iter != vertices->end(); iter++)
but want to leave the original as it is.
since they are for internal use only (even if public). 

Hint: Use pointers or references to collection elements wherever
possible.  Making local copies is often time- and memory-intensive.
For example the same code above but written as:
\begin{verbatim}
     StVertexIterator iter;
     StVertexCollection* vertices = event->vertexCollection();
Note that often some member functions or constructors are omitted
since they are for internal use only (even if public).
Destructors are not described.\\
invokes the \name{StVertex} assignment operator and creates a local copy.
This method is only useful if you intend to modify am object locally
but want to leave the original untouched.
take tables as arguments. They are for nternal use only (even if public).

Destructors, assignment operators and copy constructors are not listed.
    content of a single Central Trigger Barrel (CTB) counter.  
    
STAR CVS repository are described in alphabetic order.
\texttt{StMeasuredPoint} can be used wherever positions and errors
\index{StCtbCounter|textbf} \index{CTB}
  
\end{verbatim}
Note that some constructors are omitted, especially the ones which
    stored in the \name{dst\_TriggerDetectors.idl} table. Each counter
public).

    
listed.  \name{Inline} declarations are omitted throughout the
documentation.

    \verb+#include "StTpcHitCollection.h"+\\
    \verb+class StTpcHitCollection;+\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StCtbCounter
   
    corrected time.\index{dst\_TriggerDetectors.idl}
    The list of \name{StCtbCounter} objects (collection class \name{StVecCtbCounter}) can be obtained
    through the \name{StTriggerDetectorCollection::ctbCounters()} method.
    
    The list of \name{StCtbCounter} objects (collection class \name{StVecCtbCounter}) can be obtained
    through the \name{StTriggerDetectorCollection}.
    \index{StVecCtbCounter}
    \index{StTriggerDetectorCollection}
    content of a single Central Trigger Barrel (CTB) counter.

\item[Synopsis]
    
    \verb+class StCtbCounter;+\\
    
    
    \name{StCtbCounter} represents the CTB counter information as
    stored in the \\ \name{dst\_TriggerDetectors.idl} table. Each
    
    and the counter corrected time.\index{dst\_TriggerDetectors.idl}
    The list of \name{StCtbCounter} objects (collection class
    
    \name{StTriggerDetectorCollection::ctbCounters()} method.
    \index{StVecCtbCounter} \index{StTriggerDetectorCollection}
    
\item[Persistence]
    None
    
\item[Related Classes]
    None

\item[Public\\ Constructors]
    \verb+StCtbCounter();+ \\
    Constructs an empty CTB counter. All values are initialized to 0 (zero).

    \verb+StCtbCounter(short id, float m, float t);+ \\
    Constructs a CTB counter with id \name{id}, number of mips \name{m}
    and counter corrected time \name{t}.
    StTriggerDetectorCollection* tds = event->triggerDetectorCollection();
    \verb+short id() const;+ \\
    Returns the id of the counter.

    \verb+float mips() const;+ \\
    Returns the counter signal in number of mips.

    \verb+float time() const;+ \\
}%footnotesize    

    \verb+void setId(short);+ \\
    Sets the counter id.

    \verb+void setMips(float);+ \\
    Sets the number of mips.

    \verb+void setTime(float);+ \\
    Sets the time.

\item[Examples]
{\footnotesize
\begin{verbatim}
    energy loss (dE/dx) of a particle (track) in a specific detector.   
    
\item[Synopsis] 
//
\index{dE/dx} \index{StDedx|textbf}
    
    StTriggerDetectorCollection* tds =
                event->triggerDetectorCollection();
    StVecCtbCounter &counters = tds->ctbCounters();
    for (int i=0; i<counters.size(); i++)
        sum += counters[i].mips();
    assert(i == 240);               // must be 240 counters
    return sum;
    
\end{verbatim}
}%footnotesize
\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StDedx
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
\index{dE/dx}
\index{StDedx|textbf}
\label{sec:StDedx}
    
\item[Summary]
    \name{StDedx} is a class which provides information on the
    energy loss (dE/dx) of a particle (track) in a specific detector.
    
\item[Synopsis]
    \verb+#include "StDedx.hh"+\\
    

\item[Description]
    
    in the \name{dst\_dedx.idl} table. It contains dE/dx mean and
    variance, number of used hits and a status word. The status word
    holds information on the quality and status of the extracted dE/dx.
    The class is used for charged tracks in the TPC, FTPC and SVT.
    \index{dst\_dedx.idl}
    
\item[Persistence]
    None
    
\item[Related Classes]
    Every global track (StGlobalTrack) holds the information
    
    Currently \name{StGlobalTrack} provides dE/dx information
    for the TPC, FTPC and the SVT.
    

\item[Public\\ Constructors]
    \verb+StDedx();+ \\
    Constructs an empty instance, i.e.~all values are initialized to 0 (zero).

\item[Public Member\\ Functions]
    \verb+unsigned short numberOfPointsUsed() const;+ \\
    Returns the number of points (hits) used to derive the dE/dx value.

    \verb+float mean() const;+ \\
    Mean (most probable) dE/dx value.

 
    Returns the variance.

    \verb+unsigned long  status() const;+ \\
    Status word.

    \verb+void setNumberOfPointsUsed(unsigned short);+ \\
    Sets the number of points used in the calculation.

    \verb+void setMean(float);+ \\
    Sets the mean dE/sx value.

     cout << "<dE/dx> = " << dedx->mean() << endl;
     cout << "var(dE/dx) = " << dedx->variance() << endl;
     cout << "# of points used = " << dedx->numberOfPointsUsed() << endl;
}%footnotesize    
    Sets the status word.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  Function prints all dE/dx information of a given
//  track to stdout.
//
void printDedx(StGlobalTrack &track)
{
    StDedx *ftpc = track.ftpcDedx();
    StDedx *tpc  = track.tpcDedx();
    information on the current event as stored on the DST. 
    
\item[Synopsis] 
    if (tpc) printOneDedx(tpc, "TPC");
\index{event summary} \index{StDstEventSummary|textbf}
    
void printOneDedx(StDedx *dedx, const char* name)
{
     cout << "\nDeDx info on " << name << ':' << endl;
     cout << "<dE/dx> =     " << dedx->mean() << endl;
     cout << "var(dE/dx) =  " << dedx->variance() << endl;
     cout << "points used = " << dedx->numberOfPointsUsed() << endl;
     cout << "status word = " << dedx->status() << endl;
}
    
\begin{Entry}
\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StDstEventSummary
%
   
\subsection{StDstEventSummary}
\index{event summary}
\index{StDstEventSummary|textbf}
    
\begin{Entry}
\item[Summary]
    \name{StDstEventSummary} is a class which summarizes basic
    

\item[Synopsis]
    \verb+#include "StDstEventSummary.hh"+\\
    \verb+class StDstEventSummary;+\\

\item[Description]
    \name{StDstEventSummary} is meant to hold the information
    stored in the\\ \name{dst\_event\_summary.idl} table. However,
    the content strongly deviates from the former design draft.
    It currently holds only lists of 1- and 2-dimensional histograms
    which summarize certain event quantities. The class does neither
    defined the number of histograms nor its content.
    \index{dst\_event\_summary.idl}

\item[Persistence]
    
\item[Synopsis] 
\item[Related Classes]
    The pointer to the event summary information can be obtained directly
    
\item[Public\\ Constructors]
    \verb+StDstEventSummary();+ \\
    Default constructor.

\item[Public Member\\ Functions]
    \verb+StVecTH1F& histograms1D();+ \\
    Returns vector of 1-dimensional (Root) histograms of type THF1.

    \verb+StVecTH2F& histograms2D();+ \\
    Returns vector of 2-dimensional (Root) histograms of type THF2.
\end{Entry}
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StEmcHit
%
    The following classes are derived from \name{StEmcHit}: 
\subsection{StEmcHit}
\index{StEmcHit|textbf}
\index{EMC hit}
\index{SMD hit}
\label{sec:StEmcHit}
\begin{Entry}
\item[Summary]
    \name{StEmcHit} is the base class for all classes which represent EMC, EEMC and SMD hits.

\item[Synopsis]
    \verb+#include "StEmcHit.hh"+\\
    \verb+class StEmcHit;+\\

\item[Description]
    \name{StEmcHit} provides the basic functionality for all
    derived classes which represent EMC hits (incl. SMD and EEMC). It
    
    corresponding detector element (tower, preshower, shower maximum).
    The hit position is given in eta, phi coordinates measured at the
    center of the detector element.\\
    
    EMC cluster. Here the terminology is somewhat different to the
    TPC. Tracks are related to TPC hits and EMC clusters.  EMC hits
    

\item[Persistence]
    

\item[Related Classes]
    
    StEmcPreShowerHit, StEmcTowerHit, StSmdEtaHit, StSmdPhiHit.
    Current collection classes
    
    \index{StGlobalTrack}
    \index{StEmcPreShowerHit}
    
    \index{StSmdEtaHit}
    \index{StSmdPhiHit}
    
\item[Public\\ Constructors]
    \verb+StEmcHit();+ \\
    

    \verb+StEmcHit(int i, float E, float phi, float eta);+ \\
    Create an instance of \name{StEmcHit} with identifier \name{i},
   

\item[Public Member\\ Functions]
    \verb+float energy() const;+ \\
    Deposited energy.

    \verb+int   id() const;+ \\
    Id of the corresponding detector element.

    \verb+float phi() const;+ \\
    $\phi$ coordinate at the center of the detector element.

    \verb+float eta() const;+ \\
}%footnotesize    

    \verb+void setEnergy(float);+ \\
    Set energy.

    \verb+void setPhi(float);+ \\
    Set $\phi$ coordinate.

    \verb+void setEta(float);+ \\
    Set $\eta$ coordinate.

    \verb+void setId(int);+ \\
    Set detector element identifier.

\item[Global Operators]
    \verb+ostream& operator<< (ostream& os, const StEmcHit& h);+ \\
    Prints the hit quantities of \name{h} to ostream \name{os}.

\item[Examples]
{\footnotesize
\begin{verbatim}
    
\item[Synopsis] 
//
void test()
    
   StEmcHit hit(10, 10*GeV, 120*degree, 0.1);
   cout << "EMC hit = " << hit << endl;
}
\end{verbatim}
    
{\bf Programs Output:}
{\footnotesize
\begin{verbatim}
EMC hit = (0.1, 2.094; 10)
\end{verbatim}
}%footnotesize

\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StEmcPreShowerHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
\index{EMC pre-shower hit}  \index{StEmcPreShowerHit|textbf}
\label{sec:StEmcPreShowerHit}
\begin{Entry}
\item[Summary]
    \name{StEmcPreShowerHit} represents a hit in the EMC pre-shower detector.

\item[Synopsis]
    \verb+#include "StEmcPreShowerHit.hh"+\\
    \verb+class StEmcPreShowerHit;+\\

\item[Description]
    \name{StEmcPreShowerHit} inherits all functionality from \name{StEmcHit}.
   StEmcPreShowerHitCollection* hits = event->emcPreShowerHitCollection();

\item[Persistence]
    None

\item[Related Classes]
    \name{StEmcPreShowerHit} is derived directly from \name{StEmcHit}.
    The hits are kept in an instance of \name{StEmcPreShowerHitCollection}
    where they are stored by value (see \ref{sec:collections}).
}%footnotesize    
    \index{StEmcPreShowerHitCollection}

\item[Public\\ Constructors]
    \verb+StEmcPreShowerHit(int i, float E, float phi, float eta);+ \\
    Create an instance of \name{StEmcPreShowerHit} with identifier \name{i},
    energy deposition \name{E} and position \name{phi}, \name{eta}.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  Calculate the total-energy ratio of pre shower detectors
//  between the two hemispheres (eta < 0 and eta > 0).
//
    
\item[Synopsis] 
   StEmcPreShowerHitCollection* hits =
                       event->emcPreShowerHitCollection();
    
   double sumLeft = 0;
   double sumRight = 0;
   for (iter = hits->begin(); iter != hits->end(); iter++)
       if (iter->eta() < 0)
    
       else
           sumRight += iter->energy();
   return sumRight > 0 ? sumLeft/sumRight : 0;
}
\end{verbatim}
}%footnotesize

\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StEmcTowerHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
\item[Examples] \index{accumulate (example)} 
\label{sec:StEmcTowerHit}
\begin{Entry}
\item[Summary]
    \name{StEmcTowerHit} represents a hit in the EMC tower.

\item[Synopsis]
    \verb+#include "StEmcTowerHit.hh"+\\
    \verb+class StEmcTowerHit;+\\

\item[Description]
    \name{StEmcTowerHit} inherits all functionality from \name{StEmcHit}.
    For a complete description of the inherited member functions
    see \name{StEmcHit} (sec.~\ref{sec:StEmcHit}).

\item[Persistence]
    None

\item[Related Classes]
    StEmcTowerHit is derived directly from \name{StEmcHit}.
    The hits are kept in an instance of \name{StEmcTowerHitCollection}
    where they are stored by value (see \ref{sec:collections}).
    \index{StEmcHit}
    \index{StEmcTowerHitCollection}

\item[Public\\ Constructors]
    \verb+StEmcTowerHit(int i, float E, float phi, float eta);+ \\
    Create an instance of \name{StEmcTowerHit} with identifier \name{i},
    energy deposition \name{E} and position \name{phi}, \name{eta}.

\item[Examples] \index{accumulate (example)}
{\footnotesize
\begin{verbatim}
struct addEnergy {
    
\item[Synopsis] 

//  Calculate the total tower energy using the generic STL
    
//  (Note the binary operator addEnergy() defined above)
//
double sumEmcTowerHits(StEvent *event)
{
   StEmcTowerHitCollection* hits = event->emcTowerHitCollection();
   return accumulate(hits->begin(), hits->end(), 0., addEnergy());
}
\end{verbatim}
}%footnotesize
\end{Entry}
    event mixing) you have to create local copies of the objects.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
%    Reference: StEvent
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StEvent}
\index{StEvent|textbf}
\index{event header}
\label{sec:StEvent}
\begin{Entry}
    
    \name{StEvent} is the top class in the \StEvent\ data model.
    \verb+const string& type() const;+\\ 
    stored in the DST.

    
    \verb+#include "StEvent.hh"+\\
    \verb+class StEvent;+\\

    \verb+pair<long, long> id() const;+\\
    Objects of type \name{StEvent} are the entry point to the DST data.
    
    in the DST. Since many other \StEvent\ header files are included
    in \name{StEvent.hh} itself it is often sufficient to include only
    
    \verb+time_t time() const;+\\
    Deleting \name{StEvent} deletes the whole data tree, i.e.~all depending objects
    are deleted properly. If you want to keep objects beyond the event (e.g.~ for
    
    Event type (e.g. Au+Au, p+p, laser)

\item[Persistence]
    

\item[Related Classes]
    integers.
    
\item[Public\\ Constructors]
    \index{event time} Unique time stamp for this event.
    Default constructor. Creates an "empty" event.
    
    \verb+virtual const string& type() const;+\\
    Experiment run number.
    
    \verb+StRun* run();+\\
    \verb+virtual pair<long, long> id() const;+\\
    Trigger mask.
    \verb+StVertex* primaryVertex();+\\
    compilers do not yet support the \name{long long} integer type
    integers.\index{event Id} 
    Beam-beam bunch crossing number.
    
    \verb+virtual time_t time() const;+\\

    Luminosity reading when event was taken.
    
    Experiment run number.
    \index{run number}

    \verb+StTrackCollection* trackCollection();+\\
    \index{primary vertex}
    Trigger mask.
    

    \verb+virtual unsigned long bunchCrossingNumber() const;+\\
    Beam-beam bunch crossing number.
    \verb+StTpcHitCollection* tpcHitCollection();+\\  \index{hit collections}
    \verb+virtual double luminosity() const;+\\
    
    \index{luminosity}

    \verb+virtual StRun* run();+\\
    \index{track collection}
    \verb+StSvtHitCollection* svtHitCollection();+\\

    
    Returns a pointer to primary vertex. The same object is stored
    high importance for most analyze steps this method was added
    \verb+virtual StTpcHitCollection* tpcHitCollection();+\\  \index{hit collections}
    this functions returns a null pointer.
    \verb+StFtpcHitCollection* ftpcHitCollection();+\\

    

    if the summary is not available.

    \verb+virtual StTrackCollection* trackCollection();+\\
    \verb+StEmcTowerHitCollection* emcTowerHitCollection();+\\
    if the collection is not available.
    
    \index{track collection}

    \verb+virtual StTpcHitCollection* tpcHitCollection();+\\ 
    \verb+StEmcPreShowerHitCollection* emcPreShowerHitCollection();+\\
    if the collection is not available.
    
    \index{hit collections}

    \verb+virtual StSvtHitCollection* svtHitCollection();+\\
    \verb+StSmdPhiHitCollection* smdPhiHitCollection();+\\
    hits in the SVT (\name{StSvtHit}) or a null pointer if the
    
    is a polymorphic container.


    \verb+virtual StFtpcHitCollection* ftpcHitCollection();+\\
    \verb+StSmdEtaHitCollection* smdEtaHitCollection();+\\
    all hit in the FTPC (\name{StFtpcHit}) or a null pointer if the
    
    is a polymorphic container.


    \verb+virtual StEmcTowerHitCollection*+\\
    \verb+StVertexCollection* vertexCollection();+\\
    Returns a pointer to the EMC tower hit collection, i.e., the list
    of all hit in the Emc Tower (\name{StEmcTowerHit}) or a null
    pointer if the collection is not available.  Note that

    \name{StEmcTowerHitCollection} holds the hits by value.

    \verb+virtual StEmcPreShowerHitCollection*+\\
    \verb+emcPreShowerHitCollection();+\\
    Returns a pointer to the collection of hits from the EMC
    pre-shower detectors or a null pointer if the collection is not
    
    available.  Note that \name{StEmcPreShowerHitCollection holds} the
    \index{vertex collection} \index{vertices}
    hits by value.
    \verb+StTriggerDetectorCollection* triggerDetectorCollection();+\\
    Returns a pointer to the collection of hits from the $\phi$ shower
    max detector (SMD) or a null pointer if the collection is not
   
    member \name{type()} which allows to determine the type of vertex
    object. One than can use the type cast operator (either the
    traditional \name{()} or the ANSI \name{dynamic\_cast}) to cast
    \verb+StL0Trigger* l0Trigger();+\\
    
    \index{StV0Vertex} \index{StVertex} \index{StXiVertex}

    \verb+virtual StVertexCollection* vertexCollection();+\\
    \verb+float beamPolarization(StBeamDirection,+\\ \index{beam polarization}
    \verb+                       StBeamPolarizationAxis);+\\
    if the collection is not available. Note that StTriggerDetectorCollection
    is not a container but a more complex class which keeps track of the
    various trigger detectors and their content.
    \index{StTriggerDetectorCollection}
    a profound understanding of the relations between the different objects.    
    
    \index{L0 trigger}
    operator (either the traditional \name{()} or the ANSI
    \name{dynamic\_cast}) to cast the object to its actual type. This
    \verb+void setRunNumber(unsigned long);+\\                
    \verb+void setTriggerMask(unsigned long);+\\              
    \verb+void setBunchCrossingNumber(unsigned long);+\\      
    \verb+void setLuminosity(double);+\\               
    \verb+void setRun(StRun*);+\\                            
    \verb+void setPrimaryVertex(StVertex*);+\\                  
    \verb+void setSummary(StDstEventSummary*);+\\                        
    \verb+void setTrackCollection(StTrackCollection*);+\\                
    \verb+void setTpcHitCollection(StTpcHitCollection*);+\\               
    \verb+void setSvtHitCollection(StSvtHitCollection*);+\\               
    \verb+void setFtpcHitCollection(StFtpcHitCollection*);+\\              
    \verb+void setEmcTowerHitCollection(StEmcTowerHitCollection*);+\\              
    \verb+void setEmcPreShowerHitCollection(StEmcPreShowerHitCollection*);+\\              
    \verb+void setSmdPhiHitCollection(StSmdPhiHitCollection*);+\\              
    \verb+void setSmdEtaHitCollection(StSmdEtaHitCollection*);+\\              
    \verb+void setVertexCollection(StVertexCollection*);+\\               
    \verb+void setTriggerDetectorCollection(StTriggerDetectorCollection*);+\\      
    \verb+void setL0Trigger(StL0Trigger*);+\\                      
    \verb+void setVertexCollection(StVertexCollection*);+\\
    \verb+                         StBeamPolarizationAxis, float);+\\                   
    \verb+void setL0Trigger(StL0Trigger*);+\\
    \verb+void setBeamPolarization(StBeamDirection, +\\
    \verb+virtual void setType(const char*);+\\
    \verb+virtual void setId(const pair<long, long>&);+\\
    \verb+virtual void setTime(time_t);+\\
    \verb+virtual void setRunNumber(unsigned long);+\\
    
    \verb+virtual void setBunchCrossingNumber(unsigned long);+\\
    \verb+virtual void setLuminosity(double);+\\
    if otherwise. 
    \verb+virtual void setPrimaryVertex(StVertex*);+\\
    
    \verb+virtual void setTrackCollection(StTrackCollection*);+\\
    \verb+virtual void setTpcHitCollection(StTpcHitCollection*);+\\
    \verb+virtual void setSvtHitCollection(StSvtHitCollection*);+\\
    \verb+virtual void setFtpcHitCollection(StFtpcHitCollection*);+\\
    \verb+virtual void+\\
    \verb+setEmcTowerHitCollection(StEmcTowerHitCollection*);+\\
    \verb+virtual void+\\
    \verb+setEmcPreShowerHitCollection(StEmcPreShowerHitCollection*);+\\
//   
    \verb+setSmdPhiHitCollection(StSmdPhiHitCollection*);+\\
    \verb+virtual void+\\
    \verb+setSmdEtaHitCollection(StSmdEtaHitCollection*);+\\
    \verb+virtual void setVertexCollection(StVertexCollection*);+\\
    \verb+virtual void+\\
    \verb+setTriggerDetectorCollection(StTriggerDetectorCollection*);+\\
    \verb+virtual void setL0Trigger(StL0Trigger*);+\\
     cout << "event time = " << ctime(&t);     
    \verb+                         StBeamPolarizationAxis, float);+\\

\item[Public Member\\ Operators]
    \verb+int operator==(const StEvent &e) const;+ \\
    Returns true (1) if two instances of \name{StEvent} are equal or false (0)
     cout << "Event ID = " <<  event->id().first << '/'
                           <<  event->id().second << endl;
     cout << "Run ID = " <<  event->run()->id() << endl;
    if otherwise.
     cout << "# of tracks = " << event->trackCollection()->size() << endl;
     cout << "# of vertices = " << event->vertexCollection()->size() << endl;
     cout << "# of tpc hits = " << event->tpcHitCollection()->size() << endl;
//
          <<  event->primaryVertex()->position()/millimeter << " mm" << endl;
//   the function adds a new line by default.
//   V0 vertices with r>10 cm.  
void printEvent(StEvent *event)
{
     time_t t = event->time();

     cout << "Event ID = "
          <<  event->id().first << '/'
          <<  event->id().second << endl;
     cout << "Run ID = "
          <<  event->run()->id() << endl;
     cout << "event time = " << ctime(&t);
     cout << "# of tracks = "
          << event->trackCollection()->size() << endl;
     cout << "# of vertices = "
          << event->vertexCollection()->size() << endl;
     cout << "# of tpc hits = "
          << event->tpcHitCollection()->size() << endl;
           if (v0->position().perp() > rMin) counter++; 
          <<  event->primaryVertex()->position()/millimeter
          << " mm" << endl;
}

\end{verbatim}
}%footnotesize

{\bf Example 2:} \index{dynamic\_cast} \index{casting vertices} \index{StV0Vertex} \index{StVertex}
{\footnotesize
\begin{verbatim}
//
//   The following function returns the number of
//   V0 vertices with r>10 cm.
//   The V0 vertices are stored in the StVertexCollection
//   together with all other vertices which share the common
//   base class StVertex.
//
//  (Note the binary function addMips() defined above) 
{
   StVertexCollection* vertices = event->vertexCollection();
   StVertexIterator i;
   StVertex   *vertex;
   StV0Vertex *v0;
   return accumulate(counters.begin(), counters.end(), 0., addMips());   
   unsigned int counter = 0;
   for (i = vertices->begin(); i != vertices->end(); i++) {
       vertex = *i;
       if (vertex->type() == V0) {
           v0 = dynamic_cast<StV0Vertex*>(vertex);
           if (v0->position().perp() > rMin) counter++;
       }
   }
   return counter;
}
\end{verbatim}
}%footnotesize
{\bf Example 3:} \index{StTriggerDetectorCollection} \index{accumulate (example)}
{\footnotesize
\begin{verbatim}
struct addMips {
    double operator()(double s, StCtbCounter &c) {return s += c.mips();}
    
\item[Synopsis] 
//
//  Returns the total event multiplicity
    
\item[Description]    
//  (Note the binary function addMips() defined above)
//
double totalCtbMultiplicity(StEvent *event)
{
   StVecCtbCounter &counters =
                    event->triggerDetectorCollection()->ctbCounters();
   return accumulate(counters.begin(), counters.end(), 0., addMips());
}
\end{verbatim}
}%footnotesize
    \name{StFtpcHit}.    
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StFtpcHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StFtpcHit}
\index{FTPC hit} \index{StFtpcHit|textbf}
    which were used to reconstruct the global track. 
\begin{Entry}
\item[Summary]
    \name{StFtpcHit} represents a FTPC hit.

\item[Synopsis]
    \verb+#include "StFtpcHit.hh"+\\
    \verb+class StFtpcHit;+\\

\item[Description]
    \name{StFtpcHit} inherits most functionality from \name{StHit}.  For a complete
    
    (sec.~\ref{sec:StHit}).

    In the \StEvent\ data model each track keeps references to the
    associated hits but not vice versa. In order to allow
    the reverse navigation \name{StFtpcHit} adds a method
    \name{relatedTracks()} which allows to obtain a list of tracks
    which were reconstructed using this hit, i.e., a list of pointers
    to global tracks (StGlobalTrack$*$) which reference objects of type
    \name{StFtpcHit}.

\item[Persistence]
    None

\item[Related Classes]
    
    The hits are kept in an instance of \name{StFtpcHit}Collection
    where they are stored by pointer (see \ref{sec:collections}).
    Each instance of \name{StGlobalTrack} holds a list of FTPC hits
    which were used to reconstruct the global track.
    \index{StHit}
    \index{StGlobalTrack}
    \index{StFtpcHitCollection}

\item[Public\\ Constructors]
    \verb+StFtpcHit(const StThreeVector<float>& pos,+\\
    \verb+          const StThreeVector<float>& err,+\\
    \verb+          float q, unsigned char cnt = 0);+\\
    Create an instance of \name{StFtpcHit} with position \name{pos},
    position error \name{err}, charge \name{q}, and reference count \name{cnt}.

\item[Public Member\\ Functions]
    \verb+StVecPtrGlobalTrack+\\
    \verb+relatedTracks(const StTrackCollection& coll);+\\
    Returns a collection of tracks stored in \name{coll} which
    reference this hit.  The individual elements are a subset of the
    collection passed as argument.  The number of elements
    equals the reference count
    (\name{StFtpcHit::trackReferenceCount()}) if the track collection is
}  
    \name{StEvent::trackCollection().}  Note that this functions has to iterate
    over the given track collection in order to setup the return
    argument. The time to collect the referring tracks goes linear
    with the size of the given collection \name{coll}.
    For information on the returned collection class see sec.~\ref{sec:collections}.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  This function returns the average pt of
//  all tracks in the FTPC which use a given FTPC hit.
//  The pt is taken at the track origin.
//
double
meanPtOfRelatedTracks(StEvent *event, StFtpcHit *hit)
{
   StTrackCollection* tracks = event->trackCollection();
   double B = 0.5*tesla;

    
\item[Synopsis] 

   StVecPtrGlobalTrackIterator i;
    
   for (i = tlist.begin(); i != tlist.end(); i++) {
    
   }
   return tlist.size() > 0 ? sumPt/tlist.size() : 0;
}
\end{verbatim}
}%footnotesize
\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
    
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StGlobalTrack}
\index{StGlobalTrack|textbf}

    \name{StGlobalTrack} describes a global track in the STAR detector.  It
    inherits from \name{StTrack}. Please
\index{StHelix}
    \name{StGlobalTrack} provides additional information on the related hits
    which were used to reconstruct the track and on the energy loss
    (dE/dx) of the track in the different detectors.  All tracks
    stored on the DST are collected in a \name{StTrackCollection} which can
    be obtained through the \name{StEvent::trackCollection()} method.
    \name{StGlobalTrack} is a virtual class.

    \verb+class StGlobalTrack;+\\

\item[Description]
    
    \name{StGlobalTrack} describes a global track in the STAR
    detector.  It inherits from \name{StTrack}. Please
    see \name{StTrack} for more details.\\
    (\name{relatedTracks()}) method which is provided by all \name{StHit}
    based classes: \name{StTpcHit}, \name{StSvtHit} and \name{StFtpcHit}.  It returns a
   
    This list however has to be constructed by scanning through a
    \name{StTrackCollection} which can be obtained through the
    \name{StEvent::trackCollection()} method.  \name{StGlobalTrack} is
    a virtual class.
    
    \StEvent\ handles the relation between hits and tracks different
    from the original table-based DST design where each hit had a key
    \StEvent\ is solely kept in \name{StGlobalTrack}.  Each global track
    knows about the hits it is associated with. \name{StGlobalTrack} provides
    methods to add (assign) and remove hits from the various detectors
    to the track.  These methods also automatically increase or
    decrease the hit reference counter in a coherent way.
    \index{relation between hits and tracks}
    \name{StTpcHit}, \name{StSvtHit} and \name{StFtpcHit}.  It returns
    a list of pointers to tracks associated with an individual hit.
  
    track collection.  Holding such a list as local data member would
    increase the memory usage of the hit classes beyond what can be
    afforded. The downside of such a scheme is a somewhat increased
    \verb+const StVecPtrTpcHit& tpcHits() const;+\\
    
    The information on the relation between hits and tracks in
    \StEvent\ is solely kept in \name{StGlobalTrack}.  Each global
    track knows about the hits it is associated with.
    \verb+const StVecPtrSvtHit& svtHits() const;+\\
    hits from the various detectors to the track.  These methods also
    automatically increase or decrease the hit reference counter in a
    coherent way.  \index{relation between hits and tracks}
    \index{reference counting}
    \verb+const StVecPtrFtpcHit& ftpcHits() const;+\\
\item[Persistence]
    None

\item[Related Classes]
    \verb+StDedx* tpcDedx();+\\
    
    where they are stored by pointer (see sec.~\ref{sec:collections}).
    \index{StTrack}
    \index{StTrackCollection}
    \verb+StDedx* svtDedx();+\\
    
    \verb+StGlobalTrack();+\\
    Constructs an instance of \name{StGlobalTrack} with all values initialized to 0 (zero).
    \verb+virtual int  numberOfFtpcHits() const;+\\
    \verb+StDedx* ftpcDedx();+\\
    
    \verb+virtual const StVecPtrTpcHit& tpcHits() const;+\\
    Vector of TPC hits assigned to the track during
    
    \verb+void setFtpcDedx(StDedx*);+\\    

    \verb+virtual const StVecPtrSvtHit& svtHits() const;+\\
    \verb+void setFtpcDedx(StDedx*);+\\
    reconstruction. The returned collection holds the
    
    \verb+void setSvtDedx(StDedx*);+\\
    Returns pointer to an instance of the \name{StDedx} class which holds
    Vector of FTPC hits assigned to the track during
    reconstruction. The returned collection holds the
    hits by pointer. Note, that the collection can be empty.
    \verb+virtual StDedx* svtDedx();+\\
    Returns pointer to an instance of the \name{StDedx} class which holds
    
    information on the energy loss of the track/particle in the TPC.
    If no dE/dx information is available a null pointer is returned.
    \verb+virtual StDedx* ftpcDedx();+\\
    
    Returns a constant pointer to an instance of the \name{StDedx} class which holds
    information on the energy loss of the track/particle in the SVT.
    If no dE/dx information is available a null pointer is returned.
    
    \verb+virtual StTrackPidTraits& pidTraits();+\\
    Returns a reference to \name{StTrackPidTraits} which allows
    to obtain information on the particle identification (PID)
    

    \verb+virtual void setTpcDedx(StDedx*);+\\
    Assigns the dE/dx information for the TPC.
    
    \verb+virtual void setFtpcDedx(StDedx*);+\\
    Assigns the dE/dx information for the FTPC.

    \verb+void removeSvtHit(StSvtHit*);+\\
    Assigns the dE/dx information for the SVT.

    \emph{The following methods also manage the reference counting,
    i.e., they increase or decrease the reference counter
    of the referring hit (see the referring hit classes).}

//  is close (distance < 1.5 cm) to the primary vertex. 
    Adds a TPC hit to the internal hit collection.
    Increments the reference counter of the hit.

    \verb+virtual void addFtpcHit(StFtpcHit*);+\\
    Adds a FTPC hit to the internal hit collection.
    Increments the reference counter of the hit.

    \verb+virtual void addSvtHit(StSvtHit*);+\\
    Adds a SVT hit to the internal hit collection.
    Increments the reference counter of the hit.

    \verb+virtual void removeTpcHit(StTpcHit*);+\\
    Removes a TPC hit from the internal hit collection.
    Decrements the reference counter of the hit.

    \verb+virtual void removeFtpcHit(StFtpcHit*);+\\
    Removes a FTPC hit from the internal hit collection.
    Decrements the reference counter of the hit.

    \verb+virtual void removeSvtHit(StSvtHit*);+\\
    Removes a SVT hit from the internal hit collection.
    Decrements the reference counter of the hit.

}%footnotesize    
{\bf Example 1:}
{\footnotesize
\begin{verbatim}
//
//  Setup a vector of those tracks where the start vertex
//  is close (distance < 1.5 cm) to the primary vertex.
//
vector<StGlobalTrack*>
getPrimaryTrackCandidates(StEvent *event)
{
    StTrackCollection* tracks = event->trackCollection();

    StTrackIterator iter;
    StGlobalTrack *theTrack;
    vector<StGlobalTrack*> theVector;  // the vector to fill

    for (iter = tracks->begin(); iter != tracks->end(); iter++) {
        theTrack = *iter;              // careful here, pointer collection
        StThreeVector<double> vtxPos =
                        theTrack->startVertex()->position();
        StThreeVector<double> pvtxPos =
                        event->primaryVertex()->position();
        if (abs(vtxPos-pvtxPos) < 1.5*centimeter)
             theVector.push_back(theTrack);
    }

    return theVector;
}
\end{verbatim}
}%footnotesize

{\bf Example 2:}
{\footnotesize
\begin{verbatim}
//
//  Print the dE/dx value in all detectors
//
void printDeDx(StGlobalTrack &track)
{
      StDedx *theDedx;

     if ((theDedx = track.tpcDedx()) != 0)
        cout << "TPC: " << theDedx->mean() << endl;
     if ((theDedx = track.ftpcDedx()) != 0)
        cout << "FTPC: " << theDedx->mean() << endl;
     if ((theDedx = track.svtDedx()) != 0)
        cout << "SVT: " << theDedx->mean() << endl;
}
\end{verbatim}
}%footnotesize

{\bf Example 3:}
{\footnotesize
\begin{verbatim}
//
//  Print the momentum vector of a track
//  when it intersects the RICH detector
//  (here positioned at 12 o'clock)
//  The dimension of the RICH are 1x1 meter.
//
void printMomAtRichCrossing(StGlobalTrack &track)
{
    StPhysicalHelix& helix = track.helix();
}%footnotesize   
    // the center of the RICH
    StThreeVector<double> center(0, 2.05*meter, 0);

    // the normal vector of the RICH plane at r
    StThreeVector<double> n(0, 1, 0);

    // get s at the intersection
    double s = helix.pathLength(r, n.unit());

    //
    // Check: s is set to DBL_MAX if
    // StHelix::pathLength() fails. We also have
//  
    // within the boundaries. StHelix::pathLength()
    // assumes a infinite extended plane.
    //
    bool intersects = false;
    if (s < DBL_MAX) {
       if (abs(center - helix.at(s)) < 0.5*meter)
           intersects = true;
    }

    // print the momentum at s
    if (intersects)
        cout << helix.momentumAt(s, 0.5*tesla) << endl;
    else
        cout << "Sorry, track not in the RICH" << endl;
}
\end{verbatim}
}%footnotesize

{\bf Example 4:}
{\footnotesize
\begin{verbatim}
//
//  Calculate the mean pt of all (good) primary
//  tracks at the primary vertex.
//  Here we define a primary track as
//  a track with a distance of closest approach
//  smaller then 5 mm and a good track as a
//  track with more than 40 hits in the TPC and
//  chi2 below 1.2.
//
double meanPtOfGoodTracks(StEvent *event)
{
    StTrackCollection* tracks = event->trackCollection();

    StTrackIterator iter;
    StGlobalTrack *theTrack;

    double sumPt = 0;
    long   n = 0;

    for (iter = tracks->begin(); iter != tracks->end(); iter++) {
        theTrack = *iter;       // careful here, pointer collection

        // apply cuts
        if (theTrack->tpcHits().size() < 40) continue;
    
\item[Synopsis] 
        if (dca > 5*millimeter) continue;
        if (theTrack->fitTraits().chiSquaredInXY() > 1.2 ||
    
            continue;

        // add up pt
        double s = theTrack->helix().pathLength(pvtx);
        sumPt += theTrack->helix.momentumAt(s, 0.5*tesla);
        n++;
    }
    return n ? sumPt/n : 0;
}
    
}%footnotesize

\end{Entry}

    The following classes are derived from \name{StHit}: 
%
%    Reference: StHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\index{StHit|textbf} \index{hit}
\label{sec:StHit}
    Constructs an instance of \name{StHit} with all values initialized to 0 (zero).
    

\item[Synopsis]
    \verb+#include "StHit.hh"+\\
    \verb+class StHit;+\\

        
    \name{StHit} is not a virtual class.
    which represent TPC, FTPC and SVT hits. It provides information on
    position, position error, charge, and on the number of tracks which
    
    the \name{dst\_point.idl} table except the reference count which
    is added properly by StEventReaderMaker.
    
    \index{dst\_point.idl}

    
    \verb+unsigned char trackReferenceCount() const;+\\    

    
    The following classes are derived from \name{StHit}:
    \name{StTpcHit}, \name{StFtpcHit}, \name{StSvtHit}.
    
    \index{StFtpcHit}
    \index{StSvtHit}
    
\item[Public\\ Constructors]
    \verb+StHit();+\\
    
    to 0 (zero).

    \verb+StHit(const StThreeVector<float>& pos,+\\
    \verb+const StThreeVector<float>& position() const;+\\
    \verb+      float q, unsigned char cnt = 0);+\\
    Returns true (1) if two instances of \name{StHit} are equal or false (0)
    if otherwise.
    The only data member used for the comparison are position and charge.
\item[Public Member\\ Functions]
    Hit position in global coordinates.
    Returns true (1) if two instances of \name{StHit} are not equal or false (0)
    if otherwise. 
    This operator is implemented by simply inverting \name{operator==}.
        
    \verb+void setPosition(const StThreeVector<float>&);+\\
    Total hit charge.

    
\item[Examples] 

    \verb+void setCharge(float);+\\
    Set the hit position.
//  Create and print a random hits 
    \verb+void setTrackReferenceCount(unsigned char);+\\
    Set the error on the hit position.

    \verb+virtual void setCharge(float);+\\
    Set the total charge.

    \verb+virtual void setTrackReferenceCount(unsigned char);+\\
    Set the track reference counter.
    
\item[Public Member\\ Operators]
    \verb+int operator==(const StHit&) const;+\\
    Returns true (1) if two instances of \name{StHit} are equal or
    false (0) if otherwise.  The only data member used for the
    comparison are position and charge.
   StHit hit(pos, err, -1); 

    \verb+int operator!=(const StHit&) const;+\\
    Returns true (1) if two instances of \name{StHit} are not equal or
    false (0) if otherwise.  This operator is implemented by simply
}%footnotesize    

\item[Global Operators]
    \verb+ostream&  operator<<(ostream& os, const StHit&);+\\
    Prints hit data to output stream \name{os}.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  Create and print a random hits
//
void printArbitraryHit()
{
   HepJamesRandom engine;
   RandFlat       rndm(engine);
   RandGauss      rgauss(engine);
   const double   sigma = 120*micrometer;

   StThreeVector<float> pos(rndm.shoot(-meter,meter),
                            rndm.shoot(-meter,meter),
                            rndm.shoot(-meter,meter));
   StThreeVector<float> err(rgauss.shoot(0.,sigma),
                            rgauss.shoot(0.,sigma),
                            rgauss.shoot(0.,sigma));
    

   cout << hit << endl;
}
  
}%footnotesize
{\bf Programs Output:}
{\footnotesize
\begin{verbatim}
Position: (-20.3111, -80.7543, 76.8227)
Error: (0.00077, -0.0008, -0.00005242)
Charge: -1
RefCount: 0
    
}%footnotesize

\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
    
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StL0Trigger}
\index{StL0Trigger|textbf}
\index{L0 trigger}
\label{sec:StL0Trigger}
\begin{Entry}
    
    \name{StL0Trigger} describes the STAR level 0 trigger.

    
    \verb+#include "StL0Trigger.hh"+\\
    \verb+class StL0Trigger;+\\

\item[Description]
    MWC/CTB spacial topology.
    stored in the \name{dst\_L0\_Trigger.idl} table.
    \index{dst\_L0\_Trigger.idl} The class provides various
    information on the STAR level 0 trigger in addition to the
    methods inherited from its base class \name{StTrigger}.
    \verb+void setMwcCtbMultiplicity(long);+\\   
    by invoking the \name{StEvent::l0Trigger()} method.
    
    \verb+void setMwcCtbDipole(long);+\\           
    None
    
    \verb+void setMwcCtbTopology(long);+\\           
   \name{StL0Trigger} is derived from \name{StTrigger}.
    

\item[Public\\ Constructors]
    
    Default constructor. All data member are initialized to 0 (zero).

\item[Public Member\\ Functions]
    \verb+vector<long>& coarsePixelArray();+\\
    Coarse pixel array.

    \verb+long mwcCtbMultiplicity() const;+\\
    MWC/CTB multiplicity.

    \verb+long mwcCtbDipole() const;+\\
    MWC/CTB dipole analysis.

    \verb+long mwcCtbTopology() const;+\\
    MWC/CTB spatial topology.

    \verb+long mwcCtbMoment() const;+\\
    MWC/CTB moment analysis.

    \verb+void setMwcCtbMultiplicity(long);+\\
    Sets the MWC/CTB multiplicity.

    \verb+void setMwcCtbDipole(long);+\\
    Sets the  MWC/CTB dipole analysis word.

    \verb+void setMwcCtbTopology(long);+\\
    Sets the spacial topology analysis word.

    \verb+void setMwcCtbMoment(long);+\\
}%footnotesize    

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  Compare the MWC/CTB multiplicity from the L0
//  with the simple sum of the MWC+CTB information.
//
void compareL0MwcCtb(StEvent *event)
{
    // from the L0 trigger
    long l0Result = event->l0Trigger()->mwcCtbMultiplicity();

    // from the detectors
    double sum = 0;
    
                          event->triggerDetectorCollection();
    StVecCtbCounter &counters = tds->ctbCounters();
    for (int i=0; i<counters.size(); i++)
  
    StVecMwcSector &sectors = tds->mwcSectors();
    for (int k=0; k<sectors.size(); k++)
        sum += sectors[k].mips();

    // print-out
    cout << "Multiplicity from L0: " << l0Result << endl;
    
}
\end{verbatim}
}%footnotesize

    The list of \name{StMwcSector} objects (collection class StVecMwcSector) can be obtained
    through the StTriggerDetectorCollection.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
   
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    Constructs an empty MWC sector, i.e., all values are initialized to 0 (zero).
\index{MWC}
\label{sec:StMwcSector}
    Constructs a MWC sector with id \name{id} and number of mips \name{m}.
    \name{StMwcSector} represents a single MWC sector.

\item[Synopsis]
    \verb+#include "StMwcSector.hh"+\\
    

\item[Description]
    
    stored in the \\
    \name{dst\_TriggerDetectors.idl} table. Each sector
    
    in the sector. \index{dst\_TriggerDetectors.idl}

   
    None

\item[Related Classes]
    The list of \name{StMwcSector} objects (collection class StVecMwcSector)
    can be obtained through the StTriggerDetectorCollection.
    \index{StVecMwcSector}
    \index{StTriggerDetectorCollection}
    
\item[Public\\ Constructors]
    \verb+StMwcSector();+ \\
    Constructs an empty MWC sector, i.e., all values are initialized
    StTriggerDetectorCollection* tds = event->triggerDetectorCollection();
    \verb+StMwcSector(short id, float m);+ \\
    Constructs a MWC sector with id \name{id} and number of mips
    \name{m}.

}%footnotesize    
    \verb+short id() const;+ \\
    Unique sector ID.

    \verb+float mips() const;+ \\
    Number of mips.

    \verb+void setId(short);+ \\
\subsection{StRun} 

    \verb+void setMips(float);+ \\
    Sets the number of mips.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
    
\item[Synopsis] 
double sumMwcMips(StEvent *event)
{
    StTriggerDetectorCollection* tds =
                      event->triggerDetectorCollection();
    \name{StRun} holds information specific to a DST production run. Note that one
    DST production run may include or overlap with one or more experimental runs.
    The current instance of \name{StRun} can be obtained via \name{StEvent::run()}.
    It provides all information stored in the \name{dst\_run\_header.idl} table.
    \name{StRun} is a virtual class.
\end{verbatim}
}%footnotesize
\item[Persistence]
    None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StRun
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StRun}
    
\label{sec:StRun}
\index{run information}
\index{center-of-mass energy}

\item[Summary]
    \name{StRun} holds information about one DST production run.

    \verb+#include "StRun.hh"+\\
    \index{trigger mask}
    Trigger mask.
    
    \name{StRun} holds information specific to a DST
    \index{center-of-mass energy}
    CM total energy per NN pair (GeV).
    overlap with one or more experimental runs.  The current instance
    provides all information stored in the \name{dst\_run\_header.idl}
    \index{beam mass number}
    A of east (\name{dir=east}) or west (\name{dir=west}) moving beam.
    StBeamDirection is defined in \name{StEnumerations.hh}
    (see sec.~\ref{sec:StEnumerations}).
\item[Persistence] None
\item[Related Classes]
    \index{beam charge}
    Z of east (\name{dir=east}) or west (\name{dir=west}) moving beam.
    StBeamDirection is defined in \name{StEnumerations.hh}.
    \verb+StRun();+ \\
    \index{center-of-mass energy} CM total energy per NN pair (GeV).
\item[Public Member\\ Functions]
    \verb+virtual long id() const;+\\
    \verb+StRunSummary* summary();+\\
    The following member functions are used to set data member of \name{StEvent}.
    They are shown only for completeness and shouldn't be used without
    a profound understanding of the relations between the different objects.    
    
    \index{beam charge} Z of east (\name{dir=east}) or west
    Trigger mask.\index{trigger mask} 
    \name{StEnumerations.hh}.
    \verb+void setId(long);+\\
    \verb+void setType(const char*);+\\
    \verb+void setTriggerMask(long);+\\
    \verb+void setCenterOfMassEnergy(double);+\\
 
    \verb+void setBeamCharge(StBeamDirection, short);+\\
    \verb+void setSummary(StRunSummary*);+\\
    (\name{dir=west}) moving beam.  StBeamDirection is defined in
    \name{StEnumerations.hh} (see sec.~\ref{sec:StEnumerations}).
    \index{beam mass number} 
    
    \verb+virtual short beamCharge(StBeamDirection) const;+\\
    Z of east (\name{dir=east}) or west
    if otherwise. 
    \name{StEnumerations.hh}.\index{beam charge} 
    

    \verb+virtual StRunSummary* summary();+\\
    Returns pointer to run summary object or a null pointer if no
    summary is available.
    
//   
    \name{StEvent}.  They are shown only for completeness and
    shouldn't be used without a profound understanding of the
    relations between the different objects.}
    

    \verb+virtual void setId(long);+\\
    \verb+virtual void setType(const char*);+\\
    \verb+virtual void setTriggerMask(long);+\\
    \verb+virtual void setCenterOfMassEnergy(double);+\\
    \verb+virtual void setBeamMassNumber(StBeamDirection, short);+\\
    \verb+virtual void setBeamCharge(StBeamDirection, short);+\\
    \verb+virtual void setSummary(StRunSummary*);+\\

\item[Public Member\\ Operators]
    \verb+int operator==(const StRun&) const;+\\
    Returns true (1) if two instances of \name{StRun} are equal or false (0)
    if otherwise.
    Note that only the run id (\name{StRun::id()}) is used for the comparison.

    \verb+int operator!=(const StRun&) const;+\\
    Returns true (1) if two instances of \name{StRun} are not equal or false (0)
A=197 Z=79                            A=197 Z=79     
    This operator is implemented by simply inverting \name{operator==}.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//   Print beam characteristics of current run
//
void beamInfo(StEvent *event)
{
    string blanks(28, ' ');
    string more_blanks(12, ' ');
    string dashes(13, '-');
    StRun *run = event->run();
    cout << "A=" << setw(3) << run->beamMassNumber(east)
         << " Z=" << setw(2) << run->beamCharge(east)
         << blanks
         << "A=" << setw(3) << run->beamMassNumber(west)
    
\item[Synopsis] 
         << run->centerOfMassEnergy()/GeV << "GeV <"
         << dashes << endl;
    
}
\end{verbatim}
}%footnotesize
    \name{StRunSummary} is a class which summarizes a DST production run.
{\footnotesize
\begin{verbatim}
A=197 Z=79                            A=197 Z=79
------------->  sqrt(s) = 200 GeV <-------------
east                                        west
\end{verbatim}
    

\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
    
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
\index{run summary} \index{StRunSummary|textbf}
\label{sec:StRunSummary}
\begin{Entry}
    
    \name{StRunSummary} summarizes a DST production run.

\item[Synopsis]
    
    \verb+class StRunSummary;+\\

    
    \name{StRunSummary} provides summary information in the DST
    production run. Note that one DST production run may include or
    
    actual instance of \name{StRunSummary} can be obtained via
    \name{StRun::summary()}.  \name{StRunSummary} uses data stored in
    
    strongly deviates from the former design draft since much of the
    table content is now stored in histograms.
    \index{dst\_run\_summary.idl}
    
\item[Persistence]
    None

\item[Related Classes]
    None

\item[Public\\ Constructors]
    \verb+StRunSummary();+ \\

    
    \verb+const string& version() const;+ \\
    DST production software version.
    
    \verb+ long numberOfEvents() const;+ \\
    Total number of events in the run.
    

    \verb+ long numberOfProcessedEvents() const;+ \\
    

    \verb+time_t startTime() const;+ \\
    

    \verb+time_t stopTime() const;+ \\
    

    \verb+double cpuSeconds() const;+ \\
    
    \index{CPU time}

    \verb+StVecTH1F& histograms1D();+ \\
    Vector of 1-dimensional Root histograms.  Neither the number of
    histograms nor its content is defined. This depends on the current
    implementation.  \index{Root histograms}

    \verb+StVecTH2F& histograms2D();+ \\
    Vector of 2-dimensional Root histograms.  Neither the number of
    histograms nor its content is defined.  This depends on the
    current implementation.  \index{Root histograms}

    \verb+void setVersion(const char*);+ \\
    Sets DST production software version.

    \verb+void setNumberOfEvents(unsigned long);+ \\
    Sets number of events in the run.

    \verb+void setNumberOfProcessedEvents(unsigned long);+ \\
    Sets total number of successfully processed events.

}%footnotesize    
    

    \verb+void setStopTime(time_t);+ \\
    Sets stop time of production.

    \verb+void setCpuSeconds(double);+ \\
    Sets total CPU seconds used for production run.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  Evaluate and print DST run efficiencies.
    \name{StSmdEtaHit} represents a hit in the $\eta$ shower-maximum-detector (SMD).
    
\item[Synopsis] 

   if (!summary) return;   // no summary available
    
   double effN = (double)summary->numberOfProcessedEvents()/
                 summary->numberOfEvents();
   double effT = (double)summary->cpuSeconds()/
                 (summary->stopTime() - summary->start(Time));
    
   os << "Percentage of processed events: " << effN << endl;
   os << "Percentage of CPU/total time: "   << effT << endl;
}
\end{verbatim}
}%footnotesize

\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StSmdEtaHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StSmdEtaHit}
    
\label{sec:StSmdEtaHit}
\begin{Entry}
\item[Summary]
    \name{StSmdEtaHit} represents a hit in the $\eta$
    shower-maximum-detector (SMD).

\item[Synopsis]
    \verb+#include "StSmdEtaHit.hh"+\\
    \verb+class StSmdEtaHit;+\\

\item[Description]
    \name{StSmdEtaHit} inherits all functionality from \name{StEmcHit}.
    For a complete description of the inherited member functions
    see \name{StEmcHit} (sec.~\ref{sec:StEmcHit}).

\item[Persistence]
}%footnotesize    

\item[Related Classes]
    \name{StSmdEtaHit} is derived directly from \name{StEmcHit}.
    The hits are kept in an instance of \name{StSmdEtaHitCollection}
    where they are stored by value (see \ref{sec:collections}).
    \index{StEmcHit}
    \index{StSmdEtaHitCollection}

\item[Public\\ Constructors]
    \verb+StSmdEtaHit(int i, float E, float phi, float eta);+ \\
    Create an instance of \name{StSmdEtaHit} with identifier \name{i},
    energy deposition \name{E} and position \name{phi}, \name{eta}.

    \name{StSmdPhiHit} represents a hit in the $\phi$ shower-maximum-detector (SMD).
    
\item[Synopsis] 
//  Count the hits above given threshold minEnergy
//
    
{
   StSmdEtaHitCollection* hits = event->emcTowerHitCollection();
   double counter = 0;
   StSmdEtaHitIterator iter;
    
       if (iter->energy() > minEnergy) counter++;
   return counter;
}
\end{verbatim}
}%footnotesize

\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StSmdPhiHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StSmdPhiHit}
    
\label{sec:StSmdPhiHit}
\begin{Entry}
\item[Summary]
    \name{StSmdPhiHit} represents a hit in the $\phi$
    shower-maximum-detector (SMD).

\item[Synopsis]
    \verb+#include "StSmdPhiHit.hh"+\\
    \verb+class StSmdPhiHit;+\\

\item[Description]
    \name{StSmdPhiHit} inherits all functionality from \name{StEmcHit}.
    For a complete description of the inherited member functions
    see \name{StEmcHit} (sec.~\ref{sec:StEmcHit}).

\item[Persistence]
    None

\item[Related Classes]
}%footnotesize    
    The hits are kept in an instance of \name{StSmdPhiHitCollection}
    where they are stored by value (see \ref{sec:collections}).
    \index{StEmcHit}
    \index{StSmdPhiHitCollection}

\item[Public\\ Constructors]
    \verb+StSmdPhiHit(int i, float E, float phi, float eta);+ \\
    Create an instance of \name{StSmdPhiHit} with identifier \name{i},
    energy deposition \name{E} and position \name{phi}, \name{eta}.

\item[Examples] \index{sort (example)}
{\footnotesize
\begin{verbatim}
bool operator<(const StSmdPhiHit &x, const StSmdPhiHit &y)
    
\item[Synopsis] 
}

    
//  Sort all hits in the SmdPhiHitCollection according to their energy.
    \name{StSvtHit} inherits most functionality from \name{StHit}.  For a complete
    description of the inherited member functions see \name{StHit}
    (sec.~\ref{sec:StHit}).
void sortSmdPhiHits(StEvent *event)
{
   StSmdPhiHitCollection* hits = event->emcTowerHitCollection();
   sort(hits->begin(), hits->end());
}
\end{verbatim}
}%footnotesize
    StSvtHit.    
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StSvtHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StSvtHit}
\index{SVT hit} \index{StSvtHit|textbf}
    which were used to reconstruct the global track. 
\begin{Entry}
\item[Summary]
    \name{StSvtHit} represents a SVT hit.

\item[Synopsis]
    \verb+#include "StSvtHit.hh"+\\
    \verb+class StSvtHit;+\\

\item[Description]    
    \name{StSvtHit} inherits most functionality from \name{StHit}.
    
    \name{StHit} (sec.~\ref{sec:StHit}).

    In the \StEvent\ data model each track keeps references to the
    associated hits but not vice versa. In order to allow
    the reverse navigation \name{StSvtHit} adds a method
    collection passed as argument.  The number of elements
    equals the reference count
    (\name{StSvtHit::trackReferenceCount()}) if the track collection is
    the actual track collection obtained from
    \name{StEvent::trackCollection().}  Note that this functions has to iterate
    over the given track collection in order to setup the return
    argument. The time to collect the referring tracks goes linear
    with the size of the given collection \name{coll}.
    For information on the returned collection class see sec.~\ref{sec:collections}.
    
    The hits are kept in an instance of \name{StSvtHitCollection}
    where they are stored by pointer (see \ref{sec:collections}).
    Each instance of \name{StGlobalTrack} holds a list of SVT hits
    which were used to reconstruct the global track.
    \index{StHit}
    \index{StGlobalTrack}
    \index{StSvtHitCollection}

\item[Public\\ Constructors]
    \verb+StSvtHit(const StThreeVector<float>& pos,+\\
    \verb+         const StThreeVector<float>& err,+\\
    StSvtHitCollection *hits = 
    Create an instance of \name{StSvtHit} with position \name{pos},
    position error \name{err}, charge \name{q}, and reference count \name{cnt}.

    for(iter = hits->begin(); 
    \verb+StVecPtrGlobalTrack+\\
    \verb+relatedTracks(const StTrackCollection& coll);+\\
    Returns a collection of tracks stored in \name{coll} which
            theList.push_back(hit);        
    collection passed as argument.  The number of elements equals the
    reference count (\name{StSvtHit::trackReferenceCount()}) if the
}  
    \name{StEvent::trackCollection().}  Note that this functions has
    to iterate over the given track collection in order to setup the
    return argument. The time to collect the referring tracks goes
    linear with the size of the given collection \name{coll}.  For
    information on the returned collection class see
    sec.~\ref{sec:collections}.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  Function which returns a vector of SVT hits
//  each used by more than N tracks.
//
vector<StSvtHit*>
    
\item[Synopsis] 
    vector<StSvtHit*> theList;
    StSvtHitCollection *hits =
    
\item[Description]    
    \name{StTpcHit} inherits most functionality from \name{StHit}.  For a complete
    description of the inherited member functions see \name{StHit}
    (sec.~\ref{sec:StHit}).
        hit = iter;
        if (hit->trackReferenceCount() > N)
            theList.push_back(hit);
    }
    return theList;
}
    See sec.~\ref{sec:StTrackPidTraits}   
    \name{StTpcHit}.    
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StTpcHit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StTpcHit}
\index{TPC hit} \index{StTpcHit|textbf}
    which were used to reconstruct the global track. 
\begin{Entry}
\item[Summary]
    \name{StTpcHit} represents a TPC hit.

\item[Synopsis]
    \verb+#include "StTpcHit.hh"+\\
    \verb+class StTpcHit;+\\

\item[Description]
    \name{StTpcHit} inherits most functionality from \name{StHit}.
    
    \name{StHit} (sec.~\ref{sec:StHit}).

    In the \StEvent\ data model each track keeps references to the
    associated hits but not vice versa. In order to allow
    the reverse navigation \name{StTpcHit} adds a method
    \name{relatedTracks()} which allows to obtain a list of tracks
    which were reconstructed using this hit, i.e., a list of pointers
    to global tracks (StGlobalTrack$*$) which reference objects of type
    \name{StTpcHit}.

\item[Persistence]
    None

\item[Related Classes]
    
    The hits are kept in an instance of \name{StTpcHitCollection}
    where they are stored by pointer (see \ref{sec:collections}).
    Each instance of \name{StGlobalTrack} holds a list of TPC hits
    which were used to reconstruct the global track.
    \index{StHit}
    \index{StGlobalTrack}
    \index{StTpcHitCollection}

\item[Public\\ Constructors]
    \verb+StTpcHit(const StThreeVector<float>& pos,+\\
    \verb+         const StThreeVector<float>& err,+\\
    \verb+         float q, unsigned char cnt = 0);+\\
    Create an instance of \name{StTpcHit} with position \name{pos},
    position error \name{err}, charge \name{q}, and reference count \name{cnt}.

\item[Public Member\\ Functions]
    \verb+StVecPtrGlobalTrack+\\
    \verb+relatedTracks(const StTrackCollection& coll);+\\
    Returns a collection of tracks stored in \name{coll} which
    reference this hit.  The individual elements are a subset of the
    collection passed as argument.  The number of elements
    equals the reference count
    (\name{StTpcHit::trackReferenceCount()}) if the track collection is
    the actual track collection obtained from
    \name{StEvent::trackCollection().}  Note that this functions has to iterate
    over the given track collection in order to setup the return
    argument. The time to collect the referring tracks goes linear
    with the size of the given collection \name{coll}.
    For information on the returned collection class see sec.~\ref{sec:collections}.

\item[Examples]  \index{sort (example)} \index{gap between hits (example)}
{\footnotesize
\begin{verbatim}
//
//  Function which returns the largest gap along the trajectory
//  of a track in the TPC, i.e., the largest distance between
//  two neighboured TPC hits. Since we cannot rely on the
//  tpc hit list to be ordered we order them using the STL
//  'sort' function. Care has to be taken since the TPC hit
//  collection stores the hits by pointer.
//

//
// Needed by the STL sort algorithm. 'sort' passes
// always dereferenced iterators which in our case
// are two pointers to the TPC hits to be compared.
// Here we are free to define whatever sort criterion
// we need. In this version we compare the two hits
// according to their radial position.
// StTpcHit::position() returns a StThreeVector which
// perp() method returns the radius in cylindrical
// coordinates.
//
struct compRadiusOfHits {
    bool operator()(const StTpcHit *x, const StTpcHit *y) {
        return x->position().perp() < y->position().perp();
    }
};

double largestGap(StGlobalTrack &track)
{
    //
    // Make a copy of all TPC hits on the track
    //
    StVecPtrTpcHit hits(track.tpcHits());

    //
    // Sort the hits according to r (use STL sort)
    // (here we actually sort the pointers to the hits)
    //
}  

    //
    // Get the path length s on the track for the first hit
    // Note:
    // - the hit does not necessarily lie directly on the
    //   trajectory. Here we use the path length at the
    //   distance-of-closest approach.
    // - s is measured from the origin of the track.
    //   However, this algorithm does not depend on the
    //   actual origin. It could be arbitrary since we
    //   are only interested in distances.
    //
    double sLast = track.helix().pathLength(hits[0]->position());

    //
    // Loop all hits and find the largest gap
    //
    double s;            // the path length
    double gap;          // the current gap
    double maxGap = 0;   // the max gap so far

    for (int i=1; i<hits.size(); i++) {
    
\item[Synopsis] 
        if (gap > maxGap) maxGap = gap;
        sLast = s;
    }

    \name{StTrack} provides the basic features and functionality to describe
    a general track. It serves as base class for \name{StGlobalTrack} which
    is on a DST.
    \name{StTrack} provides information on the start and end vertices which
    mark the beginning and end of a track, the results of the
    fitting procedure used in the track reconstruction and on the
    track parameters themself. The current track model is described
    by a helix. The helix is modelled by the \name{StPhysicalHelix} class
    which itself is derived from \name{StHelix}. Both classes are part of the
    StarClassLibrary (SCL). More details on the model can be found in the
    SCL manual (see sec.~\ref{sec:furtherdoc} on how to get the manual).
    The helix classes offer a lot of functionality to extrapolate tracks, find
    the intersection of a track with planes and cylinders, obtain the
    distance of closest approach to a certain point in space or another helix,
    and lets you calculate the momentum on every point at the helix.
    \name{StTrack}, however, serves only as a base class for more specialized
    track classes and does not provide information on the hits from the
    provides information on the start and end vertices which mark the
    Because of its higher abstraction level \name{StTrack} can therefore be used
    to build your own customized track classes if needed.
    \name{StTrack} is a virtual class.
    
    is derived from \name{StHelix}. Both classes are part of the
    StarClassLibrary (SCL). More details on the model can be found in

    manual).  The helix classes offer a lot of functionality to
    The class \name{StGlobalTrack} which described global tracks in the STAR
    detector is derived from \name{StTrack}.
    

    describe a general track. It serves as base class for
    \name{StGlobalTrack} which is the more relevant type in \StEvent.
    Constructs an instance of \name{StHit} with all values initialized to 0 (zero).

    track parameters themself. The current track model is described by
    a helix. The helix is modelled by the \name{StPhysicalHelix} class
    which itself is derived from \name{StHelix}. Both classes are part
    
    \verb+StPhysicalHelix& helix();+\\
    get the manual).  The helix classes offer a lot of functionality
    to extrapolate tracks, find the intersection of a track with
    \verb+StVertex* startVertex();+\\
    
    the momentum on every point at the helix.  \name{StTrack},
    however, serves only as a base class for more specialized track
    
    \verb+StVertex* stopVertex();+\\
    Because of its higher abstraction level \name{StTrack} can
    therefore be used to build your own customized track classes if
    \verb+StTrackFitTraits& fitTraits();+\\

    
    None
    
\item[Related Classes]
    
    Returns a reference to \name{StTrackPidTraits} which keeps
    information on the particle which can be associated with the track.
    
    \verb+void setHelix(const StPhysicalHelix&);+\\
    Constructs an instance of \name{StHit} with all values initialized
    
    \verb+void setStopVertex(StVertex*);+\\            
\item[Public Member\\ Functions]
    \verb+virtual StPhysicalHelix& helix();+\\
    \verb+void setStopVertex(StVertex*);+\\

    Returns true (1) if two instances of \name{StTrack} are equal or false (0)
    if otherwise.
    The only data member used for the comparison is the helix model,
    i.e., the track parameters.
    point on the track.
    \verb+virtual StVertex* stopVertex();+\\
    Returns true (1) if two instances of \name{StTrack} are not equal or false (0)
    if otherwise. 
    This operator is implemented by simply inverting \name{operator==}.
            
    to obtain information on the particle identification (PID)
    of the current track.

    \verb+virtual StTrackFitTraits& fitTraits();+\\
    Returns a reference to \name{StTrackFitTraits} which keeps
    information on the covariant matrix, the $\chi^2$ of the
    fits, the degrees of freedom, and the actual number of fit
    points used.

    \verb+virtual void setHelix(const StPhysicalHelix&);+\\
    Sets the track parameters through the helix model..

    \verb+virtual void setStartVertex(StVertex*);+\\
    Sets the start vertex.

    \verb+virtual void setStopVertex(StVertex*);+\\
    
    
    
    \verb+int operator==(const StTrack&) const;+\\
    Returns true (1) if two instances of \name{StTrack} are equal or
    false (0) if otherwise.  The only data member used for the
    comparison is the helix model, i.e., the track parameters.
    

    \verb+int operator!=(const StTrack&) const;+\\
    Returns true (1) if two instances of \name{StTrack} are not equal
        if (s == s2) break;           // all done     
    inverting \name{operator==}.

\item[Examples]
}%footnotesize    
\begin{verbatim}
//
//  Print the momentum vector every 10 cm beginning at the
//  start vertex to the stop vertex.
//
void printMom(StTrack &track)
%    Reference: StV0Vertex
    StPhysicalHelix& helix = track.helix();

\subsection{StV0Vertex}
\index{StV0Vertex|textbf}
\index{vertex class}
\label{sec:StV0Vertex}
    double s2 = helix.pathLength(track.stopVertex()->position());

    \name{StV0Vertex} describes a V0 vertex, i.e.~a decay vertex of one
    parent into two dauhters.
    
        if (s >= s2) s = s2;        // make sure to get the last point
    \verb+#include "StV0Vertex.hh"+\\
    \verb+class StV0Vertex;+\\
  
\item[Description] 
    \name{StV0Vertex} is a specialisation of the more general
    \name{StVertex} class. \index{StVertex} Its type
    (\name{StVertex::type()}) is always V0. It cannot be changed.  In
    addition to the functionalty inherited from \name{StVertex} the
    class carries information on the distance-of-closest-approach
    (DCA) between each of the two daughter tracks and the
    primary vertex, the DCA between the parent track and the primary vertex, 
    the DCA between the two daughter tracks, and the
    momentum of the daughters at the V0 vertex. The latter can be
    different from the momentum obtained via the actual daughter
    tracks (\name{StGlobalTrack::helix().momentumAt()}) since the
    locally stored momentum is the result of a fit using the
    information of the V0 vertex.
    
    The data stored is taken from the \name{dst\_v0\_vertex.idl}
    table.\index{dst\_v0\_vertex.idl} The collection of all vertices
    (class \name{StVertexCollection}) in the event can be obtained
    through \name{StEvent::vertexCollection()}.  Remember that
    \name{StVertexCollection} stores all elements by pointer and that
    the actual vertex collection contains various types of vertices.
    In order to access member functions from a derived classes the
    instance must be casted to its actual type. This is shown in one
    of the examples.\index{type cast}
}
\end{verbatim}
}%footnotesize
%    Reference: StTrackPidTraits
%
    \name{StV0Vertex} inherits from  \name{StVertex}.
    All vertices in one event are stored
    in the StVertexCollection class. The collection stores the
    vertices by pointer; it is a plymorphic container.
    The same collection holds also different classes as \name{StVertex} and \name{StXiVertex}.
    \index{StVertex}
    \index{StXiVertex}
    \index{StVertexCollection}
   
    (DCA) between each of the two daughter tracks and the
    primary vertex, the DCA between the parent track and the primary vertex,
    the DCA between the two daughter tracks, and the
    momentum of the daughters at the V0 vertex. The latter can be
    
    tracks (\name{StGlobalTrack::helix().momentumAt()}) since the
    
    information of the V0 vertex.

    The data stored is taken from the \name{dst\_v0\_vertex.idl}
    \verb+float dcaDaughterToPrimaryVertex(StTrackSign sign) const;+\\
    through \name{StEvent::vertex\-Collection()}.  Remember that
    \name{StVertexCollection} stores all elements by pointer and that
    
    In order to access member functions from a derived classes the
    instance must be casted to its actual type. This is shown in one
    
    \verb+float dcaDaughters() const;+\\
\item[Persistence]
    \name{StVertex} and \name{StXiVertex}.  \index{StVertex}
    \verb+const StThreeVector<float>& momentumOfDaughter(StTrackSign sign) const;+\\
    \verb+StV0Vertex();+\\
    \verb+const StThreeVector<float>&+\\
    values initialized to 0 (zero).
    \verb+StV0Vertex(dst_v0_vertex_st* v0vtx, dst_vertex_st* vtx);+\\
    Constructor using a \name{dst\_v0\_vertex.idl} table
    entry.\index{dst\_v0\_vertex.idl} A pointer to the corresponding
    Pointer to the negative (\name{sign=negativeTrack}) or positive
    (\name{sign=negativeTrack}) or positive
    (\name{sign=positiveTrack}) daughter track to the primary vertex.
    \verb+void setMomentumOfDaughter(StTrackSign sign, const StThreeVector<float>&);+\\
    \verb+dcaDaughterToPrimaryVertex(StTrackSign sign) const;+\\
    \verb+void setMomentumOfDaughter(StTrackSign sign,+\\
    \name{StTrackSign} is defined in the \name{StEnumerations.hh}
    header file.

    \verb+void setType(StVertexType);+\\          
    This virtual memner function (inherited from \name{StVertex}) gets overwritten
    in \name{StV0Vertex}. The method does \textbf{not} set the type but prints
    an error message only. Instances of \name{StV0Vertex} have a fix type: V0.
    
    

    \verb+virtual StThreeVector<float> momentum() const;+\\
    Momentum of the v0 vertex.
    

    \verb+virtual void+\\
    \verb+setDcaDaughterToPrimaryVertex(StTrackSign sign, float);+\\
    Sets the DCA between a daughter track and the primary vertex.
    

    StVertexCollection *vertices = 
    Sets the DCA between the parent track and the primary vertex.
    

    \verb+virtual void setMomentumOfDaughter(StTrackSign sign,+\\
    for (iter = vertices->begin(); 
    Sets the momentum of a daughter track.
    

    \verb+virtual void setDcaDaughters(float);+\\
             if (v0p->dcaDaughters() < limit) 
    
         }  
    \verb+void setType(StVertexType);+\\
    This virtual member function (inherited from \name{StVertex}) gets
}  
  
    \name{StV0Vertex} have a fix type: V0.

\item[Examples]
{\footnotesize
\begin{verbatim}
//
// Count V0s where both daughters get closer than a
// given value (limit) to the V0 vertex.
//

unsigned long countGoodV0s(StEvent *event, double limit)
{
    unsigned long counter = 0;
    StVertexCollection *vertices =
                    event->vertexCollection();
    StVertexIterator iter;
    StV0Vertex *v0p;
    or several tracks 
    
    for (iter = vertices->begin();
         iter != vertices->end(); iter++) {
         vertex = *iter;
  
             if (v0p->dcaDaughters() < limit) counter++;
    \name{StVertex} describes a general vertex in the STAR detector. It uses the information
    stored in the \name{dst\_vertex.idl} table.\index{dst\_vertex.idl}
    \name{StVertex} has a position, a position error and can be characterized
    by its type. Each vertex can have 0 or 1 parent track and 0...n daughter
    tracks. All are referenced by pointers. In addition \name{StVertex}
}%footnotesize
    The collection of all vertices in the event can be obtained through
    \name{StEvent::vertexCollection()}.
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    through \name{StEvent::vertexCollection()}.
%    Reference: StVertex
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StVertex}
\index{StVertex|textbf}
    vertices by pointer; it is a plymorphic container.
\index{general vertex class}
\label{sec:StVertex}
\begin{Entry}
\item[Summary]
   
    or several tracks

\item[Synopsis]
    \verb+#include "StVertex.hh"+\\
    

\item[Description]
        \name{StVertex} describes a general vertex in the STAR detector.
    It uses the information stored in the \name{dst\_vertex.idl}
    \verb+StVertexType type();+\\
    
    can have 0 or 1 parent track and 0...n daughter tracks. All are
    referenced by pointers. In addition \name{StVertex}
    provides information on the $\chi^2$ of the vertex fit.\\
    
    through \name{StEvent::ver\-tex\-Col\-lection()}.

    
    \verb+unsigned int numberOfDaughters();+\\

    vertices by pointer; it is a polymorphic container.
    \verb+StGlobalTrack* daughter(unsigned int i);+\\
    
    \index{StXiVertex}
    \index{StVertexCollection}
    
    \verb+const StGlobalTrack* parent();+\\
    \verb+StVertex();+\\
    
    \verb+const StThreeVector<float>& position();+\\

    
    \verb+const StThreeVector<float>& positionError();+\\
    table entry.\index{dst\_vertex.idl}
    
    \verb+float chiSquared();+\\        
    \verb+virtual StVertexType type();+\\
    
    twoBody, threeBody, nBody, pileUpPrimary, V0, or Xi}.
    \name{StVertexType} is defined in \name{StEnumerations.hh}.
    
    \verb+virtual StVecPtrGlobalTrack& daughters();+\\
    Vector of pointers to all daughter tracks. Note that
    
    \verb+void setParent(StGlobalTrack* );+\\
    \verb+virtual unsigned int numberOfDaughters();+\\
    
    \verb+void setPosition(const StThreeVector<float>&);+\\
    \verb+virtual StGlobalTrack* daughter(unsigned int i);+\\
    
    \verb+void setPositionError(const StThreeVector<float>&);+\\
    (Index runs from 0 to \name{numberOfDaughters()-1}).
    
    \verb+void setChiSquared(float); +\\    
    Pointer to parent track or null pointer if no parent stored.

    \verb+void setChiSquared(float); +\\
    \verb+virtual StThreeVector<float> momentum(double B);+\\
    Momentum of the vertex given the magnetic field B.
    Returns the momentum of the parent track, or (if no parent)
    the sum of the momenta of the daughter tracks.

       
    bitmask of quality information.

    if otherwise. 
    $\chi^2$ of vertex fit
    
    \verb+virtual void setType(StVertexType);+\\
    Sets vertex type.

    \verb+virtual void setParent(StGlobalTrack* );+\\
    Sets pointer to parent track.

    \verb+virtual void setPosition(const StThreeVector<float>&);+\\
    Sets vertex position.

    \verb+virtual void setPositionError(const StThreeVector<float>&);+\\
    Sets position error.
    StTrackCollection *tracks = 
    \verb+virtual void setQualityBitmask(unsigned long); +\\
    Sets bitmask of quality information.

    \verb+virtual void setChiSquared(float); +\\
    Sets $\chi^2$ of vertex fit.

\item[Public Member\\ Operators]
    \verb+int operator==(const StVertex&) const;+\\
            vertex->type() == primaryVertex)      
    if otherwise.
    The only data members used for the comparison are the position and the
    vertex type.
}  
    \verb+int operator!=(const StVertex&) const;+\\
    Returns true (1) if two instances of \name{StVertex} are not equal or false (0)
    if otherwise.
    This operator is implemented by simply inverting \name{operator==}.

\item[Examples] \index{primary vertex}
{\bf Example 1:}
{\footnotesize
\begin{verbatim}
//
//  Function to count # of tracks originating
//  from the primary vertex.
//
unsigned long countPrimaryTracks(StEvent *event)
{
    TrackCollection *tracks = 
    StTrackCollection *tracks =
                event->trackCollection();
    StTrackIterator i;
    StGlobalTrack   *track;
    StVertex        *vertex;
        double dist = 
        track = *i;
        if(dist < limit) counter++  
        if (vertex &&
            vertex->type() == primaryVertex)
}  
    }
}%footnotesize    
}
\end{verbatim}
}%footnotesize

{\bf Example 2:}
{\footnotesize
\begin{verbatim}
//
// Function to count # of tracks below a given
// distance-of-closest-approach to a given vertex.
//
unsigned long countCloseOnes(StEvent *event,
                             const StVertex& vertex,
                             double limit)
{
    \name{StVpdCounter} represents a single 
    vertex position detector (VPD) counter.  
    
        if(dist < limit) counter++
    StGlobalTrack   *track;
    for (i = tracks->begin(); i != tracks->end(); i++) {
  
        double dist =
             track->helix().distance(vertex.position());
        if(dist < limit) counter++;
    }
    return counter;
}
\end{verbatim}
    

\end{Entry}
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: StVpdCounter
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StVpdCounter}
\index{StVpdCounter|textbf}
   
\index{vertex position detector}
\label{sec:StVpdCounter}
\begin{Entry}
    
    \name{StVpdCounter} represents a single
    vertex position detector (VPD) counter.

\item[Synopsis]
    \verb+#include "StVpdCounter.hh"+\\
    \verb+class StVpdCounter;+\\

    
    \index{dst\_TriggerDetectors.idl}
    \name{StVpdCounter} holds information on a single VPD counter as
    
    \name{dst\_TriggerDetectors.idl} table. Each counter
    is identified by an ID. The class holds the ADC value and the counter
    

\item[Persistence]
    

\item[Related Classes]
    
    summarized in the \name{StVpdSummary} class.  The list of
    \name{StVpdCounter} objects (collection class
    
    \name{StTriggerDetectorCollection}.  \index{StVpdSummary}
    \index{StVecVpdCounter} \index{StTriggerDetectorCollection}

\item[Public\\ Constructors]
    \verb+StVpdCounter();+ \\
    Constructs an empty VPD counter. All values are initialized to 0 (zero).

    \verb+StVpdCounter(short id, float adc, float t);+ \\
    StTriggerDetectorCollection* tds = event->triggerDetectorCollection();

\item[Public Member\\ Functions]
    \verb+short id() const;+ \\
    Unique counter ID.

    \verb+float adc() const;+ \\
}%footnotesize    
    \verb+float dcaParentToPrimaryVertex() const;+\\
    \verb+StThreeVector<float>& momentumOfV0() const;+\\
    \verb+StThreeVector<float> momentum() const;+\\
    \verb+StV0Vertex* v0Vertex() const;+\\

    \verb+void setDcaBachelorToPrimaryVertex(float);+\\
    Sets the DCA of the bachelor to the primary vertex.

    \verb+void setMomentumOfBachelor(const StThreeVector<float>&);+\\
//  What the example does
    \verb+void setDcaDaughters(float);+\\
Gene ...
    StVertex   *vertex;
    for (iter = vertices->begin();
    \name{StZdzSegment} represents a single 
    zero degree calorimeter (ZDC) segment.  
    
         if (vertex->type() == Xi) {
             xip = dynamic_cast<StXiVertex*>(vertex);
\index{zero degree calorimeter}
  
             if (xiMom.perp() > limit) counter++;
         }
    }
    return counter;
}

    
}%footnotesize

\end{Entry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    The list of \name{StZdzSegment} objects (collection class \name{StVecZdcSegment}) can be obtained
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{StZdcSegment}
    \name{StZdzSegment} represents a single
   
\index{zero degree calorimeter (ZDC)}
\label{sec:StZdcSegment}
\begin{Entry}
    
    \name{StZdcSegment} represents a single
    zero degree calorimeter (ZDC) segment.

    \name{StZdzSegment} holds information on a single ZDC segment as
    \verb+#include "StZdcSegment.hh"+\\
    \verb+class StZdcSegment;+\\

    
    \index{dst\_TriggerDetectors.idl}
    \name{StZdcSegment} holds information on a single ZDC segment as
    
    \name{dst\_TriggerDetectors.idl} table. Each segment
    is identified by an ID. The class holds the ADC and TDC value.
    
\item[Persistence]
    None
    
\item[Related Classes]
    The information of all ZDC segments is summarized in the \name{StZdcSummary} class.
    
    (collection class \name{StVecZdcSegment}) can be obtained
    through the StTriggerDetectorCollection.
    
    \index{StVecZdcSegment}
    \index{StTriggerDetectorCollection}

\item[Public\\ Constructors]
    \verb+StZdcSegment();+ \\
    Constructs an empty ZDC segment. All values are initialized to 0 (zero).

    \verb+StZdcSegment(short id, float adc, float tdc);+ \\
    StTriggerDetectorCollection* tds = event->triggerDetectorCollection();

\item[Public Member\\ Functions]
    \verb+short id() const;+ \\
    Unique segment ID.

    \verb+float adc() const;+ \\
    ADC value.
}%footnotesize    
    
\item[Persistence]
    None

\item[Related Classes]
    None

\item[Public\\ Constructors]
    \verb+StZdcSummary();+\\
    Default constructor. All data member are initialized to 0 (zero).
    
    \verb+StZdcSummary(float ae, float aw, float s);+\\


% classes still missing
StTrackFitTraits.hh
StTrackPidTraits.hh
StTriggerDetectorCollection.hh
StTrigger.hh
StVpdSummary.hh
StXiVertex.hh
StZdcSummary.hh
Hit2D.  If the name of a class would be shown in italics, it would
TrackFitter class and the CalibrartionDB class. This is the \emph{dependency}
relationship. This is often called a \emph{using} relationship.  This
relationship simply means that TrackFitter somehow depends upon
CalibrartionDB. In C++ this almost always results in a \#include:
{\footnotesize
\begin{verbatim}
class Hit3D : public Hit2D {
public:
    double z();
    double distanceTo(Hit3D& h);
private:
    double mZ;
};
\end{verbatim}
    

\subsection{Aggregation and Association}

  
relationship denotes that the aggregate class (the class with the
    
class in the relationship is somehow "part" of that whole.
Fig.~\ref{fig:umlAggregation} shows an \emph{aggregation}
relationship.
\begin{figure}[htb]
   
        \includegraphics{umlAggregation.eps}
        \caption{Aggregation.}
        \label{fig:umlAggregation}
    \end{center}
\end{figure}
    
ends of a relationship are referred to as its "roles''. Notice that
    
This indicates that the Track contains many Hit instances.  The
    
implemented in C++ as:

{\footnotesize
\begin{verbatim}
class Track {
public:
    // ...
private:
}%footnotesize    
};
\end{verbatim}
}%\footnotesize

There are other forms of containment that do not have whole/part
implications. For example, each \name{Vertex} refers back to its
parent Track. This is not aggregation since it is not reasonable to
consider a parent Track to be part of a child Vertex. We use the
\emph{association} relationship to depict this.

\begin{figure}[htb]
    \begin{center}
        \includegraphics{umlAssociation.eps}
        \caption{Association.}
        \label{fig:umlAssociation}
    \end{center}
\end{figure}

Fig.~\ref{fig:umlAssociation} shows how we draw an association.  An
association is nothing but a line drawn between the participating
classes. In Fig.~\ref{fig:umlAssociation} the association has an
arrowhead to denote that Track does not necessarily know anything
about Vertex. This relationship will almost certainly be implemented
with a pointer of some kind.

What is the difference between an aggregation and an association?
Aggregation denotes whole/part relationships whereas associations do
not. However, there is not likely to be much difference in the way
that the two relationships are implemented.  That is, it would be very
difficult to look at the code and determine whether a particular
relationship ought to be aggregation or association.  Aggregation and
Association both correspond to the \emph{has-by-reference}
relationship.

\subsection{Dependency}

Sometimes the relationship between a two classes is very weak. They
are not implemented with member variables at all. Rather they might be
implemented as member function arguments.

Consider, for example, the fit function of a TrackFitter class.
Suppose that this function takes an argument of type CalibrartionDB
since it requires information from it (e.g. if the magnetic field was
on or off) in order to perform the fit.
\begin{figure}[htb]
    \begin{center}
        \includegraphics{umlDependency.eps}
        \caption{Dependency.}
        \label{fig:umlDependency}
    \end{center}
\end{figure}
Fig.~\ref{fig:umlDependency} shows a dashed arrow between the
TrackFitter class and the CalibrartionDB class. This is the
\emph{dependency} relationship. This is often called a \emph{using}
relationship.  This relationship simply means that TrackFitter somehow
depends upon CalibrartionDB. In C++ this almost always results in a
\#include:

{\footnotesize
\begin{verbatim}
#include "CalibrartionDB.hh"
class TrackFitter {
public:
    // ...
    void fit(CalibrartionDB &db);
private:
    // ...
};
\end{verbatim}
}%\footnotesize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% The End
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printindex

\end{document}
\bye
% The text following after this line is not included into the text

%
%  Template for reference section
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Reference: className
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{className}
\index{className|textbf}
\label{sec:className}
\begin{Entry}
\item[Summary]

\item[Synopsis]
    \verb+#include "className.hh"+\\
    \verb+class className;+\\

\item[Description]

\item[Persistence]
    None

\item[Related Classes]

\item[Public\\ Constructors]

\item[Public Member\\ Functions]

\item[Public Member\\ Operators]

\item[Public Functions]

\item[Public Operators]

\item[Examples]
{\footnotesize
\begin{verbatim}
//
//  What the example does
//

\end{verbatim}
}%footnotesize

\end{Entry}
