//*-- Author :    Valery Fine(fine@bnl.gov)   10/08/98 
// 
// 
// 
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// St_db_Maker class for Makers                                      //
//                                                                      //
// This class is C++ implementation of the Begin_html <a href="http://www.rhic.bnl.gov/afs/rhic/star/doc/www/packages_l/pro/pams/db/sdb/doc/index.html">Simple Database Manager</a> End_html    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
#define MYSQLON 1999

#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>
#include "TBrowser.h"
#include "TDatime.h"
#include "TRegexp.h"
#include "TInterpreter.h"
#include "TFile.h"
#include "TSystem.h"
#include "St_db_Maker.h"
#include "St_DataSetIter.h"
#include "St_FileSet.h"
#include "St_XDFFile.h"
#include "StTree.h"

#include "St_tableDescriptor.h"
#include "St_Table.h"

#include "StDbBroker.h"

static Int_t AliasDate(const char *alias);
static Int_t AliasTime(const char *alias);
static const char *aliases[]={"sd97",   "sd98",   "year_1a","year_1b","year_1c"
			     ,"es99",   "er99"
                             ,"year_1d","year_1e","year_2a","nofield",      0};   

static const int   dates[]=  {19970101, 19980101, 19990101, 19990501, 19991001
			     ,19990615, 19990616
                             ,19991101, 19991201, 20000101, 1996010,        0};
static const int   times[]=  {       0,        0,        0,        0,        0
			     ,       0,   120000
                             ,       0,        0,        0,        0,        0};

/////////////////////////////////////////////////////////////////////////
//                                          
//  Class St_tables_hierarchy wraps the STAF table tables_hierarchy 
//  It has been generated by automatic. Please don't change it "by hand" 
//                                          
/////////////////////////////////////////////////////////////////////////  
                                            
St_tableDescriptor *St_tables_hierarchy::fgColDescriptors = 0; 
TableImp(tables_hierarchy)                     
TableStreamerImp(tables_hierarchy)             


//_________________________ class St_Validity ____________________________________
class St_ValiSet : public St_DataSet{
public:
   TDatime fTimeMin;
   TDatime fTimeMax;
   St_DataSet *fDatCnt;
   St_DataSet *fDatSql;
   St_ValiSet(const char *name,St_DataSet *parent);
   virtual ~St_ValiSet(){};
   virtual void ls(Int_t lev=1);
};

//_____________________________________________________________________________
St_ValiSet::St_ValiSet(const char *name,St_DataSet *parent): St_DataSet(name,parent)
{
  SetTitle(".Val");
  fTimeMin.Set(kMaxTime,0);
  fTimeMax.Set(kMinTime,0);
  fDatCnt =0;fDatSql =0;
}

//_____________________________________________________________________________
void St_ValiSet::ls(Int_t lev)
{
  printf("  %s.Validity = %s ",GetName(),fTimeMin.AsString());
  printf(" <-> %s\n",     fTimeMax.AsString());
  if (fDatCnt) printf("  Contains DataSet %s\n",fDatCnt->GetName());
  St_DataSet::ls(lev);
}

//__________________________ class St_db_Maker  ____________________________
ClassImp(St_db_Maker)
//_____________________________________________________________________________
St_db_Maker::St_db_Maker(const char *name, const char *maindir,const char *userdir)
:StMaker(name)
{

   m_DBBroker = 0;

   m_Hierarchy = 0;
   fIsDBTime = 0;
   m_MainDir = maindir;
   if (userdir) m_UserDir=userdir;
   m_DataBase = 0;
}
//_____________________________________________________________________________
St_db_Maker::~St_db_Maker(){
}
//_____________________________________________________________________________
Int_t St_db_Maker::Init()
{
   St_FileSet *fileset;
   TString fullpath,topdir;

   m_DataBase=0;
   if (!m_MainDir.IsNull() && strncmp("MySQL:",(const char*)m_MainDir,6)==0){
     m_DataBase = OpenMySQL(((const char*)m_MainDir)+6);
     if (m_DataBase) m_DataBase->Pass(PrepareDB,0);
   }

// 		recreate a memory resided data-structure
   m_CurrentDir = m_MainDir;
   if (!m_DataBase && !m_CurrentDir.IsNull()) {
     fileset = new St_FileSet(m_CurrentDir);
     fileset->Purge(); 
     fileset->Sort(); 
     fileset->Pass(PrepareDB,&m_CurrentDir);
     fileset->Purge(); 
     if (m_DataBase) {
       assert(strcmp(m_DataBase->GetName(),fileset->GetName())==0);
       m_DataBase->Update(fileset); delete fileset;
     } else          {m_DataBase = fileset; }
   }

   m_CurrentDir = m_UserDir; fileset = 0;
   if (!m_CurrentDir.IsNull()) {
     fileset = new St_FileSet(m_CurrentDir);
     fileset->Purge();
     fileset->Sort(); 
     fileset->Pass(PrepareDB,&m_CurrentDir);
     fileset->Purge();
     if (m_DataBase) {
       assert(strcmp(m_DataBase->GetName(),fileset->GetName())==0);
       m_DataBase->Update(fileset); delete fileset;
     } else          {m_DataBase = fileset; }
   }
   m_DataBase->Sort();

   AddData(m_DataBase);
   SetOutput(m_DataBase); //  

   if (Debug()) m_DataBase->ls("*");
   OnOff();
   return 0;
}
//_____________________________________________________________________________
TDatime St_db_Maker::Time(const char *filename)
{
  int lfilename,lname,idate,itime;

  TDatime time; time.Set(kMaxTime,0);

  lfilename = strlen(filename);
  lname = strcspn(filename,".");
  if (lname+2>lfilename) return time;
  idate = ::AliasDate(filename+lname+1);
  itime = ::AliasTime(filename+lname+1);

  if (idate) { time.Set(idate,itime);return time;}

  if (lname+20 <= lfilename    &&
      filename[lname+1 ]=='.'  && 
      filename[lname+9 ]=='.'  && 
      filename[lname+18]=='.'  ) {// file name format:  <name>.YYYYMMDD.hhmmss.<ext>
       idate  = atoi(filename+lname+ 2); 
       itime  = atoi(filename+lname+11);
   } else {			   // file name format:  <name>.<ext>
       idate = kMinTime;
       itime = 0;
   }
   time.Set(idate,itime); return time;

}

int St_db_Maker::Kind(const char *filename)
{
   int lfilename;
   
   lfilename = strlen(filename);
   if (!strcmp(filename+lfilename-4,".xdf" )) return 1;
   if (!strcmp(filename+lfilename-2,".C"   )) return 2;
   if (!strcmp(filename+lfilename-2,".c"   )) return 2;
   if (!strcmp(filename+lfilename-5,".root")) return 3;
   return 0;
}
//_____________________________________________________________________________
St_DataSet *St_db_Maker::OpenMySQL(const char *dbname)
{
   TDatime vals[2];
   int nrows,irow;
   tables_hierarchy_st *thy,*ihy,*jhy;
   St_DataSet *top,*node,*ds;
   
   m_DBBroker  = new StDbBroker();

   if (!m_DBBroker) {
     Warning("OpenDB","***Can not open MySQL DB %s ***");
     return 0;
   }

   TString ts(dbname); ts+="_hierarchy";
   m_Hierarchy = (St_tables_hierarchy*)St_Table::New((const char*)ts,"tables_hierarchy",0,0);    
   assert(m_Hierarchy);
   int ierr = UpdateTable(m_Hierarchy,vals);
   if (ierr) return 0;
   
      
   nrows = m_Hierarchy->GetNRows();
   thy 	 = m_Hierarchy->GetTable();
   if (!thy) return 0;
   
   top = new St_DataSet(thy->parname);
   top->SetTitle("directory");

//first pass: directories only

   for (irow=0,ihy=thy; irow <nrows ; irow++,ihy++)
   {
     if (ihy->tabtype[0]!='.') continue;//skip tables
//		Check repetition for directories
     for (jhy=thy; jhy!=ihy;jhy++)
      {if (strcmp(ihy->tabname,jhy->tabname)==0 && jhy->tabtype[0]=='.' ) break;}
     if (jhy!=ihy) continue;
//
     node = top->FindByName(ihy->parname);
     if (!node && strcmp(ihy->parname,top->GetName())==0) node = top;
     assert(node);
     ds = new St_DataSet(ihy->tabname,node); ds->SetTitle("directory");
   }
   //add tables
   St_DataSetIter next(top,4);
   while ( (node=next()) ) {
     if ( !node->IsFolder() ) continue;
     for (irow=0,ihy=thy; irow <nrows ; irow++,ihy++)
     {
       if (ihy->tabtype[0]=='.') continue;//skip directories
       if (strcmp(ihy->parname,node->GetName())==0)
	 {
	   ds = St_Table::New(ihy->tabname,ihy->tabtype,0,0);
	   if(ds) node->Add(ds);
	 }
     }
   }
   //was:
//    for (irow=0,ihy=thy; irow <nrows ; irow++,ihy++)
//    {     
// //		Check repetition
//      for (jhy=thy; jhy!=ihy;jhy++)
//       {  if (strcmp(ihy->tabname,jhy->tabname)==0) break;}
//      if (jhy!=ihy) continue;
// //
//      node = top->FindByName(ihy->parname);
//      if (!node && strcmp(ihy->parname,top->GetName())==0) node = top;
//      assert(node);
//      if (ihy->tabtype[0]=='.') { 	// it is a node
//        ds = new St_DataSet(ihy->tabname,node); ds->SetTitle("directory");
//      } else {				// it is a table
//        ds = St_Table::New(ihy->tabname,ihy->tabtype,0,0); if(ds) node->Add(ds);
//      }
//    }
   return top;   
}


//_____________________________________________________________________________
St_DataSet *St_db_Maker::UpdateDB(St_DataSet* ds)
{ 
  if(!ds) return 0;
  ds->Pass(UpdateDB,this);
  return ds;
}
//_____________________________________________________________________________
int St_db_Maker::UpdateTable(St_Table* dat, TDatime val[2] )
{

  assert(m_DBBroker);assert(dat);
  m_DBBroker->SetDateTime(GetDateTime().GetDate(),GetDateTime().GetTime());
  St_tableDescriptor *rowTL = ((St_Table*)dat)->GetRowDescriptors();
  int nElements = rowTL->GetNRows();

  tableDescriptor_st *elem= rowTL->GetTable();

  assert(sizeof(StDbBroker::Descriptor)==sizeof(tableDescriptor_st));

  StDbBroker::Descriptor *descriptor = (StDbBroker::Descriptor *)elem;
  m_DBBroker->SetDictionary(nElements,descriptor);
  m_DBBroker->SetTableName (dat->GetName());
  m_DBBroker->SetStructName(dat->GetTitle());
  m_DBBroker->SetStructSize(dat->GetRowSize());

// 		if descriptor filled, no need for newdat
  void *dbstruct = m_DBBroker->Use();
  if (!dbstruct) {
    Warning("UpdateTable","Table %s.%s Not FOUND",dat->GetName(),dat->GetTitle());
    return 1;
  }

  int nRows = m_DBBroker->GetNRows();
//		Adopt DB data in the new St_Table
  dat->Adopt(nRows,dbstruct);
//  dat->Print(0,1);
  val[0].Set(m_DBBroker->GetBeginDate(),m_DBBroker->GetBeginTime());
  val[1].Set(m_DBBroker->GetEndDate  (),m_DBBroker->GetEndTime  ());

//  printf("BegVal=%s\n",val[0].AsString());
//  printf("EndVal=%s\n",val[1].AsString());
  return 0;

}

 //_____________________________________________________________________________
EDataSetPass St_db_Maker::UpdateDB(St_DataSet* ds,void *user )
{
  St_DataSet *left;
  St_ValiSet *val;
  TDatime timeMin,timeMax,valsCINT[2],valsSQL[2];
   
  if (strcmp(".Val",ds->GetTitle()))	return kContinue;
//
//	It is our place.
  val = (St_ValiSet*)ds;    
  St_db_Maker *mk = (St_db_Maker*)user;    
  TDatime currenTime = mk->GetDateTime();
  UInt_t uevent = currenTime.Get();

// 		Check validity
    if (val->fTimeMin.Get() <= uevent 
     && val->fTimeMax.Get() >  uevent) return kPrune;
    if (val->fDatCnt) delete val->fDatCnt; val->fDatCnt=0;

//	Start loop
  


  val->fTimeMin.Set(kMaxTime,0);
  val->fTimeMax.Set(kMinTime,0);

  delete val->fDatCnt; val->fDatCnt=0;
  ds->GetParent()->Remove(val->fDatSql);

  int kase = 0;
  if (val->fDatSql) {	// Try to load from MySQL
     
    int ierr = mk->UpdateTable((St_Table*)val->fDatSql, valsSQL );
    if (!ierr) kase = 1;
  }
  
  left = mk->FindLeft(val,valsCINT);
  if (left) kase+=2;
  
SWITCH:  switch (kase) {
  
    case 0:   break;  
    
    case 1:   val->fTimeMin = valsSQL[0];  val->fTimeMax = valsSQL[1]; 
              ds->GetParent()->AddFirst(val->fDatSql);
    break;

    case 2:   val->fDatCnt = mk->LoadTable(left);
              val->fTimeMin = valsCINT[0];  val->fTimeMax = valsCINT[1];
              ds->GetParent()->AddFirst(val->fDatCnt); break;
  
    case 3:   if (valsCINT[0].Get()>=valsSQL[0].Get()) {
                kase = 2; 
                if (valsCINT[1].Get()>valsSQL[1].Get()) valsCINT[1] = valsSQL[1];   
              } else {
                kase = 1;               
                if (valsSQL[1].Get()>valsCINT[1].Get()) valsSQL[1] = valsCINT[1];   
              }
              goto SWITCH;
    default:  assert(0);
  }
  
  return kPrune;  
}
//_____________________________________________________________________________
St_DataSet *St_db_Maker::FindLeft(St_ValiSet *val, TDatime vals[2])
{

//	Start loop
  UInt_t uevent = GetDateTime().Get();
  
  vals[0].Set(950101  ,0);
  vals[1].Set(kMaxTime,0);
  UInt_t utmp,udifleft=(UInt_t)(-1),udifrite=(UInt_t)(-1); 
  St_DataSet *left=0,*rite=0,*set=0; 
  TListIter next(val->GetList());
  while ((set = (St_DataSet*)next())) {
    const char *filename = set->GetName();
    UInt_t ucur = St_db_Maker::Time(filename).Get();
    if (uevent < ucur) 
    { utmp = ucur - uevent;
      if (utmp <= udifrite) { udifrite=utmp; rite=set;}
    }else{
      utmp = uevent - ucur;
      if (utmp <= udifleft) { udifleft=utmp; left=set;}
    }
  }// end while


  if (left) vals[0] = St_db_Maker::Time(left->GetName());
  if (rite) vals[1] = St_db_Maker::Time(rite->GetName());
  return left;
}


//_____________________________________________________________________________
St_DataSet *St_db_Maker::LoadTable(St_DataSet* left)
{
  TFile *tf =0;
  TObject *to =0;
  TString command;  
  St_DataSet *newdat = 0;
  TString dbfile = left->GetTitle()+5;


  St_DataSet *ds = left->GetParent();
  ds = ds->GetParent();
  dbfile += strchr(strstr(ds->Path(),"/.data/")+7,'/');
  dbfile += "/"; dbfile += left->GetName();
  gSystem->ExpandPathName(dbfile);
  
  switch (Kind(left->GetName())) {
  
    case 1: // .xdf file
    newdat = St_XDFFile::GetXdFile(dbfile);assert (newdat);
    break;

    case 2: // .C file

      command = ".L "; command += dbfile;
      gInterpreter->ProcessLine(command);
      newdat = (St_DataSet *) gInterpreter->Calc("CreateTable()");
      command.ReplaceAll(".L ",".U "); 
      gInterpreter->ProcessLine(command);

      break;

    case 3: // .root file
    
      tf = new TFile(dbfile);
      to = StIO::Read (tf, "*");
      delete tf;
      if (!to) break;
      if (strcmp(to->ClassName(),"StIOEvent")==0) to = ((StIOEvent*)to)->fObj;
      if (!to) break;
      if (to->InheritsFrom(St_DataSet::Class())) 	{
        newdat = (St_DataSet*)to; 
      } else 					{ 
	newdat = new St_ObjectSet(to->GetName());
	newdat->SetObject(to);
      }
    break;
    
    default: assert(0);
  }

  return newdat;
}

//_____________________________________________________________________________
EDataSetPass St_db_Maker::PrepareDB(St_DataSet* ds, void *user)
{
  St_DataSet *set;
  St_ValiSet *pseudo;
  const char *dsname,*filename,*dot;     
  char psname[100];
  int ldsname,lpsname;
  
  TList *list = ds->GetList();
  if (!list) return kContinue;
  if (strcmp("directory",ds->GetTitle())) return kPrune;
  dsname = ds->GetName(); ;
  if (!strcmp("CVS",dsname)) { delete ds; return kPrune;}
  ldsname= strlen(dsname);

  TString newTitle = "file ";
  if (user) newTitle += *((TString*)user);

//	Start loop
  pseudo = 0; psname[0]='.'; psname[1]=0;
  TListIter next(list);
  while ((set = (St_DataSet*)next())) {
    filename = set->GetName();
    int isSql =(set->InheritsFrom(St_Table::Class())!=0);
    if (isSql) {			// Sql object
      lpsname = strlen(filename); 
    } else {				// Cint object
      if (strncmp("file",set->GetTitle(),4))	continue;  
      if (!(dot = strchr(filename,'.'))) 	continue;
      if (!Kind(filename)){ delete set;		continue;}
      set->SetTitle(newTitle);
      lpsname = dot - filename;
    }
    if (strncmp(filename,psname+1,lpsname)) {// make new pseudo directory
      psname[1]=0; strncat(psname,filename,lpsname);
      pseudo = new St_ValiSet(psname,ds); strcat(psname,".");
    }

    if (isSql) { 	// save SQL  object
      pseudo->fDatSql=set; set->Shunt(0);
    } else     {	// save Cint object 
      set->Shunt(pseudo);
    }   
  }
  return kContinue;
}
//_____________________________________________________________________________
void    St_db_Maker::SetMainDir(const Char_t *db)
{m_MainDir = db; gSystem->ExpandPathName(m_MainDir);}
//_____________________________________________________________________________
void    St_db_Maker::SetUserDir(const Char_t *db)
{m_UserDir = db; gSystem->ExpandPathName(m_UserDir);}
//_____________________________________________________________________________
TDatime St_db_Maker::GetDateTime()
{ 
  if (!fIsDBTime) return StMaker::GetDateTime();
  return fDBTime;
}
//_____________________________________________________________________________
void St_db_Maker::SetDateTime(Int_t idat,Int_t itim)
{ 
  fIsDBTime=1;
  fDBTime.Set(idat,itim);
}
//_____________________________________________________________________________
void   St_db_Maker::SetDateTime(const char *alias)
{ 
  fIsDBTime=1;
  int idat = AliasDate(alias);// <name>.YYYYMMDD.hhmmss.<ext>
  int itim = AliasTime(alias);
  assert(idat);
  fDBTime.Set(idat,itim);
}
//_____________________________________________________________________________
void   St_db_Maker::SetOn(const char *path)
{ AddAlias("On" ,path,".onoff"); OnOff();}
//_____________________________________________________________________________
void   St_db_Maker::SetOff(const char *path)
{ AddAlias("Off",path,".onoff"); OnOff();}
//_____________________________________________________________________________
void St_db_Maker::OnOff()
{
  int Off,len;
  if (!m_DataBase) return;
  St_DataSet *onoff = Find(".onoff");
  if (!onoff) return;
  
  TString tsBase,tsDir,tsTit;
  St_DataSet *ono;  
  St_DataSetIter onoffNext(onoff);
  while((ono=onoffNext())) {// loop onoffs
    Off = (strcmp("Off",ono->GetName())==0);
    tsDir  = gSystem->DirName(ono->GetTitle());
    tsBase = gSystem->BaseName(ono->GetTitle());
    TRegexp rex(tsBase,1);
    St_DataSet *dsDir = GetDataSet(tsDir);
    if (!dsDir) continue;
    if (GetMaker(dsDir) != this) continue;
    St_DataSetIter nextVal(dsDir);
    St_DataSet *val;
    while ((val=nextVal())) {//loop over val's  
      const char *name = val->GetName();
      if(name[0]!='.') 				continue;
      tsTit = val->GetTitle();
      int ival = tsTit.Index(".Val");
      if (ival<0) 				continue;		
      if (Off != (ival==0))			continue;
      if (rex.Index(name+1,&len)!=0)		continue;
      if ( Off) tsTit.Replace(0,0,".Off");
      if (!Off) tsTit.Replace(0,4,""    );
      val->SetTitle(tsTit);
      printf("<%s::Set%s>   %s/%s\n"
      ,ClassName(),ono->GetName(),(const char*)tsDir,val->GetName()+1);
    }//end loop over val's 
  }// end loop onoffs
}
//_____________________________________________________________________________
static Int_t AliasDate(const char *alias)

{

  int n = strcspn(alias," ."); if (n<4) return 0;
  int i;
  for (i=0;aliases[i] && strncmp(alias,aliases[i],n);i++) {} 
  return dates[i];
}
//_____________________________________________________________________________
static Int_t AliasTime(const char *alias)

{

  int n = strcspn(alias," ."); if (n<4) return 0;
  int i;
  for (i=0;aliases[i] && strncmp(alias,aliases[i],n);i++) {} 
  return times[i];
}
