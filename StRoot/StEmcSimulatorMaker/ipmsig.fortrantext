      Integer function ipmsig(nphe, iver, ierr)
c     """""""""""""""""""""""""""""""""""""""""
c---
Created   by V. and M. Rykov on 09/10/99
c---
C     ***************************************************************
C     Simulation of the digitized PMT signals with a given number  of
C     photoelectrons, emerging from photocathode, taking into account
C     statistics of secondary electrons and noise.
C     ***************************************************************
C---
c     INPUT:
c     """""
c       Integer nphe       - Number of photoelectron emitted from photocathode.
c       Integer iver       - iver.NE.0: full (slow) simulation;
c                            iver.EQ.0: fast (approximate) simulations;
c                            Poisson distributions with the mean > 100 are
c                            replaced with Gaussians. Statistically consistent
c                            with "full simulations" at the statistics up to 10^5
c                            and an agreement is acceptable up to 10^6.
c---
c     OUTPUT:
c     """"""
c       Integer ipmsig     - PMT signal, ADC-counts.
c       Integer ierr       - Completion status: ierr = 0  - successful;
c                                               otherwise - failure.
c---
c     EXTERNAL CONSTANTS:
c     """"""""""""""""""
c     General setup parameters:
c       COMMON/CHNPAR/ gain, adcped, gnoise
c       """""""""""""
c       Real    gain       - Overall gain of the chain "PMT-...-ADC",
c                            ADC-counts/phe.
c       Real    adcped     - ADC pedestal, ADC-counts.
c       Real    gnoise     - Sigma of the gaussian (thermal) noise, ADC-counts.
c
c
c     PMT parameters  (These parameters should be reasonably adjusted to the
c                      characteristics of the simulated PMT. After any change
c                      of these parameters, the CALL IPMSIG_INIT must be issued
c                      first before simulating signals with IPMSIG):
c       COMMON/PMTPAR/ ndyn, pmtgain, cnoise, dnoise, base(ndyn)
c       """""""""""""
c       Integer ndyn       - Number of PMT amplification stages (dynodes);
c                            in the current version, ndyn <= 15.
c       Real    base(ndyn) - Relative voltage distribution between dynodes,
c                            starting from the "photocathode-dynode#1" gap.
c       Real    pmtgain    - Approximate PMT amplification. This parameter
c                            is used solely for estimations of the widths of
c                            the signal distributions with the fixed numbers
c                            of photoelectrons, and it DOES NOT affect (at
c                            all!) the overall gain which is FULLY DEFINED by
c                            the parameter "gain" above. Actually, even quite
c                            sizeable variations of the "pmtgain" just
c                            slightly affect the charateristics of the simu-
c                            lated signals. For example, if "pmtgain" was
c                            changed by a factor of 2, it would lead to just
c                            to ~6-7% variation of widths of the "fixed-phe"
c                            peaks in a PMT with 10-12 dynodes. Therefore, IT
c                            IS NOT NECESSARY to change "pmtgain" parameter in
c                            this routine every time when high-voltage (and
c                            the actual PMT gain) is corrected. For most
c                            application, the accuracy should be sufficient if
c                            "pmtgain" is kept just "somewhere in the range"
c                            deviating by no more than 2-3 times from the
c                            actual amplification of the PMT which is intended
c                            to be simulated.
c       Real    cnoise     - A probability for a thermal electron (or the
c                            average number of thermal electrons per pulse) to
c                            spontaneously emerge from the photocathode within
c                            the ADC gate.
c       Real    dnoise     - A probability for a thermal electron (or the
c                            average number of thermal electrons per pulse) to
c                            spontaneously emerge from a dynode within the ADC
c                            gate. This probability is assumed to be the same
c                            for all dynodes.
c                           
c     EXTERNAL FUNCTIONS USED:
c     """""""""""""""""""""""
c       POISSN and NORRAN from CERNLIB.
c
c     USAGE:
c     """""
c       Before using "function ipmsig" to simulate the signals, it must be
c       initialized by calling:
c
c       CALL ipmsig_init
c       """"""""""""""""
c       Then, the "ipmtsig" function itself could be called unlimited number
c       of times, every time generating one PMT signal at a time. Parameters
c       in COMMON/CHNPAR/ may vary from call to call to simulate, for example,
c       several PMT-ADC channels with different gains, pedestals, and external
c       to PMTs themselves gaussian noise.
c
c     TIMING at "rhic14.physics.wayne.edu" (SGI, R4000, ??? MHz):
c     """"""""""""""""""""""""""""""""""""""""""""""""""""""""""
c       ----------------------------------------------------------------------
c       nphe+cnoise+dnoise | fast(iver=0), mks/cycle | full(iver=0), mks/cycle
c       ----------------------------------------------------------------------
c                0                      18                        21
c                1                      80                       120
c                2                      70                       120
c                5                      42                       100
c               10                      39                       100
c               20                      18                        80
c               50                      12                        80
c             >100                     3.5                        80
c       ----------------------------------------------------------------------
c
c                             E X A M P L E S:
c                             """""""""""""""
c Simulate signals in 4800 EMC towers with 21 scintillator tiles each, using a
c HAMAMATSU-R6427 PMT with amplifications in the range ~(1-2.5)*10^6. Assume
c the noise having purely gaussian shape with the width (sigma) in the range
c from 0.5 to 1.5 ADC channels.
c     Data structure:
c     """"""""""""""
c       Real  chgain(4800)       - Channel gains in ADC-counts/Phe
c       Real   chped(4800)       - ADC pedestals, ADC-counts
c       Real chnoise(4800)       - Gaussian noise in the channels (sigma),
c                                  ADC-counts.
c---
c       Real tile_yield(21,4800) - "Light-yield" from the scintillator tiles
c                                  in phe/GeV of deposited energy. For 5 mm
c                                  thick tiles, 1 MIP corresponds to
c                                  approximately 0.9 MeV.
c       Real e_deposit(21,4800)  - Energy depositions in tiles, GeV.
c---
c       COMMON/CHNPAR/ gain, adcped, gnoise
c       COMMON/PMTPAR/ ndyn, pmtgain, cnoise, dnoise, base(11)
c       DATA ndyn/11/, base/2*2.,6*1.,2.,3.,4./       ! Base used in Beam-test-98
c       DATA pmtgain/1.5e6/, cnoise/0./, dnoise/0./
c
c     Executable code:
c     """""""""""""""
c
c     Example #1 (simplified approach, ignoring the light yield variations
c     """"""""""  from tile-to-tile):
c
c       call ipmsig_init
c       do ievent = 1, nevent
c         Generate event and fill out array "e_deposit"
c         do itw = 1, 4800
c           esum       = 0.
c           yield_mean = 0.
c           do lay = 1, 21
c             esum = esum             + e_deposit(lay,itw)
c             yield_mean = yield_mean + tile_yield(lay,itw) ! This could be done earlier
c           enddo
c           phe_mean = 21.*esum/yield_mean
c           call poissn(phe_mean, nphe, ierr)
c           gain   = chgain(itw)
c           adcped = chped(itw)
c           gnoise = chnoise(itw)
c           call hfill(itw, FLOAT(ipmsig(nphe,0,ierr)+0.5, 0., 1.)
c         enddo
c       enddo
c     
c     Example #2 (full version, accounting light-yield variations
c     """"""""""  from tile-to-tile):
c
c       call ipmsig_init
c       do ievent = 1, nevent
c         Generate event and fill out array "e_deposit"
c         do itw = 1, 4800
c           phe_mean = 0.
c           do lay = 1, 21
c             phe_mean=phe_mean+e_deposit(lay,itw)/tile_yield(lay,itw)
c           enddo
c           call poissn(phe_mean, nphe, ierr)
c           gain   = chgain(itw)
c           adcped = chped(itw)
c           gnoise = chnoise(itw)
c           call hfill(itw, FLOAT(ipmsig(nphe,0,ierr)+0.5, 0., 1.)
c         enddo
c       enddo
c     
C*****************************************************************************
c
      Implicit None

c---Input/output parameters
      Integer nphe, iver, ierr, ipmsig_init      
c---External constants
      Real    gain, adcped, gnoise
      COMMON/CHNPAR/ gain, adcped, gnoise
c---PMT characteristics
      Integer ndynpar, ndyn
      Real    pmtgain, cnoise, dnoise, base
      PARAMETER (ndynpar = 15)
      COMMON/PMTPAR/ ndyn, pmtgain, cnoise, dnoise, base(ndynpar)
c---
c---Internal variables
      Integer nel, j
      Real    sec(ndynpar), dyngain(0:ndynpar)
      Real    g1(0:ndynpar), gdyn(0:ndynpar), dnw(0:ndynpar)
      Real    dn, sne, r

c---Declared static ...
      SAVE sec, dyngain, g1, gdyn, dnw, dn

c       Executable code
c       ===============
c
      IF(cnoise .LT. 1.e-18)                                   THEN
        nel = nphe
      ELSE
        CALL POISSN(cnoise, nel, ierr)
        IF(ierr .NE. 0)                                  RETURN
        nel = nphe + nel
      ENDIF

      IF(iver .EQ. 0)                                          THEN

c--- Fast version
        j = 0
        DO WHILE(j.LT.ndyn .AND. nel.LT.100)
          j = j + 1
          sne = sec(j)*FLOAT(nel) + dn
          CALL POISSN(sne, nel, ierr)
          IF(ierr .NE. 0)                                RETURN
        ENDDO
c...Normalized signal with noise
        sne = gain*FLOAT(nel)*dyngain(j)
        CALL NORRAN(r)
        sne = sne + gain*dnoise*gdyn(j) +
     *        r*sqrt(gain*(sne*gdyn(j)+gain*dnw(j))+gnoise**2)
        
      ELSE

c---Full version
        DO j = 1, ndyn
          sne = sec(j)*FLOAT(nel) + dn
          CALL POISSN(sne, nel, ierr)
          IF(ierr .NE. 0)                                RETURN
        ENDDO
        CALL NORRAN(sne)
        sne = gain*FLOAT(nel)*dyngain(ndyn) + gnoise*sne
      ENDIF

      sne = sne + adcped
      ipmsig = INT(sne)
      IF(sne .LT. 0.) ipmsig = ipmsig - 1
      
      RETURN

c---  I n i t i a l i z e r
      ENTRY  ipmsig_init
c     """"""""""""""""""
c...Secondary electron conversion coefficients
      sne = 1.
      DO j = 1, ndyn
        sne = sne*base(j)
      ENDDO
      sne = (pmtgain/sne)**(1./FLOAT(ndyn))
      DO j = 1, ndyn
        sec(j) = sne*base(j)
      ENDDO
c...Inversed partial gains after each dynode and "g1=G-1" constants (see SN301)
      dyngain(0) = 1.
      g1(ndyn)   = 0.
      DO j = 1, ndyn
        dyngain(j) = dyngain(j-1)/sec(j)
        g1(ndyn-j) = (1. + g1(ndyn-j+1))/sec(ndyn-j+1)
      ENDDO
c...Constants for the dnoise contribution calculation in the "fast" version
      dnw(ndyn)  = 0.
      gdyn(ndyn) = 0.
      DO j = ndyn, 1, -1
        dnw(j-1)  = dnoise*(1.+g1(j))*dyngain(j)**2 + dnw(j)
        gdyn(j-1) = g1(j-1)*dyngain(j-1)
      ENDDO
c...Shifts "dnoise" to avoid POISSN calls at mean=0.
      dn = dnoise + 1.e-18
      
      Return
      End

