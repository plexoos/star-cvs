#if !defined(__CINT__) || defined(__MAKECINT__)
#include "Riostream.h"
#include <stdio.h>
#include "TSystem.h"
#include "TMath.h"
#include "TH1.h"
#include "TH2.h"
#include "TH3.h"
#include "TStyle.h"
#include "TF1.h"
#include "TProfile.h"
#include "TTree.h"
#include "TChain.h"
#include "TFile.h"
#include "TNtuple.h"
#include "TCanvas.h"
#include "TClassTable.h"
#include "TFileSet.h"
#include "TDataSetIter.h"
#include "TDataSet.h"
#include "TDataSetIter.h"
#include "TClassTable.h"
//#include "DeDxTree.C"
#include "TMinuit.h"
#include "TCanvas.h"
#include "TSpectrum.h"
#include "StBichsel/Bichsel.h"
#include "TROOT.h"
#include "TSystem.h"
#include "TString.h"
#include "TLine.h"
#include "TText.h"
#else
class TMinuit;
class TF1;
class TH1F;
class TH2F;
class TH3F;
class TProfile;
class TH2D;
class TCanvas;
class TSpectrum;
class TSystem;
class Bichsel;
#endif
#include "Names.h"
const Int_t NH = NHYPS/2;
Int_t N = 0;
const Int_t noPoints = 1000;
Double_t X[noPoints];
Double_t dX[noPoints];
Double_t Nu[noPoints];
Double_t Mu[noPoints];
Double_t dMu[noPoints];
Double_t Sigma[noPoints];
Double_t dSigma[noPoints];
TCanvas *canvas = 0;
Double_t Xlog10bg, Ylog2dx, Z;
TFile *newf = 0;
const Char_t *NAMES[6] = {"e","p","K","pi","mu","d"};
Bichsel *gBichsel = 0;
//#define PRINT 1
TF1 *func = 0;
class St_TpcSecRowCor;
//________________________________________________________________________________
Double_t fithfcn(Double_t *x,Double_t *par) {
  Double_t z   = x[0];
  Double_t sigma = par[0];
  Double_t norm = 1./TMath::Sqrt(2*TMath::Pi())/sigma;
  Double_t value = 0;
  //  Int_t    hyp   = (Int_t) par[1+2*NH];
  //  Double_t ref = par[hyp+1];
  for (int k = 0; k < NH; k++) {
    Double_t mu = par[k+1];
    //    if (k != hyp) mu -= ref;
    Double_t dev = (z - mu)/sigma;
    value += norm*TMath::Exp(par[k+1+NH]-dev*dev/2.);
  }
  return value;
}
//________________________________________________________________________________
void FitH(const Char_t *set="z", Int_t Hyp = -1, Int_t Bin=-1) {
  if (!gBichsel) {
    gSystem->Load("StBichsel");
    gBichsel = new Bichsel();
  }
  TString Set(set);
  const Double_t window = 0.4;
  const Double_t range[2] = {-2., 4.};
  const Double_t LFrMin = -10;
  if (! canvas) {
    canvas = new TCanvas("FitHC","FitH Canvas");
    canvas->SetGrid();
  }
  const Int_t nHYPS = NHYPS;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  else               printf("%s found\n",fRootFile->GetName());
  TString newfile("FitH");
  newfile += Set; 
  newfile += gSystem->BaseName(fRootFile->GetName());
  TString FileN("FitPars");
  FileN += Set;
  FileN += ".h";
  TFile * f = 0;
  if (Bin < 0)  f = new TFile(newfile.Data(),"update");
  TH1 *proj = 0;
  TF1 *g = new TF1("g",fithfcn,range[0],range[1],2+2*NH);
  g->SetParName(0,"Sigma"); g->SetParLimits(0,0.06,0.12);
  g->SetParName(1+2*NH,"Hyp");
  Int_t Nfit = 0;
  Int_t nh1 = 0;
  Int_t nh2 = NHYPS-1; //Int_t nh1 = 3, nh2 = 3;
  if (Hyp >=0 ) {nh1 = nh2 = Hyp;}
  Int_t parstatus[NH];
  for (Int_t hyp = nh1; hyp<=nh2; hyp++) {
    Int_t kh = hyp%NH;
    Char_t *HistN =  HistNames[hyp];
    if (Set.Contains("70")) HistN = HistNames70[hyp];
    hists[hyp] = (TH2 *) fRootFile->Get(HistN);
    if (!hists[hyp]) {printf("Cannot histogram %s\n",HistNames[hyp]); continue;}
    histp[hyp] = (TProfile *) fRootFile->Get(HistNameP[hyp]);
    if (!histp[hyp]) {printf("Cannot histogram %s\n",HistNameP[hyp]); continue;;}
    Int_t k = 0;
    if (hyp > NH) k = NH;
    for (Int_t hypl = (hyp/NH)*NH; hypl < (hyp/NH+1)*NH; hypl++) {
      Int_t lh = hypl%NH;
      TString name1("LF.");
      name1 += Names[hypl];
      TString name2("");
      name2 += Names[hypl];
      g->SetParName(lh+1+NH,name1.Data());
      g->SetParName(lh+1,name2.Data());
    }
    Int_t nx = hists[hyp]->GetNbinsX();
    Int_t jbin1 = 1;
    Int_t jbin2 = nx;
    if (Bin > 0) {jbin1 = jbin2 = Bin;}
    for (int jbin=jbin1; jbin<=jbin2; jbin++) {
      TString name(Form("%s_%i_%i",hists[hyp]->GetName(),hyp,jbin));
      proj = hists[hyp]->ProjectionY(name.Data(),jbin,jbin);
      Int_t ix1=proj->GetXaxis()->FindBin(-window);
      Int_t ix2=proj->GetXaxis()->FindBin( window);
      Double_t dinT = 5*proj->Integral();
      Double_t dint = proj->Integral(ix1,ix2);
      if (dint < 100.) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hists[hyp]->GetName(),jbin,hyp,dint);
	delete proj;
	continue;
      }
      for (Int_t lh = 0; lh < NH; lh++) {
	g->ReleaseParameter(lh+1);
	g->ReleaseParameter(lh+1+NH);
	parstatus[lh] = 0;
      }
      printf("hist:%s bin %i for hyp %i has  %10.0f entries\n",hists[hyp]->GetName(),jbin,hyp,dint);
      Double_t bg = TMath::Power(10., hists[hyp]->GetBinCenter(jbin));
      Double_t pmom = Masses[hyp]*bg;
      if (pmom > 0.1) {parstatus[4] = 1; printf("fix muon\n");}
      if (kh == 4 && pmom > 0.1) continue;
      Double_t devZ[NH];
      Double_t zref = 0;
      if (TString(set) == "70")  zref = 1.e-6*gBichsel->GetI70(TMath::Log10(bg),1.0); 
      else                       zref = 1.e-6*TMath::Exp(gBichsel->GetMostProbableZ(TMath::Log10(bg),1.0));
      //      printf("zref = %f\n",zref);
      Int_t iok = 1;
      for (Int_t hypl = (hyp/NH)*NH; hypl < (hyp/NH+1)*NH; hypl++) {
	Int_t lh = hypl%NH;
	Double_t z = 0;
	bg = pmom/Masses[hypl];
	if (Set.Contains("70")) z = 1.e-6*gBichsel->GetI70(TMath::Log10(bg),1.0); 
	else                    z = 1.e-6*TMath::Exp(gBichsel->GetMostProbableZ(TMath::Log10(bg),1.0));
	devZ[lh] = TMath::Log(z/zref);
      }
      for (int l = 0; l < NH; l++) {
	if (l == kh) continue;
	if (devZ[l] < -2.0 || devZ[l] > 4.0) {
	  printf("Fix %s dZ = %f\n", Names[NH*(hyp/NH)+l],devZ[l]);
	  parstatus[l] = 1;
	  continue;
	}
	if (TMath::Abs(devZ[l]) < 0.01 || 
	    hyp%NH == 3 && l == 4 && TMath::Abs(devZ[l]) < 0.04) {
	    printf("Fix %s dZ = %f\n", Names[NH*(hyp/NH)+l],devZ[l]);
	    parstatus[l] = 1;
	    continue;
	}
      }
      for (Int_t hypl = (hyp/NH)*NH; hypl < (hyp/NH+1)*NH; hypl++) {
      AGAIN:
	Int_t lh = hypl%NH;
	if (parstatus[lh]) continue;
	Double_t windowN = devZ[lh]-window;
	Double_t windowP = devZ[lh]+window;
	for (int m = 0; m < NH; m++) {
	  if (m != lh && ! parstatus[m]) {
	    Double_t dev = 0.5*(devZ[m] - devZ[lh]);
	    if (dev < 0 && windowN < devZ[lh] + dev) windowN = devZ[lh] + dev;
	    if (dev > 0 && windowP > devZ[lh] + dev) windowP = devZ[lh] + dev;
	  } 
	}
#if 0
	printf("Set Limits for %s ref = %f in [%f,%f]\n",Names[hypl],devZ[lh],windowN,windowP);
#endif
	g->SetParameter(lh+1,devZ[lh]);
	g->SetParLimits(lh+1,windowN, windowP);
	g->SetParLimits(lh+1+NH,LFrMin, TMath::Log(dinT));
	if (hypl == hyp) 
	  g->SetParameter(lh+1+NH,TMath::Log(dint));
	else {
	  ix1=proj->GetXaxis()->FindBin(windowN);
	  ix2=proj->GetXaxis()->FindBin(windowP);
	  Double_t din= proj->Integral(ix1,ix2);
	  //	  printf("%s dZ = %f in = %f\n", Names[hypl], devZ[lh], din);
	  if (din > 0) g->SetParameter(lh+1+NH,TMath::Log(din));
	  else         {
	    printf("Fix %s din = %f\n", Names[hypl],din);
	    parstatus[lh] = 1;
	    goto AGAIN;
	  }
	}
      }
      for (int l = 0; l < NH; l++) 
	if (parstatus[l]) {
	  printf("Fix %s\n",Names[NH*(hyp/NH)+l]);
	  g->FixParameter(l+1+NH, LFrMin); 
	  g->FixParameter(l+1, devZ[l]);
	}
      g->FixParameter(1+2*NH, hyp);
      if (parstatus[kh]) iok = 0;
      if (! iok) {printf("Too close\n"); continue;}
      //      proj->Fit(g->GetName(),"RIM");
      proj->Fit(g->GetName(),"R");
      canvas->Update();
      Int_t lh = (hyp%NH)+1;
      Double_t Nu  = g->GetParameter(lh); 
      printf("hyp = %i lh = %i Nu = %f zref =%f %f\n",hyp,lh,Nu,zref,g->GetParameter(lh));
      Double_t Mu  = 1.e6*zref*TMath::Exp(Nu);
      Double_t dMu = g->GetParError(lh);
      Int_t NFitPoints = g->GetNumberFitPoints();
      Int_t NDF = g->GetNDF();
      Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
      Double_t chisq      = g->GetChisquare();
      Double_t X = hists[hyp]->GetXaxis()->GetBinCenter(jbin);
      printf("Nu = %f Mu = %f dMu = %f\n",Nu,Mu,dMu);
      printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
	      "chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
	      Names[hyp],hyp,jbin,Nfit,X,pmom,Nu,Mu,dMu,chisq,NFitPoints,NDF,prob);
      printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
	     Names[hyp],hyp,jbin,Nfit,X,pmom,Nu,Mu,dMu,chisq,NFitPoints,NDF,prob,g->GetName());
      if (f) {
	FILE *fp = fopen(FileN.Data(),"a");
	if (fp) {
	  if (Nfit == 0) {
	    TDatime time;
	    fprintf (fp,"dEdxPoint_t dEdxZ[] = {\n");
		    fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	    fprintf(fp,
		    "//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	  }
	  if (Nfit == 0) fprintf(fp," {");
	  else           fprintf(fp,",{");
	  fprintf(fp,
		  "\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		  Names[hyp],hyp,jbin,Nfit,X,pmom,Nu,Mu,dMu,chisq,NFitPoints,NDF,prob,g->GetName());
	  fclose(fp);
	  Nfit++; 	
	}
	proj->Write();
      }
    }
  }
  if (f) {
    FILE *fp = fopen(FileN.Data(),"a");
    if (fp) fprintf(fp,"};\n");
    fclose(fp);
    delete f;
  }
}


//________________________________________________________________________________
TH2F *Project(TH3F *hist) {
  if (!hist) return 0;
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  TString name(hist->GetName());
  name += "_xy";
  TH2F *h = new TH2F(name.Data(),hist->GetTitle(),
		     nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
		     ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  Double_t params[5];
  Double_t error;
  TF1 *g = new TF1("g","gaus(0)+pol1(3)");
  for (int i=1;i<=nx;i++){
    for (int j=1;j<=ny;j++){
      TH1D *proj = hist->ProjectionZ("f_11",i,i,j,j);
      Double_t mean = proj->GetMean();
      Double_t sum  = proj->Integral();
      Double_t rms = proj->GetRMS();
      params[0] = sum;
      params[1] = mean;
      params[2] = rms;
      params[3] = 0;
      params[4] = 0;
      g->SetParameters(params);
      //      g->SetRange(mean-2*rms,mean+2*rms);
      g->SetRange(-1.,1.);
      error = 0;
      if (sum > 100) {
	proj->Fit("g","RQ");
	g->GetParameters(params);
	error = g->GetParError(1);
      }
      else error = 0;
      h->SetCellContent(i,j,params[1]);
      h->SetCellError(i,j,error);
      printf("i:%i j:%i sum:%f mean:%f rms:%f mu:%f sigma:%f\n",
	     i,j,sum,mean,rms,params[1],params[2]);
      delete proj;
    }
  }
  return h;
} 
//________________________________________________________________________________
TH2D *GetRelYZError(TH3 *hist, const Char_t *Name="_yz") {
  if (!hist) return 0;
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  Int_t nz = hist->GetNbinsZ();
  TString name(hist->GetName());
  name += Name;
  //  TAxis *fXaxis = hist->GetXaxis();
  TAxis *fYaxis = hist->GetYaxis();
  TAxis *fZaxis = hist->GetZaxis();
  TH2D *h = new TH2D(name.Data(),"Relative error in Space charge (%)",
		     ny,fYaxis->GetXmin(),fYaxis->GetXmax(),
		     nz,fZaxis->GetXmin(),fZaxis->GetXmax());
  h->SetXTitle("Row number");
  h->SetYTitle("Z (cm)");
  Int_t bin;
  Double_t Scale = TMath::Sqrt(24.*3726./1153.);
  for (int iybin=0;iybin<ny;iybin++){
    for (int izbin=0;izbin<nz;izbin++){
      Double_t cont = 0, err = 0;
      for (int ixbin=1;ixbin<nx;ixbin++){
	bin = hist->GetBin(ixbin,iybin,izbin);
	cont += hist->GetBinContent(bin);
	err  += hist->GetBinError(bin)*hist->GetBinError(bin);
      }
      if (cont > 0) {
	bin = h->GetBin(iybin,izbin);
	Double_t val = 100*TMath::Sqrt(err)/cont*Scale;
	h->SetBinContent(bin,val);
      }
    }
  }
  return h;
} 
//________________________________________________________________________________
TH2F *ProjectX(TH3F *hist, const Char_t *Name="_yz",const Int_t binx1=0,const Int_t binx2=10000) {
  if (!hist) return 0;
  Int_t nx = hist->GetNbinsX();
  if (nx > binx2) nx = binx2;
  Int_t ny = hist->GetNbinsY();
  Int_t nz = hist->GetNbinsZ();
  TString name(hist->GetName());
  name += Name;
  //  TAxis *fXaxis = hist->GetXaxis();
  TAxis *fYaxis = hist->GetYaxis();
  TAxis *fZaxis = hist->GetZaxis();
  TH2F *h = new TH2F(name.Data(),hist->GetTitle(),
		     ny,fYaxis->GetXmin(),fYaxis->GetXmax(),
		     nz,fZaxis->GetXmin(),fZaxis->GetXmax());
  //  Double_t params[3];
  //  Double_t error;
  //  TF1 *g = new TF1("g","gaus");
  for (int iybin=0;iybin<ny;iybin++){
    for (int izbin=0;izbin<nz;izbin++){
      for (int ixbin=binx1;ixbin<nx;ixbin++){
	Int_t bin = hist->GetBin(ixbin,iybin,izbin);
	Double_t cont = hist->GetBinContent(bin);
	if (cont) h->Fill(fYaxis->GetBinCenter(iybin),fZaxis->GetBinCenter(izbin), cont);
      }
    }
  }
  return h;
} 
//________________________________________________________________________________
TF1 *FitGP(TH1D *proj, Option_t *opt="RQ", Double_t nSigma=3, Int_t pow=3) {
  if (! proj) return 0;
  TString Opt(opt);
  //  Bool_t quet = Opt.Contains("Q",TString::kIgnoreCase);
  TF1 *g = 0, *g0 = 0;
  TF1 *gaus = (TF1*) gROOT->GetFunction("gaus");
  if (pow >= 0) g0 = new TF1("g0",Form("gaus(0)+pol%i(3)",pow),-0.2,0.2);
  else          g0 = new TF1("g0","gaus",-0.2,0.2); 
  g0->SetParName(0,"Constant");
  g0->SetParName(1,"Mean");
  g0->SetParName(2,"Sigma");
  for (int i=0; i<=pow;i++) g0->SetParName(3+i,Form("a%i",i));
  TF1 *g1 = new TF1("g1",Form("gaus(0)+pol%i(3)",pow+1),-0.2,0.2);
  g1->SetParName(0,"Constant");
  g1->SetParName(1,"Mean");
  g1->SetParName(2,"Sigma");
  for (int i=0; i<=pow+1;i++) g1->SetParName(3+i,Form("a%i",i));
  TF1 *g2 = new TF1("g1",Form("gaus(0)+pol%i(3)",pow+2),-0.2,0.2);
  g2->SetParName(0,"Constant");
  g2->SetParName(1,"Mean");
  g2->SetParName(2,"Sigma");
  for (int i=0; i<=pow+2;i++) g2->SetParName(3+i,Form("a%i",i));
  Double_t params[9];
#if 0
  TSpectrum *spec = new TSpectrum();
  Int_t nPeaks = spec->Search(proj,3,""); 
  if (!quet) {cout << proj->GetName() << "\tfound " << nPeaks << " peaks" << endl;}
  if (! nPeaks) return 0;
  Float_t *xpeak = spec->GetPositionX();
  Int_t peak = -1;
  Double_t dist = 9999.;
  for (Int_t i = 0; i < nPeaks; i++) {
    if (!quet) cout << "\tx \t" << xpeak[i]; 
    if (TMath::Abs(xpeak[i]) < dist) { 
      dist = TMath::Abs(xpeak[i]); peak = i;
    }
  }
  if (peak < 0) return 0;
  //  peak = 0;
  GetMaximumBin()
  if (!quet) {
    cout << endl;
    cout << "Take x\t" << xpeak[peak] << endl;
  }
  //  delete spec;
  Int_t  peakbin = proj->GetXaxis()->FindBin(xpeak[peak]);
  params[0] = 1.e5;
  params[1] = proj->GetBinCenter(peakbin);
  params[2] = 0.2;//proj->GetRMS();
#else
  Int_t peak = proj->GetMaximumBin();
  Double_t peakX = proj->GetBinCenter(peak);
  params[0] = proj->GetBinContent(peak);
  if (peakX > 0.5) {
    params[1] = 0;
    params[2] = 0.2;
  }
  else {
    params[1] = peakX;
    params[2] = proj->GetRMS();
    if (params[2] > 0.25) params[2] = 0.25;
  }
#endif
  params[3] = 0;
  params[4] = 0;
  params[5] = 0;
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  if (gaus) {
    g = gaus;
    g->SetParameters(params);
    g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
    proj->Fit(g,opt);
    g->GetParameters(params);
    if (g->GetProb() > 0.01) return g;
    params[2] = TMath::Abs(params[2]);
  }
  g = g0;
  g->SetParameters(params);
  g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
  proj->Fit(g,opt);
#if 1
  if (g->GetProb() > 0.01) return g;
  g->GetParameters(params);
  g = g1;
  params[2] = TMath::Abs(params[2]);
  g->SetParameters(params);
  g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
  proj->Fit(g,opt);
  if (g->GetProb() > 0.01) return g;
  g->GetParameters(params);
  g = g2;
  params[2] = TMath::Abs(params[2]);
  g->SetParameters(params);
  g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
  proj->Fit(g,opt);
#endif
  return g;
}
//________________________________________________________________________________
TF1 *FitG2(TH1D *proj, Option_t *opt="RQ") {
  if (! proj) return 0;
  Double_t params[9];
  TF1 *gaus = new TF1("gaus","gaus",-5.,5.);
  proj->Fit(gaus,opt);
  params[0] = gaus->GetParameter(0);
  params[1] = gaus->GetParameter(1);
  params[2] = gaus->GetParameter(2);
  params[3] = 1;
  params[4] = 2;
  params[5] = gaus->GetParameter(2);
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  TF1 *g = new TF1("g","gaus(0)+gaus(3)",-5.,5.);
  g->SetParameters(params);
  g->SetParLimits(0,0,1.e10);
  g->SetParLimits(1,-5,5);
  g->SetParLimits(2,0.01,5);
  g->SetParLimits(3,0,1.e10);
  g->SetParLimits(4,-5,5);
  g->SetParLimits(5,0.01,5);
  proj->Fit(g,opt);
  g->GetParameters(params);
  if (TMath::Abs(params[1]) > TMath::Abs(params[4])) {
    g->SetParameter(0,params[3]);
    g->SetParameter(1,params[4]);
    g->SetParameter(2,params[5]);
    g->SetParameter(3,params[0]);
    g->SetParameter(4,params[1]);
    g->SetParameter(5,params[2]);
    proj->Fit(g,opt);
  }
  proj->Fit(g,opt);
  delete gaus;
  return g;
}
//________________________________________________________________________________
TF1 *FitG3(TH1D *proj, Option_t *opt="RQ") {
  if (! proj) return 0;
  Double_t params[9];
  TF1 *gaus = new TF1("gaus","gaus",-5.,5.);
  TF1 *g = 0;
  proj->Fit(gaus,opt);
  params[0] = gaus->GetParameter(0);
  params[1] = gaus->GetParameter(1);
  params[2] = gaus->GetParameter(2);
  params[3] = 1;
  params[4] = 2;
  params[5] = gaus->GetParameter(2);
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  delete gaus;
  g = new TF1("g","gaus(0)+gaus(3)",-5.,5.);
  g->SetParameters(params);
  g->SetParLimits(0,0,1.e10);
  g->SetParLimits(1,-5,5);
  g->SetParLimits(2,0.1,5);
  g->SetParLimits(3,0,1.e10);
  g->SetParLimits(4,-5,5);
  g->SetParLimits(5,0.1,5);
  proj->Fit(g,opt);
  g->GetParameters(params);
  if (TMath::Abs(params[1]) > TMath::Abs(params[4])) {
    g->SetParameter(0,params[3]);
    g->SetParameter(1,params[4]);
    g->SetParameter(2,params[5]);
    g->SetParameter(3,params[0]);
    g->SetParameter(4,params[1]);
    g->SetParameter(5,params[2]);
  }
  proj->Fit(g,opt);
  if (g->GetProb() > 0) return g;
  g->GetParameters(params);
  delete g;
  g = new TF1("g","gaus(0)+gaus(3)+gaus(6)",-5.,5.);
  g->SetParLimits(6,0,1.e10);
  g->SetParLimits(7,-5,5);
  g->SetParLimits(8,0.1,5);
  params[6] = 10.;
  params[7] = 0.5*(params[1]+params[4]);
  params[8] = params[2];
  g->SetParameters(params);
  proj->Fit(g,opt);
  return g;
}
//________________________________________________________________________________
void dEdxFit(const Char_t *HistName = "Time",const Char_t *FitName = "GP", 
	     Option_t *opt="R", 
	     Int_t mergeX=1, Int_t mergeY=1, Int_t ix = 0, Int_t jy = 0, 
	     Double_t nSigma=3, Int_t pow=1) {
  TCanvas *canvas = 0;
  TString Opt(opt);
  if (! Opt.Contains("Q",TString::kIgnoreCase)) canvas = new TCanvas("Fit","Fit results");
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("There is no opened file\n"); return;}
  TH1 *hist = (TH1 *) fRootFile->Get(HistName);
  if (!hist) {printf("Cannot find %s\n", HistName); return;}
  TAxis *xax = hist->GetXaxis();
  Int_t nx = xax->GetNbins(); printf ("nx = %i",nx);
  Axis_t xmin = xax->GetXmin(); printf (" xmin = %f",xmin);
  Axis_t xmax = xax->GetXmax(); printf (" xmax = %f\n",xmax);
  TAxis *yax = hist->GetYaxis();
  Int_t dim = hist->GetDimension();
  Int_t ny = yax->GetNbins();
  if (dim < 3) ny = 1;  printf ("ny = %i",ny);
  Axis_t ymin = yax->GetXmin(); printf (" ymin = %f",ymin);
  Axis_t ymax = yax->GetXmax(); printf (" ymax = %f\n",ymax);
  struct Fit_t {
    Float_t i;
    Float_t j;
    Float_t x;
    Float_t y;
    Float_t mean;
    Float_t rms;
    Float_t peak;
    Float_t mu;
    Float_t sigma;
    Float_t entries;
    Float_t chisq;
    Float_t prob;
    Float_t a0;
    Float_t a1;
    Float_t a2;
    Float_t a3;
    Float_t a4;
    Float_t a5;
    Float_t Npar;
    Float_t dpeak;
    Float_t dmu;
    Float_t dsigma;
    Float_t da0;
    Float_t da1;
    Float_t da2;
    Float_t da3;
    Float_t da4;
    Float_t da5;
  };
  Fit_t Fit;
  TString NewRootFile(gSystem->DirName(fRootFile->GetName()));
  NewRootFile += "/";
  NewRootFile += HistName;
  NewRootFile += FitName;
  if (mergeX != 1) NewRootFile += Form("_x%i",mergeX);
  if (mergeY != 1) NewRootFile += Form("_y%i",mergeY);
  //  NewRootFile += "_2_";
  NewRootFile += gSystem->BaseName(fRootFile->GetName());
  TFile *f = 0;
  TNtuple *FitP = 0;
  if (ix == 0 && jy == 0) {
    f = new TFile(NewRootFile.Data(),"update");
    //  TString TupName(HistName);
    //  TupName += "FitP";
    FitP = new TNtuple("FitP","Fit results",
		       "i:j:x:y:mean:rms:peak:mu:sigma:entries:chisq:prob:a0:a1:a2:a3:a4:a5:Npar:dpeak:dmu:dsigma:da0:da1:da2:da3:da4:da5");
  }
  TH1 *mean;   
  TH1 *rms;    
  TH1 *entries;
  TH1 *mu;
  TH1 *sigma;  
  TH1 *chisq; 
  if (dim == 3) {
    mean    = new TH2D("mean",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    rms     = new TH2D("rms",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    entries = new TH2D("entries",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    mu      = new TH2D("mu",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    sigma   = new TH2D("sigma",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    chisq   = new TH2D("chisq",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
  }
  else {
    if (dim == 2 || dim == 1) {
      mean    = new TH1D("mean",hist->GetTitle(),nx,xmin,xmax);
      rms     = new TH1D("rms",hist->GetTitle(),nx,xmin,xmax);
      entries = new TH1D("entries",hist->GetTitle(),nx,xmin,xmax);
      mu      = new TH1D("mu",hist->GetTitle(),nx,xmin,xmax);
      sigma   = new TH1D("sigma",hist->GetTitle(),nx,xmin,xmax);
      chisq   = new TH1D("chisq",hist->GetTitle(),nx,xmin,xmax);
    }
    else {
      printf("Histogram %s has wrong dimension %i\n", hist->GetName(),dim);
      return;
    }
  }
  Double_t params[9];
  TH1D *proj = 0;
  TF1 *g = 0;
  Int_t ix1 = ix, jy1 = jy;
  if (ix > 0) nx = ix;
  if (jy > 0) ny = jy;
  if (ix1 <= 0) ix1 = 1;
  if (jy1 <= 0) jy1 = 1;
  for (int i=ix1;i<=nx-mergeX+1;i++){
    Int_t ir0 = i;
    Int_t ir1=i+mergeX-1;
    if (i == 0) {ir0 = 1; ir1 = nx;}
    for (int j=jy1;j<=ny-mergeY+1;j++){
      Int_t jr0 = j;
      Int_t jr1 = j+mergeY-1;
      if (j == 0) {jr0 = 1; jr1 = ny;}
      if (dim == 3) 
	proj = ((TH3 *) hist)->ProjectionZ(Form("f%i_%i",i,j),ir0,ir1,jr0,jr1);
      else                       
	proj = ((TH2 *) hist)->ProjectionY(Form("f%i",i),ir0,ir1);
      memset (&Fit, 0, sizeof(Fit_t));
      Fit.i = (2.*i+mergeX-1.)/2;
      Fit.j = (2.*j+mergeY-1.)/2;
      Fit.x = 0.5*(xax->GetBinLowEdge(i) + xax->GetBinUpEdge(i+mergeX-1));
      Fit.y = 0.5*(yax->GetBinLowEdge(j) + yax->GetBinUpEdge(j+mergeY-1));
      Fit.mean = proj->GetMean();
      Fit.rms  = proj->GetRMS();
      Fit.chisq = -100;
      Fit.prob  = 0;
      Fit.entries = proj->Integral();
      if (Fit.entries < 100) {delete proj; continue;}
      if (TString(FitName) == "GP") g = FitGP(proj,opt,nSigma,pow);
      else if (TString(FitName) == "G2") g = FitG2(proj,opt);
      else {cout << FitName << " has not been definded" << endl; break;}
      if (! g ) {delete proj; continue;}
      g->GetParameters(params);
      Fit.Npar  = g->GetNpar();
      Fit.chisq = g->GetChisquare();
      Fit.prob  = g->GetProb();
      Fit.peak = params[0];
      Fit.mu = params[1];
      Fit.sigma = TMath::Abs(params[2]);
      Fit.a0  = params[3];
      Fit.a1  = params[4];
      Fit.a2  = params[5];
      Fit.a3  = params[6];
      Fit.a4  = params[7];
      Fit.a5  = params[8];
      Fit.dpeak  = g->GetParError(0);
      Fit.dmu    = g->GetParError(1);
      Fit.dsigma = g->GetParError(2);
      Fit.da0    = g->GetParError(3);
      Fit.da1  	 = g->GetParError(4);
      Fit.da2  	 = g->GetParError(5);
      Fit.da3  	 = g->GetParError(6);
      Fit.da4  	 = g->GetParError(7);
      Fit.da5  	 = g->GetParError(8);
      //      Fit.chisq = g3->GetChisquare();
      //      if (Fit.prob > 0) {
	if (dim == 3) {
	  mean->SetBinContent(i,j,Fit.mean);
	  rms->SetBinContent(i,j,Fit.rms);
	  entries->SetBinContent(i,j,Fit.entries);
	  mu->SetBinContent(i,j,Fit.mu);
	  mu->SetBinError(i,j,g->GetParError(1));
	  sigma->SetBinContent(i,j,Fit.sigma);
	  sigma->SetBinError(i,j,g->GetParError(2));
	  chisq->SetBinContent(i,j,Fit.chisq);
	}
	else {
	  mean->SetBinContent(i,Fit.mean);
	  rms->SetBinContent(i,Fit.rms);
	  entries->SetBinContent(i,Fit.entries);
	  mu->SetBinContent(i,Fit.mu);
	  mu->SetBinError(i,g->GetParError(1));
	  sigma->SetBinContent(i,Fit.sigma);
	  sigma->SetBinError(i,g->GetParError(2));
	  chisq->SetBinContent(i,Fit.chisq);
	}
	//      }
      printf("%i/%i %f/%f mean %f rms = %f entries = %f mu = %f sigma = %f chisq = %f prob = %f\n",
	    i,j,Fit.x,Fit.y,Fit.mean,Fit.rms,Fit.entries,Fit.mu,Fit.sigma,Fit.chisq,Fit.prob);
      if (FitP)  FitP->Fill(&Fit.i);
      if (canvas) {
	canvas->Update();
#if 0
	int ii;
	cout << "Type i ";
	cin >> ii; if (ii <0) return;
#endif
      }
      if (! canvas) delete proj;
      delete g;
    }
  }
  if (f) {
    f->Write();
    delete f;
  }
} 
//________________________________________________________________________________
Int_t FitG(TH1 *proj, TF1 *g, TF1 *ga, Double_t scaleM=-2., Double_t scaleP=2.) {
  Double_t params[10];
  proj->Fit("g","R");
  Double_t chisq = g->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  g->GetParameters(params);
  params[3] = 0;
  params[4] = 0;
  params[5] = 0;
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  params[9] = 0;
  ga->SetParameters(params);
  proj->Fit("ga","r");
  //  proj->Fit("ga","rIM");
  chisq = g->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  return 0;
}
//________________________________________________________________________________
Int_t FitGG(TH1 *proj, TF1 *g1, TF1 *g2=0, TF1 *ga2=0, Double_t scaleM=-2., Double_t scaleP=2.) {
  Double_t params[9];
  proj->Fit("g1","R");
  g1->GetParameters(params);
  Double_t chisq = g1->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  params[3] = 1;
  params[4] = params[1]+0.1;
  params[5] = params[2];
  g2->SetParameters(params);
  proj->Fit("g2");
  chisq = g2->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  g2->GetParameters(params);
  if (ga2) {
    params[6] = 0;
    params[7] = 0;
    params[8] = 0;
    ga2->SetParameters(params);
    proj->Fit("ga2","R");
    ga2->GetParameters(params);
    ga2->SetRange(params[1]+scaleM*params[2],params[1]+scaleP*params[2]);
    proj->Fit("ga2","R");
  }
//   if (gPad) {
//     gPad->Update();
//     gPad->WaitPrimitive();
//   }
  return 0;
}
//________________________________________________________________________________
void FitX(TH2 *hist=0, Double_t range=1, Int_t Ibin = 0) {
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  if (!hist) {
    Char_t *HistName = "FPoints";
    hist = (TH2D *) fRootFile->Get(HistName);
    if (!hist) {printf("Cannot histogram %s\n",HistName); return;}
  }
  //  const Int_t nx = hist->GetNbinsX();
  TF1 *g = new TF1("g","gaus",-range,range);
  //  TF1 *ga = g;
  TString fitN("gaus(0)+exp(pol3(3))");
  if (range > 2.) fitN = "gaus(0)+exp(pol5(3))";
  TF1 *ga= new TF1("ga",fitN.Data(),-range,range);
  ga->SetParName(0,"Area  Pi");
  ga->SetParName(1,"Mean  Pi"); 
  ga->SetParName(2,"Sigma Pi");
  ga->SetParName(3,"A0");
  ga->SetParName(4,"A1");
  ga->SetParName(5,"A2");
  ga->SetParName(6,"A3");
  ga->SetParName(7,"A4");
  ga->SetParName(8,"A5");
  
  TCanvas *c = new TCanvas("Fit","Fit results");
  int i;
  TString name(hist->GetName());
  name += "MuFG";
  Int_t nBins = hist->GetXaxis()->GetNbins();
  Double_t xlow = hist->GetXaxis()->GetXmin();
  Double_t xup  = hist->GetXaxis()->GetXmax();
  TH1D *MuF = new TH1D(name.Data(),"Avarage shift versus no. of measurement points",
		       nBins,  xlow, xup);
  name = hist->GetName();
  name += "SigmaFG";
  TH1D *SigmaF = new TH1D(name.Data(),"Sigma of z versus no. of measurement points",
		       nBins,  xlow, xup);
  Int_t i1 = 1, i2 = nBins;
  if (Ibin > 0 && Ibin <= nBins) {i1 = Ibin; i2 = Ibin;}
  Double_t XFitP, dXFitP,  MuFitP,dMuFitP,SigmaFitP,dSigmaFitP;
  TH1D *proj = 0;
  for (i=i1; i<=i2; i++) {
    if (proj) delete proj;
    proj = hist->ProjectionY("proj",i,i);
    XFitP = hist->GetXaxis()->GetBinCenter(i);
    dXFitP = hist->GetXaxis()->GetBinWidth(i);
    Double_t chisq = -999;
    if (proj->Integral() < 1000) {
      if (N>0) goto NEXT;
      continue;
    }
    if (FitG(proj,g,ga)) goto NEXT;
    //    proj->Fit("g","R");
    if (ga->GetParError(1) <= 0 || ga->GetParError(1) > 0.01 ) {
      printf("============= REJECT ================\n");
      goto NEXT;
    }
    MuFitP  = ga->GetParameter(1);
    dMuFitP = ga->GetParError(1);///MuFitP;
    //    MuFitP = TMath::Log(MuFitP);
    SigmaFitP  = ga->GetParameter(2);
    dSigmaFitP = ga->GetParError(2);
    chisq = ga->GetChisquare();
    if (chisq > 1.e4) goto NEXT; 
    MuF->SetCellContent(i,0,MuFitP);
    MuF->SetCellError(i,0,dMuFitP);
    SigmaF->SetCellContent(i,0,SigmaFitP);
    SigmaF->SetCellError(i,0,dSigmaFitP);
    proj->Draw(); c->Update();
    printf("Bin: %i x: %f +/- %f MuF: %f+/-%f Sigma: %f+/-%f chisq: %f \n",
	   i,XFitP,dXFitP,MuFitP,dMuFitP,SigmaFitP,dSigmaFitP,chisq);
 NEXT:   
    N++;  
    //    delete proj;
  }
  if (! Ibin ) {
    c->Clear();
    //   c->Divide(2,1);
    //   c->cd(1);
    //   MuF->Draw();
    //   c->cd(2);
    SigmaF->SetMarkerStyle(20);
    TF1 *p = new TF1("p","[0]/pow(x,[1])");
    p->SetParameter(0,0.64);
    p->SetParameter(1,0.50);
    SigmaF->Fit("p","R");
    SigmaF->SetMinimum(0.06);
    SigmaF->Draw();
  }
  TString NewRootFile(hist->GetName());
  NewRootFile += fRootFile->GetName();
  TFile *f = new TFile(NewRootFile.Data(),"update");
  MuF->Write();
  SigmaF->Write();
  delete f;
  fRootFile->cd();
}
#if 0
//________________________________________________________________________________
void FitC4G(const Char_t *set="z") {
  Double_t sigmas[2] = {0.06,0.12};
  const Int_t nHYPS = NHYPS;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  TString newfile("FitC4G");
  newfile += "set";
  newfile += gSystem->BaseName(fRootFile->GetName());
  TFile * f = new TFile(newfile.Data(),"update");
  for (Int_t i = 0; i< nHYPS; i++) {
    Char_t *HistN =  HistNames[i];
    if (TString(set) == "70") HistN = HistNames70[i];
    fRootFile->Get(HistN);
    if (!hists[i]) {printf("Cannot histogram %s\n",HistNames[i]); return;}
    histp[i] = (TProfile *) fRootFile->Get(HistNameP[i]);
    if (!histp[i]) {printf("Cannot histogram %s\n",HistNameP[i]); return;}
  }
  TF1 *g[4];
  TF1 *g1 = new TF1("g1","gaus",-0.3,0.3);
  TF1 *g = 0, *g2 = 0, *g3 = 0, *g4 = 0, *ga = 0;
  TCanvas *canvas = new TCanvas("canvas","canvas");
  if (Mu2 != 0) {
    if (Mu2 < -1.) {
      if   (Mu2 <= -4.) ga = new TF1("ga","gaus(0)+exp(pol3(3))",xmin2,xmax2);
      else {
	if (Mu2 <= -3.) ga = new TF1("ga","gaus(0)+exp(pol2(3))",xmin2,xmax2);
	else            ga = new TF1("ga","gaus(0)+exp(pol1(3))",xmin2,xmax2);
      }
      g = ga;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Const");
      g->SetParName(4,"Slope1"); 
      g->SetParName(5,"Slope2"); 
      g->SetParName(6,"Slope3"); 
      g->SetParName(7,"Slope4"); 
    }
    else {
      g2 = new TF1("g2","gaus(0)+gaus(3)",xmin2,xmax2);
      g = g2;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Constant2");
      g->SetParName(4,"Mean2"); 
      g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
      if (Mu3 != 0) { 
	g3= new TF1("g3","gaus(0)+gaus(3)+gaus(6)",xmin3,xmax3);
	g = g3;
	g->SetParName(0,"Constant1");
	g->SetParName(1,"Mean1"); 
	g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
	g->SetParName(3,"Constant2");
	g->SetParName(4,"Mean2"); 
	g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
	g->SetParName(6,"Constant3");
	g->SetParName(7,"Mean3"); 
	g->SetParName(8,"Sigma3"); g->SetParLimits(8,sigmas[0],sigmas[1]);
	if (Mu4 != 0) { 
	  g4= new TF1("g4","gaus(0)+gaus(3)+gaus(6)+gaus(9)",xmin3,xmax3);
	  g4->SetParName(0,"Constant1");
	  g4->SetParName(1,"Mean1"); 
	  g4->SetParName(2,"Sigma1"); g4->SetParLimits(2,sigmas[0],sigmas[1]);
	  g4->SetParName(3,"Constant2");
	  g4->SetParName(4,"Mean2"); 
	  g4->SetParName(5,"Sigma2"); g4->SetParLimits(5,sigmas[0],sigmas[1]);
	  g4->SetParName(6,"Constant3");
	  g4->SetParName(7,"Mean3"); 
	  g4->SetParName(8,"Sigma3"); g4->SetParLimits(8,sigmas[0],sigmas[1]);
	  g4->SetParName(9,"Constant4");
	  g4->SetParName(10,"Mean4"); 
	  g4->SetParName(11,"Sigma4"); g4->SetParLimits(11,sigmas[0],sigmas[1]);
	}
      }
    }
  }
  TH1 *proj = 0;
  Double_t params[12];
  Int_t k;//,ibin;
  Int_t Bin = TMath::Abs(bin);
  for (k = 0; k<nHYPS; k++) {
    if (hyp != -1 && k != hyp) continue;
    TH2 *hist = hists[k];
    Int_t nx = hist->GetNbinsX();
    for (i=1; i<=nx; i++) {
      if (bin != 0 && Bin != i) continue;
      //      if (proj) delete  proj;
      Char_t line[40];
      sprintf(line,"%s_%i",hist->GetName(),i);
      TString name(line);
      proj = hist->ProjectionY(name.Data(),i,i);
      Int_t ix1=proj->GetXaxis()->FindBin(-.1);
      Int_t ix2=proj->GetXaxis()->FindBin(0.1);
      if (proj->Integral(ix1,ix2) < 100.) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hist->GetName(),Bin,k,proj->Integral());
	delete proj;
	continue;
      }
      Int_t NFitPoints = 0;
      Double_t chisq;
      g = g1;
      g->SetParLimits(0,0,1.e7);
      g->SetParLimits(1,-.1,.1);
      g->SetParLimits(2,sigmas[0],sigmas[1]);
      proj->Fit(g->GetName(),"ri");
      g->GetParameters(params);
      Int_t kcase = -1;
      if (xmin1 < -0.5 && xmax1 > 0.5 && g->GetProb() > 1.e-3 
	  && TMath::Abs(g->GetParameter(1)) < 0.05) goto Done;
     if (ga) {
	g = ga;
	g1->GetParameters(params);
	params[1] = 0.;
	params[3] = 0.;
	params[4] = 0.;
	params[5] = 0.;
	params[6] = 0.;
	params[7] = 0.;
	params[8] = 0.;
	g->SetParameters(params);
	kcase = 0;
	if (g->GetProb() > 1.e-3) goto Done;
      }
      else {
	if (g2) {
	  params[1] = 0.;
	  params[3] = params[0];
	  params[4] = Mu2;
	  params[5] = 2.0*params[2];
	  g = g2;
	  g->SetParameters(params);
	  g->SetParLimits(0,0,1.e7);
	  g->SetParLimits(1,-.1,.1);
	  g->SetParLimits(2,sigmas[0],sigmas[1]);
	  g->SetParLimits(3,0,1.e7);
	  g->SetParLimits(5,sigmas[0],sigmas[1]);
	  proj->Fit(g->GetName(),"ri");
	  g->GetParameters(params);
	  kcase = 2;
	  if (g->GetProb() > 1.e-3) goto Done;
	  if (g3) {
	    params[1] = 0.;
	    params[6] = params[0];
	    params[7] = Mu3;
	    params[8] = 2.0*params[2];
	    g = g3;
	    g->SetParameters(params);
	    g->SetParLimits(0,0,1.e7);
	    g->SetParLimits(1,-.1,.1);
	    g->SetParLimits(2,sigmas[0],sigmas[1]);
	    g->SetParLimits(3,0,1.e7);
	    g->SetParLimits(5,sigmas[0],sigmas[1]);
	    g->SetParLimits(6,0,1.e7);
	    g->SetParLimits(8,sigmas[0],sigmas[1]);
	    proj->Fit(g->GetName(),"ri");
	    g->GetParameters(params);
	    kcase = 3;
	    if (g->GetProb() > 1.e-3) goto Done;
	    if (g4) {
	      params[1] = 0.;
	      params[9] = params[0];
	      params[10] = Mu4;
	      params[11] = 2.0*params[2];
	      g = g4;
	      g->SetParameters(params);
	      g->SetParLimits(0,0,1.e7);
	      g->SetParLimits(1,-.1,.1);
	      g->SetParLimits(2,sigmas[0],sigmas[1]);
	      g->SetParLimits(3,0,1.e7);
	      g->SetParLimits(5,sigmas[0],sigmas[1]);
	      g->SetParLimits(6,0,1.e7);
	      g->SetParLimits(8,sigmas[0],sigmas[1]);
	      g->SetParLimits(9,0,1.e7);
	      g->SetParLimits(11,sigmas[0],sigmas[1]);
	      proj->Fit(g->GetName(),"ri");
	      kcase = 4;
	      g->GetParameters(params);
	    }
	  }
	}
      }
    Done:
      if (g) {
	proj->Fit(g->GetName(),"RIM");
	canvas->Update();
	Int_t l = 1;
	Double_t mu =  g->GetParameter(l);
	for (int m=2;m<=kcase;m++) {
	  if (TMath::Abs(mu) > TMath::Abs(g->GetParameter(3*m-2))) {
	    l = 3*m-2; mu =  g->GetParameter(l);
	    //	    printf("l=%i\n",l);
	  }
	}
	Nu[N]  = g->GetParameter(l);// printf("l=%i Nu=%f\n",l,Nu[N]);
	Mu[N]  = Nu[N] + histp[k]->GetBinContent(i);
	dMu[N] = g->GetParError(l);///Mu[N];
	//    Mu[N] = TMath::Log(Mu[N]);
	Sigma[N]  = g->GetParameter(2);
	dSigma[N] = g->GetParError(2);
	NFitPoints = g->GetNumberFitPoints();
	Int_t NDF = g->GetNDF();
	Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
	chisq      = g->GetChisquare();
	X[N] = hist->GetXaxis()->GetBinCenter(i);
	dX[N] = hist->GetXaxis()->GetBinWidth(i);
	Double_t pionM = Masses[k]*pow(10.,X[N]);
	printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
		"chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
		Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob);
	//	if (bin < 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.05) {
	//	if ( bin >= 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	if ( bin >= 0 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	  printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		 Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	  TString FileN("FitPars");
	  if (hyp > -1)  FileN += HistNames[hyp];
	  FileN += ".h";
	  FILE *fp = fopen(FileN.Data(),"a");
	  if (fp) {
	    if (N == 0) {
	      TDatime time;
	      fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	      fprintf(fp,
"//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	    }
	  fprintf(fp,
		  "{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		  Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	    fclose(fp);
	  }
#if 1
	  proj->Write();
#endif
	}
	else printf ("================== Skip it\n");
      }
      N++; 	
      proj->Draw();// cnew->Update();
    }
  }
  if (f) {delete f;}
}
#endif
//________________________________________________________________________________
void FitB4G(Int_t hyp=-1, Int_t bin=0, 
		                      Double_t xmin1=-1.0, Double_t xmax1 = 1.0,
#if 0
		     Double_t Mu2 =-3.0,Double_t xmin2=-.2, Double_t xmax2 = .2,
		     Double_t Mu3 = 0.0,Double_t xmin3=-2., Double_t xmax3 = 4.,
		     Double_t Mu4 = 0.0
#else
		     Double_t Mu2 = -.5,Double_t xmin2=-2., Double_t xmax2 = 4.,
		     Double_t Mu3 = 0.1,Double_t xmin3=-2., Double_t xmax3 = 4.,
		     Double_t Mu4 = 0.3
#endif
	    )
{  
  Double_t sigmas[2] = {0.06,0.12};
  const Int_t nHYPS = NHYPS;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  TFile *f = 0;
  if (bin == 0) {
    TString newfile("FitB4G");
    newfile += gSystem->BaseName(fRootFile->GetName());
    f = new TFile(newfile.Data(),"update");
  }
  Int_t i;
  for (i = 0; i< nHYPS; i++) {
    if (hyp >= 0 && hyp != i) continue;
    hists[i] = (TH2 *) fRootFile->Get(HistNames[i]);
    if (!hists[i]) {printf("Cannot histogram %s\n",HistNames[i]); return;}
    histp[i] = (TProfile *) fRootFile->Get(HistNameP[i]);
    if (!histp[i]) {printf("Cannot histogram %s\n",HistNameP[i]); return;}
  }
  TF1 *g1 = new TF1("g1","gaus",xmin1,xmax1);
  TF1 *g = 0, *g2 = 0, *g3 = 0, *g4 = 0, *ga = 0;
  TCanvas *canvas = new TCanvas("canvas","canvas");
  if (Mu2 != 0) {
    if (Mu2 < -1.) {
      if   (Mu2 <= -4.) ga = new TF1("ga","gaus(0)+exp(pol3(3))",xmin2,xmax2);
      else {
	if (Mu2 <= -3.) ga = new TF1("ga","gaus(0)+exp(pol2(3))",xmin2,xmax2);
	else            ga = new TF1("ga","gaus(0)+exp(pol1(3))",xmin2,xmax2);
      }
      g = ga;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Const");
      g->SetParName(4,"Slope1"); 
      g->SetParName(5,"Slope2"); 
      g->SetParName(6,"Slope3"); 
      g->SetParName(7,"Slope4"); 
    }
    else {
      g2 = new TF1("g2","gaus(0)+gaus(3)",xmin2,xmax2);
      g = g2;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Constant2");
      g->SetParName(4,"Mean2"); 
      g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
      if (Mu3 != 0) { 
	g3= new TF1("g3","gaus(0)+gaus(3)+gaus(6)",xmin3,xmax3);
	g = g3;
	g->SetParName(0,"Constant1");
	g->SetParName(1,"Mean1"); 
	g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
	g->SetParName(3,"Constant2");
	g->SetParName(4,"Mean2"); 
	g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
	g->SetParName(6,"Constant3");
	g->SetParName(7,"Mean3"); 
	g->SetParName(8,"Sigma3"); g->SetParLimits(8,sigmas[0],sigmas[1]);
	if (Mu4 != 0) { 
	  g4= new TF1("g4","gaus(0)+gaus(3)+gaus(6)+gaus(9)",xmin3,xmax3);
	  g4->SetParName(0,"Constant1");
	  g4->SetParName(1,"Mean1"); 
	  g4->SetParName(2,"Sigma1"); g4->SetParLimits(2,sigmas[0],sigmas[1]);
	  g4->SetParName(3,"Constant2");
	  g4->SetParName(4,"Mean2"); 
	  g4->SetParName(5,"Sigma2"); g4->SetParLimits(5,sigmas[0],sigmas[1]);
	  g4->SetParName(6,"Constant3");
	  g4->SetParName(7,"Mean3"); 
	  g4->SetParName(8,"Sigma3"); g4->SetParLimits(8,sigmas[0],sigmas[1]);
	  g4->SetParName(9,"Constant4");
	  g4->SetParName(10,"Mean4"); 
	  g4->SetParName(11,"Sigma4"); g4->SetParLimits(11,sigmas[0],sigmas[1]);
	}
      }
    }
  }
  TH1 *proj = 0;
  Double_t params[12];
  Int_t k;//,ibin;
  Int_t Bin = TMath::Abs(bin);
  for (k = 0; k<nHYPS; k++) {
    if (hyp != -1 && k != hyp) continue;
    TH2 *hist = hists[k];
    Int_t nx = hist->GetNbinsX();
    for (i=1; i<=nx; i++) {
      if (bin != 0 && Bin != i) continue;
      //      if (proj) delete  proj;
      Char_t line[40];
      sprintf(line,"%s_%i",hist->GetName(),i);
      TString name(line);
      proj = hist->ProjectionY(name.Data(),i,i);
      Int_t ix1=proj->GetXaxis()->FindBin(-.1);
      Int_t ix2=proj->GetXaxis()->FindBin(0.1);
      if (proj->Integral(ix1,ix2) < 100.) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hist->GetName(),Bin,k,proj->Integral());
	delete proj;
	continue;
      }
      Int_t NFitPoints = 0;
      Double_t chisq;
      g = g1;
      g->SetParLimits(0,0,1.e7);
      g->SetParLimits(1,-.1,.1);
      g->SetParLimits(2,sigmas[0],sigmas[1]);
      proj->Fit(g->GetName(),"ri");
      g->GetParameters(params);
      Int_t kcase = -1;
      if (xmin1 < -0.5 && xmax1 > 0.5 && g->GetProb() > 1.e-3 
	  && TMath::Abs(g->GetParameter(1)) < 0.05) goto Done;
     if (ga) {
	g = ga;
	g1->GetParameters(params);
	params[1] = 0.;
	params[3] = 0.;
	params[4] = 0.;
	params[5] = 0.;
	params[6] = 0.;
	params[7] = 0.;
	params[8] = 0.;
	g->SetParameters(params);
	kcase = 0;
	if (g->GetProb() > 1.e-3) goto Done;
      }
      else {
	if (g2) {
	  params[1] = 0.;
	  params[3] = params[0];
	  params[4] = Mu2;
	  params[5] = 2.0*params[2];
	  g = g2;
	  g->SetParameters(params);
	  g->SetParLimits(0,0,1.e7);
	  g->SetParLimits(1,-.1,.1);
	  g->SetParLimits(2,sigmas[0],sigmas[1]);
	  g->SetParLimits(3,0,1.e7);
	  g->SetParLimits(5,sigmas[0],sigmas[1]);
	  proj->Fit(g->GetName(),"ri");
	  g->GetParameters(params);
	  kcase = 2;
	  if (g->GetProb() > 1.e-3) goto Done;
	  if (g3) {
	    params[1] = 0.;
	    params[6] = params[0];
	    params[7] = Mu3;
	    params[8] = 2.0*params[2];
	    g = g3;
	    g->SetParameters(params);
	    g->SetParLimits(0,0,1.e7);
	    g->SetParLimits(1,-.1,.1);
	    g->SetParLimits(2,sigmas[0],sigmas[1]);
	    g->SetParLimits(3,0,1.e7);
	    g->SetParLimits(5,sigmas[0],sigmas[1]);
	    g->SetParLimits(6,0,1.e7);
	    g->SetParLimits(8,sigmas[0],sigmas[1]);
	    proj->Fit(g->GetName(),"ri");
	    g->GetParameters(params);
	    kcase = 3;
	    if (g->GetProb() > 1.e-3) goto Done;
	    if (g4) {
	      params[1] = 0.;
	      params[9] = params[0];
	      params[10] = Mu4;
	      params[11] = 2.0*params[2];
	      g = g4;
	      g->SetParameters(params);
	      g->SetParLimits(0,0,1.e7);
	      g->SetParLimits(1,-.1,.1);
	      g->SetParLimits(2,sigmas[0],sigmas[1]);
	      g->SetParLimits(3,0,1.e7);
	      g->SetParLimits(5,sigmas[0],sigmas[1]);
	      g->SetParLimits(6,0,1.e7);
	      g->SetParLimits(8,sigmas[0],sigmas[1]);
	      g->SetParLimits(9,0,1.e7);
	      g->SetParLimits(11,sigmas[0],sigmas[1]);
	      proj->Fit(g->GetName(),"ri");
	      kcase = 4;
	      g->GetParameters(params);
	    }
	  }
	}
      }
    Done:
      if (g) {
	proj->Fit(g->GetName(),"RIM");
	canvas->Update();
	Int_t l = 1;
	Double_t mu =  g->GetParameter(l);
	for (int m=2;m<=kcase;m++) {
	  if (TMath::Abs(mu) > TMath::Abs(g->GetParameter(3*m-2))) {
	    l = 3*m-2; mu =  g->GetParameter(l);
	    //	    printf("l=%i\n",l);
	  }
	}
	Nu[N]  = g->GetParameter(l);// printf("l=%i Nu=%f\n",l,Nu[N]);
	Mu[N]  = Nu[N] + histp[k]->GetBinContent(i);
	dMu[N] = g->GetParError(l);///Mu[N];
	//    Mu[N] = TMath::Log(Mu[N]);
	Sigma[N]  = g->GetParameter(2);
	dSigma[N] = g->GetParError(2);
	NFitPoints = g->GetNumberFitPoints();
	Int_t NDF = g->GetNDF();
	Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
	chisq      = g->GetChisquare();
	X[N] = hist->GetXaxis()->GetBinCenter(i);
	dX[N] = hist->GetXaxis()->GetBinWidth(i);
	Double_t pionM = Masses[k]*pow(10.,X[N]);
	printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
		"chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
		Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob);
	//	if (bin < 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.05) {
	//	if ( bin >= 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	if ( bin >= 0 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	  printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		 Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	  TString FileN("FitPars");
	  if (hyp > -1)  FileN += HistNames[hyp];
	  FileN += ".h";
	  FILE *fp = fopen(FileN.Data(),"a");
	  if (fp) {
	    if (N == 0) {
	      TDatime time;
	      fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	      fprintf(fp,
"//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	    }
	  fprintf(fp,
		  "{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		  Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	    fclose(fp);
	  }
#if 1
	  proj->Write();
#endif
	}
	else printf ("================== Skip it\n");
      }
      N++; 	
      proj->Draw();// cnew->Update();
    }
  }
  if (f) {delete f;}
}
//________________________________________________________________________________
void Fit4G(Int_t ng=2, Int_t hyp=-1, Int_t bin=0, 
	   Double_t xmin1=-1.0, Double_t xmax1 = 1.0,
	   Double_t Mu2 = -.5,Double_t xmin2=-1., Double_t xmax2 = 1.,
	   Double_t Mu3 = 0.0,Double_t xmin3=-1., Double_t xmax3 = 1.,
	   Double_t Mu4 = 0.0){  
  Double_t sigmas[2] = {0.06,0.12};
  const Int_t nHYPS = 4;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  TFile *f = 0;
  if (bin == 0) {
    TString newfile("BBFit");
    newfile += gSystem->BaseName(fRootFile->GetName());
    f = new TFile(newfile.Data(),"update");
  }
  for (int i = 0; i< nHYPS; i++) {
    if (hyp >= 0 && hyp != i) continue;
    hists[i] = (TH2 *) fRootFile->Get(HistNames[i]);
    if (!hists[i]) {printf("Cannot histogram %s\n",HistNames[i]); return;}
    histp[i] = (TProfile *) fRootFile->Get(HistNameP[i]);
    if (!histp[i]) {printf("Cannot histogram %s\n",HistNameP[i]); return;}
  }
  TF1 *g1 = new TF1("g1","gaus",xmin1,xmax1);
  TF1 *g = 0, *g2 = 0, *g3 = 0, *g4 = 0, *ga = 0;
  TCanvas *canvas = new TCanvas("canvas","canvas");
  if (ng<0) {
    ga = new TF1("ga",Form("gaus(0)+exp(pol%i(3))",-ng),xmin2,xmax2);
    ga->SetParName(0,"Constant1");
    ga->SetParName(1,"Mean1"); 
    ga->SetParName(2,"Sigma1");
    ga->SetParName(3,"Const");
    for (int m = 0; m <= -ng; m++) ga->SetParName(m+3,Form("Slope%i",m)); 
  }
  else {
    for (int m = 2; m <= ng; m++) {
      if (m == 2)  {g2 = new TF1("g2","gaus(0)+gaus(3)",xmin2,xmax2); g = g2;}
      if (m == 3)  {g3 = new TF1("g3","gaus(0)+gaus(3)+gaus(6)",xmin3,xmax3); g = g3;}
      if (m == 4)  {g4 = new TF1("g4","gaus(0)+gaus(3)+gaus(6)+gaus(9)",-1.,1.); g = g4;}
      for (int k = 0; k < 3*m; k += 3) {
	g->SetParName(k  ,Form("Constant%i",m));
	g->SetParName(k+1,Form("Mean%i",m)); 
	g->SetParName(k+2,Form("Sigma%i",m));
      }
    }
  }
  TH1 *proj = 0;
  Double_t params[12];
  Int_t k,i;//,ibin;
  Int_t Bin = TMath::Abs(bin);
  for (k = 0; k<nHYPS; k++) {
    if (hyp != -1 && k != hyp) continue;
    TH2 *hist = hists[k];
    Int_t nx = hist->GetNbinsX();
    for (i=1; i<=nx; i++) {
      if (bin != 0 && Bin != i) continue;
      //      if (proj) delete  proj;
      Char_t line[40];
      sprintf(line,"%s_%i",hist->GetName(),i);
      TString name(line);
      proj = hist->ProjectionY(name.Data(),i,i);
      Int_t ix1=proj->GetXaxis()->FindBin(-.1);
      Int_t ix2=proj->GetXaxis()->FindBin(0.1);
      if (proj->Integral(ix1,ix2) < 100) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hist->GetName(),Bin,k,proj->Integral());
	delete proj;
	continue;
      }
      Int_t NFitPoints = 0;
      Double_t chisq;
      g = g1;
      g->SetParLimits(0,0,1.e7);
      g->SetParLimits(1,-.1,.1);
      g->SetParLimits(2,sigmas[0],sigmas[1]);
      proj->Fit(g->GetName(),"ri");
      g->GetParameters(params);
      Int_t kcase = -1;
      if (xmin1 < -0.5 && xmax1 > 0.5 && g->GetProb() > 1.e-3 
	  && TMath::Abs(g->GetParameter(1)) < 0.05) goto Done;
     if (ga) {
	g = ga;
	g1->GetParameters(params);
	params[1] = 0.;
	params[3] = 0.;
	params[4] = 0.;
	params[5] = 0.;
	params[6] = 0.;
	params[7] = 0.;
	params[8] = 0.;
	g->SetParameters(params);
	kcase = 0;
	if (g->GetProb() > 1.e-3) goto Done;
      }
      else {
	if (g2) {
	  params[1] = 0.;
	  params[3] = params[0];
	  params[4] = Mu2;
	  params[5] = 2.0*params[2];
	  g = g2;
	  g->SetParameters(params);
	  g->SetParLimits(0,0,1.e7);
	  g->SetParLimits(1,-.1,.1);
	  g->SetParLimits(2,sigmas[0],sigmas[1]);
	  g->SetParLimits(3,0,1.e7);
	  g->SetParLimits(5,sigmas[0],sigmas[1]);
	  proj->Fit(g->GetName(),"ri");
	  g->GetParameters(params);
	  kcase = 2;
	  if (g->GetProb() > 1.e-3) goto Done;
	  if (g3) {
	    params[1] = 0.;
	    params[6] = params[0];
	    params[7] = Mu3;
	    params[8] = 2.0*params[2];
	    g = g3;
	    g->SetParameters(params);
	    g->SetParLimits(0,0,1.e7);
	    g->SetParLimits(1,-.1,.1);
	    g->SetParLimits(2,sigmas[0],sigmas[1]);
	    g->SetParLimits(3,0,1.e7);
	    g->SetParLimits(5,sigmas[0],sigmas[1]);
	    g->SetParLimits(6,0,1.e7);
	    g->SetParLimits(8,sigmas[0],sigmas[1]);
	    proj->Fit(g->GetName(),"ri");
	    g->GetParameters(params);
	    kcase = 3;
	    if (g->GetProb() > 1.e-3) goto Done;
	    if (g4) {
	      params[1] = 0.;
	      params[9] = params[0];
	      params[10] = Mu4;
	      params[11] = 2.0*params[2];
	      g = g4;
	      g->SetParameters(params);
	      g->SetParLimits(0,0,1.e7);
	      g->SetParLimits(1,-.1,.1);
	      g->SetParLimits(2,sigmas[0],sigmas[1]);
	      g->SetParLimits(3,0,1.e7);
	      g->SetParLimits(5,sigmas[0],sigmas[1]);
	      g->SetParLimits(6,0,1.e7);
	      g->SetParLimits(8,sigmas[0],sigmas[1]);
	      g->SetParLimits(9,0,1.e7);
	      g->SetParLimits(11,sigmas[0],sigmas[1]);
	      proj->Fit(g->GetName(),"ri");
	      kcase = 4;
	      g->GetParameters(params);
	    }
	  }
	}
      }
    Done:
      if (g) {
	proj->Fit(g->GetName(),"RIM");
	canvas->Update();
	Int_t l = 1;
	Double_t mu =  g->GetParameter(l);
	for (int m=2;m<=kcase;m++) {
	  if (TMath::Abs(mu) > TMath::Abs(g->GetParameter(3*m-2))) {
	    l = 3*m-2; mu =  g->GetParameter(l);
	    //	    printf("l=%i\n",l);
	  }
	}
	Nu[N]  = g->GetParameter(l);// printf("l=%i Nu=%f\n",l,Nu[N]);
	Mu[N]  = Nu[N] + histp[k]->GetBinContent(i);
	dMu[N] = g->GetParError(l);///Mu[N];
	//    Mu[N] = TMath::Log(Mu[N]);
	Sigma[N]  = g->GetParameter(2);
	dSigma[N] = g->GetParError(2);
	NFitPoints = g->GetNumberFitPoints();
	Int_t NDF = g->GetNDF();
	Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
	chisq      = g->GetChisquare();
	X[N] = hist->GetXaxis()->GetBinCenter(i);
	dX[N] = hist->GetXaxis()->GetBinWidth(i);
	Double_t pionM = Masses[k]*pow(10.,X[N]);
	printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
		"chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
		Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob);
	//	if (bin < 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.05) {
	//	if ( bin >= 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	if ( bin >= 0 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	  printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		 Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	  TString FileN("FitPars");
	  if (hyp > -1)  FileN += HistNames[hyp];
	  FileN += ".h";
	  FILE *fp = fopen(FileN.Data(),"a");
	  if (fp) {
	    if (N == 0) {
	      TDatime time;
	      fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	      fprintf(fp,
"//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	    }
	  fprintf(fp,
		  "{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		  Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	    fclose(fp);
	  }
#if 1
	  proj->Write();
#endif
	}
	else printf ("================== Skip it\n");
      }
      N++; 	
      proj->Draw();// cnew->Update();
    }
  }
  if (f) {delete f;}
}
#ifdef PLUSHIKIN
//________________________________________________________________________________
void DrawMonths(TH1 *TimeMuFG,Double_t ymin=-.5, Double_t ymax=2.5) {
  //  TCanvas *canvas = new TCanvas("Y2001timeFit","z Fit");
  TimeMuFG->SetMaximum(ymax);
  TimeMuFG->SetMinimum(ymin);
  TimeMuFG->SetStats(0);
  TimeMuFG->Draw();
  TimeMuFG->SetMarkerStyle(20);
  TimeMuFG->SetXTitle("seconds since the Epoch");
  TimeMuFG->SetYTitle("z Fit");
  TimeMuFG->SetTitle("");
  TimeMuFG->GetXaxis()->SetTimeDisplay(1);
  TimeMuFG->GetXaxis()->SetTimeFormat("%m/%d/%y");
  TimeMuFG->Draw();
  for (Int_t i=7; i<13; i++) {
    Int_t d = 20010001 + 100*i;
    TDatime t(d,0);
    TString ts(t.AsSQLString());
    TString ymd(ts.Data(),ts.Index("-01 "));
    Double_t x = t.Convert();
    TLine *l = new TLine(x,ymin,x,ymax);
    l->SetLigneColor(i-6);
    l->Draw();
    TText *text = new TText(x, 0.8*(ymin+ymax),ymd.Data());
    text->Draw();
  }
}
//________________________________________________________________________________
void dEdxSpC(TTree *DeDxTree) {
  const Int_t noSectors = 24;
  const Int_t noPadrows = 45;
  const Int_t noSigns  = 2;
  Int_t nx = noSectors*noPadrows*noSigns;
  TCut  Cut("m_flag0points>36 && m_dx>0 && m_dx<10 && m_de>0 && m_de<1.e-4 && m_pmag > 0.5");
  Char_t line[80];
  sprintf(line,"log(m_de/m_dx/m_zPi):(m_charge+1)/2+%i*(m_padrow-1+%i*(m_sector-1))",noSigns,noPadrows);
  TString Plot(line); printf("Plot = %s\n",Plot.Data());
  TString Title = Plot;
  Title += "versus Sector, Padrow, Charge for ";
  Title += Cut.GetTitle();
  TH2F *SpC = new TH2F("SpC",Title.Data(),nx,0,nx,200,-3.,7.);
  Plot += " >> SpC";
  DeDxTree->Draw(Plot.Data(),Cut);  
  TFile *f = new TFile("SpC.root","RECREATE");
  SpC->Write();
  delete f;
}
//________________________________________________________________________________
void plotProfSpC(TCanvas *c1,TProfile *prof) 
{
  if (c1 && prof) {
    c1->Clear();
    c1->Divide(4,6);
    char line[10];
    for (Int_t i=0;i<24;i++) {
      c1->cd(i+1);
      sprintf(line,"Sector %i",i+1);
      prof->SetTitle(line);
      Int_t i1 = 90*i;
      prof->SetAxisRange(i1,i1+89); prof->Draw("R");
    }
  }
}
//_______________________________________________________________________________
Double_t LogLandau(Double_t *x, Double_t *par){
   Double_t yy =x[0];
   Double_t xx = TMath::Exp(yy); 
   Double_t f = xx*TMath::Landau(xx,par[0],par[1]);
   return f;
}
//________________________________________________________________________________
void Func()
{
   TF1 *f1 = new TF1("Func",LogLandau,0,10,2);
   f1->SetParameters(0,1);
   f1->SetParNames("mean","sigma");
   f1->Draw();
}
//________________________________________________________________________________
void SpCfit(TH2F *hist, Int_t i1, Int_t i2)
{
   TH1D *h1 = hist->ProjectionY("bin",i1,i2);
   TF1 *f1= (TF1 *) gROOT->GetFunction("Func");
   f1->SetParameters(0,1);
   h1->Fit("Func");
}
//________________________________________________________________________________
void Fee(const Char_t *topDir = "/star/rcf/scratch/fisyak/NTuples2/",
	 const Char_t *TreeName = "DeDxTree") {
  Int_t NoSector = 24;
  Int_t NoFee = 82;
  TH3F *Fee = new TH3F("Fee","dEdx versus sector and Fee",
		       NoSector,1,NoSector+1,
		       NoFee,0,NoFee,
		       200,-5.,5.);
  if (gClassTable->GetID("TDataSet")<0) gSystem->Load("libTable");
  TFileSet dirs(topDir);
  TDataSetIter next(&dirs,0);
  TDataSet *set = 0; 
  Int_t NFiles = 0;
  while ( (set = next()) ) {           
    if (strcmp(set->GetTitle(),"file") || 
	!strstr(set->GetName(),".root")) continue;
    TString File(gSystem->ConcatFileName(topDir,set->Path()));
    
    TString HName("F");
    HName += set->Path();
    HName.ReplaceAll("/","");
    HName.ReplaceAll(".root","");
    TFile f(File.Data());
    cout << " ================== Opened " <<  File.Data() << endl;
    NFiles++;
    TTree *DeDxTree = (TTree *) f.Get(TreeName);
    if (DeDxTree) {
      if (NFiles > 2) break;
      TH3F *fee = new TH3F(HName.Data(),"dEdx versus sector and Fee",
			   NoSector,1,NoSector+1,
			   NoFee,0,NoFee,
			   200,-5.,5.);
      DeDxTree->Draw("log(m_de/m_dx/m_zPi):m_fee:m_sector>>Fee","m_de>0 && m_de<2e-4");
//       Int_t nentries = Int_t(DeDxTree->GetEntries());
      
//       Int_t nbytes = 0, nb = 0;
//       for (Int_t jentry=0; jentry<nentries;jentry++) {
// 	Int_t ientry = LoadTree(jentry); //in case of a TChain, ientry is the entry number in the current file
// 	nb = DeDxTree->GetEntry(jentry);   nbytes += nb;
// 	// if (Cut(ientry) < 0) continue;
//       }
      Fee->Add(fee);
      TFile *ff = new TFile("fee.root","UPDATE");
      fee->Write();
      delete ff;
      delete fee;
    }
    else {
      cout << "  --------------------  File is empty" << endl;
      //      break;
    }
    Fee->Draw("colz");
    gPad->Update();
    TFile *ff = new TFile("fee.root","UPDATE");
    Fee->Write();
    delete ff;
  }
}
//________________________________________________________________________________
void MakeTimeGain(TH1 *hist, const Char_t *TabNam = "TpcTimeGain"){
  char filename[80]; 
  Double_t params[2];
//   TF1 *p0 = new TF1("p0","pol0");
//   hist->Fit("p0");
//  p0->GetParameters(params);
  if (gClassTable->GetID("TTable") < 0) gSystem->Load("libTable");
  if (gClassTable->GetID("St_TpcTimeGain") < 0) gSystem->Load("St_Tables");
  params[0] = 0;//-7.95305e-02;
  St_TpcTimeGain *timegain = new St_TpcTimeGain(TabNam,1);
  timegain->SetNRows(1);
  TpcTimeGain_st *gain = timegain->GetTable();
  Int_t Nbins = hist->GetNbinsX();
  for (Int_t i=1; i<=Nbins; i++) {
    Double_t scale = hist->GetBinContent(i);
    Double_t error = hist->GetBinError(i);
    if (error == 0) continue;
    if (error > 0.1) continue;
    //    if (scale > 0 || scale < -.20) continue;
    if (TMath::Abs(scale) > 0.50) continue;
    gain->ScaleFactor = TMath::Exp(-(scale-params[0]));
    gain->ErrorScaleFactor = error;
    Double_t dt    = hist->GetBinLowEdge(i);
    UInt_t   date  = dt;
    TDatime  time; time.Set(date);
    printf("bin: %i date: %i Date: %i Time: %i\n",i,date,time.GetDate(),time.GetTime());
    sprintf(filename,"./StarDb/Calibrations/tpc/%s.%08d.%06d.C",TabNam,time.GetDate(),time.GetTime());
    printf("Create %s\n",filename);
    TString dirname = gSystem->DirName(filename);
    if (gSystem->OpenDirectory(dirname.Data())==0) { 
      if (gSystem->mkdir(dirname.Data())) {
	cout << "Directory " << dirname << " creation failed" << endl;
	cout << "Putting " << TabNam << ".C in current directory" << endl;
	for (int i=0;i<80;i++){filename[i]=0;}
	sprintf(filename,"%s.%08d.%06d.C",TabNam.time.GetDate(),time.GetTime());
      }
    }
    ofstream *out = new ofstream(filename);
    timegain->SavePrimitive(*out,"");
    delete out;
    //    break;
  }
}
//________________________________________________________________________________
void FitF(TH2 *hist=0, TF1 *ga=0) {
  if (!hist || !ga) return;
  Int_t nx = hist->GetNbinsX();
  TH1D *proj = 0;
  TCanvas *c = new TCanvas("Fit");
  TString name(hist->GetName());
  name += "MuFG";
  Int_t nBins = hist->GetXaxis()->GetNbins();
  Double_t xlow = hist->GetXaxis()->GetXmin();
  Double_t xup  = hist->GetXaxis()->GetXmax();
  TH1D *MuF = new TH1D(name.Data(),"Avarage shift versus no. of measurement points",
		       nBins,  xlow, xup);
  name = hist->GetName();
  name += "SigmaFG";
  TH1D *SigmaF = new TH1D(name.Data(),"Sigma of z versus no. of measurement points",
		       nBins,  xlow, xup);
  N = 0;
  Double_t chisq = -999;
  for (int i=1; i<=nBins; i++) {
    if (proj) delete proj;
    proj = hist->ProjectionY("proj",i,i);
    X[N] = hist->GetXaxis()->GetBinCenter(i);
    dX[N] = hist->GetXaxis()->GetBinWidth(i);
    if (proj->Integral() < 1000) {
      if (N>0) goto NEXT;
      continue;
    }
    ga->SetParameter(0,1.e6);
    ga->SetParameter(1,0.);
    //    ga->SetParLimits(1,-.1e-9,.1e-9);
    ga->SetParameter(2,0.);
    //    ga->SetParLimits(2,-.1e-9,.1e-9);
#if 0
    ga->SetParameter(1,1.e-9);
    ga->SetParLimits(1,1.e-9,1.e-9);
    //#else
    ga->SetParameter(2,1.);
    ga->SetParLimits(2,1.,1.);
#endif
    ga->SetParameter(3,X[N]);
    ga->SetParLimits(3,X[N],X[N]);
    proj->Fit(ga->GetName(),"R");
    Mu[N]  = ga->GetParameter(1);
    dMu[N] = ga->GetParError(1);///Mu[N];
    //    Mu[N] = TMath::Log(Mu[N]);
    Sigma[N]  = ga->GetParameter(2);
    dSigma[N] = ga->GetParError(2);
    chisq = ga->GetChisquare();
    MuF->SetCellContent(i,0,Mu[N]);
    MuF->SetCellError(i,0,dMu[N]);
    SigmaF->SetCellContent(i,0,Sigma[N]);
    SigmaF->SetCellError(i,0,dSigma[N]);
    proj->Draw(); c->Update();
    printf("Bin: %i x: %f +/- %f MuF: %f+/-%f Sigma: %f+/-%f chisq: %f \n",
	   N,X[N],dX[N],Mu[N],dMu[N],Sigma[N],dSigma[N],chisq);
 NEXT:   
    N++;  
  }
}
//________________________________________________________________________________
void MakeProjY(TH2 *hist, UInt_t ls=0) {
  if (! hist) {printf("Missing hist\n"); return;}
  if (ls > 1) {printf("Illegal ls = %i\n",ls); return;}
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  TString name(hist->GetName());
  static Double_t ShapeMu[2][3] = {
    {-2.32656e-01, 7.63952e-02, 6.59020e-03},
    {-3.75038e-01, 1.28860e-01,-6.93063e-02}
  };
  static Double_t ShapeSigma[2][3] = {
    { 6.41952e-01,-2.19547e-01, 9.63439e-03},
    { 8.29636e-01,-3.71708e-01, 8.65136e-02}
  };
  name += "pY";
  TH1D *h = new TH1D(name.Data(),hist->GetTitle(),ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  for (int i=1;i<=nx;i++){
    Double_t x = hist->GetXaxis()->GetBinCenter(i);
    Double_t yy   = ShapeMu[ls][0] + x*(ShapeMu[ls][1] + x*ShapeMu[ls][2]);
    Double_t dy   = ShapeSigma[ls][0] + x*(ShapeSigma[ls][1] + x*ShapeSigma[ls][2]);
    for (int j=1;j<=ny;j++){
      Double_t y = hist->GetYaxis()->GetBinCenter(j);
      h->Fill((y-yy)/dy,hist->GetCellContent(i,j));
    }
  }
}
//________________________________________________________________________________
void badRun(TH1 *hist, Double_t ymin = -0.2, Double_t ymax = 0.) {
  if (! hist) return;
  Int_t nx = hist->GetNbinsX();
  TDatime t;
  for (Int_t i=1; i<=nx; i++) {
    Double_t y = hist->GetBinContent(i);
    if (y < ymin || y > ymax) {
      UInt_t d = (UInt_t) hist->GetBinLowEdge(i);
      t.Set(d);
      cout << "Wrong scale =" << y << " Date " <<  t.AsSQLString() 
	   << " Date : " << t.AsString() << endl;
    }
  }
}
//____________________________________
Double_t bdEdx(Double_t *xx, Double_t *par) {
  Double_t zz = TMath::Log(xx[0]);
  Double_t x = par[0]; // log10bg
  Double_t y = par[1]; // log2dx
  Double_t zprob = gBichsel->GetMostProbableZ(x,y)-5.07402529167365057e-01;
  Double_t sigma = gBichsel->GetRmsZ(x,y);
  Double_t z = (zz - zprob)/sigma;
  return gBichsel->GetProbability(x,y,z)/xx[0]/sigma;
}
//____________________________________
Double_t bFunc(Double_t *xx, Double_t *par) {
  Double_t z = xx[0];
  Double_t x = par[0];
  Double_t y = par[1];
  return gBichsel->GetProbability(x,y,z);
}
//____________________________________
Double_t bFuncPA(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return TMath::Exp(gBichsel->GetMostProbableZ(x,y));
}
//____________________________________
Double_t bFuncP(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return gBichsel->GetMostProbableZ(x,y);
}
//____________________________________
Double_t bFuncA(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return TMath::Exp(gBichsel->GetAverageZ(x,y));
}
//____________________________________
Double_t bFunc70(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return gBichsel->GetI70(x,y);
}
//____________________________________
Double_t bFunc60(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return gBichsel->GetI60(x,y);
}
//____________________________________
Double_t fncMip(Double_t *xx, Double_t *par) {
  Z = xx[0];
  Double_t zMostProb = par[0];//gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx) + par[0];
  Double_t sigma     = gBichsel->GetRmsZ(Xlog10bg,Ylog2dx) + par[1];
  //  sigma *= sigma;
  //  sigma += par[1];
  //  sigma = TMath::Sqrt(sigma);
  //  Double_t sigma     = 1. +  par[1];
  Double_t z = (Z - zMostProb)/sigma;
  //  Double_t z  = par[0] + (1. + par[1])*zz;
  //  Double_t Value = gBichsel->GetProbability(Xlog10bg,Ylog2dx,z)/sigma*(1+par[1]);
  Double_t Value = gBichsel->GetProbability(Xlog10bg,Ylog2dx,z)/sigma;
#ifdef PRINT
  cout << "Xlog10bg/Ylog2dx/Z =\t" << Xlog10bg << "/" << Ylog2dx << "/" << Z 
       << "\tzMostProb =\t" << zMostProb
       << "\tsigma = \t" << sigma
       << "\tValue = \t" << Value << endl;
#endif
  return Value;
}
//____________________________________
Double_t fncMipX(Double_t *xx, Double_t *par) {//  modify dx
  Z = xx[0];
  Double_t dx = pow(2.,Ylog2dx);
  Double_t dX = dx + par[0];
  if (dX < 0.1) dX = 0.1;
  Double_t ylog2dx = TMath::Log2(dX);
  Double_t zMostProb = 
    gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx) - 
    gBichsel->GetMostProbableZ(Xlog10bg,ylog2dx);
  Double_t sigma     = gBichsel->GetRmsZ(Xlog10bg,ylog2dx);
  Double_t ZZ = Z - TMath::Log(dX/dx);
  Double_t z = (ZZ - zMostProb)/sigma;
  Double_t Value = gBichsel->GetProbability(Xlog10bg,ylog2dx,z)/sigma;
#ifdef PRINT
  cout << "Xlog10bg/Ylog2dx/Z =\t" << Xlog10bg << "/" << Ylog2dx << "/" << Z 
       << "\tzMostProb =\t" << zMostProb
       << "\tsigma = \t" << sigma
       << "\tValue = \t" << Value << endl;
#endif
  return Value;
}
//____________________________________
void bFitMip(const Int_t iX = 8,const Int_t iY=8) {
  TDirectory *dir = gDirectory; cout << "Directory: " << dir->GetName() << endl;
  if (! gBichsel) {
    gSystem->Load("StBichsel");
    gBichsel = new Bichsel();
  };
  dir->cd(); cout << "Directory: " << gDirectory->GetName() << endl;
  TString name3D("SecRow3Mip");
  canvas = new TCanvas("BinFit","Fit parameters");
  TH3 *hist = (TH3 *) gDirectory->Get(name3D);
  if (!hist) return;
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  Int_t hyp = 0;
  TString tFName("SecRowMipFit");
  tFName += NAMES[hyp];
  tFName += gSystem->BaseName(gDirectory->GetName());
  if (! newf) newf = new TFile(tFName.Data(),"update");
  TNtuple *FitP = (TNtuple *) newf->Get("FitP");
  if (! FitP) FitP = new TNtuple("FitP","Fit results",
				 "i:j:x:y:mean:rms:peak:mu:sigma:p2:emu:esigma:ep2:sum:chisq:prob:hyp:chisqGP:probGP:peakGP:muGP:sigmaGP:a0:a1:a2:a3:a4:a5:Npar");
  TH2D *p0 = (TH2D *)  newf->Get("p0");
  if (! p0) p0 = new TH2D("p0","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  TH2D *p1 = (TH2D *)  newf->Get("p1");
  if (! p1) p1 = new TH2D("p1","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
#if 0
  TH2D *p2 = (TH2D *)  newf->Get("p2");
  if (! p2) p2 = new TH2D("p2","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
#endif
  TH2D *chisq = (TH2D *)  newf->Get("chisq");
  if (! chisq) chisq = new TH2D("chisq","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  if (! func) func = new TF1("func",fncMip,hist->GetZaxis()->GetXmin(),hist->GetZaxis()->GetXmax(),2);
  //  if (! func) func = new TF1("func",fncMipX,hist->GetZaxis()->GetXmin(),hist->GetZaxis()->GetXmax(),1);
  //  func->SetParLimits(0,-2.,2.);
  //  func->FixParameter(1,0);
  struct  FitMip_t {
    Float_t i;
    Float_t j;
    Float_t x;
    Float_t y;
    Float_t mean;
    Float_t rms;
    Float_t peak;
    Float_t p0;
    Float_t p1;
    Float_t p2;
    Float_t ep0;
    Float_t ep1;
    Float_t ep2;
    Float_t sum;
    Float_t chisq;
    Float_t prob;
    Float_t hyp;
#if 0
    Float_t chisqGP;
    Float_t probGP;
    Float_t peakGP;
    Float_t muGP;
    Float_t sigmaGP;
    Float_t a0;
    Float_t a1;
    Float_t a2;
    Float_t a3;
    Float_t a4;
    Float_t a5;
#endif
  };
  FitMip_t Fit;
  Double_t params[9];
  Int_t i1 = 1, i2 = nx;  if (iX > 0) {i1 = iX; i2 = iX;}
  Int_t j1 = 1, j2 = ny;  if (iY > 0) {j1 = iY; j2 = iY;}
  TF1 *g = 0;
  for (Int_t i=i1; i<=i2; i++) {
    for (Int_t j=j1; j<=j2; j++) {
      newf->cd();
      TString projName(Form("%s_%i_%i",NAMES[hyp],i,j));
      TH1D *proj = (TH1D *) newf->Get(projName.Data());
      if (! proj) proj = hist->ProjectionZ(projName.Data(),i,i,j,j);
      if (! proj) continue;
      double xx = hist->GetXaxis()->GetBinCenter(i);
      double yy = hist->GetYaxis()->GetBinCenter(j);
      Ylog2dx = yy;
#if 0  
      double dy = hist->GetYaxis()->GetBinWidth(j);
      double b = 7.5;
      if (xx >=14) b = 4;
      Double_t xm = yy + 1./b - 0.5*dy/TMath::TanH(0.5*dy*b);
      Ylog2dx = xm;
#endif
      Double_t sum = proj->Integral();
      memset (&Fit.i, 0, sizeof(Fit));
      Fit.sum = sum;
      Fit.i = i;
      Fit.j = j;
      Fit.mean = proj->GetMean();
      Fit.rms  = proj->GetRMS();
      Fit.x = xx;
      Fit.y = Ylog2dx;
      Int_t Row = (int) xx;
      //      Xlog10bg = TMath::Log10(1.5/0.13956995);
      Xlog10bg = TMath::Log10(0.448/0.14);
      if (sum < 1.e2) {delete proj; continue;}
      cout << "Projection:\t" 
	   << proj->GetName() 
	   << "\ti/j\t" << i << "/" << j 
	   << "\tXlog10bg/Ylog2dx\t" << Row << "/" << Ylog2dx 
	   << "\tRow/dx\t" << Row << "/" << pow(2.,Ylog2dx) << "/" << pow(2.,yy) 
	   << "\tIntegral = \t" << sum << endl;
      proj->SetTitle(Form("Row = %i dx = %6.2f", Row, pow(2.,Ylog2dx)));
      Double_t bw = proj->GetBinWidth(1);
      Int_t nb = proj->GetNbinsX();
      Int_t l1 = 999, l2 = 0;
      for (int l=1; l<=nb; l++) {
	Double_t val = proj->GetBinContent(l);
	val = val/sum;
	Double_t err = TMath::Sqrt(val*(1.-val)/2./sum);
	proj->SetBinContent(l,val/bw);
	proj->SetBinError(l,err/bw);
	if (val <= 0.0) continue;
	if (l < l1 ) l1 = l;
	l2 = l;
      }
      if (l1 < l2) proj->GetXaxis()->SetRange(l1,l2);
      //      sum *= proj->GetBinWidth(1);
      //      proj->Scale(1./sum);
      Int_t lx = proj->GetMaximumBin();
      Fit.peak = proj->GetBinCenter(lx);
//       func->FixParameter(0,params[0]);
//       func->FixParameter(1,params[1]);
#if 0
      g = FitGP(proj,"r");
      g->GetParameters(params);
      Fit.Npar  = g->GetNpar();
      Fit.chisqGP = g->GetChisquare();
      Fit.probGP  = g->GetProb();
      Fit.peakGP  = params[0];
      Fit.muGP    = params[1];
      Fit.sigmaGP = params[2];
      Fit.a0  = params[3];
      Fit.a1  = params[4];
      Fit.a2  = params[5];
      Fit.a3  = params[6];
      Fit.a4  = params[7];
      Fit.a5  = params[8];
#endif
      params[0] =  0; // - gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx);
      params[1] =  0;
      func->SetParameters(params);
      proj->Fit("func","+em");
      //      proj->Fit("func","lm");
      Fit.p0 = func->GetParameter(0);
      Fit.ep0 = func->GetParError(0);
      p0->SetBinContent(i,j,func->GetParameter(0));
      p0->SetBinError(i,j,func->GetParError(0));
      Fit.p1 = func->GetParameter(1);
      Fit.ep1 = func->GetParError(1);
      p1->SetBinContent(i,j,func->GetParameter(1));
      p1->SetBinError(i,j,func->GetParError(1));
      Fit.Npar  = g->GetNpar();
      Fit.chisq = func->GetChisquare();
      chisq->SetBinContent(i,j,func->GetChisquare());
      Fit.prob = func->GetProb();
      Fit.hyp = hyp;
      FitP->Fill(&Fit.i);
      proj->Draw();
      if (canvas) canvas->Update();
      Double_t zz = 0.1303 + gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx);
      func->Eval(zz);
    }
  }  
  if (iX == 0 && iY == 0) {  newf->cd(); newf->Write(); delete newf;}
}
//________________________________________________________________________________
void MakeTable(St_tpcFeeGainCor *gain) {
  if (!gain) return;
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  //  Char_t *Nmean = "mean";
  Char_t *Nmean = "mu";
  TH2D *mean = (TH2D *) fRootFile->Get(Nmean);
  if (!mean) {printf("Cannot histogram %s\n",Nmean); return;}
  TH2D *entries = (TH2D *) fRootFile->Get("entries");
  if (!entries) {printf("Cannot histogram entries\n"); return;}
  TH2D *chisq = (TH2D *) fRootFile->Get("chisq");
  if (!chisq) {printf("Cannot histogram chisq\n"); return;}
  TH2D *sigma = (TH2D *) fRootFile->Get("sigma");
  if (!sigma) {printf("Cannot histogram sigma\n"); return;}

  Int_t nx = mean->GetNbinsX(); printf ("nx = %i\n",nx);
  Int_t ny = mean->GetNbinsY(); printf ("ny = %i\n",ny);
  for (int i=1;i<=nx;i++){
    tpcFeeGainCor_st row; memset(&row,0,gain->GetRowSize());
    for (int j=1;j<=ny;j++){
      Double_t res = -1;
      if (entries->GetCellContent(i,j) > 0.5e3) {
	if (sigma->GetCellContent(i,j) > 0.2) {
	  Double_t d = mean->GetCellContent(i,j);
	  if (d > -0.5 && d < 0.5) res = TMath::Exp(-d);
	  else printf("d: %f i:%i j:%i\n",d,i,j);
	}
	else printf("entires:%f sigma:%f i:%i j:%i\n"
		    ,entries->GetCellContent(i,j),sigma->GetCellContent(i,j),i,j);
      }
      int fee = (j-1)/2;
      int eo  = (j-1)%2;
      row.Gain[fee][eo] = res;
    }
    gain->AddAt(&row,i-1);
  }
}
//________________________________________________________________________________
void FillTable() {
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  Char_t *Nmean = "mu";
  TH2D *mean = (TH2D *) fRootFile->Get(Nmean);
  if (!mean) {printf("Cannot histogram %s\n",Nmean); return;}
  TH2D *entries = (TH2D *) fRootFile->Get("entries");
  if (!entries) {printf("Cannot histogram entries\n"); return;}
  TH2D *chisq = (TH2D *) fRootFile->Get("chisq");
  if (!chisq) {printf("Cannot histogram chisq\n"); return;}

  Int_t nx = mean->GetNbinsX(); printf ("nx = %i\n",nx);
  Int_t ny = mean->GetNbinsY(); printf ("ny = %i\n",ny);
  TString NewFile("Correction_");
  NewFile += fRootFile->GetName();
  NewFile->ReplaceAll(".root",".h");
  FILE *fp = fopen(NewFile.Data(),"w");
  fprintf(fp,"static Double_t correction[%i][%i] = {// %s %s\n",
	  ny,nx,mean->GetName(),mean->GetTitle());
  for (int j=1;j<=ny;j++){
    fprintf(fp,"{");
    for (int i=1;i<=nx;i++){
      Double_t res = -1;
      if (entries->GetCellContent(i,j) > 0.7e4 && 
	  chisq->GetCellContent(i,j)>0 && 
	  chisq->GetCellContent(i,j)<2e3
	  ) {
	res = TMath::Exp(-mean->GetCellContent(i,j));
      }
      if(i != 1)  fprintf(fp,",");
      fprintf(fp,"%6.3f",res);
      if (i==12) fprintf(fp,"\n");
    }
    fprintf(fp,"},  // fee%i\n",j);
  }
  fprintf(fp,"};\n");
  fclose(fp);
}
//________________________________________________________________________________
void Make2Dproj(TH2D *h, Int_t N = 100, Double_t xlow = -1., Double_t xup = 1.) {
  if (!h) return;
  Int_t nx = h->GetNbinsX();
  Int_t ny = h->GetNbinsY();
  TString name(h->GetName());
  name += "_P";
  TH1D *hist = new TH1D(name.Data(),h->GetTitle(),N,xlow,xup);
  for (int i = 1; i<=nx;i++) {
    for (int j = 1; j <= ny; j++){
      if (TMath::Abs(h->GetCellContent(i,j)) < 0.01) continue;
      hist->Fill(h->GetCellContent(i,j));
    }
  }
}
#endif /* PLUSHIKIN */
