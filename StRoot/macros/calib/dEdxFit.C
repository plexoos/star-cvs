/* 
   root.exe -q -b lBichsel.C pionMIP.root 'dEdxFit.C+("SecRow3C","GF")'
*/
#if !defined(__CINT__)
// code that should be seen ONLY by the compiler
#else
#if !defined(__CINT__) || defined(__MAKECINT__)
// code that should be seen by the compiler AND rootcint
#else
// code that should always be seen
#endif
#endif
#if ROOT_VERSION_CODE >= ROOT_VERSION(5,34,18)
#define __USE_ROOFIT__
#endif
//________________________________________________________________________________
#if !defined(__CINT__) || defined(__MAKECINT__)
#include "Riostream.h"
#include <stdio.h>
#include "TROOT.h"
#include "TSystem.h"
#include "TMath.h"
#include "TH1.h"
#include "TH2.h"
#include "TH3.h"
#include "TStyle.h"
#include "TF1.h"
#include "TProfile.h"
#include "TTree.h"
#include "TChain.h"
#include "TFile.h"
#include "TNtuple.h"
#include "TCanvas.h"
#include "TFileSet.h"
#include "TDataSetIter.h"
#include "TDataSet.h"
#include "TClassTable.h"
//#include "DeDxTree.C"
#include "TMinuit.h"
#include "TSpectrum.h"
#include "StBichsel/Bichsel.h"
#include "TString.h"
#include "TLine.h"
#include "TText.h"
#include "TList.h"
#include "TPolyMarker.h"
#include "TKey.h"
#include "TLegend.h"
#ifdef __USE_ROOFIT__
#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooFFTConvPdf.h"
#include "RooPlot.h"
#include "RooCFunction1Binding.h" 
#include "RooCFunction3Binding.h"
#include "RooTFnBinding.h" 
#include "RooDataHist.h"
#include "RooAbsPdf.h"
#include "RooRealProxy.h"
#include "RooFit.h"
#include "RooRandom.h"
#include "RooFitResult.h"
#include "RooWorkspace.h"
using namespace RooFit ;
#endif /* __USE_ROOFIT__ */
#include "TObjectTable.h"
#else
class TMinuit;
class TF1;
class TH1F;
class TH2F;
class TH3F;
class TProfile;
class TH2D;
class TCanvas;
class TSpectrum;
class TSystem;
class Bichsel;
// Refer to a class implemented in libRooFit to force its loading
// via the autoloader.
#ifdef __USE_ROOFIT__
class Roo2DKeysPdf;
#endif /* __USE_ROOFIT__ */
#endif
#include "Names.h"
using namespace std;
const Int_t NH = NHYPS/2;
Int_t N = 0;
const Int_t noPoints = 1000;
Double_t X[noPoints];
Double_t dX[noPoints];
Double_t Nu[noPoints];
Double_t Mu[noPoints];
Double_t dMu[noPoints];
Double_t Sigma[noPoints];
Double_t dSigma[noPoints];
TCanvas *canvas = 0;
Double_t Xlog10bg, Ylog2dx, Z;
TFile *newf = 0;
const Char_t *NAMES[6] = {"e","p","K","pi","mu","d"};
// peak postion at p = 0.475 GeV/c wrt pion
//                        Z     pion
/// <peak postion> at p = [0.45,0.50] GeV/c wrt pion
struct peak_t {Double_t peak, sigma, mass; const Char_t *Name;};
//                                mean         RMS
static const  peak_t Peaks[6] = {
//   {0.      ,       0., 0.13956995, "pion"}, // pion
//   {1.425822, 0.101693, 0.93827231, "proton"}, // proton - pion
//   {0.565455, 0.061626, 0.493677,   "kaon"  }, // Kaon   - pi
//   {0.424916, 0.004081, 0.51099907e-3,"e"}, // e      - pi
//   {2.655586, 0.123754, 1.875613,   "d"}, // d      - pi
//   {0.004178, 0.002484, 0.105658,   "mu"}};// mu     - pi
  // 06/25/10
  {       0.      ,       0.,           0.13956995,       "pion"}, // pion
  {       1.42574,        0.101741,       0.938272,       "proton"},
  {       0.565411,       0.0616611,      0.493677,       "kaon"},
  {       0.424919,       0.00408318,     0.000510999,    "e"},
  {       2.65548,        0.123809,       1.87561,        "deuteron"},
  {       0.000717144,    0.00490783,     0.105658,       "mu"}};

Bichsel *gBichsel = 0;
//#define PRINT 1
TF1 *func = 0;
TF1 *LandauF = 0; 
class St_TpcSecRowCor;
#ifdef __USE_ROOFIT__
Double_t landauZ(Double_t *x, Double_t *par) {
  Double_t xd = x[0];
  Double_t meand = par[0];
  Double_t sigmad = par[1];
  Double_t mpshift  = -0.22278298; // 1.0844535734 + 0.61417;       // LandauZ maximum location
  // MP shift correction
  Double_t mpc = TMath::Exp(meand) - mpshift * sigmad; 
  Double_t xx = TMath::Exp(xd);
  return xx*TMath::Landau(xx,mpc,sigmad);
}
class RooRealVar;

class RooLandauZ : public RooAbsPdf {
public:
  RooLandauZ() {} ;
  RooLandauZ(const char *name, const char *title, RooAbsReal& _x, RooAbsReal& _mean, RooAbsReal& _sigma);
  RooLandauZ(const RooLandauZ& other, const char* name=0);
  virtual TObject* clone(const char* newname) const { return new RooLandauZ(*this,newname); }
  inline virtual ~RooLandauZ() { }

  Int_t getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t staticInitOK=kTRUE) const;
  void generateEvent(Int_t code);
  
protected:
  
  RooRealProxy x ;
  RooRealProxy mean ;
  RooRealProxy sigma ;
  
  Double_t evaluate() const ;
  
private:
  
  ClassDef(RooLandauZ,1) // LandauZ Distribution PDF
};
ClassImp(RooLandauZ)


//_____________________________________________________________________________
RooLandauZ::RooLandauZ(const char *name, const char *title, RooAbsReal& _x, RooAbsReal& _mean, RooAbsReal& _sigma) :
  RooAbsPdf(name,title),
  x("x","Dependent",this,_x),
  mean("mean","Mean",this,_mean),
  sigma("sigma","Width",this,_sigma)
{
}
 

//_____________________________________________________________________________
RooLandauZ::RooLandauZ(const RooLandauZ& other, const char* name) : 
  RooAbsPdf(other,name),
  x("x",this,other.x),
  mean("mean",this,other.mean),
  sigma("sigma",this,other.sigma)
{
} 


//_____________________________________________________________________________
Double_t RooLandauZ::evaluate() const
{
  //  return TMath::Landau(x, mean, sigma);
  const Double_t par[2] = {mean, sigma};
  Double_t xd = x;
  return landauZ(&xd,(Double_t *) par);
  //  return xx*TMath::Landau(xx,mpc,sigmad);
  //  return xx*TMath::Landau(xx,mpc,sigmad) / sigmad;

}


//_____________________________________________________________________________
Int_t RooLandauZ::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const
{
  if (matchArgs(directVars,generateVars,x)) return 1 ;  
  return 0 ;
}


//_____________________________________________________________________________
void RooLandauZ::generateEvent(Int_t code)
{
  assert(code==1) ;
  Double_t xgen ;
  Double_t mpshift  = -0.22278298; // 1.0844535734 + 0.61417;       // Landau maximum location
  // MP shift correction
  Double_t meand = mean;
  Double_t sigmad = sigma;
  Double_t mpc = TMath::Exp(meand) - mpshift * sigmad; 
  while(1) {    
    xgen = RooRandom::randomGenerator()->Landau(mpc,sigma);
    if (xgen <= 0) continue;
    Double_t xgl = TMath::Log(xgen) ;
    if (xgl<x.max() && xgl>x.min()) {
      x = xgl;
      break;
    }
  }
  return;
}
//_______________________________________________________________________________
///.........................................................................//
//--------------------------B E G I N N I N G ------------------------------//
//------------------------L A N D A U   Z    5  function ------------------//
//---------------------------------------------------------------//
Double_t landauZ5(Double_t *x, Double_t *par) {
  // Double_t Norm = par[0];
  Double_t xd = x[0];
  Double_t meand_pi = par[1];
  Double_t meand_pr = par[1] + Peaks[1].peak;
  Double_t sigmad_pi = par[8];
  Double_t sigmad_pr = sigmad_pi;
  Double_t meand_k = par[1] + Peaks[2].peak;
  Double_t sigmad_k = sigmad_pi;
  Double_t meand_el = par[1] + Peaks[3].peak;
  Double_t sigmad_el = sigmad_pi;
  Double_t meand_d = par[1] + Peaks[4].peak;
  Double_t sigmad_d = sigmad_pi;
  Double_t mpshift  = -0.22278298; // 1.0844535734 + 0.61417;       // LandauZ maximum location
  Double_t frac[5];
  frac[1] = TMath::Power(TMath::Sin(par[3]),2);
  frac[2] = TMath::Power(TMath::Sin(par[4]),2);
  frac[3] = TMath::Power(TMath::Sin(par[5]),2);
  frac[4] = TMath::Power(TMath::Sin(par[6]),2);

  if( ((par[4]==0.)&&(par[5]==0.)&&(par[6]==0.)&&(par[3]!=0.)) || 
      ((par[3]==0.)&&(par[5]==0.)&&(par[6]==0.)&&(par[4]!=0.)) ||
      ((par[3]==0.)&&(par[4]==0.)&&(par[6]==0.)&&(par[5]!=0.)) ||
      ((par[3]==0.)&&(par[4]==0.)&&(par[5]==0.)&&(par[6]!=0.)) )
    {frac[0]=0.;
    }

  else {frac[0] = 1. - frac[1] - frac[2] - frac[3] - frac[4];}
  // MP shift correction
  Double_t mpc_pi = TMath::Exp(meand_pi) - mpshift * sigmad_pi; 
  Double_t mpc_pr = TMath::Exp(meand_pr) - mpshift * sigmad_pr;
  Double_t mpc_k = TMath::Exp(meand_k)   - mpshift * sigmad_k;
  Double_t mpc_el = TMath::Exp(meand_el) - mpshift * sigmad_el;
  Double_t mpc_d = TMath::Exp(meand_d)   - mpshift * sigmad_d;

  Double_t xx = TMath::Exp(xd);
 
  return (xx*TMath::Landau(xx,mpc_pi,sigmad_pi)*frac[0] + 
	  xx*TMath::Landau(xx,mpc_pr,sigmad_pr)*frac[1] + 
	  xx*TMath::Landau(xx,mpc_k,sigmad_k)*frac[2] + 
	  xx*TMath::Landau(xx,mpc_el,sigmad_el)*frac[3] + 
	   xx*TMath::Landau(xx,mpc_d,sigmad_d)*frac[4])*par[7];
}


//________________________________________________________________________________

//-------------------------L A N D A U   5   C L A S S --------------------------------------------------------------------------------//
//-------------------------------------------------------------------------------------------------------------------------//

class RooLandauZ5:public RooAbsPdf
{

public:
  RooLandauZ5(){}
  RooLandauZ5(const char *name, const char *title, RooAbsReal& _x, 
	      RooAbsReal& _norm, RooAbsReal& _mean_pi, 
	      RooAbsReal& _sigma_pi, RooAbsReal& _sigma_pr, 
	      RooAbsReal& _sigma_k, RooAbsReal& _sigma_el, 
	      RooAbsReal& _sigma_d, RooAbsReal& _total, RooAbsReal& _width);
  RooLandauZ5(const RooLandauZ5& other, const char* name=0);
  virtual TObject *clone(const char *newname) const 
  {    return new RooLandauZ5(*this,newname);  }
  inline virtual ~RooLandauZ5() {}

protected:
  RooRealProxy x;
  RooRealProxy norm;
  RooRealProxy mu;
  RooRealProxy sigma_pi;
  RooRealProxy sigma_pr;
  RooRealProxy sigma_k;
  RooRealProxy sigma_el;
  RooRealProxy sigma_d;
  RooRealProxy total;
  RooRealProxy width;

  Double_t evaluate() const;

private:
  ClassDef(RooLandauZ5,1)
};

ClassImp(RooLandauZ5)

RooLandauZ5::RooLandauZ5(const char *name, const char *title, RooAbsReal& _x,
			 RooAbsReal& _norm, RooAbsReal& _mu, 
			 RooAbsReal& _sigma_pi, RooAbsReal& _sigma_pr,
			 RooAbsReal& _sigma_k, RooAbsReal& _sigma_el, 
			 RooAbsReal& _sigma_d, RooAbsReal& _total,
			 RooAbsReal& _width): 
  RooAbsPdf(name,title), 
  x("x","Dependent",this,_x), 
  norm("norm","Norm",this,_norm), 
  mu("mu","peak position",this,_mu),
  sigma_pi("sigma_pi","Width pion",this,_sigma_pi), 
  sigma_pr("sigma_pr","Width proton",this,_sigma_pr),
  sigma_k("sigma_k","Width kaon",this,_sigma_k),
  sigma_el("sigma_el","Width electron",this,_sigma_el),
  sigma_d("sigma_d","Width deutron",this,_sigma_d),
  total("total","Total",this,_total),
  width("width","Width",this,_width){}

RooLandauZ5::RooLandauZ5(const RooLandauZ5& other, const char* name): 
  RooAbsPdf(other,name), 
  x("x",this,other.x), 
  norm("norm",this,other.norm), 
  mu("mu",this,other.mu),
  sigma_pi("sigma_pi",this,other.sigma_pi), 
  sigma_pr("sigma_pr",this,other.sigma_pr),
  sigma_k("sigma_k",this,other.sigma_k), 
  sigma_el("sigma_el",this,other.sigma_el),
  sigma_d("sigma_d",this,other.sigma_d), 
  total("total",this,other.total), 
  width("width",this,other.width){} 


Double_t RooLandauZ5::evaluate() const{
  const Double_t par[10] = {norm,mu,sigma_pi,sigma_pr,sigma_k,sigma_el,sigma_d,total,width};
  Double_t xd =x;
  return landauZ5(&xd, (Double_t *)par);
}

//---------------------------------------------------------------------//
//------Global variables needed to create TF1 for particle fraction ----//
TF1 *l5xg_func = 0, *func_pi=0, *func_pr=0, *func_k=0, *func_el=0, *func_de=0;
Double_t frac_pr=0.,frac_k=0.,frac_el=-0.,frac_de=0., frac_pi=0.;

//-------------Function for scaling TF1 ---------------// 
Double_t func_lz5xg_mult(Double_t *x, Double_t *par) {
  Double_t xd = x[0];
  Double_t mult = par[8];
  Int_t Case = (int)par[9];
  switch(Case){
  case 0: 
    return ((func_pi->Eval(xd))*mult*frac_pi);
    break;
  case 1: 
    return ((func_pr->Eval(xd))*mult*frac_pr);
    break;
  case 2: 
    return ((func_k->Eval(xd))*mult*frac_k);
    break;
  case 3: 
    return ((func_el->Eval(xd))*mult*frac_el);    
    break;
  case 4: 
    return ((func_de->Eval(xd))*mult*frac_de);
    break;
  case 5:
    return ((l5xg_func->Eval(xd))*mult);
    break;
  default: 
    return ((l5xg_func->Eval(xd))*mult);
    break;
  }
}

//--------------------Function for creating TF1 for particle fractions -----//
void Sep_func(RooFFTConvPdf *l5xg, RooRealVar *t, RooRealVar *norm, RooRealVar *mu, RooRealVar *sg, RooRealVar *fProton, RooRealVar *fKaon, RooRealVar *fElektron, RooRealVar *fDeuteron, RooRealVar *total, RooRealVar *width, Int_t i )
{

    switch(i){
    case 0://Pion//
      if (func_pi) delete func_pi;
      func_pi = (TF1*)l5xg->asTF(RooArgList(*t), RooArgList(*norm,*mu,*sg,*fProton,*fKaon,*fElektron,*fDeuteron,*total,*width),*t ); 
      func_pi->FixParameter(3,0.);
      func_pi->FixParameter(4,0.);
      func_pi->FixParameter(5,0.);
      func_pi->FixParameter(6,0.);
      break;
    case 1://Proton//
      if (func_pr) delete func_pr;
      func_pr = (TF1*)l5xg->asTF(RooArgList(*t), RooArgList(*norm,*mu,*sg,*fProton,*fKaon,*fElektron,*fDeuteron,*total,*width),*t );
      frac_pr = TMath::Power(TMath::Sin(func_pr->GetParameter(i+2)),2);
      func_pr->FixParameter(4,0.);
      func_pr->FixParameter(5,0.);
      func_pr->FixParameter(6,0.);
      break;
    case 2: //Kaon//
      if (func_k) delete func_k;
      func_k = (TF1*)l5xg->asTF(RooArgList(*t), RooArgList(*norm,*mu,*sg,*fProton,*fKaon,*fElektron,*fDeuteron,*total,*width),*t );
      frac_k = TMath::Power(TMath::Sin(func_k->GetParameter(i+2)),2);
      func_k->FixParameter(3,0.);
      func_k->FixParameter(5,0.);
      func_k->FixParameter(6,0.);
      break;
    case 3: //Elektron//
      if (func_el) delete func_el;
      func_el = (TF1*)l5xg->asTF(RooArgList(*t), RooArgList(*norm,*mu,*sg,*fProton,*fKaon,*fElektron,*fDeuteron,*total,*width),*t );
      frac_el = TMath::Power(TMath::Sin(func_el->GetParameter(i+2)),2);
      func_el->FixParameter(3,0.);
      func_el->FixParameter(4,0.);
      func_el->FixParameter(6,0.);
      break;
    case 4: //Deuteron//
      if (func_de) delete func_de;
      func_de = (TF1*)l5xg->asTF(RooArgList(*t), RooArgList(*norm,*mu,*sg,*fProton,*fKaon,*fElektron,*fDeuteron,*total,*width),*t );
      frac_de = TMath::Power(TMath::Sin(func_de->GetParameter(i+2)),2);
      func_de->FixParameter(3,0.);
      func_de->FixParameter(4,0.);
      func_de->FixParameter(5,0.);
      break;
    default: break;
    }
}

//----------------------------------------------------------------------//

TF1 *FitRL5(TH1 *hist, Bool_t outer = kFALSE)
{
  if(!hist) return 0;

 l5xg_func = 0; func_pi=0; func_pr=0; func_k=0; func_el=0;func_de=0; frac_pr=0.;frac_k=0.;frac_el=-0.;frac_de=0.; frac_pi=0.;

  //Variables
  static RooRealVar *t = 0, *norm =0, *mu =0, *sigma=0, *fProton, *fKaon=0, *fElektron=0, *fDeuteron=0, *total = 0, *width=0;
  static RooRealVar *mg = 0, *sg = 0;
  static RooLandauZ5 *landauZ5 = 0 ;
  static RooGaussian *gauss = 0;
  static RooFFTConvPdf *l5xg = 0;
  static TF1 *l5xg_mult = 0;

  if (! t)        {t         = new RooRealVar("t"        ,"t"        ,-2.,5.) ;   t->setBins(10000,"cache");}
  if (! norm)      norm      = new RooRealVar("norm"     ,"norm"     ,0.) ;
  if (! mu)        mu        = new RooRealVar("mu"       ,"mu"       ,0.,-1.,1.) ;
  if (! sigma)     sigma     = new RooRealVar("sigma"    ,"sigma"    ,0.) ;
  if (! fProton)   fProton   = new RooRealVar("fProton"  ,"fProton"  ,0.,0.,1.57) ;
  if (! fKaon )    fKaon     = new RooRealVar("fKaon"    ,"fKaon"    ,0.,0.,1.57) ;
  if (! fElektron) fElektron = new RooRealVar("fElektron","fElektron",0.,0.,1.57) ;
  if (! fDeuteron) fDeuteron = new RooRealVar("fDeuteron","fDeuteron",0.,0.,1.57) ;
  if (! total)     total     = new RooRealVar("total"    ,"total"    ,0.,0.,10.);
  if (! width)     width     = new RooRealVar("width"    ,"width"    ,0.07);//0.1,0.01,2.5 ;
  if (! mg)        mg        = new RooRealVar("mg","mg",0.) ;
  if (! sg)        sg        = new RooRealVar("sg","sg",0.25,0.01,10.) ;
  if (! landauZ5)  landauZ5  = new RooLandauZ5("landauZ5","landauZ5",*t,*norm,*mu,*sigma,*fProton,*fKaon,*fElektron,*fDeuteron,*total,*width) ;
  if (! gauss)     gauss     = new RooGaussian ("gauss","gauss",*t,*mg,*sg) ;
  if (! l5xg)      l5xg      = new RooFFTConvPdf("l5xg","landauZ5 (X) gauss",*t,*landauZ5,*gauss) ; 
  //Import data
  //--------------------------------------------------------------
  RooDataHist data("data","data",*t,Import(*hist));
  //------- Fit to data -----------------------//
  l5xg->fitTo(data,Save());
  //----- Create TF1 -------------//
  if (l5xg_func) delete l5xg_func;
  l5xg_func = (TF1*)l5xg->asTF(RooArgList(*t), RooArgList(*norm,*mu,*sg,*fProton,*fKaon,*fElektron,*fDeuteron,*width,*total),*t );
  l5xg_func->SetParError(0,norm->getError());
  l5xg_func->SetParError(1,mu->getError());
  l5xg_func->SetParError(2,sg->getError());
  l5xg_func->SetParError(3,fProton->getError());
  l5xg_func->SetParError(4,fKaon->getError());
  l5xg_func->SetParError(5,fElektron->getError());
  l5xg_func->SetParError(6,fDeuteron->getError());
  l5xg_func->SetParError(7,width->getError());
  l5xg_func->SetParError(8,total->getError());
  //----- Scale TF1 fit function ------//
  Double_t mult_ev = hist->Integral()*hist->GetBinWidth(5);
  if (! l5xg_mult) 
    l5xg_mult = new TF1("mult",func_lz5xg_mult,-2.,5.,11);
  l5xg_mult->SetParent(hist);
  l5xg_mult->SetLineColor(1);
  l5xg_mult->SetParName(0,"norm");  //l5xg_mult->SetParLimits(0,-80,80);
  l5xg_mult->SetParName(1,"mu");    //l5xg_mult->SetParLimits(1,-1.5,1.5);
  l5xg_mult->SetParName(2,"Sigma"); //l5xg_mult->SetParLimits(2,0.2,0.8);
  l5xg_mult->SetParName(3,"P"); 
  l5xg_mult->SetParName(4,"K");     //l5xg_mult->SetParLimits(4,0.0,0.5);
  l5xg_mult->SetParName(5,"e");     //l5xg_mult->SetParLimits(5,0.0,0.5);
  l5xg_mult->SetParName(6,"d");     //l5xg_mult->SetParLimits(6,0.0,0.5);
  l5xg_mult->SetParName(7,"WidthL");//l5xg_mult->SetParLimits(7,0.01,2.0);
  l5xg_mult->SetParName(8,"Total");
  l5xg_mult->SetParName(9,"case");  
  l5xg_mult->SetParName(10,"Mu");    //l5xg_mult->SetParLimits(1,-1.5,1.5);
  Double_t pars[11], errs[11];
  memset(pars, 0, sizeof(pars));
  memset(errs, 0, sizeof(errs));
  l5xg_func->GetParameters(pars);
  pars[8] = mult_ev;
  pars[9] = 5;
  pars[10] = pars[1];
  l5xg_mult->SetParameters(pars);
  memcpy(errs, l5xg_func->GetParErrors(), 8*sizeof(Double_t));
  errs[10] = errs[1];
  l5xg_mult->SetParErrors(errs);
  hist->GetListOfFunctions()->Add(l5xg_mult);
  l5xg_mult->SetParent(hist);
  Double_t X = l5xg_mult->GetParameter(1);
  Double_t Y = 0;
  static TPolyMarker *pm = 0;
  if (pm) delete pm;
  pm = new TPolyMarker(1, &X, &Y);
  hist->GetListOfFunctions()->Add(pm);
  pm->SetMarkerStyle(23);
  pm->SetMarkerColor(kRed);
  pm->SetMarkerSize(1.3);
    //-- Fits for particles: 0.Pion, 1.Proton, 2.Kaon, 3.Elektron, 4.Deuteron --//
  for (Int_t i = 1; i <= 5; i++) {
    Int_t k = i;
    if (i == 5) k = 0;
    Sep_func(l5xg,t,norm,mu,sg,fProton,fKaon,fElektron,fDeuteron,total,width,k);
    TF1 *g0 = (TF1 *) gROOT->GetFunction(Peaks[k].Name);
    if (! g0) {
      g0 = new TF1(*l5xg_mult);
      g0->SetName(Peaks[k].Name);
    }
    // Peaks[i].Name,func_lz5xg_mult,-2.,5.,2);
    g0->SetParameter(8,mult_ev);
    g0->SetParameter(9,k);
    g0->SetLineColor(k+2);
    if(i==1){frac_pi+=frac_pr;}
    else if(i==2){frac_pi+=frac_k;}
    else if(i==3){frac_pi+=frac_el;}
    else if(i==4){frac_pi+=frac_de;}
    else         {
      frac_pi = 1.-frac_pi;
      g0->SetNpx(1000);
      pars[1] = g0->GetMaximumX();
      l5xg_mult->SetParameter(1,pars[1]);
    }
#if 0
    g0->Draw("same");
#else
    g0->SetParent(hist);
    hist->GetListOfFunctions()->Add(g0);
#endif
  }
  hist->Draw();
  return l5xg_mult;
}
//________________________________________________________________________________
TF1 *FitRL5(const Char_t *hName = "f1_1",Bool_t outer = kFALSE ) {
  TH1 *hist = (TH1 *) gDirectory->Get(hName);
  if (! hist) return 0;
  return FitRL5(hist,outer);
}
//---------------------------------------------------------------------------//
//----------------------------LANDAU Z 5 END --------------------------------//
//---------------------------------------------------------------------------//

//________________________________________________________________________________
TF1 *FitRL1lxg() {
  static TF1 *flxg = 0;
  if (flxg) return flxg;
  static RooFFTConvPdf *lxg = 0;
  static RooRealVar *t = 0, *ml = 0, *sl = 0, *mg = 0, *sg = 0;
  static RooLandauZ *landauz = 0;
  static RooGaussian *gauss = 0;
  if (! lxg) {
    // S e t u p   c o m p o n e n t   p d f s 
    // ---------------------------------------
    // Construct observable
    t = new RooRealVar("t","t",-2,6) ;
    // Construct landauz(t,ml,sl) ;
    ml = new RooRealVar("ml","log mean landauz",0.0,-20,20) ;
    sl = new RooRealVar("sl","sigma landauz",0.10,0.01,10) ;
    landauz = new RooLandauZ("lx","lx",*t,*ml,*sl) ;
    // Construct gauss(t,mg,sg)
    mg = new RooRealVar("mg","mg",0) ;
    sg = new RooRealVar("sg","sg",0.25,0.01,10) ;
    gauss = new RooGaussian ("gauss","gauss",*t,*mg,*sg) ;
    // C o n s t r u c t   c o n v o l u t i o n   p d f 
    // ---------------------------------------
    // Set #bins to be used for FFT sampling to 10000
    t->setBins(10000,"cache") ; 
    // Construct landauz (x) gauss
    lxg = new RooFFTConvPdf("lxg","landauZ (X) gauss",*t,*landauz,*gauss) ;
  }
  flxg = (TF1*)lxg->asTF(RooArgList(*t), RooArgList(*ml,*sl,*sg),*t );
  return flxg;
}
//________________________________________________________________________________
Double_t gfR5Func(Double_t *x, Double_t *par) {
  // par[0] - norm
  // par[1] - pion position wrt Z_pion (Bichsel prediction)
  // par[2] - sigma 
  // par[3] - proton signal
  // par[4] - Kaon    -"-
  // par[5] - electorn -"-
  // par[6] - deuteron -"-
  // par[7] - Total
  // par[8] - width of Landau
  Double_t sigma = par[2];
  Double_t frac[5];
  Int_t i;
  frac[0] = 1;
  for (i = 1; i < 5; i++) {
    frac[i] = TMath::Sin(par[2+i]);
    frac[i] *= frac[i];
    frac[0] -= frac[i];
  }
  if (frac[0] < 0.4) return 0;
  Double_t Value = 0;
  Int_t i1 = 0;
  Int_t i2 = 4;
  Int_t icase = (Int_t ) par[9];
  if (icase >= 0) {i1 = i2 = icase;}
  //                        MP,  WidthL,   SigmaG
  Double_t parLI[3] = { par[1],  par[8],    0.24};
  TF1 *lxg = FitRL1lxg();
  for (i = i1; i <= i2; i++) { 
    Double_t Sigma = TMath::Sqrt(sigma*sigma + Peaks[i].sigma*Peaks[i].sigma);
    parLI[0] = par[1] + Peaks[i].peak;
    parLI[1] = par[8];
    parLI[2] = Sigma;
    Value += frac[i]*lxg->EvalPar(x,parLI); 
    //    cout << "i\t" << i << "\tx = " << x[0] << " frac " << frac[i] << "\t" << Value << endl;
  }
  return par[7]*TMath::Exp(par[0])*Value;
}
//________________________________________________________________________________
TF1 *FitR5(TH1 *proj, Option_t *opt="", Int_t nhyps = 5) { // fit by 5 landau convoluted with gauss via RooFit
  // fit in momentum range p = 0.45 - 0.50 GeV/c
  if (! proj) return 0;
  TString Opt(opt);
  //  Bool_t quet = Opt.Contains("Q",TString::kIgnoreCase);
  TF1 *g2 = (TF1*) gROOT->GetFunction("R5");
  if (! g2) {
    g2 = new TF1("R5",gfR5Func, -5, 5, 10);
    g2->SetParName(0,"norm"); g2->SetParLimits(0,-80,80);
    g2->SetParName(1,"mu");     //g2->SetParLimits(1,-1.5,1.5);
    g2->SetParName(2,"Sigma");  g2->SetParLimits(2,0.2,0.8);
    g2->SetParName(3,"P"); 
    g2->SetParName(4,"K");      g2->SetParLimits(4,0.0,0.5);
    g2->SetParName(5,"e");      g2->SetParLimits(5,0.0,0.5);
    g2->SetParName(6,"d");      g2->SetParLimits(6,0.0,0.5);
    g2->SetParName(7,"Total");
    g2->SetParName(8,"WidthL"); g2->SetParLimits(8,0.01,2.0);
    g2->SetParName(9,"case");  
    //    g2->SetParName(7,"factor"); g2->SetParLimits(7,-.1,0.1);
  }
  
  Double_t total = proj->Integral()*proj->GetBinWidth(5);
  g2->SetParameters(0, proj->GetMean(), proj->GetRMS(), 0.0, 0.0, 0.0, 0.0,0.0,0.5,-1);
  g2->FixParameter(3,0);
  g2->FixParameter(4,0);
  g2->FixParameter(5,0);
  g2->FixParameter(6,0);
  g2->FixParameter(7,total);
  g2->FixParameter(9,-1);
  Int_t iok = proj->Fit(g2,Opt.Data());
  if (nhyps == 5) {
    g2->ReleaseParameter(3); g2->SetParLimits(3,0.0,TMath::Pi()/2);
    g2->ReleaseParameter(4); g2->SetParLimits(4,0.0,TMath::Pi()/2);
    g2->ReleaseParameter(5); g2->SetParLimits(5,0.0,TMath::Pi()/2);
    g2->ReleaseParameter(6); g2->SetParLimits(6,0.0,TMath::Pi()/2);
    iok = proj->Fit(g2,Opt.Data());
  }
  if ( iok ) {
    cout << g2->GetName() << " fit has failed with " << iok << " for " 
	 << proj->GetName() << "/" << proj->GetTitle() << " Try one again" << endl; 
    proj->Fit(g2,Opt.Data());
  }
  Opt += "m";
  iok = proj->Fit(g2,Opt.Data());
  if (! Opt.Contains("q",TString::kIgnoreCase)) {
    Double_t params[10];
    g2->GetParameters(params);
    Double_t X = params[1];
    Double_t Y = TMath::Exp(params[0]);
    TPolyMarker *pm = new TPolyMarker(1, &X, &Y);
    proj->GetListOfFunctions()->Add(pm);
    pm->SetMarkerStyle(23);
    pm->SetMarkerColor(kRed);
    pm->SetMarkerSize(1.3);
    if (nhyps == 5) {
      for (int i = 0; i < nhyps; i++) {
	TF1 *f = new TF1(*g2);
	f->SetName(Form("L5%s",Peaks[i].Name));
	f->FixParameter(9,i);
	f->SetLineColor(i+2);
	proj->GetListOfFunctions()->Add(f);
      }
      proj->Draw();
    }
  }
  return g2;
}

//________________________________________________________________________________
//RooFitResult *FitRL1(TH1 *hist) {
TF1 *FitRL1(TH1 *hist) {
  if (! hist) return 0;
  // S e t u p   c o m p o n e n t   p d f s 
  // ---------------------------------------
  // Construct observable
  RooRealVar t("t","t",-2,6) ;
  // Construct landauz(t,ml,sl) ;
  RooRealVar ml("ml","log mean landauz",0.0,-20,20) ;
  RooRealVar sl("sl","sigma landauz",0.10,0.01,10) ;
  RooLandauZ landauz("lx","lx",t,ml,sl) ;
  // Construct gauss(t,mg,sg)
  RooRealVar mg("mg","mg",0) ;
  RooRealVar sg("sg","sg",0.25,0.01,10) ;
  RooGaussian gauss("gauss","gauss",t,mg,sg) ;
  // C o n s t r u c t   c o n v o l u t i o n   p d f 
  // ---------------------------------------
  // Set #bins to be used for FFT sampling to 10000
  t.setBins(10000,"cache") ; 
  // Construct landauz (x) gauss
  RooFFTConvPdf lxg("lxg","landauZ (X) gauss",t,landauz,gauss) ;
  // S a m p l e ,   f i t   a n d   p l o t   c o n v o l u t e d   p d f 
  RooDataHist* data = new RooDataHist("data","data",t,Import(*hist));
  // Fit gxlx to data
  //RooFitResult* r = 
  lxg.fitTo(*data,Save()) ;
  // Plot data, landauz pdf, landauz (X) gauss pdf
  RooPlot* frame = t.frame(Title("landauz (x) gauss convolution")) ;
  data->plotOn(frame) ;
  lxg.plotOn(frame) ;
  //  landauz.plotOn(frame,LineStyle(kDashed)) ;
  // Draw frame on canvas
  TCanvas *ca = (TCanvas *) gROOT->GetListOfCanvases()->FindObject("FitRL1");
  if (! ca) ca = new TCanvas("FitRL1","FitRL1",600,600) ;
  else      ca->Clear();
  //  gPad->SetLeftMargin(0.15) ; frame->GetYaxis()->SetTitleOffset(1.4) ; 
  frame->Draw() ;
  delete data;
  return 0;//r;
}
//________________________________________________________________________________
//RooFitResult *FitRL1(const Char_t *hName = "f1_1") {
TF1 *FitRL1(const Char_t *hName = "f1_1") {
  TH1 *hist = (TH1 *) gDirectory->Get(hName);
  if (! hist) return 0;
  return FitRL1(hist);
}
#endif /* __USE_ROOFIT__ */
//________________________________________________________________________________
TF1* Landau(){
  if (!LandauF) 
#if 0
    LandauF =  // Ar
      new TF1("LandauF","exp([0]-0.5*((x-[1])/[2])*((x-[1])/[2])+exp([3]-0.5*((x-[4])/[5])*((x-[4])/[5])))",-5,10);
  Double_t params[6] = {
   -3.93739e+00,//    1  p0           5.96123e-03   2.40826e-06  -8.19249e-03
    1.98550e+00,//    2  p1           7.17058e-03   3.54798e-06   2.69672e-03
    1.56338e+00,//    3  p2           1.37436e-03   2.59636e-06   3.43991e-03
    1.44692e+00,//    4  p3           3.29935e-03   7.69892e-07  -3.93145e-02
   -4.93793e-01,//    5  p4           2.46951e-03   2.28224e-06  -8.62375e-03
    1.54585e+00 //    6  p5           2.63794e-03   2.24202e-06  -8.62431e-03
  };
  Double_t sigma_p[4] = {// sigma versus dX
  6.67647e-01,//   1  p0            4.60469e-03   3.85534e-06   9.21504e-09
 -1.58690e-01,//   2  p1            4.88288e-03   1.07412e-06   6.61512e-07
  2.79764e-02,//   3  p2            1.35356e-03   1.76894e-07  -3.01259e-05
 -1.67180e-03 //   4  p3            1.05796e-04   2.50225e-08   2.55565e-05
  };
  Double_t sigmaI =  5.07430e-01;
  Double_t sigmaO =  3.80682e-01;
#else
  LandauF = // P10
    new TF1("LandauF","exp([0]-0.5*((x-[1])/[2])**2+exp([3]-0.5*((x-[4])/[5])**2+exp([6]-0.5*((x-[7])/[8])**2)))",-5,10);
  // dEdxP->Draw("phi*sigma_z:(z-zm)/sigma_z>>Lan(100,-3,7)","bg>1&&x>1&&x<3","prof");
  // Lan->Fit("LandauF","i")
  Double_t params[9] = {
    -7.74975e+00,
     6.53414e+00,
     1.21524e+00,
     3.31409e+00,
    -2.58291e+00,
     3.51463e+00,
    -3.47755e+00,
     3.77698e-02,
     6.67913e-01};
#endif
  LandauF->SetParameters(params);
  return LandauF;
}
//________________________________________________________________________________
Double_t fithfcn(Double_t *x,Double_t *par) {
  Double_t z   = x[0];
  Double_t sigma = par[0];
  Double_t norm = 1./TMath::Sqrt(2*TMath::Pi())/sigma;
  Double_t value = 0;
  //  Int_t    hyp   = (Int_t) par[1+2*NH];
  //  Double_t ref = par[hyp+1];
  for (int k = 0; k < NH; k++) {
    Double_t mu = par[k+1];
    //    if (k != hyp) mu -= ref;
    Double_t dev = (z - mu)/sigma;
    value += norm*TMath::Exp(par[k+1+NH]-dev*dev/2.);
  }
  return value;
}
//________________________________________________________________________________
void FitH(const Char_t *set="z", Int_t Hyp = -1, Int_t Bin=-1) {
  if (!gBichsel) {
    gSystem->Load("StBichsel");
    gBichsel = Bichsel::Instance();
  }
  TString Set(set);
  const Double_t window = 0.4;
  const Double_t range[2] = {-2., 4.};
  const Double_t LFrMin = -10;
  if (! canvas) {
    canvas = new TCanvas("FitHC","FitH Canvas");
    canvas->SetGrid();
  }
  const Int_t nHYPS = NHYPS;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  else               printf("%s found\n",fRootFile->GetName());
  TString newfile("FitH");
  newfile += Set; 
  newfile += gSystem->BaseName(fRootFile->GetName());
  TString FileN("FitPars");
  FileN += Set;
  FileN += ".h";
  TFile * f = 0;
  if (Bin < 0)  f = new TFile(newfile.Data(),"recreate");
  TH1 *proj = 0;
  TF1 *g = new TF1("g",fithfcn,range[0],range[1],2+2*NH);
  g->SetParName(0,"Sigma"); g->SetParLimits(0,0.06,0.12);
  g->SetParName(1+2*NH,"Hyp");
  Int_t Nfit = 0;
  Int_t nh1 = 0;
  Int_t nh2 = NHYPS-1; //Int_t nh1 = 3, nh2 = 3;
  if (Hyp >=0 ) {nh1 = nh2 = Hyp;}
  Int_t parstatus[NH];
  for (Int_t hyp = nh1; hyp<=nh2; hyp++) {
    Int_t kh = hyp%NH;
    Char_t *HistN                 = (Char_t *) HistNames[hyp];
    if (Set.Contains("70")) HistN = (Char_t *) HistNames70[hyp];
    hists[hyp] = (TH2 *) fRootFile->Get(HistN);
    if (!hists[hyp]) {printf("Cannot histogram %s\n",HistNames[hyp]); continue;}
    histp[hyp] = (TProfile *) fRootFile->Get(HistNameP[hyp]);
    if (!histp[hyp]) {printf("Cannot histogram %s\n",HistNameP[hyp]); continue;;}
    Int_t k = 0;
    if (hyp > NH) k = NH;
    for (Int_t hypl = (hyp/NH)*NH; hypl < (hyp/NH+1)*NH; hypl++) {
      Int_t lh = hypl%NH;
      TString name1("LF.");
      name1 += Names[hypl];
      TString name2("");
      name2 += Names[hypl];
      g->SetParName(lh+1+NH,name1.Data());
      g->SetParName(lh+1,name2.Data());
    }
    Int_t nx = hists[hyp]->GetNbinsX();
    Int_t jbin1 = 1;
    Int_t jbin2 = nx;
    if (Bin > 0) {jbin1 = jbin2 = Bin;}
    for (int jbin=jbin1; jbin<=jbin2; jbin++) {
      TString name(Form("%s_%i_%i",hists[hyp]->GetName(),hyp,jbin));
      proj = hists[hyp]->ProjectionY(name.Data(),jbin,jbin);
      Int_t ix1=proj->GetXaxis()->FindBin(-window);
      Int_t ix2=proj->GetXaxis()->FindBin( window);
      Double_t dinT = 5*proj->Integral();
      Double_t dint = proj->Integral(ix1,ix2);
      if (dint < 100.) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hists[hyp]->GetName(),jbin,hyp,dint);
	delete proj;
	continue;
      }
      for (Int_t lh = 0; lh < NH; lh++) {
	g->ReleaseParameter(lh+1);
	g->ReleaseParameter(lh+1+NH);
	parstatus[lh] = 0;
      }
      printf("hist:%s bin %i for hyp %i has  %10.0f entries\n",hists[hyp]->GetName(),jbin,hyp,dint);
      Double_t bg = TMath::Power(10., hists[hyp]->GetBinCenter(jbin));
      Double_t pmom = Masses[hyp]*bg;
      if (pmom > 0.1) {parstatus[4] = 1; printf("fix muon\n");}
      if (kh == 4 && pmom > 0.1) continue;
      Double_t devZ[NH];
      Double_t zref = 0;
      if (TString(set) == "70")  zref = 1.e-6*gBichsel->GetI70(TMath::Log10(bg),1.0); 
      else                       zref = 1.e-6*TMath::Exp(gBichsel->GetMostProbableZ(TMath::Log10(bg),1.0));
      //      printf("zref = %f\n",zref);
      Int_t iok = 1;
      for (Int_t hypl = (hyp/NH)*NH; hypl < (hyp/NH+1)*NH; hypl++) {
	Int_t lh = hypl%NH;
	Double_t z = 0;
	bg = pmom/Masses[hypl];
	if (Set.Contains("70")) z = 1.e-6*gBichsel->GetI70(TMath::Log10(bg),1.0); 
	else                    z = 1.e-6*TMath::Exp(gBichsel->GetMostProbableZ(TMath::Log10(bg),1.0));
	devZ[lh] = TMath::Log(z/zref);
      }
      for (int l = 0; l < NH; l++) {
	if (l == kh) continue;
	if (devZ[l] < -2.0 || devZ[l] > 4.0) {
	  printf("Fix %s dZ = %f\n", Names[NH*(hyp/NH)+l],devZ[l]);
	  parstatus[l] = 1;
	  continue;
	}
	if (TMath::Abs(devZ[l]) < 0.01 || 
	    (hyp%NH == 3 && l == 4 && TMath::Abs(devZ[l]) < 0.04)) {
	    printf("Fix %s dZ = %f\n", Names[NH*(hyp/NH)+l],devZ[l]);
	    parstatus[l] = 1;
	    continue;
	}
      }
      for (Int_t hypl = (hyp/NH)*NH; hypl < (hyp/NH+1)*NH; hypl++) {
      AGAIN:
	Int_t lh = hypl%NH;
	if (parstatus[lh]) continue;
	Double_t windowN = devZ[lh]-window;
	Double_t windowP = devZ[lh]+window;
	for (int m = 0; m < NH; m++) {
	  if (m != lh && ! parstatus[m]) {
	    Double_t dev = 0.5*(devZ[m] - devZ[lh]);
	    if (dev < 0 && windowN < devZ[lh] + dev) windowN = devZ[lh] + dev;
	    if (dev > 0 && windowP > devZ[lh] + dev) windowP = devZ[lh] + dev;
	  } 
	}
#if 0
	printf("Set Limits for %s ref = %f in [%f,%f]\n",Names[hypl],devZ[lh],windowN,windowP);
#endif
	g->SetParameter(lh+1,devZ[lh]);
	g->SetParLimits(lh+1,windowN, windowP);
	g->SetParLimits(lh+1+NH,LFrMin, TMath::Log(dinT));
	if (hypl == hyp) 
	  g->SetParameter(lh+1+NH,TMath::Log(dint));
	else {
	  ix1=proj->GetXaxis()->FindBin(windowN);
	  ix2=proj->GetXaxis()->FindBin(windowP);
	  Double_t din= proj->Integral(ix1,ix2);
	  //	  printf("%s dZ = %f in = %f\n", Names[hypl], devZ[lh], din);
	  if (din > 0) g->SetParameter(lh+1+NH,TMath::Log(din));
	  else         {
	    printf("Fix %s din = %f\n", Names[hypl],din);
	    parstatus[lh] = 1;
	    goto AGAIN;
	  }
	}
      }
      for (int l = 0; l < NH; l++) 
	if (parstatus[l]) {
	  printf("Fix %s\n",Names[NH*(hyp/NH)+l]);
	  g->FixParameter(l+1+NH, LFrMin); 
	  g->FixParameter(l+1, devZ[l]);
	}
      g->FixParameter(1+2*NH, hyp);
      if (parstatus[kh]) iok = 0;
      if (! iok) {printf("Too close\n"); continue;}
      //      proj->Fit(g->GetName(),"RIM");
      proj->Fit(g->GetName(),"R");
      canvas->Update();
      Int_t lh = (hyp%NH)+1;
      Double_t Nul  = g->GetParameter(lh); 
      printf("hyp = %i lh = %i Nul = %f zref =%f %f\n",hyp,lh,Nul,zref,g->GetParameter(lh));
      Double_t Mul  = 1.e6*zref*TMath::Exp(Nul);
      Double_t dMul = g->GetParError(lh);
      Int_t NFitPoints = g->GetNumberFitPoints();
      Int_t NDF = g->GetNDF();
      Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
      Double_t chisq      = g->GetChisquare();
      Double_t X = hists[hyp]->GetXaxis()->GetBinCenter(jbin);
      printf("Nul = %f Mul = %f dMul = %f\n",Nul,Mul,dMul);
      printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
	      "chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
	      Names[hyp],hyp,jbin,Nfit,X,pmom,Nul,Mul,dMul,chisq,NFitPoints,NDF,prob);
      printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
	     Names[hyp],hyp,jbin,Nfit,X,pmom,Nul,Mul,dMul,chisq,NFitPoints,NDF,prob,g->GetName());
      if (f) {
	FILE *fp = fopen(FileN.Data(),"a");
	if (fp) {
	  if (Nfit == 0) {
	    TDatime time;
	    fprintf (fp,"dEdxPoint_t dEdxZ[] = {\n");
		    fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	    fprintf(fp,
		    "//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	  }
	  if (Nfit == 0) fprintf(fp," {");
	  else           fprintf(fp,",{");
	  fprintf(fp,
		  "\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		  Names[hyp],hyp,jbin,Nfit,X,pmom,Nul,Mul,dMul,chisq,NFitPoints,NDF,prob,g->GetName());
	  fclose(fp);
	  Nfit++; 	
	}
	proj->Write();
      }
    }
  }
  if (f) {
    FILE *fp = fopen(FileN.Data(),"a");
    if (fp) fprintf(fp,"};\n");
    fclose(fp);
    delete f;
  }
}


//________________________________________________________________________________
TH2F *Project(TH3F *hist) {
  if (!hist) return 0;
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  TString name(hist->GetName());
  name += "_xy";
  TH2F *h = new TH2F(name.Data(),hist->GetTitle(),
		     nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
		     ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  Double_t params[5];
  Double_t error;
  TF1 *g = new TF1("g","gaus(0)+pol1(3)");
  for (int i=1;i<=nx;i++){
    for (int j=1;j<=ny;j++){
      TH1D *proj = hist->ProjectionZ("f_11",i,i,j,j);
      Double_t mean = proj->GetMean();
      Double_t sum  = proj->Integral();
      Double_t rms = proj->GetRMS();
      params[0] = sum;
      params[1] = mean;
      params[2] = rms;
      params[3] = 0;
      params[4] = 0;
      g->SetParameters(params);
      //      g->SetRange(mean-2*rms,mean+2*rms);
      g->SetRange(-1.,1.);
      error = 0;
      if (sum > 100) {
	proj->Fit("g","RQ");
	g->GetParameters(params);
	error = g->GetParError(1);
      }
      else error = 0;
      h->SetCellContent(i,j,params[1]);
      h->SetCellError(i,j,error);
      printf("i:%i j:%i sum:%f mean:%f rms:%f mu:%f sigma:%f\n",
	     i,j,sum,mean,rms,params[1],params[2]);
      delete proj;
    }
  }
  return h;
} 
//________________________________________________________________________________
TH2D *GetRelYZError(TH3 *hist, const Char_t *Name="_yz") {
  if (!hist) return 0;
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  Int_t nz = hist->GetNbinsZ();
  TString name(hist->GetName());
  name += Name;
  //  TAxis *fXaxis = hist->GetXaxis();
  TAxis *fYaxis = hist->GetYaxis();
  TAxis *fZaxis = hist->GetZaxis();
  TH2D *h = new TH2D(name.Data(),"Relative error in Space charge (%)",
		     ny,fYaxis->GetXmin(),fYaxis->GetXmax(),
		     nz,fZaxis->GetXmin(),fZaxis->GetXmax());
  h->SetXTitle("Row number");
  h->SetYTitle("Z (cm)");
  Int_t bin;
  Double_t Scale = TMath::Sqrt(24.*3726./1153.);
  for (int iybin=0;iybin<ny;iybin++){
    for (int izbin=0;izbin<nz;izbin++){
      Double_t cont = 0, err = 0;
      for (int ixbin=1;ixbin<=nx;ixbin++){
	bin = hist->GetBin(ixbin,iybin,izbin);
	cont += hist->GetBinContent(bin);
	err  += hist->GetBinError(bin)*hist->GetBinError(bin);
      }
      if (cont > 0) {
	bin = h->GetBin(iybin,izbin);
	Double_t val = 100*TMath::Sqrt(err)/cont*Scale;
	h->SetBinContent(bin,val);
      }
    }
  }
  return h;
} 
//________________________________________________________________________________
TH2F *ProjectX(TH3F *hist, const Char_t *Name="_yz",const Int_t binx1=0,const Int_t binx2=10000) {
  if (!hist) return 0;
  Int_t nx = hist->GetNbinsX();
  if (nx > binx2) nx = binx2;
  Int_t ny = hist->GetNbinsY();
  Int_t nz = hist->GetNbinsZ();
  TString name(hist->GetName());
  name += Name;
  //  TAxis *fXaxis = hist->GetXaxis();
  TAxis *fYaxis = hist->GetYaxis();
  TAxis *fZaxis = hist->GetZaxis();
  TH2F *h = new TH2F(name.Data(),hist->GetTitle(),
		     ny,fYaxis->GetXmin(),fYaxis->GetXmax(),
		     nz,fZaxis->GetXmin(),fZaxis->GetXmax());
  //  Double_t params[3];
  //  Double_t error;
  //  TF1 *g = new TF1("g","gaus");
  for (int iybin=0;iybin<ny;iybin++){
    for (int izbin=0;izbin<nz;izbin++){
      for (int ixbin=binx1;ixbin<nx;ixbin++){
	Int_t bin = hist->GetBin(ixbin,iybin,izbin);
	Double_t cont = hist->GetBinContent(bin);
	if (cont) h->Fill(fYaxis->GetBinCenter(iybin),fZaxis->GetBinCenter(izbin), cont);
      }
    }
  }
  return h;
} 
//________________________________________________________________________________
TF1 *FitGP(TH1 *proj, Option_t *opt="RQ", Double_t nSigma=3, Int_t pow=3) {
  if (! proj) return 0;
  TString Opt(opt);
  //  Bool_t quet = Opt.Contains("Q",TString::kIgnoreCase);
  TF1 *g = 0, *g0 = 0;
  TF1 *gaus = (TF1*) gROOT->GetFunction("gaus");
  if (pow >= 0) g0 = new TF1("g0",Form("gaus(0)+pol%i(3)",pow),-0.2,0.2);
  else          g0 = new TF1("g0","gaus",-0.2,0.2); 
  g0->SetParName(0,"Constant");
  g0->SetParName(1,"Mean");
  g0->SetParName(2,"Sigma");
  for (int i=0; i<=pow;i++) g0->SetParName(3+i,Form("a%i",i));
  TF1 *g1 = new TF1("g1",Form("gaus(0)+pol%i(3)",pow+1),-0.2,0.2);
  g1->SetParName(0,"Constant");
  g1->SetParName(1,"Mean");
  g1->SetParName(2,"Sigma");
  for (int i=0; i<=pow+1;i++) g1->SetParName(3+i,Form("a%i",i));
  TF1 *g2 = new TF1("g2",Form("gaus(0)+pol%i(3)",pow+2),-0.2,0.2);
  g2->SetParName(0,"Constant");
  g2->SetParName(1,"Mean");
  g2->SetParName(2,"Sigma");
  for (int i=0; i<=pow+2;i++) g2->SetParName(3+i,Form("a%i",i));
  Double_t params[9];
#if 0
  TSpectrum *spec = new TSpectrum();
  Int_t nPeaks = spec->Search(proj,3,""); 
  if (!quet) {cout << proj->GetName() << "\tfound " << nPeaks << " peaks" << endl;}
  if (! nPeaks) return 0;
  Float_t *xpeak = spec->GetPositionX();
  Int_t peak = -1;
  Double_t dist = 9999.;
  for (Int_t i = 0; i < nPeaks; i++) {
    if (!quet) cout << "\tx \t" << xpeak[i]; 
    if (TMath::Abs(xpeak[i]) < dist) { 
      dist = TMath::Abs(xpeak[i]); peak = i;
    }
  }
  if (peak < 0) return 0;
  //  peak = 0;
  GetMaximumBin()
  if (!quet) {
    cout << endl;
    cout << "Take x\t" << xpeak[peak] << endl;
  }
  //  delete spec;
  Int_t  peakbin = proj->GetXaxis()->FindBin(xpeak[peak]);
  params[0] = 1.e5;
  params[1] = proj->GetBinCenter(peakbin);
  params[2] = 0.2;//proj->GetRMS();
#else
  Int_t peak = proj->GetMaximumBin();
  Double_t peakX = proj->GetBinCenter(peak);
  params[0] = proj->GetBinContent(peak);
  if (peakX > 0.5) {
    params[1] = 0;
    params[2] = 0.2;
  }
  else {
    params[1] = peakX;
    params[2] = proj->GetRMS();
    if (params[2] > 0.25) params[2] = 0.25;
  }
#endif
  params[3] = 0;
  params[4] = 0;
  params[5] = 0;
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  if (gaus) {
    g = gaus;
    g->SetParameters(params);
    g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
    proj->Fit(g,opt);
    g->GetParameters(params);
    if (g->GetProb() > 0.01) return g;
    params[2] = TMath::Abs(params[2]);
  }
  g = g0;
  g->SetParameters(params);
  g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
  proj->Fit(g,opt);
#if 1
  if (g->GetProb() > 0.01) return g;
  g->GetParameters(params);
  g = g1;
  params[2] = TMath::Abs(params[2]);
  g->SetParameters(params);
  g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
  proj->Fit(g,opt);
  if (g->GetProb() > 0.01) return g;
  g->GetParameters(params);
  g = g2;
  params[2] = TMath::Abs(params[2]);
  g->SetParameters(params);
  g->SetRange(params[1]-nSigma*params[2],params[1]+nSigma*params[2]);
  proj->Fit(g,opt);
#endif
  if (! Opt.Contains("q",TString::kIgnoreCase)) {
    g->GetParameters(params);
    Double_t X = params[1];
    Double_t Y = params[0]/TMath::Sqrt(2*TMath::Pi()*params[2]);
    TPolyMarker *pm = new TPolyMarker(1, &X, &Y);
    proj->GetListOfFunctions()->Add(pm);
    pm->SetMarkerStyle(23);
    pm->SetMarkerColor(kRed);
    pm->SetMarkerSize(1.3);
    proj->Draw();
  }
  return g;
}
//________________________________________________________________________________
Double_t gfFunc(Double_t *x, Double_t *par) {
  // par[0] - norm
  // par[1] - pion position wrt Z_pion (Bichsel prediction)
  // par[2] - sigma 
  // par[3] - proton signal
  // par[4] - Kaon    -"-
  // par[5] - electorn -"-
  // par[6] - deuteron -"-
  // par[7] - Total
  Double_t sigma = par[2];
  Double_t frac[5];
  Int_t i;
  frac[0] = 1;
  for (i = 1; i < 5; i++) {
    frac[i] = TMath::Sin(par[2+i]);
    frac[i] *= frac[i];
    frac[0] -= frac[i];
  }
  if (frac[0] < 0.4) return 0;
  Double_t Value = 0;
  Int_t icase = (Int_t) par[8];
  Int_t i1 = 0;
  Int_t i2 = 4;
  if (icase >= 0) {i1 = i2 = icase;}
  for (i = i1; i <= i2; i++) { 
    Double_t Sigma = TMath::Sqrt(sigma*sigma + Peaks[i].sigma*Peaks[i].sigma);
    Value += frac[i]*TMath::Gaus(x[0],par[1]+Peaks[i].peak,Sigma,1);
    //    cout << "i\t" << i << "\tx = " << x[0] << " frac " << frac[i] << "\t" << Value << endl;
  }
  return par[7]*TMath::Exp(par[0])*Value;
}
//________________________________________________________________________________
TF1 *FitGF(TH1 *proj, Option_t *opt="") {
  // fit in momentum range p = 0.45 - 0.50 GeV/c
  if (! proj) return 0;
  TString Opt(opt);
  //  Bool_t quet = Opt.Contains("Q",TString::kIgnoreCase);
  TF1 *g2 = (TF1*) gROOT->GetFunction("GF");
  if (! g2) {
    g2 = new TF1("GF",gfFunc, -5, 5, 9);
    g2->SetParName(0,"norm"); g2->SetParLimits(0,-80,80);
    g2->SetParName(1,"mu");     //g2->SetParLimits(1,-1.5,1.5);
    g2->SetParName(2,"Sigma");  g2->SetParLimits(2,0.2,0.8);
    g2->SetParName(3,"P"); 
    g2->SetParName(4,"K");      g2->SetParLimits(4,0.0,0.5);
    g2->SetParName(5,"e");      g2->SetParLimits(5,0.0,0.5);
    g2->SetParName(6,"d");      g2->SetParLimits(6,0.0,0.5);
    g2->SetParName(7,"Total");
    g2->SetParName(8,"Case");
    //    g2->SetParName(7,"factor"); g2->SetParLimits(7,-.1,0.1);
  }
  
  Double_t total = proj->Integral()*proj->GetBinWidth(5);
  g2->SetParameters(0, proj->GetMean(), proj->GetRMS(), 0.1, 0.1, 0.1, 0.1,0.1,-1.);
  g2->FixParameter(3,2.86731e-01);
  g2->FixParameter(4,4.27788e-01);
  g2->FixParameter(5,1e-6);
  g2->FixParameter(6,5.77664e-02);
  g2->FixParameter(7,total);
  g2->FixParameter(8,-1);
  proj->Fit(g2,Opt.Data());
  g2->ReleaseParameter(3); g2->SetParLimits(3,0.0,TMath::Pi()/2);
  g2->ReleaseParameter(4); g2->SetParLimits(4,0.0,TMath::Pi()/2);
  g2->ReleaseParameter(5); g2->SetParLimits(5,0.0,TMath::Pi()/2);
  g2->ReleaseParameter(6); g2->SetParLimits(6,0.0,TMath::Pi()/2);
  Int_t iok = proj->Fit(g2,Opt.Data());
  if ( iok ) {
    cout << g2->GetName() << " fit has failed with " << iok << " for " 
	 << proj->GetName() << "/" << proj->GetTitle() << " Try one again" << endl; 
    proj->Fit(g2,Opt.Data());
  }
  Opt += "m";
  iok = proj->Fit(g2,Opt.Data());
  if (! Opt.Contains("q",TString::kIgnoreCase)) {
    Double_t params[10];
    g2->GetParameters(params);
    Double_t X = params[1];
    Double_t Y = TMath::Exp(params[0]);
    TPolyMarker *pm = new TPolyMarker(1, &X, &Y);
    proj->GetListOfFunctions()->Add(pm);
    pm->SetMarkerStyle(23);
    pm->SetMarkerColor(kRed);
    pm->SetMarkerSize(1.3);
    for (int i = 0; i <= 4; i++) {
      TF1 *f = new TF1(*g2);
      f->SetName(Peaks[i].Name);
      f->FixParameter(8,i);
      f->SetLineColor(i+2);
      proj->GetListOfFunctions()->Add(f);
    }
    proj->Draw();
  }
  return g2;
}
//________________________________________________________________________________
Double_t langaufun(Double_t *x, Double_t *par) {// $ROOTSYS/tutorials/fit/langaus.C

   //Fit parameters:
   //par[0]=Width (scale) parameter of Landau density
   //par[1]=Most Probable (MP, location) parameter of Landau density
   //par[2]=Total area (integral -inf to inf, normalization constant)
   //par[3]=Width (sigma) of convoluted Gaussian function
   //
   //In the Landau distribution (represented by the CERNLIB approximation), 
   //the maximum is located at x=-0.22278298 with the location parameter=0.
   //This shift is corrected within this function, so that the actual
   //maximum is identical to the MP parameter.

      // Numeric constants
      Double_t invsq2pi = 0.3989422804014;   // (2 pi)^(-1/2)
      Double_t mpshift  = -0.22278298;       // Landau maximum location

      // Control constants
      Double_t np = 100.0;      // number of convolution steps
      Double_t sc =   5.0;      // convolution extends to +-sc Gaussian sigmas

      // Variables
      Double_t xx, zz;
      Double_t mpc;
      Double_t fland;
      Double_t sum = 0.0;
      Double_t xlow,xupp;
      Double_t step;
      Double_t i;


      // MP shift correction
      mpc = TMath::Exp(par[1]) - mpshift * par[0]; 

      // Range of convolution integral
      xlow = x[0] - sc * par[3];
      xupp = x[0] + sc * par[3];

      step = (xupp-xlow) / np;
      // Convolution integral of Landau and Gaussian by sum
      for(i=1.0; i<=np/2; i++) {
         zz = xlow + (i-.5) * step;
	 xx = TMath::Exp(zz);
         fland = xx*TMath::Landau(xx,mpc,par[0]) / par[0];
         sum += fland * TMath::Gaus(x[0],zz,par[3]);

         zz = xupp - (i-.5) * step;
	 xx = TMath::Exp(zz);
         fland = xx*TMath::Landau(xx,mpc,par[0]) / par[0];
         sum += fland * TMath::Gaus(x[0],zz,par[3]);
      }

      return (par[2] * step * sum * invsq2pi / par[3]);
}

//________________________________________________________________________________
Double_t gfL5Func(Double_t *x, Double_t *par) {
  // par[0] - norm
  // par[1] - pion position wrt Z_pion (Bichsel prediction)
  // par[2] - sigma 
  // par[3] - proton signal
  // par[4] - Kaon    -"-
  // par[5] - electorn -"-
  // par[6] - deuteron -"-
  // par[7] - Total
  // par[8] - width of Landau
  Double_t sigma = par[2];
  Double_t frac[5];
  Int_t i;
  frac[0] = 1;
  for (i = 1; i < 5; i++) {
    frac[i] = TMath::Sin(par[2+i]);
    frac[i] *= frac[i];
    frac[0] -= frac[i];
  }
  if (frac[0] < 0.4) return 0;
  Double_t Value = 0;
  Int_t i1 = 0;
  Int_t i2 = 4;
  Int_t icase = (Int_t ) par[9];
  if (icase >= 0) {i1 = i2 = icase;}
  //                   WidthL        MP  Total, SigmaG
  Double_t parLI[4] = {  par[8], par[1],     1,   0.24};
  for (i = i1; i <= i2; i++) { 
    Double_t Sigma = TMath::Sqrt(sigma*sigma + Peaks[i].sigma*Peaks[i].sigma);
    parLI[1] = par[1] + Peaks[i].peak;
    parLI[3] = Sigma;
    Value += frac[i]*langaufun(x,parLI); 
    //    cout << "i\t" << i << "\tx = " << x[0] << " frac " << frac[i] << "\t" << Value << endl;
  }
  return par[7]*TMath::Exp(par[0])*Value;
}
//________________________________________________________________________________
TF1 *FitL5(TH1 *proj, Option_t *opt="", Int_t nhyps = 5) { // fit by 5 landau convoluted with gauss
  // fit in momentum range p = 0.45 - 0.50 GeV/c
  if (! proj) return 0;
  TString Opt(opt);
  //  Bool_t quet = Opt.Contains("Q",TString::kIgnoreCase);
  TF1 *g2 = (TF1*) gROOT->GetFunction("L5");
  if (! g2) {
    g2 = new TF1("L5",gfL5Func, -5, 5, 10);
    g2->SetParName(0,"norm"); g2->SetParLimits(0,-80,80);
    g2->SetParName(1,"mu");     //g2->SetParLimits(1,-1.5,1.5);
    g2->SetParName(2,"Sigma");  g2->SetParLimits(2,0.2,0.8);
    g2->SetParName(3,"P"); 
    g2->SetParName(4,"K");      g2->SetParLimits(4,0.0,0.5);
    g2->SetParName(5,"e");      g2->SetParLimits(5,0.0,0.5);
    g2->SetParName(6,"d");      g2->SetParLimits(6,0.0,0.5);
    g2->SetParName(7,"Total");
    g2->SetParName(8,"WidthL"); g2->SetParLimits(8,0.01,2.0);
    g2->SetParName(9,"case");  
    //    g2->SetParName(7,"factor"); g2->SetParLimits(7,-.1,0.1);
  }
  
  Double_t total = proj->Integral()*proj->GetBinWidth(5);
  g2->SetParameters(0, proj->GetMean(), proj->GetRMS(), 0.0, 0.0, 0.0, 0.0,0.0,0.5,-1);
  g2->FixParameter(3,0);
  g2->FixParameter(4,0);
  g2->FixParameter(5,0);
  g2->FixParameter(6,0);
  g2->FixParameter(7,total);
  g2->FixParameter(9,-1);
  Int_t iok = proj->Fit(g2,Opt.Data());
  if (nhyps == 5) {
    g2->ReleaseParameter(3); g2->SetParLimits(3,0.0,TMath::Pi()/2);
    g2->ReleaseParameter(4); g2->SetParLimits(4,0.0,TMath::Pi()/2);
    g2->ReleaseParameter(5); g2->SetParLimits(5,0.0,TMath::Pi()/2);
    g2->ReleaseParameter(6); g2->SetParLimits(6,0.0,TMath::Pi()/2);
    iok = proj->Fit(g2,Opt.Data());
  }
  if ( iok ) {
    cout << g2->GetName() << " fit has failed with " << iok << " for " 
	 << proj->GetName() << "/" << proj->GetTitle() << " Try one again" << endl; 
    proj->Fit(g2,Opt.Data());
  }
  Opt += "m";
  iok = proj->Fit(g2,Opt.Data());
  if (! Opt.Contains("q",TString::kIgnoreCase)) {
    Double_t params[10];
    g2->GetParameters(params);
    Double_t X = params[1];
    Double_t Y = TMath::Exp(params[0]);
    TPolyMarker *pm = new TPolyMarker(1, &X, &Y);
    proj->GetListOfFunctions()->Add(pm);
    pm->SetMarkerStyle(23);
    pm->SetMarkerColor(kRed);
    pm->SetMarkerSize(1.3);
    if (nhyps == 5) {
      for (int i = 0; i < nhyps; i++) {
	TF1 *f = new TF1(*g2);
	f->SetName(Form("L5%s",Peaks[i].Name));
	f->FixParameter(9,i);
	f->SetLineColor(i+2);
	proj->GetListOfFunctions()->Add(f);
      }
      proj->Draw();
    }
  }
  return g2;
}
//________________________________________________________________________________
Double_t gbFunc(Double_t *x, Double_t *par) {
  // par[0] - norm
  // par[1] - pion position wrt Z_pion (Bichsel prediction)
  // par[2] - sigma 
  // par[3] - proton signal
  // par[4] - Kaon    -"-
  // par[5] - electorn -"-
  // par[6] - deuteron -"-
  // par[7] - Total
  // par[8] - <dX>
#if 1
  if (! LandauF) Landau();
  static Double_t sigma_p[3] = {// sigma versus ::log(dX)
    5.31393e-01,//    1  p0  1.33485e-03   7.13072e-07   7.08416e-08
    -1.43277e-01,//    2  p1  3.36846e-03   6.62434e-07  -1.13681e-05
    2.43800e-02 //    3  p2  1.81240e-03   4.02492e-07  -2.08423e-05
  };
  Double_t sigmaC = par[2];
  Double_t frac[5];
  Int_t i;
  frac[0] = 1;
  for (i = 1; i < 5; i++) {
    frac[i] = TMath::Sin(par[2+i]);
    frac[i] *= frac[i];
    frac[0] -= frac[i];
  }
  Double_t Value = 0;
  static Double_t pMom = 0.475;
  static Double_t Xlog10bg[5];
  Double_t Ylog2dx = TMath::Log2(par[8]);
  Double_t Sigma = sigma_p[2];
  for (int n = 1; n>=0; n--) Sigma = Ylog2dx*Sigma + sigma_p[n];
  Double_t zMostProb[5];
  for (i = 0; i < 5; i++) {
    Xlog10bg[i] = TMath::Log10(pMom/Peaks[i].mass);
    zMostProb[i] = gBichsel->GetMostProbableZ(Xlog10bg[i],Ylog2dx);
    Double_t sigma     = Sigma + sigmaC;
    //    Double_t xi = (x[0] + zMostProb[0] - zMostProb[i])/sigma;
    //    Double_t xi = (x[0] + par[1] + zMostProb[0] - zMostProb[i])/sigma;
    Double_t xi = (x[0] - par[1] - Peaks[i].peak)/sigma;
    Double_t Prob = LandauF->Eval(xi);
    
    Value += frac[i]*Prob;
    //    cout << "i\t" << i << "\tx = " << x[0] << " frac " << frac[i] << "\t" << Value << endl;
  }
  return par[7]*TMath::Exp(par[0])*Value;
#else
  Double_t sigmaC = par[2];
  Double_t frac[5];
  Int_t i;
  frac[0] = 1;
  for (i = 1; i < 5; i++) {
    frac[i] = TMath::Sin(par[2+i]);
    frac[i] *= frac[i];
    frac[0] -= frac[i];
  }
  Double_t Value = 0;
  static Double_t pMom = 0.475;
  static Double_t Xlog10bg[5];
  Double_t Ylog2dx = TMath::Log2(par[8]);
  Double_t zMostProb[5];
  for (i = 0; i < 5; i++) {
    Xlog10bg[i] = TMath::Log10(pMom/Peaks[i].mass);
    zMostProb[i] = gBichsel->GetMostProbableZ(Xlog10bg[i],Ylog2dx);
    Double_t sigma     = gBichsel->GetRmsZ(Xlog10bg[i],Ylog2dx) + sigmaC;
    //    Double_t xi = (x[0] + zMostProb[0] - zMostProb[i])/sigma;
    Double_t xi = (x[0] - par[1] - Peaks[i].peak)/sigma;
    Double_t  Phi = gBichsel->GetProbability(Xlog10bg[i],Ylog2dx,xi);
    Double_t Prob = Phi/sigma;
    
    Value += frac[i]*Prob;
    //    cout << "i\t" << i << "\tx = " << x[0] << " frac " << frac[i] << "\t" << Value << endl;
  }
  return par[7]*TMath::Exp(par[0])*Value;
#endif
}
//________________________________________________________________________________
TF1 *FitGB(TH1 *proj, Option_t *opt="", Double_t dX = 2.364) {
  if (!gBichsel) {
    gSystem->Load("StBichsel");
    gBichsel = Bichsel::Instance();
  }
  // fit in momentum range p = 0.45 - 0.50 GeV/c
  if (! proj) return 0;
  TString Opt(opt);
  //  Bool_t quet = Opt.Contains("Q",TString::kIgnoreCase);
  TF1 *g2 = (TF1*) gROOT->GetFunction("GB");
  if (! g2) {
    g2 = new TF1("GB",gbFunc, -5, 5, 9);
    g2->SetParName(0,"norm"); 
    g2->SetParName(1,"mu");     g2->SetParLimits(1,-1.5,1.5);
    g2->SetParName(2,"Sigma");  g2->SetParLimits(2,0.0,0.8);
    g2->SetParName(3,"P"); 
    g2->SetParName(4,"K"); 
    g2->SetParName(5,"e"); 
    g2->SetParName(6,"d");
    g2->SetParName(7,"Total");
    g2->SetParName(8,"dX");
    //    g2->SetParName(7,"factor"); g2->SetParLimits(7,-.1,0.1);
  }
  
  Double_t total = proj->Integral()*proj->GetBinWidth(5);
#if 0
  TAxis *xx = proj->GetXaxis();
  for (int i = 0; i <5; i++) {
    Double_t x = 0;
    if (i) x = peaks[i];
    Int_t bin = xx->FindBin(x);
    Int_t p = 0;
    if (i != 0) p = i+3;
    Double_t cont = proj->GetBinContent(bin);
    g2->ReleaseParameter(p);
    if (cont > 0) g2->SetParameter(p,TMath::Log(cont));
    else          g2->FixParameter(p,-99.);
  }
#endif
  g2->SetParameters(0, 1e-3, 0.01, 0.4, 0., 0., 0.,0.);
  g2->FixParameter(7,total);
  g2->FixParameter(8,dX);
  Int_t iok = proj->Fit(g2,Opt.Data());
  if ( iok ) {
    cout << g2->GetName() << " fit has failed with " << iok << " for " 
	 << proj->GetName() << "/" << proj->GetTitle() << " Try one again" << endl; 
    proj->Fit(g2,Opt.Data());
  }
  Opt += "m";
  iok = proj->Fit(g2,Opt.Data());
  if (! Opt.Contains("q",TString::kIgnoreCase)) {
    Double_t params[10];
    g2->GetParameters(params);
    Double_t X = params[1];
    Double_t Y = TMath::Exp(params[0]);
    TPolyMarker *pm = new TPolyMarker(1, &X, &Y);
    proj->GetListOfFunctions()->Add(pm);
    pm->SetMarkerStyle(23);
    pm->SetMarkerColor(kRed);
    pm->SetMarkerSize(1.3);
    proj->Draw();
  }
  return g2;
}
//________________________________________________________________________________
TF1 *FitG2(TH1 *proj, Option_t *opt="RQ") {
  if (! proj) return 0;
  Double_t params[9];
  TF1 *gaus = new TF1("gaus","gaus",-5.,5.);
  proj->Fit(gaus,opt);
  params[0] = gaus->GetParameter(0);
  params[1] = gaus->GetParameter(1);
  params[2] = gaus->GetParameter(2);
  params[3] = 1;
  params[4] = 2;
  params[5] = gaus->GetParameter(2);
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  TF1 *g = new TF1("g","gaus(0)+gaus(3)",-5.,5.);
  g->SetParameters(params);
  g->SetParLimits(0,0,1.e10);
  g->SetParLimits(1,-5,5);
  g->SetParLimits(2,0.01,5);
  g->SetParLimits(3,0,1.e10);
  g->SetParLimits(4,-5,5);
  g->SetParLimits(5,0.01,5);
  proj->Fit(g,opt);
  g->GetParameters(params);
  if (TMath::Abs(params[1]) > TMath::Abs(params[4])) {
    g->SetParameter(0,params[3]);
    g->SetParameter(1,params[4]);
    g->SetParameter(2,params[5]);
    g->SetParameter(3,params[0]);
    g->SetParameter(4,params[1]);
    g->SetParameter(5,params[2]);
    proj->Fit(g,opt);
  }
  proj->Fit(g,opt);
  delete gaus;
  return g;
}
//________________________________________________________________________________
TF1 *FitG3(TH1 *proj, Option_t *opt="RQ") {
  if (! proj) return 0;
  Double_t params[9];
  TF1 *gaus = new TF1("gaus","gaus",-5.,5.);
  TF1 *g = 0;
  proj->Fit(gaus,opt);
  params[0] = gaus->GetParameter(0);
  params[1] = gaus->GetParameter(1);
  params[2] = gaus->GetParameter(2);
  params[3] = 1;
  params[4] = 2;
  params[5] = gaus->GetParameter(2);
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  delete gaus;
  g = new TF1("g","gaus(0)+gaus(3)",-5.,5.);
  g->SetParameters(params);
  g->SetParLimits(0,0,1.e10);
  g->SetParLimits(1,-5,5);
  g->SetParLimits(2,0.1,5);
  g->SetParLimits(3,0,1.e10);
  g->SetParLimits(4,-5,5);
  g->SetParLimits(5,0.1,5);
  proj->Fit(g,opt);
  g->GetParameters(params);
  if (TMath::Abs(params[1]) > TMath::Abs(params[4])) {
    g->SetParameter(0,params[3]);
    g->SetParameter(1,params[4]);
    g->SetParameter(2,params[5]);
    g->SetParameter(3,params[0]);
    g->SetParameter(4,params[1]);
    g->SetParameter(5,params[2]);
  }
  proj->Fit(g,opt);
  if (g->GetProb() > 0) return g;
  g->GetParameters(params);
  delete g;
  g = new TF1("g","gaus(0)+gaus(3)+gaus(6)",-5.,5.);
  g->SetParLimits(6,0,1.e10);
  g->SetParLimits(7,-5,5);
  g->SetParLimits(8,0.1,5);
  params[6] = 10.;
  params[7] = 0.5*(params[1]+params[4]);
  params[8] = params[2];
  g->SetParameters(params);
  proj->Fit(g,opt);
  return g;
}
//________________________________________________________________________________
void FitB4G(Int_t icase = 0, Int_t hyp=-1, Int_t bin=0, 
	    Double_t xmin1=-1.0, Double_t xmax1 = 1.0,
#if 0
		     Double_t Mu2 =-3.0,Double_t xmin2=-.2, Double_t xmax2 = .2,
		     Double_t Mu3 = 0.0,Double_t xmin3=-2., Double_t xmax3 = 4.,
		     Double_t Mu4 = 0.0
#else
		     Double_t Mu2 = -.5,Double_t xmin2=-2., Double_t xmax2 = 4.,
		     Double_t Mu3 = 0.1,Double_t xmin3=-2., Double_t xmax3 = 4.,
		     Double_t Mu4 = 0.3
#endif
	    )
{   // icase = 0 z; icase != 0 70
  Double_t sigmas[2] = {0.06,0.12};
  const Int_t nHYPS = NHYPS;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  TFile *f = 0;
  if (bin == 0) {
    TString newfile("FitB4G");
    newfile += gSystem->BaseName(fRootFile->GetName());
    f = new TFile(newfile.Data(),"update");
  }
  Int_t i;
  for (i = 0; i< nHYPS; i++) {
    if (hyp >= 0 && hyp != i) continue;
    if (! icase) {
      hists[i] = (TH2 *) fRootFile->Get(HistNames[i]);
      if (!hists[i]) {printf("Cannot histogram %s\n",HistNames[i]); return;}
    }
    else {
      hists[i] = (TH2 *) fRootFile->Get(HistNames70[i]);
      if (!hists[i]) {printf("Cannot histogram %s\n",HistNames70[i]); return;}
    }
    histp[i] = (TProfile *) fRootFile->Get(HistNameP[i]);
    if (!histp[i]) {printf("Cannot histogram %s\n",HistNameP[i]); return;}
  }
  TF1 *g1 = new TF1("g1","gaus",xmin1,xmax1);
  TF1 *g = 0, *g2 = 0, *g3 = 0, *g4 = 0, *ga = 0;
  TCanvas *canvas = new TCanvas("canvas","canvas");
  if (Mu2 != 0) {
    if (Mu2 < -1.) {
      if   (Mu2 <= -4.) ga = new TF1("ga","gaus(0)+exp(pol3(3))",xmin2,xmax2);
      else {
	if (Mu2 <= -3.) ga = new TF1("ga","gaus(0)+exp(pol2(3))",xmin2,xmax2);
	else            ga = new TF1("ga","gaus(0)+exp(pol1(3))",xmin2,xmax2);
      }
      g = ga;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Const");
      g->SetParName(4,"Slope1"); 
      g->SetParName(5,"Slope2"); 
      g->SetParName(6,"Slope3"); 
      g->SetParName(7,"Slope4"); 
    }
    else {
      g2 = new TF1("g2","gaus(0)+gaus(3)",xmin2,xmax2);
      g = g2;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Constant2");
      g->SetParName(4,"Mean2"); 
      g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
      if (Mu3 != 0) { 
	g3= new TF1("g3","gaus(0)+gaus(3)+gaus(6)",xmin3,xmax3);
	g = g3;
	g->SetParName(0,"Constant1");
	g->SetParName(1,"Mean1"); 
	g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
	g->SetParName(3,"Constant2");
	g->SetParName(4,"Mean2"); 
	g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
	g->SetParName(6,"Constant3");
	g->SetParName(7,"Mean3"); 
	g->SetParName(8,"Sigma3"); g->SetParLimits(8,sigmas[0],sigmas[1]);
	if (Mu4 != 0) { 
	  g4= new TF1("g4","gaus(0)+gaus(3)+gaus(6)+gaus(9)",xmin3,xmax3);
	  g4->SetParName(0,"Constant1");
	  g4->SetParName(1,"Mean1"); 
	  g4->SetParName(2,"Sigma1"); g4->SetParLimits(2,sigmas[0],sigmas[1]);
	  g4->SetParName(3,"Constant2");
	  g4->SetParName(4,"Mean2"); 
	  g4->SetParName(5,"Sigma2"); g4->SetParLimits(5,sigmas[0],sigmas[1]);
	  g4->SetParName(6,"Constant3");
	  g4->SetParName(7,"Mean3"); 
	  g4->SetParName(8,"Sigma3"); g4->SetParLimits(8,sigmas[0],sigmas[1]);
	  g4->SetParName(9,"Constant4");
	  g4->SetParName(10,"Mean4"); 
	  g4->SetParName(11,"Sigma4"); g4->SetParLimits(11,sigmas[0],sigmas[1]);
	}
      }
    }
  }
  TH1 *proj = 0;
  Double_t params[12];
  Int_t k;//,ibin;
  Int_t Bin = TMath::Abs(bin);
  for (k = 0; k<nHYPS; k++) {
    if (hyp != -1 && k != hyp) continue;
    TH2 *hist = hists[k];
    Int_t nx = hist->GetNbinsX();
    for (i=1; i<=nx; i++) {
      if (bin != 0 && Bin != i) continue;
      //      if (proj) delete  proj;
      Char_t line[40];
      sprintf(line,"%s_%i",hist->GetName(),i);
      TString name(line);
      proj = hist->ProjectionY(name.Data(),i,i);
      Int_t ix1=proj->GetXaxis()->FindBin(-.1);
      Int_t ix2=proj->GetXaxis()->FindBin(0.1);
      if (proj->Integral(ix1,ix2) < 100.) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hist->GetName(),Bin,k,proj->Integral());
	delete proj;
	continue;
      }
      Int_t NFitPoints = 0;
      Double_t chisq;
      Double_t xrange = 0.6;
      g = g1;
      g->SetParLimits(0,0,1.e7);
      g->SetParLimits(1,-xrange,xrange); 
      g->SetParLimits(2,sigmas[0],sigmas[1]);
      proj->Fit(g->GetName(),"r");
      g->GetParameters(params);
      Int_t kcase = -1;
      if (xmin1 < -0.5 && xmax1 > 0.5 && g->GetChisquare() < 1.e3 // g->GetProb() > 1.e-3 
	  ) goto Done;
	//	  && TMath::Abs(g->GetParameter(1)) < 0.05) goto Done;
     if (ga) {
	g = ga;
	g1->GetParameters(params);
	params[1] = 0.;
	params[3] = 0.;
	params[4] = 0.;
	params[5] = 0.;
	params[6] = 0.;
	params[7] = 0.;
	params[8] = 0.;
	g->SetParameters(params);
	kcase = 0;
	if (g->GetChisquare() < 1.e3 // g->GetProb() > 1.e-3
	    ) goto Done;
      }
      else {
	if (g2) {
	  params[1] = 0.;
	  params[3] = params[0];
	  params[4] = Mu2;
	  params[5] = 2.0*params[2];
	  g = g2;
	  g->SetParameters(params);
	  g->SetParLimits(0,0,1.e7);
	  g->SetParLimits(1,-xrange,xrange); 
	  //	  g->SetParLimits(1,-.3,.3);
	  g->SetParLimits(2,sigmas[0],sigmas[1]);
	  g->SetParLimits(3,0,1.e7);
	  g->SetParLimits(5,sigmas[0],sigmas[1]);
	  proj->Fit(g->GetName(),"r");
	  g->GetParameters(params);
	  kcase = 2;
	  if (g->GetChisquare() < 1.e3 // g->GetProb() > 1.e-3
	      ) goto Done;
	  if (g3) {
	    params[1] = 0.;
	    params[6] = params[0];
	    params[7] = Mu3;
	    params[8] = 2.0*params[2];
	    g = g3;
	    g->SetParameters(params);
	    g->SetParLimits(0,0,1.e7);
	    g->SetParLimits(1,-xrange,xrange); 
	    //	    g->SetParLimits(1,-.1,.1);
	    g->SetParLimits(2,sigmas[0],sigmas[1]);
	    g->SetParLimits(3,0,1.e7);
	    g->SetParLimits(5,sigmas[0],sigmas[1]);
	    g->SetParLimits(6,0,1.e7);
	    g->SetParLimits(8,sigmas[0],sigmas[1]);
	    proj->Fit(g->GetName(),"r");
	    g->GetParameters(params);
	    kcase = 3;
	    if (g->GetChisquare() < 1.e3 // g->GetProb() > 1.e-3
		) goto Done;
	    if (g4) {
	      params[1] = 0.;
	      params[9] = params[0];
	      params[10] = Mu4;
	      params[11] = 2.0*params[2];
	      g = g4;
	      g->SetParameters(params);
	      g->SetParLimits(0,0,1.e7);
	      g->SetParLimits(1,-xrange,xrange); 
      //	      g->SetParLimits(1,-.1,.1);
	      g->SetParLimits(2,sigmas[0],sigmas[1]);
	      g->SetParLimits(3,0,1.e7);
	      g->SetParLimits(5,sigmas[0],sigmas[1]);
	      g->SetParLimits(6,0,1.e7);
	      g->SetParLimits(8,sigmas[0],sigmas[1]);
	      g->SetParLimits(9,0,1.e7);
	      g->SetParLimits(11,sigmas[0],sigmas[1]);
	      proj->Fit(g->GetName(),"r");
	      kcase = 4;
	      g->GetParameters(params);
	    }
	  }
	}
      }
    Done:
     if (g) {
       proj->Fit(g->GetName(),"RM");
       canvas->Update();
       Int_t l = 1;
       Double_t mu =  g->GetParameter(l);
       for (int m=2;m<=kcase;m++) {
	 if (TMath::Abs(mu) > TMath::Abs(g->GetParameter(3*m-2))) {
	   l = 3*m-2; mu =  g->GetParameter(l);
	   //	    printf("l=%i\n",l);
	 }
       }
       Nu[N]  = g->GetParameter(l);// printf("l=%i Nu=%f\n",l,Nu[N]);
       Mu[N]  = Nu[N] + histp[k]->GetBinContent(i);
       dMu[N] = g->GetParError(l);//Mu[N];
       //    Mu[N] = TMath::Log(Mu[N]);
       Sigma[N]  = g->GetParameter(2);
       dSigma[N] = g->GetParError(2);
       NFitPoints = g->GetNumberFitPoints();
       Int_t NDF = g->GetNDF();
       Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
       chisq      = g->GetChisquare();
       X[N] = hist->GetXaxis()->GetBinCenter(i);
       dX[N] = hist->GetXaxis()->GetBinWidth(i);
       Double_t pionM = Masses[k]*pow(10.,X[N]);
       printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
	       "chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
	       Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob);
       //	if (bin < 0 && prob > 1.e-7 && TMath::Abs(Nu[N]) < 0.05) {
       //	if ( bin >= 0 && prob > 1.e-7 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
       //       if ( bin >= 0 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
       if ( bin >= 0) {
	 printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	 TString FileN("FitPars");
	 if (hyp > -1)  FileN += hist->GetName();
	 FileN += ".h";
	 FILE *fp = fopen(FileN.Data(),"a");
	 if (fp) {
	   if (N == 0) {
	     TDatime time;
	     fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	     fprintf(fp,
		     "//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	   }
	   fprintf(fp,
		   "{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		   Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	   fclose(fp);
	 }
#if 1
	 proj->Write();
#endif
       }
       else printf ("================== Skip it\n");
     }
     N++; 	
     proj->Draw();// cnew->Update();
    }
  }
  if (f) {delete f;}
}
//________________________________________________________________________________
void dEdxFit(const Char_t *HistName = "Time",const Char_t *FitName = "GP", 
	     Option_t *opt="R", 
	     Int_t mergeX=1, Int_t mergeY=1, Int_t ix = 0, Int_t jy = 0, 
	     Double_t nSigma=3, Int_t pow=1) {
  TCanvas *canvas = 0;
  TString Opt(opt);
  if (! Opt.Contains("Q",TString::kIgnoreCase)) canvas = new TCanvas("Fit","Fit results");
  TList *list = (TList *) gROOT->GetListOfFiles();
  if (! list) {printf("File list is empty\n"); return;}
  TIter next(list);
  TFile *fRootFile = (TFile *) next(); // gDirectory->GetFile();
  if (! fRootFile ) {printf("There is no opened file\n"); return;}
  TH1 *hist = 0;// = (TH1 *) fRootFile->Get(HistName);
  fRootFile->GetObject(HistName,hist);
  if (!hist) {printf("Cannot find %s\n", HistName); return;}
  TAxis *xax = hist->GetXaxis();
  Int_t nx = xax->GetNbins(); printf ("nx = %i",nx);
  Axis_t xmin = xax->GetXmin(); printf (" xmin = %f",xmin);
  Axis_t xmax = xax->GetXmax(); printf (" xmax = %f\n",xmax);
  TAxis *yax = hist->GetYaxis();
  Int_t dim = hist->GetDimension();
  Int_t ny = yax->GetNbins();
  Int_t NX = nx;
  Int_t NY = ny;
  if (dim < 3) ny = 1;  printf ("ny = %i",ny);
  Axis_t ymin = yax->GetXmin(); printf (" ymin = %f",ymin);
  Axis_t ymax = yax->GetXmax(); printf (" ymax = %f\n",ymax);
  struct Fit_t {
    Float_t i;
    Float_t j;
    Float_t x;
    Float_t y;
    Float_t mean;
    Float_t rms;
    Float_t peak;
    Float_t mu;
    Float_t sigma;
    Float_t entries;
    Float_t chisq;
    Float_t prob;
    Float_t a0;
    Float_t a1;
    Float_t a2;
    Float_t a3;
    Float_t a4;
    Float_t a5;
    Float_t Npar;
    Float_t dpeak;
    Float_t dmu;
    Float_t dsigma;
    Float_t da0;
    Float_t da1;
    Float_t da2;
    Float_t da3;
    Float_t da4;
    Float_t da5;
  };
  Fit_t Fit;
  TString NewRootFile(gSystem->DirName(gSystem->BaseName(fRootFile->GetName())));
  NewRootFile += "/";
  NewRootFile += HistName;
  NewRootFile += FitName;
  if (mergeX != 1) NewRootFile += Form("_x%i",mergeX);
  if (mergeY != 1) NewRootFile += Form("_y%i",mergeY);
  //  NewRootFile += "_2_";
  NewRootFile += gSystem->BaseName(fRootFile->GetName());
  TFile *f = 0;
  TNtuple *FitP = 0;
  f = new TFile(NewRootFile.Data(),"update");
  if (! f) f = new TFile(NewRootFile.Data(),"new");
  if (f) cout << NewRootFile << " has been opened." << endl;
  else {cout << "Failed to open " << NewRootFile << endl; return;}
  //  TString TupName(HistName);
  //  TupName += "FitP";
#if 0
  if (TString(FitName) == "GF")
    FitP = new TNtuple("FitP","Fit results",
		       "i:j:x:y:mean:rms:peak:mu:sigma:entries:chisq:prob:pi:P:K:e:d:a5:Npar:dpeak:dmu:dsigma:dpi:dP:dK:de:dd:da5");
  else if (TString(FitName) == "GB")
    FitP = new TNtuple("FitP","Fit results",
		       "i:j:x:y:mean:rms:peak:mu:sigma:entries:chisq:prob:pi:P:K:e:d:dX:Npar:dpeak:dmu:dsigma:dpi:dP:dK:de:dd:ddX");
  else 
#endif
    FitP = new TNtuple("FitP","Fit results",
		       "i:j:x:y:mean:rms:peak:mu:sigma:entries:chisq:prob:a0:a1:a2:a3:a4:a5:Npar:dpeak:dmu:dsigma:da0:da1:da2:da3:da4:da5");
  FitP->SetMarkerStyle(20);
  FitP->SetLineWidth(2);
  TH1 *mean;   
  TH1 *rms;    
  TH1 *entries;
  TH1 *mu;
  TH1 *sigma;  
  TH1 *chisq; 
  if (dim == 3) {
    mean    = new TH2D("mean",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    rms     = new TH2D("rms",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    entries = new TH2D("entries",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    mu      = new TH2D("mu",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    sigma   = new TH2D("sigma",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
    chisq   = new TH2D("chisq",hist->GetTitle(),nx,xmin,xmax,ny,ymin,ymax);
  }
  else {
    if (dim == 2 || dim == 1) {
      mean    = new TH1D("mean",hist->GetTitle(),nx,xmin,xmax);
      rms     = new TH1D("rms",hist->GetTitle(),nx,xmin,xmax);
      entries = new TH1D("entries",hist->GetTitle(),nx,xmin,xmax);
      mu      = new TH1D("mu",hist->GetTitle(),nx,xmin,xmax);
      sigma   = new TH1D("sigma",hist->GetTitle(),nx,xmin,xmax);
      chisq   = new TH1D("chisq",hist->GetTitle(),nx,xmin,xmax);
    }
    else {
      printf("Histogram %s has wrong dimension %i\n", hist->GetName(),dim);
      return;
    }
  }
  Double_t params[9];
  TH1 *proj = 0;
  TF1 *g = 0;
  Int_t ix1 = ix, jy1 = jy;
  if (ix > 0) nx = ix;
  if (jy > 0) ny = jy;
  if (ix1 <= 0) ix1 = 0;
  if (jy1 <= 0) jy1 = 0;
  for (int i=ix1;i<=nx-mergeX+1;i++){
    Int_t ir0 = i;
    Int_t ir1=i+mergeX-1;
    if (i == 0) {ir0 = 1; ir1 = nx;}
    for (int j=jy1;j<=ny-mergeY+1;j++){
      Int_t jr0 = j;
      Int_t jr1 = j+mergeY-1;
      if (j == 0) {jr0 = 1; jr1 = ny;}
      if (dim == 3) {
	if (ir0 == ir1 && jr0 == jr1) 
	  proj = ((TH3 *) hist)->ProjectionZ(Form("f%i_%i",      ir0,    jr0    ),ir0,ir1,jr0,jr1);
	else                          
	  proj = ((TH3 *) hist)->ProjectionZ(Form("f%i_%i_%i_%i",ir0,ir1,jr0,jr1),ir0,ir1,jr0,jr1);
	if (! proj) continue;
	TString title(proj->GetTitle());
	title += Form(" in x [%5.1f,%5.1f] and y [%5.1f,%5.1f] range",
		      xax->GetBinLowEdge(ir0), xax->GetBinUpEdge(ir1),
		      yax->GetBinLowEdge(jr0), yax->GetBinUpEdge(jr1));
	proj->SetTitle(title.Data());
      }
      else {
	if (ir0 == ir1) 
	  proj = ((TH2 *) hist)->ProjectionY(Form("f%i",   ir0),    ir0,ir1);
	else 
	  proj = ((TH2 *) hist)->ProjectionY(Form("f%i_%i",ir0,ir1),ir0,ir1);
	if (! proj) continue;
	TString title(proj->GetTitle());
	title += Form("in x [%5.1f,%5.1f] range",
		      xax->GetBinLowEdge(ir0), xax->GetBinUpEdge(ir1));
	proj->SetTitle(title.Data());
      }
      cout << "i/j\t" << i << "/" << j << "\t" <<  proj->GetName() << "\t" << proj->GetTitle() << "\t" <<  proj->Integral() << endl;
      //      continue;
      memset (&Fit, 0, sizeof(Fit_t));
      Fit.i = (2.*i+mergeX-1.)/2;
      Fit.j = (2.*j+mergeY-1.)/2;
      Fit.x = 0.5*(xax->GetBinLowEdge(i) + xax->GetBinUpEdge(i+mergeX-1));
      Fit.y = 0.5*(yax->GetBinLowEdge(j) + yax->GetBinUpEdge(j+mergeY-1));
      Fit.mean = proj->GetMean();
      Fit.rms  = proj->GetRMS();
      Fit.chisq = -100;
      Fit.prob  = 0;
      Fit.entries = proj->Integral();
      if (Fit.entries < 100) {delete proj; continue;}
      if (TString(FitName) == "GP") g = FitGP(proj,opt,nSigma,pow);
      else if (TString(FitName) == "G2") g = FitG2(proj,opt);
      else if (TString(FitName) == "GF") g = FitGF(proj,opt);
      else if (TString(FitName) == "L5") g = FitL5(proj,opt,5);
      else if (TString(FitName) == "L1") g = FitL5(proj,opt,0);
#ifdef __USE_ROOFIT__
      else if (TString(FitName) == "R1") g  = FitR5(proj,opt,0);
      else if (TString(FitName) == "R5") g  = FitR5(proj,opt,5);
      else if (TString(FitName) == "RL5") {
	Bool_t outer = kFALSE;
	if      (NX == 45) {outer = i > 13;}
	else if (NY == 45) {outer = j > 13;}
	g = FitRL5(proj,outer);
      }
      else if (TString(FitName) == "RL1") g = FitRL1(proj);
#endif /* __USE_ROOFIT__ */
      else if (TString(FitName) == "GB") {
#if 0
	Double_t dX = 2.364; // <dX> Outer
	if ( (nx == 48 && (i > 0 && i <= 24)) ||
	     (nx == 24 && (nY == 13 + 32 || nY == 40 + 32 || nY == 50 + 32) && (j > 0 && j <= nY - 32)) ||
	     (nx == 13 + 32 || nx == 40 + 32 || nx == 50 + 32) && (i > 0 && i <= nx - 32))  
	  dX = 1.372; // <dX> Inner
#else
	Double_t dX = 2.0; // <dX> Outer
#endif
	g = FitGB(proj,opt,dX);
      }
      else {cout << FitName << " has not been definded" << endl; break;}
      if ( g ) {
	Int_t kpeak = 0;
	if (TString(FitName) == "RL5" || TString(FitName) == "RL1") kpeak = 10;
	g->GetParameters(params);
	Fit.Npar  = g->GetNpar();
	Fit.chisq = g->GetChisquare();
	Fit.prob  = g->GetProb();
	Fit.peak = params[kpeak]; // norm, Mu for RL5
	Fit.mu = params[1];
	Fit.sigma = TMath::Abs(params[2]);
	Fit.a0  = params[3]; // FitGF "P"
	Fit.a1  = params[4]; //       "K"
	Fit.a2  = params[5]; //       "e"
	Fit.a3  = params[6]; //       "d"
	Fit.a4  = params[7]; //       "Total"
	Fit.a5  = params[8]; //       "Case", sigma of Landau for L5
	Fit.dpeak  = g->GetParError(kpeak);
	Fit.dmu    = g->GetParError(1);
	Fit.dsigma = g->GetParError(2);
	Fit.da0    = g->GetParError(3);
	Fit.da1  	 = g->GetParError(4);
	Fit.da2  	 = g->GetParError(5);
	Fit.da3  	 = g->GetParError(6);
	Fit.da4  	 = g->GetParError(7);
	Fit.da5  	 = g->GetParError(8);
#if 0 /* No RooFit fit */
      }	else if (r) { // this is the block for rootfit
	Fit.Npar = r->floatParsFinal().getSize();
	
	//	Fit.chisq = g->GetChisquare();
	//	Fit.prob  = g->GetProb();
	Float_t *pars = &Fit.mu;
	Float_t *errs = &Fit.dmu;
	for (Int_t p = 0; p < Fit.Npar; p++) {
	  pars[p] = ((RooRealVar*) r->floatParsFinal().at(p))->getVal();
	  errs[p] = ((RooRealVar*) r->floatParsFinal().at(p))->getError();
	}
#endif
      } else {
	delete proj; continue;
      }
      //      Fit.chisq = g3->GetChisquare();
      //      if (Fit.prob > 0) {
	if (dim == 3) {
	  mean->SetBinContent(i,j,Fit.mean);
	  rms->SetBinContent(i,j,Fit.rms);
	  entries->SetBinContent(i,j,Fit.entries);
	  mu->SetBinContent(i,j,Fit.mu);
	  mu->SetBinError(i,j,g->GetParError(1));
	  sigma->SetBinContent(i,j,Fit.sigma);
	  sigma->SetBinError(i,j,g->GetParError(2));
	  chisq->SetBinContent(i,j,Fit.chisq);
	}
	else {
	  mean->SetBinContent(i,Fit.mean);
	  rms->SetBinContent(i,Fit.rms);
	  entries->SetBinContent(i,Fit.entries);
	  mu->SetBinContent(i,Fit.mu);
	  mu->SetBinError(i,g->GetParError(1));
	  sigma->SetBinContent(i,Fit.sigma);
	  sigma->SetBinError(i,g->GetParError(2));
	  chisq->SetBinContent(i,Fit.chisq);
	}
	//      }
      printf("%i/%i %f/%f mean %f rms = %f entries = %f mu = %f sigma = %f chisq = %f prob = %f\n",
	    i,j,Fit.x,Fit.y,Fit.mean,Fit.rms,Fit.entries,Fit.mu,Fit.sigma,Fit.chisq,Fit.prob);
      if (FitP)  FitP->Fill(&Fit.i);
      if (canvas) {
	canvas->Update();
#if 0
	int ii;
	cout << "Type i ";
	cin >> ii; if (ii <0) return;
#endif
      }
      proj->Write();
      if (! canvas) delete proj;
      //      delete g;
      //      if (f) f->Flush();
      //      gObjectTable->Print();
    }
  }
  if (f) {
    f->Write();
    delete f;
  }
} 
//________________________________________________________________________________
Int_t FitG(TH1 *proj, TF1 *g, TF1 *ga){//, Double_t scaleM=-2., Double_t scaleP=2.) {
  Double_t params[10];
  proj->Fit("g","R");
  Double_t chisq = g->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  g->GetParameters(params);
  params[3] = 0;
  params[4] = 0;
  params[5] = 0;
  params[6] = 0;
  params[7] = 0;
  params[8] = 0;
  params[9] = 0;
  ga->SetParameters(params);
  proj->Fit("ga","r");
  //  proj->Fit("ga","rIM");
  chisq = g->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  return 0;
}
//________________________________________________________________________________
Int_t FitGG(TH1 *proj, TF1 *g1, TF1 *g2=0, TF1 *ga2=0, Double_t scaleM=-2., Double_t scaleP=2.) {
  Double_t params[9];
  proj->Fit("g1","R");
  g1->GetParameters(params);
  Double_t chisq = g1->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  params[3] = 1;
  params[4] = params[1]+0.1;
  params[5] = params[2];
  g2->SetParameters(params);
  proj->Fit("g2");
  chisq = g2->GetChisquare();
  if (chisq <= 0. || chisq > 1.e10) return -1;
  g2->GetParameters(params);
  if (ga2) {
    params[6] = 0;
    params[7] = 0;
    params[8] = 0;
    ga2->SetParameters(params);
    proj->Fit("ga2","R");
    ga2->GetParameters(params);
    ga2->SetRange(params[1]+scaleM*params[2],params[1]+scaleP*params[2]);
    proj->Fit("ga2","R");
  }
//   if (gPad) {
//     gPad->Update();
//     gPad->WaitPrimitive();
//   }
  return 0;
}
//________________________________________________________________________________
void FitX(TH2 *hist=0, Double_t range=1, Int_t Ibin = 0) {
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  if (!hist) {
    const Char_t *HistName = "FPoints";
    hist = (TH2D *) fRootFile->Get(HistName);
    if (!hist) {printf("Cannot histogram %s\n",HistName); return;}
  }
  //  const Int_t nx = hist->GetNbinsX();
  TF1 *g = new TF1("g","gaus",-range,range);
  //  TF1 *ga = g;
  TString fitN("gaus(0)+exp(pol3(3))");
  if (range > 2.) fitN = "gaus(0)+exp(pol5(3))";
  TF1 *ga= new TF1("ga",fitN.Data(),-range,range);
  ga->SetParName(0,"Area  Pi");
  ga->SetParName(1,"Mean  Pi"); 
  ga->SetParName(2,"Sigma Pi");
  ga->SetParName(3,"A0");
  ga->SetParName(4,"A1");
  ga->SetParName(5,"A2");
  ga->SetParName(6,"A3");
  ga->SetParName(7,"A4");
  ga->SetParName(8,"A5");
  
  TCanvas *c = new TCanvas("Fit","Fit results");
  int i;
  TString name(hist->GetName());
  name += "MuFG";
  Int_t nBins = hist->GetXaxis()->GetNbins();
  Double_t xlow = hist->GetXaxis()->GetXmin();
  Double_t xup  = hist->GetXaxis()->GetXmax();
  TH1D *MuF = new TH1D(name.Data(),"Avarage shift versus no. of measurement points",
		       nBins,  xlow, xup);
  name = hist->GetName();
  name += "SigmaFG";
  TH1D *SigmaF = new TH1D(name.Data(),"Sigma of z versus no. of measurement points",
		       nBins,  xlow, xup);
  Int_t i1 = 1, i2 = nBins;
  if (Ibin > 0 && Ibin <= nBins) {i1 = Ibin; i2 = Ibin;}
  Double_t XFitP, dXFitP,  MuFitP,dMuFitP,SigmaFitP,dSigmaFitP;
  TH1 *proj = 0;
  for (i=i1; i<=i2; i++) {
    if (proj) delete proj;
    proj = hist->ProjectionY("proj",i,i);
    XFitP = hist->GetXaxis()->GetBinCenter(i);
    dXFitP = hist->GetXaxis()->GetBinWidth(i);
    Double_t chisq = -999;
    if (proj->Integral() < 1000) {
      if (N>0) goto NEXT;
      continue;
    }
    if (FitG(proj,g,ga)) goto NEXT;
    //    proj->Fit("g","R");
    if (ga->GetParError(1) <= 0 || ga->GetParError(1) > 0.01 ) {
      printf("============= REJECT ================\n");
      goto NEXT;
    }
    MuFitP  = ga->GetParameter(1);
    dMuFitP = ga->GetParError(1);///MuFitP;
    //    MuFitP = TMath::Log(MuFitP);
    SigmaFitP  = ga->GetParameter(2);
    dSigmaFitP = ga->GetParError(2);
    chisq = ga->GetChisquare();
    if (chisq > 1.e4) goto NEXT; 
    MuF->SetCellContent(i,0,MuFitP);
    MuF->SetCellError(i,0,dMuFitP);
    SigmaF->SetCellContent(i,0,SigmaFitP);
    SigmaF->SetCellError(i,0,dSigmaFitP);
    proj->Draw(); c->Update();
    printf("Bin: %i x: %f +/- %f MuF: %f+/-%f Sigma: %f+/-%f chisq: %f \n",
	   i,XFitP,dXFitP,MuFitP,dMuFitP,SigmaFitP,dSigmaFitP,chisq);
 NEXT:   
    N++;  
    //    delete proj;
  }
  if (! Ibin ) {
    c->Clear();
    //   c->Divide(2,1);
    //   c->cd(1);
    //   MuF->Draw();
    //   c->cd(2);
    SigmaF->SetMarkerStyle(20);
    TF1 *p = new TF1("p","[0]/pow(x,[1])");
    p->SetParameter(0,0.64);
    p->SetParameter(1,0.50);
    SigmaF->Fit("p","R");
    SigmaF->SetMinimum(0.06);
    SigmaF->Draw();
  }
  TString NewRootFile(hist->GetName());
  NewRootFile += fRootFile->GetName();
  TFile *f = new TFile(NewRootFile.Data(),"update");
  MuF->Write();
  SigmaF->Write();
  delete f;
  fRootFile->cd();
}
#if 0
//________________________________________________________________________________
void FitC4G(const Char_t *set="z") {
  Double_t sigmas[2] = {0.06,0.12};
  const Int_t nHYPS = NHYPS;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  TString newfile("FitC4G");
  newfile += "set";
  newfile += gSystem->BaseName(fRootFile->GetName());
  TFile * f = new TFile(newfile.Data(),"update");
  for (Int_t i = 0; i< nHYPS; i++) {
    Char_t *HistN =  HistNames[i];
    if (TString(set) == "70") HistN = HistNames70[i];
    fRootFile->Get(HistN);
    if (!hists[i]) {printf("Cannot histogram %s\n",HistNames[i]); return;}
    histp[i] = (TProfile *) fRootFile->Get(HistNameP[i]);
    if (!histp[i]) {printf("Cannot histogram %s\n",HistNameP[i]); return;}
  }
  TF1 *g[4];
  TF1 *g1 = new TF1("g1","gaus",-0.3,0.3);
  TF1 *g = 0, *g2 = 0, *g3 = 0, *g4 = 0, *ga = 0;
  TCanvas *canvas = new TCanvas("canvas","canvas");
  if (Mu2 != 0) {
    if (Mu2 < -1.) {
      if   (Mu2 <= -4.) ga = new TF1("ga","gaus(0)+exp(pol3(3))",xmin2,xmax2);
      else {
	if (Mu2 <= -3.) ga = new TF1("ga","gaus(0)+exp(pol2(3))",xmin2,xmax2);
	else            ga = new TF1("ga","gaus(0)+exp(pol1(3))",xmin2,xmax2);
      }
      g = ga;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Const");
      g->SetParName(4,"Slope1"); 
      g->SetParName(5,"Slope2"); 
      g->SetParName(6,"Slope3"); 
      g->SetParName(7,"Slope4"); 
    }
    else {
      g2 = new TF1("g2","gaus(0)+gaus(3)",xmin2,xmax2);
      g = g2;
      g->SetParName(0,"Constant1");
      g->SetParName(1,"Mean1"); 
      g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
      g->SetParName(3,"Constant2");
      g->SetParName(4,"Mean2"); 
      g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
      if (Mu3 != 0) { 
	g3= new TF1("g3","gaus(0)+gaus(3)+gaus(6)",xmin3,xmax3);
	g = g3;
	g->SetParName(0,"Constant1");
	g->SetParName(1,"Mean1"); 
	g->SetParName(2,"Sigma1"); g->SetParLimits(2,sigmas[0],sigmas[1]);
	g->SetParName(3,"Constant2");
	g->SetParName(4,"Mean2"); 
	g->SetParName(5,"Sigma2"); g->SetParLimits(5,sigmas[0],sigmas[1]);
	g->SetParName(6,"Constant3");
	g->SetParName(7,"Mean3"); 
	g->SetParName(8,"Sigma3"); g->SetParLimits(8,sigmas[0],sigmas[1]);
	if (Mu4 != 0) { 
	  g4= new TF1("g4","gaus(0)+gaus(3)+gaus(6)+gaus(9)",xmin3,xmax3);
	  g4->SetParName(0,"Constant1");
	  g4->SetParName(1,"Mean1"); 
	  g4->SetParName(2,"Sigma1"); g4->SetParLimits(2,sigmas[0],sigmas[1]);
	  g4->SetParName(3,"Constant2");
	  g4->SetParName(4,"Mean2"); 
	  g4->SetParName(5,"Sigma2"); g4->SetParLimits(5,sigmas[0],sigmas[1]);
	  g4->SetParName(6,"Constant3");
	  g4->SetParName(7,"Mean3"); 
	  g4->SetParName(8,"Sigma3"); g4->SetParLimits(8,sigmas[0],sigmas[1]);
	  g4->SetParName(9,"Constant4");
	  g4->SetParName(10,"Mean4"); 
	  g4->SetParName(11,"Sigma4"); g4->SetParLimits(11,sigmas[0],sigmas[1]);
	}
      }
    }
  }
  TH1 *proj = 0;
  Double_t params[12];
  Int_t k;//,ibin;
  Int_t Bin = TMath::Abs(bin);
  for (k = 0; k<nHYPS; k++) {
    if (hyp != -1 && k != hyp) continue;
    TH2 *hist = hists[k];
    Int_t nx = hist->GetNbinsX();
    for (i=1; i<=nx; i++) {
      if (bin != 0 && Bin != i) continue;
      //      if (proj) delete  proj;
      Char_t line[40];
      sprintf(line,"%s_%i",hist->GetName(),i);
      TString name(line);
      proj = hist->ProjectionY(name.Data(),i,i);
      Int_t ix1=proj->GetXaxis()->FindBin(-.1);
      Int_t ix2=proj->GetXaxis()->FindBin(0.1);
      if (proj->Integral(ix1,ix2) < 100.) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hist->GetName(),Bin,k,proj->Integral());
	delete proj;
	continue;
      }
      Int_t NFitPoints = 0;
      Double_t chisq;
      g = g1;
      g->SetParLimits(0,0,1.e7);
      g->SetParLimits(1,-.1,.1);
      g->SetParLimits(2,sigmas[0],sigmas[1]);
      proj->Fit(g->GetName(),"ri");
      g->GetParameters(params);
      Int_t kcase = -1;
      if (xmin1 < -0.5 && xmax1 > 0.5 && g->GetProb() > 1.e-3 
	  && TMath::Abs(g->GetParameter(1)) < 0.05) goto Done;
     if (ga) {
	g = ga;
	g1->GetParameters(params);
	params[1] = 0.;
	params[3] = 0.;
	params[4] = 0.;
	params[5] = 0.;
	params[6] = 0.;
	params[7] = 0.;
	params[8] = 0.;
	g->SetParameters(params);
	kcase = 0;
	if (g->GetProb() > 1.e-3) goto Done;
      }
      else {
	if (g2) {
	  params[1] = 0.;
	  params[3] = params[0];
	  params[4] = Mu2;
	  params[5] = 2.0*params[2];
	  g = g2;
	  g->SetParameters(params);
	  g->SetParLimits(0,0,1.e7);
	  g->SetParLimits(1,-.1,.1);
	  g->SetParLimits(2,sigmas[0],sigmas[1]);
	  g->SetParLimits(3,0,1.e7);
	  g->SetParLimits(5,sigmas[0],sigmas[1]);
	  proj->Fit(g->GetName(),"ri");
	  g->GetParameters(params);
	  kcase = 2;
	  if (g->GetProb() > 1.e-3) goto Done;
	  if (g3) {
	    params[1] = 0.;
	    params[6] = params[0];
	    params[7] = Mu3;
	    params[8] = 2.0*params[2];
	    g = g3;
	    g->SetParameters(params);
	    g->SetParLimits(0,0,1.e7);
	    g->SetParLimits(1,-.1,.1);
	    g->SetParLimits(2,sigmas[0],sigmas[1]);
	    g->SetParLimits(3,0,1.e7);
	    g->SetParLimits(5,sigmas[0],sigmas[1]);
	    g->SetParLimits(6,0,1.e7);
	    g->SetParLimits(8,sigmas[0],sigmas[1]);
	    proj->Fit(g->GetName(),"ri");
	    g->GetParameters(params);
	    kcase = 3;
	    if (g->GetProb() > 1.e-3) goto Done;
	    if (g4) {
	      params[1] = 0.;
	      params[9] = params[0];
	      params[10] = Mu4;
	      params[11] = 2.0*params[2];
	      g = g4;
	      g->SetParameters(params);
	      g->SetParLimits(0,0,1.e7);
	      g->SetParLimits(1,-.1,.1);
	      g->SetParLimits(2,sigmas[0],sigmas[1]);
	      g->SetParLimits(3,0,1.e7);
	      g->SetParLimits(5,sigmas[0],sigmas[1]);
	      g->SetParLimits(6,0,1.e7);
	      g->SetParLimits(8,sigmas[0],sigmas[1]);
	      g->SetParLimits(9,0,1.e7);
	      g->SetParLimits(11,sigmas[0],sigmas[1]);
	      proj->Fit(g->GetName(),"ri");
	      kcase = 4;
	      g->GetParameters(params);
	    }
	  }
	}
      }
    Done:
      if (g) {
	proj->Fit(g->GetName(),"RIM");
	canvas->Update();
	Int_t l = 1;
	Double_t mu =  g->GetParameter(l);
	for (int m=2;m<=kcase;m++) {
	  if (TMath::Abs(mu) > TMath::Abs(g->GetParameter(3*m-2))) {
	    l = 3*m-2; mu =  g->GetParameter(l);
	    //	    printf("l=%i\n",l);
	  }
	}
	Nu[N]  = g->GetParameter(l);// printf("l=%i Nu=%f\n",l,Nu[N]);
	Mu[N]  = Nu[N] + histp[k]->GetBinContent(i);
	dMu[N] = g->GetParError(l);///Mu[N];
	//    Mu[N] = TMath::Log(Mu[N]);
	Sigma[N]  = g->GetParameter(2);
	dSigma[N] = g->GetParError(2);
	NFitPoints = g->GetNumberFitPoints();
	Int_t NDF = g->GetNDF();
	Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
	chisq      = g->GetChisquare();
	X[N] = hist->GetXaxis()->GetBinCenter(i);
	dX[N] = hist->GetXaxis()->GetBinWidth(i);
	Double_t pionM = Masses[k]*pow(10.,X[N]);
	printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
		"chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
		Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob);
	//	if (bin < 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.05) {
	//	if ( bin >= 0 && prob > 1.e-3 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	if ( bin >= 0 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	  printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		 Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	  TString FileN("FitPars");
	  if (hyp > -1)  FileN += HistNames[hyp];
	  FileN += ".h";
	  FILE *fp = fopen(FileN.Data(),"a");
	  if (fp) {
	    if (N == 0) {
	      TDatime time;
	      fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	      fprintf(fp,
"//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	    }
	  fprintf(fp,
		  "{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		  Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	    fclose(fp);
	  }
#if 1
	  proj->Write();
#endif
	}
	else printf ("================== Skip it\n");
      }
      N++; 	
      proj->Draw();// cnew->Update();
    }
  }
  if (f) {delete f;}
}
#endif
//________________________________________________________________________________
void Fit4G(Int_t ng=2, Int_t hyp=-1, Int_t bin=0, 
	   Double_t xmin1=-1.0, Double_t xmax1 = 1.0,
	   Double_t Mu2 = -.5,Double_t xmin2=-1., Double_t xmax2 = 1.,
	   Double_t Mu3 = 0.0,Double_t xmin3=-1., Double_t xmax3 = 1.,
	   Double_t Mu4 = 0.0){  
  Double_t sigmas[2] = {0.06,0.12};
  const Int_t nHYPS = 4;
  TH2 *hists[nHYPS];
  TProfile *histp[nHYPS];
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  TFile *f = 0;
  if (bin == 0) {
    TString newfile("BBFit");
    newfile += gSystem->BaseName(fRootFile->GetName());
    f = new TFile(newfile.Data(),"update");
  }
  for (int i = 0; i< nHYPS; i++) {
    if (hyp >= 0 && hyp != i) continue;
    hists[i] = (TH2 *) fRootFile->Get(HistNames[i]);
    if (!hists[i]) {printf("Cannot histogram %s\n",HistNames[i]); return;}
    histp[i] = (TProfile *) fRootFile->Get(HistNameP[i]);
    if (!histp[i]) {printf("Cannot histogram %s\n",HistNameP[i]); return;}
  }
  TF1 *g1 = new TF1("g1","gaus",xmin1,xmax1);
  TF1 *g = 0, *g2 = 0, *g3 = 0, *g4 = 0, *ga = 0;
  TCanvas *canvas = new TCanvas("canvas","canvas");
  if (ng<0) {
    ga = new TF1("ga",Form("gaus(0)+exp(pol%i(3))",-ng),xmin2,xmax2);
    ga->SetParName(0,"Constant1");
    ga->SetParName(1,"Mean1"); 
    ga->SetParName(2,"Sigma1");
    ga->SetParName(3,"Const");
    for (int m = 0; m <= -ng; m++) ga->SetParName(m+3,Form("Slope%i",m)); 
  }
  else {
    for (int m = 2; m <= ng; m++) {
      if (m == 2)  {g2 = new TF1("g2","gaus(0)+gaus(3)",xmin2,xmax2); g = g2;}
      if (m == 3)  {g3 = new TF1("g3","gaus(0)+gaus(3)+gaus(6)",xmin3,xmax3); g = g3;}
      if (m == 4)  {g4 = new TF1("g4","gaus(0)+gaus(3)+gaus(6)+gaus(9)",-1.,1.); g = g4;}
      for (int k = 0; k < 3*m; k += 3) {
	g->SetParName(k  ,Form("Constant%i",m));
	g->SetParName(k+1,Form("Mean%i",m)); 
	g->SetParName(k+2,Form("Sigma%i",m));
      }
    }
  }
  TH1 *proj = 0;
  Double_t params[12];
  Int_t k,i;//,ibin;
  Int_t Bin = TMath::Abs(bin);
  for (k = 0; k<nHYPS; k++) {
    if (hyp != -1 && k != hyp) continue;
    TH2 *hist = hists[k];
    Int_t nx = hist->GetNbinsX();
    for (i=1; i<=nx; i++) {
      if (bin != 0 && Bin != i) continue;
      //      if (proj) delete  proj;
      Char_t line[40];
      sprintf(line,"%s_%i",hist->GetName(),i);
      TString name(line);
      proj = hist->ProjectionY(name.Data(),i,i);
      Int_t ix1=proj->GetXaxis()->FindBin(-.1);
      Int_t ix2=proj->GetXaxis()->FindBin(0.1);
      if (proj->Integral(ix1,ix2) < 100) {
	printf("hist:%s bin %i for hyp %i has only %10.0f entries\n",hist->GetName(),Bin,k,proj->Integral());
	delete proj;
	continue;
      }
      Int_t NFitPoints = 0;
      Double_t xrange = 0.6;
      Double_t chisq;
      g = g1;
      g->SetParLimits(0,0,1.e7);
      g->SetParLimits(1,-xrange,xrange); 
      //      g->SetParLimits(1,-.1,.1);
      g->SetParLimits(2,sigmas[0],sigmas[1]);
      proj->Fit(g->GetName(),"ri");
      g->GetParameters(params);
      Int_t kcase = -1;
      if (xmin1 < -0.5 && xmax1 > 0.5 && g->GetProb() > 1.e-7 
	  && TMath::Abs(g->GetParameter(1)) < 0.05) goto Done;
     if (ga) {
	g = ga;
	g1->GetParameters(params);
	params[1] = 0.;
	params[3] = 0.;
	params[4] = 0.;
	params[5] = 0.;
	params[6] = 0.;
	params[7] = 0.;
	params[8] = 0.;
	g->SetParameters(params);
	kcase = 0;
	if (g->GetProb() > 1.e-7) goto Done;
      }
      else {
	if (g2) {
	  params[1] = 0.;
	  params[3] = params[0];
	  params[4] = Mu2;
	  params[5] = 2.0*params[2];
	  g = g2;
	  g->SetParameters(params);
	  g->SetParLimits(0,0,1.e7);
	  g->SetParLimits(1,-xrange,xrange); 
	  //	  g->SetParLimits(1,-.1,.1);
	  g->SetParLimits(2,sigmas[0],sigmas[1]);
	  g->SetParLimits(3,0,1.e7);
	  g->SetParLimits(5,sigmas[0],sigmas[1]);
	  proj->Fit(g->GetName(),"ri");
	  g->GetParameters(params);
	  kcase = 2;
	  if (g->GetProb() > 1.e-7) goto Done;
	  if (g3) {
	    params[1] = 0.;
	    params[6] = params[0];
	    params[7] = Mu3;
	    params[8] = 2.0*params[2];
	    g = g3;
	    g->SetParameters(params);
	    g->SetParLimits(0,0,1.e7);
	    g->SetParLimits(1,-xrange,xrange); 
      //	    g->SetParLimits(1,-.1,.1);
	    g->SetParLimits(2,sigmas[0],sigmas[1]);
	    g->SetParLimits(3,0,1.e7);
	    g->SetParLimits(5,sigmas[0],sigmas[1]);
	    g->SetParLimits(6,0,1.e7);
	    g->SetParLimits(8,sigmas[0],sigmas[1]);
	    proj->Fit(g->GetName(),"ri");
	    g->GetParameters(params);
	    kcase = 3;
	    if (g->GetProb() > 1.e-7) goto Done;
	    if (g4) {
	      params[1] = 0.;
	      params[9] = params[0];
	      params[10] = Mu4;
	      params[11] = 2.0*params[2];
	      g = g4;
	      g->SetParameters(params);
	      g->SetParLimits(0,0,1.e7);
      g->SetParLimits(1,-xrange,xrange); 
	      //	      g->SetParLimits(1,-.1,.1);
	      g->SetParLimits(2,sigmas[0],sigmas[1]);
	      g->SetParLimits(3,0,1.e7);
	      g->SetParLimits(5,sigmas[0],sigmas[1]);
	      g->SetParLimits(6,0,1.e7);
	      g->SetParLimits(8,sigmas[0],sigmas[1]);
	      g->SetParLimits(9,0,1.e7);
	      g->SetParLimits(11,sigmas[0],sigmas[1]);
	      proj->Fit(g->GetName(),"ri");
	      kcase = 4;
	      g->GetParameters(params);
	    }
	  }
	}
      }
    Done:
      if (g) {
	proj->Fit(g->GetName(),"RIM");
	canvas->Update();
	Int_t l = 1;
	Double_t mu =  g->GetParameter(l);
	for (int m=2;m<=kcase;m++) {
	  if (TMath::Abs(mu) > TMath::Abs(g->GetParameter(3*m-2))) {
	    l = 3*m-2; mu =  g->GetParameter(l);
	    //	    printf("l=%i\n",l);
	  }
	}
	Nu[N]  = g->GetParameter(l);// printf("l=%i Nu=%f\n",l,Nu[N]);
	Mu[N]  = Nu[N] + histp[k]->GetBinContent(i);
	dMu[N] = g->GetParError(l);///Mu[N];
	//    Mu[N] = TMath::Log(Mu[N]);
	Sigma[N]  = g->GetParameter(2);
	dSigma[N] = g->GetParError(2);
	NFitPoints = g->GetNumberFitPoints();
	Int_t NDF = g->GetNDF();
	Double_t prob = g->GetProb();//TMath::Prob(chisq, NDF);
	chisq      = g->GetChisquare();
	X[N] = hist->GetXaxis()->GetBinCenter(i);
	dX[N] = hist->GetXaxis()->GetBinWidth(i);
	Double_t pionM = Masses[k]*pow(10.,X[N]);
	printf ("%s :hyp = %i bin=%i, Point=%i, x=%f, p=%f, Delta_I=%f, I=%f, Sigma_I=%f,\n"
		"chisq=%f, NoPoints=%i,ndf=%i, prob=%f\n",
		Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob);
	//	if (bin < 0 && prob > 1.e-7 && TMath::Abs(Nu[N]) < 0.05) {
	//	if ( bin >= 0 && prob > 1.e-7 && TMath::Abs(Nu[N]) < 0.10 || bin < 0) {
	if ( (bin >= 0 && TMath::Abs(Nu[N]) < 0.10) || bin < 0) {
	  printf("{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		 Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	  TString FileN("FitPars");
	  if (hyp > -1)  FileN += HistNames[hyp];
	  FileN += ".h";
	  FILE *fp = fopen(FileN.Data(),"a");
	  if (fp) {
	    if (N == 0) {
	      TDatime time;
	      fprintf(fp,"// Date: Time = %i : %i\n",time.GetDate(), time.GetTime());
	      fprintf(fp,
"//          bin, Point,     x,      p,   Delta_I,         I, Sigma_I, chisq, NoPoints,ndf, prob\n");
	    }
	  fprintf(fp,
		  "{\"%-4s\",%2i,%4i,%6i,%6.3f,%7.3f,%10.6f,%10.6f,%8.5f,%10.3f},//%3i,%3i,%5.3f -- %s\n",
		  Names[k],k,i,N,X[N],pionM,Nu[N],Mu[N],dMu[N],chisq,NFitPoints,NDF,prob,g->GetName());
	    fclose(fp);
	  }
#if 1
	  proj->Write();
#endif
	}
	else printf ("================== Skip it\n");
      }
      N++; 	
      proj->Draw();// cnew->Update();
    }
  }
  if (f) {delete f;}
}
#ifdef PLUSHIKIN
//________________________________________________________________________________
void DrawMonths(TH1 *TimeMuFG,Double_t ymin=-.5, Double_t ymax=2.5) {
  //  TCanvas *canvas = new TCanvas("Y2001timeFit","z Fit");
  TimeMuFG->SetMaximum(ymax);
  TimeMuFG->SetMinimum(ymin);
  TimeMuFG->SetStats(0);
  TimeMuFG->Draw();
  TimeMuFG->SetMarkerStyle(20);
  TimeMuFG->SetXTitle("seconds since the Epoch");
  TimeMuFG->SetYTitle("z Fit");
  TimeMuFG->SetTitle("");
  TimeMuFG->GetXaxis()->SetTimeDisplay(1);
  TimeMuFG->GetXaxis()->SetTimeFormat("%m/%d/%y");
  TimeMuFG->Draw();
  for (Int_t i=7; i<13; i++) {
    Int_t d = 20010001 + 100*i;
    TDatime t(d,0);
    TString ts(t.AsSQLString());
    TString ymd(ts.Data(),ts.Index("-01 "));
    Double_t x = t.Convert();
    TLine *l = new TLine(x,ymin,x,ymax);
    l->SetLigneColor(i-6);
    l->Draw();
    TText *text = new TText(x, 0.8*(ymin+ymax),ymd.Data());
    text->Draw();
  }
}
//________________________________________________________________________________
void plotProfSpC(TCanvas *c1,TProfile *prof) 
{
  if (c1 && prof) {
    c1->Clear();
    c1->Divide(4,6);
    char line[10];
    for (Int_t i=0;i<24;i++) {
      c1->cd(i+1);
      sprintf(line,"Sector %i",i+1);
      prof->SetTitle(line);
      Int_t i1 = 90*i;
      prof->SetAxisRange(i1,i1+89); prof->Draw("R");
    }
  }
}
//_______________________________________________________________________________
Double_t LogLandau(Double_t *x, Double_t *par){
   Double_t yy =x[0];
   Double_t xx = TMath::Exp(yy); 
   Double_t f = xx*TMath::Landau(xx,par[0],par[1]);
   return f;
}
//________________________________________________________________________________
void Func()
{
   TF1 *f1 = new TF1("Func",LogLandau,0,10,2);
   f1->SetParameters(0,1);
   f1->SetParNames("mean","sigma");
   f1->Draw();
}
//________________________________________________________________________________
void SpCfit(TH2F *hist, Int_t i1, Int_t i2)
{
   TH1 *h1 = hist->ProjectionY("bin",i1,i2);
   TF1 *f1= (TF1 *) gROOT->GetFunction("Func");
   f1->SetParameters(0,1);
   h1->Fit("Func");
}
//________________________________________________________________________________
void Fee(const Char_t *topDir = "/star/rcf/scratch/fisyak/NTuples2/",
	 const Char_t *TreeName = "DeDxTree") {
  Int_t NoSector = 24;
  Int_t NoFee = 82;
  TH3F *Fee = new TH3F("Fee","dEdx versus sector and Fee",
		       NoSector,1,NoSector+1,
		       NoFee,0,NoFee,
		       200,-5.,5.);
  if (gClassTable->GetID("TDataSet")<0) gSystem->Load("libTable");
  TFileSet dirs(topDir);
  TDataSetIter next(&dirs,0);
  TDataSet *set = 0; 
  Int_t NFiles = 0;
  while ( (set = next()) ) {           
    if (strcmp(set->GetTitle(),"file") || 
	!strstr(set->GetName(),".root")) continue;
    TString File(gSystem->ConcatFileName(topDir,set->Path()));
    
    TString HName("F");
    HName += set->Path();
    HName.ReplaceAll("/","");
    HName.ReplaceAll(".root","");
    TFile f(File.Data());
    cout << " ================== Opened " <<  File.Data() << endl;
    NFiles++;
    TTree *DeDxTree = (TTree *) f.Get(TreeName);
    if (DeDxTree) {
      if (NFiles > 2) break;
      TH3F *fee = new TH3F(HName.Data(),"dEdx versus sector and Fee",
			   NoSector,1,NoSector+1,
			   NoFee,0,NoFee,
			   200,-5.,5.);
      DeDxTree->Draw("log(m_de/m_dx/m_zPi):m_fee:m_sector>>Fee","m_de>0 && m_de<2e-4");
//       Int_t nentries = Int_t(DeDxTree->GetEntries());
      
//       Int_t nbytes = 0, nb = 0;
//       for (Int_t jentry=0; jentry<nentries;jentry++) {
// 	Int_t ientry = LoadTree(jentry); //in case of a TChain, ientry is the entry number in the current file
// 	nb = DeDxTree->GetEntry(jentry);   nbytes += nb;
// 	// if (Cut(ientry) < 0) continue;
//       }
      Fee->Add(fee);
      TFile *ff = new TFile("fee.root","UPDATE");
      fee->Write();
      delete ff;
      delete fee;
    }
    else {
      cout << "  --------------------  File is empty" << endl;
      //      break;
    }
    Fee->Draw("colz");
    gPad->Update();
    TFile *ff = new TFile("fee.root","UPDATE");
    Fee->Write();
    delete ff;
  }
}
//________________________________________________________________________________
void MakeTimeGain(TH1 *hist, const Char_t *TabNam = "TpcTimeGain"){
  char filename[80]; 
  Double_t params[2];
//   TF1 *p0 = new TF1("p0","pol0");
//   hist->Fit("p0");
//  p0->GetParameters(params);
  if (gClassTable->GetID("TTable") < 0) gSystem->Load("libTable");
  if (gClassTable->GetID("St_TpcTimeGain") < 0) gSystem->Load("St_Tables");
  params[0] = 0;//-7.95305e-02;
  St_TpcTimeGain *timegain = new St_TpcTimeGain(TabNam,1);
  timegain->SetNRows(1);
  TpcTimeGain_st *gain = timegain->GetTable();
  Int_t Nbins = hist->GetNbinsX();
  for (Int_t i=1; i<=Nbins; i++) {
    Double_t scale = hist->GetBinContent(i);
    Double_t error = hist->GetBinError(i);
    if (error == 0) continue;
    if (error > 0.1) continue;
    //    if (scale > 0 || scale < -.20) continue;
    if (TMath::Abs(scale) > 0.50) continue;
    gain->ScaleFactor = TMath::Exp(-(scale-params[0]));
    gain->ErrorScaleFactor = error;
    Double_t dt    = hist->GetBinLowEdge(i);
    UInt_t   date  = dt;
    TDatime  time; time.Set(date);
    printf("bin: %i date: %i Date: %i Time: %i\n",i,date,time.GetDate(),time.GetTime());
    sprintf(filename,"./StarDb/Calibrations/tpc/%s.%08d.%06d.C",TabNam,time.GetDate(),time.GetTime());
    printf("Create %s\n",filename);
    TString dirname = gSystem->DirName(filename);
    if (gSystem->OpenDirectory(dirname.Data())==0) { 
      if (gSystem->mkdir(dirname.Data())) {
	cout << "Directory " << dirname << " creation failed" << endl;
	cout << "Putting " << TabNam << ".C in current directory" << endl;
	for (int i=0;i<80;i++){filename[i]=0;}
	sprintf(filename,"%s.%08d.%06d.C",TabNam.time.GetDate(),time.GetTime());
      }
    }
    ofstream *out = new ofstream(filename);
    timegain->SavePrimitive(*out,"");
    delete out;
    //    break;
  }
}
//________________________________________________________________________________
void FitF(TH2 *hist=0, TF1 *ga=0) {
  if (!hist || !ga) return;
  Int_t nx = hist->GetNbinsX();
  TH1 *proj = 0;
  TCanvas *c = new TCanvas("Fit");
  TString name(hist->GetName());
  name += "MuFG";
  Int_t nBins = hist->GetXaxis()->GetNbins();
  Double_t xlow = hist->GetXaxis()->GetXmin();
  Double_t xup  = hist->GetXaxis()->GetXmax();
  TH1D *MuF = new TH1D(name.Data(),"Avarage shift versus no. of measurement points",
		       nBins,  xlow, xup);
  name = hist->GetName();
  name += "SigmaFG";
  TH1D *SigmaF = new TH1D(name.Data(),"Sigma of z versus no. of measurement points",
		       nBins,  xlow, xup);
  N = 0;
  Double_t chisq = -999;
  for (int i=1; i<=nBins; i++) {
    if (proj) delete proj;
    proj = hist->ProjectionY("proj",i,i);
    X[N] = hist->GetXaxis()->GetBinCenter(i);
    dX[N] = hist->GetXaxis()->GetBinWidth(i);
    if (proj->Integral() < 1000) {
      if (N>0) goto NEXT;
      continue;
    }
    ga->SetParameter(0,1.e6);
    ga->SetParameter(1,0.);
    //    ga->SetParLimits(1,-.1e-9,.1e-9);
    ga->SetParameter(2,0.);
    //    ga->SetParLimits(2,-.1e-9,.1e-9);
#if 0
    ga->SetParameter(1,1.e-9);
    ga->SetParLimits(1,1.e-9,1.e-9);
    //#else
    ga->SetParameter(2,1.);
    ga->SetParLimits(2,1.,1.);
#endif
    ga->SetParameter(3,X[N]);
    ga->SetParLimits(3,X[N],X[N]);
    proj->Fit(ga->GetName(),"R");
    Mu[N]  = ga->GetParameter(1);
    dMu[N] = ga->GetParError(1);///Mu[N];
    //    Mu[N] = TMath::Log(Mu[N]);
    Sigma[N]  = ga->GetParameter(2);
    dSigma[N] = ga->GetParError(2);
    chisq = ga->GetChisquare();
    MuF->SetCellContent(i,0,Mu[N]);
    MuF->SetCellError(i,0,dMu[N]);
    SigmaF->SetCellContent(i,0,Sigma[N]);
    SigmaF->SetCellError(i,0,dSigma[N]);
    proj->Draw(); c->Update();
    printf("Bin: %i x: %f +/- %f MuF: %f+/-%f Sigma: %f+/-%f chisq: %f \n",
	   N,X[N],dX[N],Mu[N],dMu[N],Sigma[N],dSigma[N],chisq);
 NEXT:   
    N++;  
  }
}
//________________________________________________________________________________
void MakeProjY(TH2 *hist, UInt_t ls=0) {
  if (! hist) {printf("Missing hist\n"); return;}
  if (ls > 1) {printf("Illegal ls = %i\n",ls); return;}
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  TString name(hist->GetName());
  static Double_t ShapeMu[2][3] = {
    {-2.32656e-01, 7.63952e-02, 6.59020e-03},
    {-3.75038e-01, 1.28860e-01,-6.93063e-02}
  };
  static Double_t ShapeSigma[2][3] = {
    { 6.41952e-01,-2.19547e-01, 9.63439e-03},
    { 8.29636e-01,-3.71708e-01, 8.65136e-02}
  };
  name += "pY";
  TH1D *h = new TH1D(name.Data(),hist->GetTitle(),ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  for (int i=1;i<=nx;i++){
    Double_t x = hist->GetXaxis()->GetBinCenter(i);
    Double_t yy   = ShapeMu[ls][0] + x*(ShapeMu[ls][1] + x*ShapeMu[ls][2]);
    Double_t dy   = ShapeSigma[ls][0] + x*(ShapeSigma[ls][1] + x*ShapeSigma[ls][2]);
    for (int j=1;j<=ny;j++){
      Double_t y = hist->GetYaxis()->GetBinCenter(j);
      h->Fill((y-yy)/dy,hist->GetCellContent(i,j));
    }
  }
}
//________________________________________________________________________________
void badRun(TH1 *hist, Double_t ymin = -0.2, Double_t ymax = 0.) {
  if (! hist) return;
  Int_t nx = hist->GetNbinsX();
  TDatime t;
  for (Int_t i=1; i<=nx; i++) {
    Double_t y = hist->GetBinContent(i);
    if (y < ymin || y > ymax) {
      UInt_t d = (UInt_t) hist->GetBinLowEdge(i);
      t.Set(d);
      cout << "Wrong scale =" << y << " Date " <<  t.AsSQLString() 
	   << " Date : " << t.AsString() << endl;
    }
  }
}
//____________________________________
Double_t bdEdx(Double_t *xx, Double_t *par) {
  Double_t zz = TMath::Log(xx[0]);
  Double_t x = par[0]; // log10bg
  Double_t y = par[1]; // log2dx
  Double_t zprob = gBichsel->GetMostProbableZ(x,y)-5.07402529167365057e-01;
  Double_t sigma = gBichsel->GetRmsZ(x,y);
  Double_t z = (zz - zprob)/sigma;
  return gBichsel->GetProbability(x,y,z)/xx[0]/sigma;
}
//____________________________________
Double_t bFunc(Double_t *xx, Double_t *par) {
  Double_t z = xx[0];
  Double_t x = par[0];
  Double_t y = par[1];
  return gBichsel->GetProbability(x,y,z);
}
//____________________________________
Double_t bFuncPA(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return TMath::Exp(gBichsel->GetMostProbableZ(x,y));
}
//____________________________________
Double_t bFuncP(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return gBichsel->GetMostProbableZ(x,y);
}
//____________________________________
Double_t bFuncA(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return TMath::Exp(gBichsel->GetAverageZ(x,y));
}
//____________________________________
Double_t bFunc70(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return gBichsel->GetI70(x,y);
}
//____________________________________
Double_t bFunc60(Double_t *xx, Double_t *par) {
  Double_t x = xx[0];
  Double_t y = par[0];
  return gBichsel->GetI60(x,y);
}
//____________________________________
Double_t fncMip(Double_t *xx, Double_t *par) {
  Z = xx[0];
  Double_t zMostProb = par[0];//gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx) + par[0];
  Double_t sigma     = gBichsel->GetRmsZ(Xlog10bg,Ylog2dx) + par[1];
  //  sigma *= sigma;
  //  sigma += par[1];
  //  sigma = TMath::Sqrt(sigma);
  //  Double_t sigma     = 1. +  par[1];
  Double_t z = (Z - zMostProb)/sigma;
  //  Double_t z  = par[0] + (1. + par[1])*zz;
  //  Double_t Value = gBichsel->GetProbability(Xlog10bg,Ylog2dx,z)/sigma*(1+par[1]);
  Double_t Value = gBichsel->GetProbability(Xlog10bg,Ylog2dx,z)/sigma;
#ifdef PRINT
  cout << "Xlog10bg/Ylog2dx/Z =\t" << Xlog10bg << "/" << Ylog2dx << "/" << Z 
       << "\tzMostProb =\t" << zMostProb
       << "\tsigma = \t" << sigma
       << "\tValue = \t" << Value << endl;
#endif
  return Value;
}
//____________________________________
Double_t fncMipX(Double_t *xx, Double_t *par) {//  modify dx
  Z = xx[0];
  Double_t dx = pow(2.,Ylog2dx);
  Double_t dX = dx + par[0];
  if (dX < 0.1) dX = 0.1;
  Double_t ylog2dx = TMath::Log2(dX);
  Double_t zMostProb = 
    gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx) - 
    gBichsel->GetMostProbableZ(Xlog10bg,ylog2dx);
  Double_t sigma     = gBichsel->GetRmsZ(Xlog10bg,ylog2dx);
  Double_t ZZ = Z - TMath::Log(dX/dx);
  Double_t z = (ZZ - zMostProb)/sigma;
  Double_t Value = gBichsel->GetProbability(Xlog10bg,ylog2dx,z)/sigma;
#ifdef PRINT
  cout << "Xlog10bg/Ylog2dx/Z =\t" << Xlog10bg << "/" << Ylog2dx << "/" << Z 
       << "\tzMostProb =\t" << zMostProb
       << "\tsigma = \t" << sigma
       << "\tValue = \t" << Value << endl;
#endif
  return Value;
}
//____________________________________
void bFitMip(const Int_t iX = 8,const Int_t iY=8) {
  TDirectory *dir = gDirectory; cout << "Directory: " << dir->GetName() << endl;
  if (! gBichsel) {
    gSystem->Load("StBichsel");
    gBichsel = Bichsel::Instance();
  };
  dir->cd(); cout << "Directory: " << gDirectory->GetName() << endl;
  TString name3D("SecRow3Mip");
  canvas = new TCanvas("BinFit","Fit parameters");
  TH3 *hist = (TH3 *) gDirectory->Get(name3D);
  if (!hist) return;
  Int_t nx = hist->GetNbinsX();
  Int_t ny = hist->GetNbinsY();
  Int_t hyp = 0;
  TString tFName("SecRowMipFit");
  tFName += NAMES[hyp];
  tFName += gSystem->BaseName(gDirectory->GetName());
  if (! newf) newf = new TFile(tFName.Data(),"update");
  TNtuple *FitP = (TNtuple *) newf->Get("FitP");
  if (! FitP) {
    FitP = new TNtuple("FitP","Fit results",
		       "i:j:x:y:mean:rms:peak:mu:sigma:p2:emu:esigma:ep2:sum:chisq:prob:hyp:chisqGP:probGP:peakGP:muGP:sigmaGP:a0:a1:a2:a3:a4:a5:Npar");
    FitP->SetMarkerStyle(20);
    FitP->SetLineWidth(2);
  }
  TH2D *p0 = (TH2D *)  newf->Get("p0");
  if (! p0) p0 = new TH2D("p0","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  TH2D *p1 = (TH2D *)  newf->Get("p1");
  if (! p1) p1 = new TH2D("p1","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
#if 0
  TH2D *p2 = (TH2D *)  newf->Get("p2");
  if (! p2) p2 = new TH2D("p2","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
#endif
  TH2D *chisq = (TH2D *)  newf->Get("chisq");
  if (! chisq) chisq = new TH2D("chisq","shift of most probable value",
			  nx,hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),
			  ny,hist->GetYaxis()->GetXmin(),hist->GetYaxis()->GetXmax());
  if (! func) func = new TF1("func",fncMip,hist->GetZaxis()->GetXmin(),hist->GetZaxis()->GetXmax(),2);
  //  if (! func) func = new TF1("func",fncMipX,hist->GetZaxis()->GetXmin(),hist->GetZaxis()->GetXmax(),1);
  //  func->SetParLimits(0,-2.,2.);
  //  func->FixParameter(1,0);
  struct  FitMip_t {
    Float_t i;
    Float_t j;
    Float_t x;
    Float_t y;
    Float_t mean;
    Float_t rms;
    Float_t peak;
    Float_t p0;
    Float_t p1;
    Float_t p2;
    Float_t ep0;
    Float_t ep1;
    Float_t ep2;
    Float_t sum;
    Float_t chisq;
    Float_t prob;
    Float_t hyp;
#if 0
    Float_t chisqGP;
    Float_t probGP;
    Float_t peakGP;
    Float_t muGP;
    Float_t sigmaGP;
    Float_t a0;
    Float_t a1;
    Float_t a2;
    Float_t a3;
    Float_t a4;
    Float_t a5;
#endif
  };
  FitMip_t Fit;
  Double_t params[9];
  Int_t i1 = 1, i2 = nx;  if (iX > 0) {i1 = iX; i2 = iX;}
  Int_t j1 = 1, j2 = ny;  if (iY > 0) {j1 = iY; j2 = iY;}
  TF1 *g = 0;
  for (Int_t i=i1; i<=i2; i++) {
    for (Int_t j=j1; j<=j2; j++) {
      newf->cd();
      TString projName(Form("%s_%i_%i",NAMES[hyp],i,j));
      TH1 *proj = (TH1 *) newf->Get(projName.Data());
      if (! proj) proj = hist->ProjectionZ(projName.Data(),i,i,j,j);
      if (! proj) continue;
      double xx = hist->GetXaxis()->GetBinCenter(i);
      double yy = hist->GetYaxis()->GetBinCenter(j);
      Ylog2dx = yy;
#if 0  
      double dy = hist->GetYaxis()->GetBinWidth(j);
      double b = 7.5;
      if (xx >=14) b = 4;
      Double_t xm = yy + 1./b - 0.5*dy/TMath::TanH(0.5*dy*b);
      Ylog2dx = xm;
#endif
      Double_t sum = proj->Integral();
      memset (&Fit.i, 0, sizeof(Fit));
      Fit.sum = sum;
      Fit.i = i;
      Fit.j = j;
      Fit.mean = proj->GetMean();
      Fit.rms  = proj->GetRMS();
      Fit.x = xx;
      Fit.y = Ylog2dx;
      Int_t Row = (int) xx;
      //      Xlog10bg = TMath::Log10(1.5/0.13956995);
      Xlog10bg = TMath::Log10(0.448/0.14);
      if (sum < 1.e2) {delete proj; continue;}
      cout << "Projection:\t" 
	   << proj->GetName() 
	   << "\ti/j\t" << i << "/" << j 
	   << "\tXlog10bg/Ylog2dx\t" << Row << "/" << Ylog2dx 
	   << "\tRow/dx\t" << Row << "/" << pow(2.,Ylog2dx) << "/" << pow(2.,yy) 
	   << "\tIntegral = \t" << sum << endl;
      proj->SetTitle(Form("Row = %i dx = %6.2f", Row, pow(2.,Ylog2dx)));
      Double_t bw = proj->GetBinWidth(1);
      Int_t nb = proj->GetNbinsX();
      Int_t l1 = 999, l2 = 0;
      for (int l=1; l<=nb; l++) {
	Double_t val = proj->GetBinContent(l);
	val = val/sum;
	Double_t err = TMath::Sqrt(val*(1.-val)/2./sum);
	proj->SetBinContent(l,val/bw);
	proj->SetBinError(l,err/bw);
	if (val <= 0.0) continue;
	if (l < l1 ) l1 = l;
	l2 = l;
      }
      if (l1 < l2) proj->GetXaxis()->SetRange(l1,l2);
      //      sum *= proj->GetBinWidth(1);
      //      proj->Scale(1./sum);
      Int_t lx = proj->GetMaximumBin();
      Fit.peak = proj->GetBinCenter(lx);
//       func->FixParameter(0,params[0]);
//       func->FixParameter(1,params[1]);
#if 0
      g = FitGP(proj,"r");
      g->GetParameters(params);
      Fit.Npar  = g->GetNpar();
      Fit.chisqGP = g->GetChisquare();
      Fit.probGP  = g->GetProb();
      Fit.peakGP  = params[0];
      Fit.muGP    = params[1];
      Fit.sigmaGP = params[2];
      Fit.a0  = params[3];
      Fit.a1  = params[4];
      Fit.a2  = params[5];
      Fit.a3  = params[6];
      Fit.a4  = params[7];
      Fit.a5  = params[8];
#endif
      params[0] =  0; // - gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx);
      params[1] =  0;
      func->SetParameters(params);
      proj->Fit("func","+em");
      //      proj->Fit("func","lm");
      Fit.p0 = func->GetParameter(0);
      Fit.ep0 = func->GetParError(0);
      p0->SetBinContent(i,j,func->GetParameter(0));
      p0->SetBinError(i,j,func->GetParError(0));
      Fit.p1 = func->GetParameter(1);
      Fit.ep1 = func->GetParError(1);
      p1->SetBinContent(i,j,func->GetParameter(1));
      p1->SetBinError(i,j,func->GetParError(1));
      Fit.Npar  = g->GetNpar();
      Fit.chisq = func->GetChisquare();
      chisq->SetBinContent(i,j,func->GetChisquare());
      Fit.prob = func->GetProb();
      Fit.hyp = hyp;
      FitP->Fill(&Fit.i);
      proj->Draw();
      if (canvas) canvas->Update();
      Double_t zz = 0.1303 + gBichsel->GetMostProbableZ(Xlog10bg,Ylog2dx);
      func->Eval(zz);
    }
  }  
  if (iX == 0 && iY == 0) {  newf->cd(); newf->Write(); delete newf;}
}
//________________________________________________________________________________
void MakeTable(St_tpcFeeGainCor *gain) {
  if (!gain) return;
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  //  Char_t *Nmean = "mean";
  Char_t *Nmean = "mu";
  TH2D *mean = (TH2D *) fRootFile->Get(Nmean);
  if (!mean) {printf("Cannot histogram %s\n",Nmean); return;}
  TH2D *entries = (TH2D *) fRootFile->Get("entries");
  if (!entries) {printf("Cannot histogram entries\n"); return;}
  TH2D *chisq = (TH2D *) fRootFile->Get("chisq");
  if (!chisq) {printf("Cannot histogram chisq\n"); return;}
  TH2D *sigma = (TH2D *) fRootFile->Get("sigma");
  if (!sigma) {printf("Cannot histogram sigma\n"); return;}

  Int_t nx = mean->GetNbinsX(); printf ("nx = %i\n",nx);
  Int_t ny = mean->GetNbinsY(); printf ("ny = %i\n",ny);
  for (int i=1;i<=nx;i++){
    tpcFeeGainCor_st row; memset(&row,0,gain->GetRowSize());
    for (int j=1;j<=ny;j++){
      Double_t res = -1;
      if (entries->GetCellContent(i,j) > 0.5e3) {
	if (sigma->GetCellContent(i,j) > 0.2) {
	  Double_t d = mean->GetCellContent(i,j);
	  if (d > -0.5 && d < 0.5) res = TMath::Exp(-d);
	  else printf("d: %f i:%i j:%i\n",d,i,j);
	}
	else printf("entires:%f sigma:%f i:%i j:%i\n"
		    ,entries->GetCellContent(i,j),sigma->GetCellContent(i,j),i,j);
      }
      int fee = (j-1)/2;
      int eo  = (j-1)%2;
      row.Gain[fee][eo] = res;
    }
    gain->AddAt(&row,i-1);
  }
}
//________________________________________________________________________________
void FillTable() {
  TFile *fRootFile = (TFile *) gDirectory->GetFile();
  if (! fRootFile ) {printf("Cannot find/open %s",fRootFile->GetName()); return;}
  Char_t *Nmean = "mu";
  TH2D *mean = (TH2D *) fRootFile->Get(Nmean);
  if (!mean) {printf("Cannot histogram %s\n",Nmean); return;}
  TH2D *entries = (TH2D *) fRootFile->Get("entries");
  if (!entries) {printf("Cannot histogram entries\n"); return;}
  TH2D *chisq = (TH2D *) fRootFile->Get("chisq");
  if (!chisq) {printf("Cannot histogram chisq\n"); return;}

  Int_t nx = mean->GetNbinsX(); printf ("nx = %i\n",nx);
  Int_t ny = mean->GetNbinsY(); printf ("ny = %i\n",ny);
  TString NewFile("Correction_");
  NewFile += fRootFile->GetName();
  NewFile->ReplaceAll(".root",".h");
  FILE *fp = fopen(NewFile.Data(),"w");
  fprintf(fp,"static Double_t correction[%i][%i] = {// %s %s\n",
	  ny,nx,mean->GetName(),mean->GetTitle());
  for (int j=1;j<=ny;j++){
    fprintf(fp,"{");
    for (int i=1;i<=nx;i++){
      Double_t res = -1;
      if (entries->GetCellContent(i,j) > 0.7e4 && 
	  chisq->GetCellContent(i,j)>0 && 
	  chisq->GetCellContent(i,j)<2e3
	  ) {
	res = TMath::Exp(-mean->GetCellContent(i,j));
      }
      if(i != 1)  fprintf(fp,",");
      fprintf(fp,"%6.3f",res);
      if (i==12) fprintf(fp,"\n");
    }
    fprintf(fp,"},  // fee%i\n",j);
  }
  fprintf(fp,"};\n");
  fclose(fp);
}
//________________________________________________________________________________
void Make2Dproj(TH2D *h, Int_t N = 100, Double_t xlow = -1., Double_t xup = 1.) {
  if (!h) return;
  Int_t nx = h->GetNbinsX();
  Int_t ny = h->GetNbinsY();
  TString name(h->GetName());
  name += "_P";
  TH1D *hist = new TH1D(name.Data(),h->GetTitle(),N,xlow,xup);
  for (int i = 1; i<=nx;i++) {
    for (int j = 1; j <= ny; j++){
      if (TMath::Abs(h->GetCellContent(i,j)) < 0.01) continue;
      hist->Fill(h->GetCellContent(i,j));
    }
  }
}
#endif /* PLUSHIKIN */
//#define DEBUG
//________________________________________________________________________________
TList *ListOfKeys() {
  TList *list = 0;
  TSeqCollection *files = gROOT->GetListOfFiles();
  TIter next(files);
  TFile *f = 0;
  while ((f = (TFile *) next())) {
    f->cd();
    list = f->GetListOfKeys();
    break;
  }
  return list;
}
//________________________________________________________________________________
TH1 *FindHistograms(const Char_t *Name, const Char_t *fit = "") {
  TH1 *hist = 0;
#ifdef DEBUG
  cout << "FindHistograms(\"" << Name << "\",\"" << fit << "\")" << endl;
#endif  
  TSeqCollection *files = gROOT->GetListOfFiles();
  TIter next(files);
  TFile *f = 0;
  TString Fit(fit);
  if (Fit != "") {
    while ((f = (TFile *) next())) {
#ifdef DEBUG
      cout << "look in " << f->GetName() << endl;
#endif
      TString fName(gSystem->BaseName(f->GetName()));
      if (fName.BeginsWith(Name)) {
	hist = (TH1 *) f->Get(fit);
#ifdef DEBUG
	if (hist) cout << "Found histogram " << hist->GetName() << " in file " << f->GetName() << endl;
#endif
	return hist;
      }
    }
  } else {
    while ((f = (TFile *) next())) {
      f->cd();
#ifdef DEBUG
      cout << "look in " << f->GetName() << endl;
#endif
      hist = (TH1 *) f->Get(Name);
      if (hist) {
#ifdef DEBUG
	cout << "Found histogram " << hist->GetName() << " in file " << f->GetName() << endl;
#endif
	return hist;
      }
    }
  }
  return hist;
}
//________________________________________________________________________________
void DrawSummary0(TFile *f, const Char_t *opt) {
  if (! f) return;
  gStyle->SetTimeOffset(788936400);
  f->cd();
  TList *keys = f->GetListOfKeys();
  if (! keys) return;
  keys->Sort();
  TIter next(keys);
  TKey *key = 0;
  TObjArray hists;
  TString Opt(opt);
  TString Title;
  TF1 *powfit = new TF1("powfit","[0]*pow(x,[1])",40,80);
  powfit->SetParameters(0.5,-0.5);
  while ((key = (TKey *) next())) {
    TH1 *hist  = FindHistograms(key->GetName());
    if (! hist) continue;
    if (hist->GetEntries() < 1) continue;
    if (Opt != "") {
      TString name(hist->GetName());
      if (! name.Contains(Opt.Data())) continue;
    }
    hists.AddLast(hist);
    TString hName(hist->GetName());
    if ((( hist->IsA()->InheritsFrom( "TH3C" )   ||
	   hist->IsA()->InheritsFrom( "TH3S" ) 	 ||
	   hist->IsA()->InheritsFrom( "TH3I" ) 	 ||
	   hist->IsA()->InheritsFrom( "TH3F" ) 	 ||
	   hist->IsA()->InheritsFrom( "TH3D" ) ) || 
	 ( hist->IsA()->InheritsFrom( "TH2C" )   ||
	   hist->IsA()->InheritsFrom( "TH2S" ) 	 ||
	   hist->IsA()->InheritsFrom( "TH2I" ) 	 ||
	   hist->IsA()->InheritsFrom( "TH2F" ) 	 ||
	   hist->IsA()->InheritsFrom( "TH2D" ) ))&& 
	 ( ! (hName.BeginsWith("Points") || hName.BeginsWith("TPoints") || hName.BeginsWith("MPoints")) ) ) {
      TH1 *mu    = FindHistograms(key->GetName(),"mu");
      if (! mu) continue;
      mu->SetName(Form("%s_mu",hist->GetName()));
      hists.AddLast(mu);
      TH1 *sigma = FindHistograms(key->GetName(),"sigma");
      if (! sigma) continue;
      sigma->SetName(Form("%s_sigma",hist->GetName()));
      hists.AddLast(sigma);
    }
  }
  Int_t N = hists.GetEntriesFast();
  Int_t nx = (Int_t) (TMath::Sqrt(N));
  if (nx*nx < N) nx++;
  Int_t ny = N/nx;
  if (nx*ny < N) ny++;
  cout << "N " << N << " nx " << nx << " ny " << ny << endl;
  TString Tag(gSystem->BaseName(f->GetName()));
  Tag.ReplaceAll(".root","");
  Tag += opt;
  //  TCanvas *c1 = new TCanvas(Tag,Tag,200,10,700,780);
  Double_t dx = 0.98/nx;
  Double_t dy = 0.98/ny;
  TObjArray pads(N);
  for (Int_t iy = 0; iy < ny; iy++) {
    for (Int_t ix = 0; ix < nx; ix++) {
      Int_t i = ix + nx*iy;
      if (i >= N) continue;
      TH1 *hist = (TH1 *) hists[i];
      if (! hist) continue;
      Double_t x1 = 0.01 + dx* ix;
      Double_t x2 = 0.01 + dx*(ix+1);
      Double_t y1 = 0.99 - dy*(iy+1);
      Double_t y2 = 0.99 - dy* iy;
      TPad *pad = new TPad(Form("pad_%s",hist->GetName()),hist->GetTitle(),x1,y1,x2,y2);
      //      cout << "Create pad " << pad->GetName() << "/" << pad->GetTitle() << endl;
      pad->Draw();
      pads.AddLast(pad);
    }
  }
  for (Int_t iy = 0; iy < ny; iy++) {
    for (Int_t ix = 0; ix < nx; ix++) {
      Int_t i = ix + nx*iy;
      if (i >= N) continue;
      TH1 *hist = (TH1 *) hists[i];
      if (! hist) continue;
      TPad *pad = (TPad *) pads[i];
      if (! pad) continue;
      pad->cd();
      TProfile *prof = 0;
      if ( hist->IsA()->InheritsFrom( "TProfile" ) ) prof = (TProfile *) hist;
      Int_t NbinsX = hist->GetNbinsX();
      Int_t xmin =  NbinsX;
      Int_t xmax =  0;
      Double_t ymin =  1e9;
      Double_t ymax = -1e9;
      //      cout << "Draw pad " << pad->GetName() << "/" << pad->GetTitle() << "\t x " << ix << " y " << iy << endl;
      //3D
      if ( hist->IsA()->InheritsFrom( "TH3C" ) ||
	   hist->IsA()->InheritsFrom( "TH3S" ) ||
	   hist->IsA()->InheritsFrom( "TH3I" ) ||
	   hist->IsA()->InheritsFrom( "TH3F" ) ||
	   hist->IsA()->InheritsFrom( "TH3D" ) ) {
	((TH3 *)hist)->Project3DProfile("xy")->Draw("colz");
	goto TIMEAxis;
      }
      //2D
      if ( hist->IsA()->InheritsFrom( "TH2C" ) ||
	   hist->IsA()->InheritsFrom( "TH2S" ) ||
	   hist->IsA()->InheritsFrom( "TH2I" ) ||
	   hist->IsA()->InheritsFrom( "TH2F" ) ||
	   hist->IsA()->InheritsFrom( "TH2D" ) ) {
	if (hist->GetMaximum() > 0 && hist->GetMinimum() >= 0) pad->SetLogz(1);
	TString hName(hist->GetName());
	if (hName.BeginsWith("Points") || hName.BeginsWith("TPoints") || hName.BeginsWith("MPoints")) {
	  Title = hist->GetTitle();
	  Title.ReplaceAll("/sigma","");
	  hist->SetTitle(Title);
	  TAxis *y = hist->GetYaxis();
	  Int_t iy1 = y->FindBin(-0.15);
	  Int_t iy2 = y->FindBin( 0.50);
	  y->SetRange(iy1,iy2);
	  ((TH2 *)hist)->Draw("colz");
	  TH1 *mu    = FindHistograms(hist->GetName(),"mu");
	  if (! mu) goto TIMEAxis;
	  mu->SetMarkerColor(1);
	  mu->SetMarkerStyle(20);
	  mu->Draw("same");
	  mu->Fit("pol0","e0r","",10,120);
	  TLegend *leg = new TLegend(0.25,0.6,0.9,0.9,"");
	  TF1 *f = mu->GetFunction("pol0");
	  if (f) {
	    f->Draw("same");
	    Title = Form("#mu  = %5.2f +/- %5.2f %\%",100*f->GetParameter(0),100*f->GetParError(0));
	    cout << Title << endl;
	    leg->AddEntry(mu,Title.Data());
	  }
	  TH1 *sigma = FindHistograms(hist->GetName(),"sigma");
	  if (! sigma) goto TIMEAxis;
	  sigma->SetMarkerColor(1);
	  sigma->SetMarkerStyle(21);
	  sigma->Draw("same");
	  sigma->Fit(powfit,"r0");
	  f = sigma->GetFunction("powfit");
	  if (f) {
	    f->Draw("same");
	    Title = Form("#sigma(@76cm) = %5.2f%\%",100*f->Eval(76));
	    cout << Title << endl;
	    leg->AddEntry(sigma,Title.Data());
	  }
	  leg->Draw();
	} else hist->Draw("colz");
	goto TIMEAxis;
      }
      //1D + Prof
      NbinsX = hist->GetNbinsX();
      xmin =  NbinsX;
      xmax =  0;
      ymin =  1e9;
      ymax = -1e9;
      for (Int_t i = 1; i <= NbinsX; i++) {
	Double_t y = hist->GetBinContent(i);
	if ((prof && prof->GetBinEntries(i)) || y > 0) {
	  Int_t x = i;
	  xmin = TMath::Min(xmin,x);
	  xmax = TMath::Max(xmax,x);
	  ymin = TMath::Min(ymin,y);
	  ymax = TMath::Max(ymax,y);
	}
      }
      if (ymin < ymax) {
	hist->SetMaximum(1.1*ymax);
	hist->SetMinimum(0.9*ymin);
	//	  cout << "Set min/max for " << hist->GetName() << "\t" << hist->GetMinimum() << "/" <<  hist->GetMaximum() << endl;
      }
      if (xmin < xmax) hist->GetXaxis()->SetRange(xmin,xmax);
      hist->Draw();
    TIMEAxis:
      TAxis *xax = hist->GetXaxis();
      if (xax->GetBinLowEdge(1) > 1e6) {
	xax->SetTimeDisplay(1);
	gPad->Modified();
      }
    } 
  }
}
//________________________________________________________________________________
void DrawSummary(const Char_t *opt="") {
  TSeqCollection *files = gROOT->GetListOfFiles();
  TIter next(files);
  TFile *f = 0;
  TString FName("");
  while ((f = (TFile *) next())) {
    FName = gSystem->BaseName(f->GetName());
    if (FName.BeginsWith("Hist")) break;
  }
  if (! f) {
    cout << "Hist* root file has not been found" << endl;
    return;
  }
  DrawSummary0(f,opt);
}
