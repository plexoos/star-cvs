#include <stdio.h>
#include <iostream>
#include <fstream>
#include "TSystem.h"
#include "TMath.h"
#include "TFile.h"
#include "TTree.h"
#include "TH1.h"
#include "TF1.h"
#include "TCanvas.h"
#include "TGraph.h"
#include "TCernLib.h"
#include "TMatrixD.h"
#include "TRandom.h"
#include "TVectorD.h"
#include "TVector2.h"
#include "TVector3.h"
#include "TTreeIter.h"
#include "TTable.h"
#include "TInterpreter.h"
#include "TMinuit.h"
#include "StvUtil/StvHitErrCalculator.h"
#include <vector>
//______________________________________________________________________________
class FEEvent;
class StvHitErrCalculator;
class StvTpcHitErrCalculator;
int StvFitErr(const char *file="pulls.root");

#if !defined(__MAKECINT__)
enum {kMaxPars = StvHitErrCalculator::kMaxPars};
TMatrixD T(TMatrixD a) { TMatrixD mx(a); return mx.T();}


//______________________________________________________________________________
class FERead : public TNamed
{
public:
FERead(const char *file);
FEEvent *ReadEvent();
private:
TTreeIter *mTreeIter;
FEEvent   *mEvent;
};

//______________________________________________________________________________
class Poli2 {
public:
Poli2(int npw=1);
Poli2(int npw,int n,const double *X,const double *Y,const double *W);
double Fit();
void Clear();
void Add(double x, double y, double w);
double Xi2() const  			{return fXi2;}
double LiH() const  			{return fXi2-fLiH;}
double Xi2(int ipt) const; 		
double Res2(int ipt) const; 		
double EvalXi2() const; 		
int    Pw()  const 			{return fPw ;}
int    NPt() const 			{return fN  ;}
double Fun( double x ) const;
double dXi2dW( int ipt ) const;
double d2Xi2dW( int k, int l ) const;
double dLiHdW( int ipt ) const;
double d2LiHdW( int kpt ,int lpt) const;
double Deriv( TVectorD &Di ) const;
double D2riv( TMatrixD &Dik) const;
void   TestIt() const;
void   MyTest() const;
static void Test();
static void Test2();
private:
int fPw;
char   fBeg[1];
int    fN;
double fX[100];
double fY[100];
double fW[100];
double fXi2;
double fLiH;
double fX0,fY0;
char   fEnd[1];
TVectorD fP;
TVectorD fB;
TMatrixD fA;
TMatrixD fAi;
}; 


//______________________________________________________________________________
class FEEvent 
{
public:
  FEEvent(TTreeIter &th);
  int NextTrack(int &jr);
 void Reset() {mLTrack=0;mRTrack=-1;}
public:
int mLTrack,mRTrack;
const   int &run;
const   int &evt;
const   int   &nGHits;
const   float *&mCurv;
const   float *&mPt;
const   short *&mTrackNumber;
const unsigned char *&nAllHits; 	//number of all hits in track
const unsigned char *&nTpcHits; 	//number of tpc hits in track
const unsigned char *&nFtpcHits; 	//number of ftpc hits in track
const unsigned char *&nSsdHits; 	//number of ssd hits in track
const unsigned char *&nRndHits; 	//number of RND hits in track
const unsigned char *&mDetector;	
const   float *&lYHit;
const   float *&lZHit;
const   float *&lLen;
const   float *&gPhiHP;			//  phi    of normal vector of hit plane in global Stv frame
const   float *&gLamHP;			//  lambda of normal vector of hit plane in global Stv frame
const   float *&gPsi;
const   float *&gDip;
const   float *&gRFit;
const   float *&gPFit;
const   float *&gZFit;
};
//______________________________________________________________________________
class FECalcHolder
{
public:
  FECalcHolder(int id,StvHitErrCalculator* calc,const double miMax[2][2]);	
        StvHitErrCalculator *GetCalc() const 		{return mCalc;} 
virtual StvHitErrCalculator *GetCalc(const float x[3])  {if(x){};return mCalc;} 
  int GetId() {return mId;}
 void SetOffset(int off) 	{mOffset=off;}
  int GetOffset() const  	{return mOffset;}
  int GetNPars()  const   	{return mCalc->GetNPars();}
const double *GetPars() const   {return mCalc->GetPars() ;}
const char   *GetName() const   {return mCalc->GetName() ;}
 void Update(const double *a);
 void DbLoad();
 void DbSave();

 void AvInit();
 void AvAdd(const double hRR[3]);
 void AvEnd();

private:
char    mBeg[1];
TTable *mTab;
int mId;
int mOffset;
public:
double mAve[5];
double mAveDer[kMaxPars][3];
double mMiMax[2][2];
StvHitErrCalculator* mCalc;
char    mEnd[1];
};

//______________________________________________________________________________
class FETpcCalcHolder: public FECalcHolder
{
public:
  FETpcCalcHolder(StvHitErrCalculator* calc,const double miMax[2][2])
                 :FECalcHolder(1,calc,miMax){;}
virtual StvHitErrCalculator *GetCalc(const float x[3]);
};


//______________________________________________________________________________
class FENode
{
public:
float  tkDir[3];
float  hiPos[3];
float  hiDir[3][3];
float  s; 
float  yz[2]; 
float  detId;
};
//______________________________________________________________________________
class FETrak
{
public:
int    GetNWords() const 		{return int(mNWords);}
int    GetNNodes() const 		{return (sizeof(float)*(GetNWords()-1))/sizeof(FENode);}
const FENode *GetNode(int idx) const	{return mNodes+idx;}
FETrak *Next()     const 		{float *f=(float*)this+GetNWords();
                           	 	 return (*f)? (FETrak*)f:0;}
private:
float mNWords;
FENode mNodes[1];
};
//______________________________________________________________________________
class FEFcn 
{
public:
    FEFcn();
    void Clear();
    void Add(FECalcHolder *holder);
    void DbLoad();
    void DbSave();
     int Add(FEEvent *event);
    void End()	{mTks.push_back(0.);}

    void InitFitter();
    void ResetFitter();
    int GetNPars() const 		{return mNPars;}
double* GetPars()       		{return mPars ;}
    int GetNFixd() const 		{return mNFixd;}
   void Update(const double *upd);
const FETrak* GetTrak()  	        {return (FETrak*)&mTks[0];}
FECalcHolder *GetCalc(int id,const float hiPos[3]);
   void  Eval(int  npar, double* grad, double& fval, double* par, int flag);
   void  FixPar(int iPar,int fix=1);
    int  IsFixed(int iPar) const 	{return mFix[iPar];}
    int  Fit();
   void  AvErr(const char *tit);

static  void Fcn(int &npar, double* grad, double& fval, double* par, int flag);


private:
char mFix[400];
int  mNPars;
int  mNFixd;
int  mNEvs;
int  mNTks;
int  mNHits;
int  mN00;
int  mNCall;
double mPars[100];
double mVal00;
char mEnd[1];
std::vector<FECalcHolder*> 	mCas;
std::vector<float> 		mTks;
static FEFcn *mgInst;
};

//______________________________________________________________________________
class FEApprox 
{
public:
    FEApprox(FEFcn *fefcn);
int Prepare();
int Quadr();
int Approx();
int Test();
private:
FEFcn *mFcn;
int mNPars;
TMatrixD mG,mGi,mC;
TVectorD mB,mP,mPrev,mClo,mIclo,mCup,mIcup;
double mXi2;
};
FEFcn *FEFcn::mgInst=0;

//______________________________________________________________________________
//______________________________________________________________________________
//______________________________________________________________________________
void CalcInit();
FEFcn myFcn;
TMinuit myFitter(100);
//______________________________________________________________________________
int StvFitErr(const char *file)
{

  printf("StvFitErr(%s) started",file);

  CalcInit();
  myFcn.DbLoad();
  myFcn.InitFitter();
  
  FERead input(file);
  int nEv=0;
  FEEvent *ev=0;
  int eot=0;
  while ((ev=input.ReadEvent()))
  {
//    printf ("Event %d\n",nEv);
    nEv++; eot = myFcn.Add(ev);
    if (eot) break;
  }
  printf ("StvFitErr: %d Events used\n",nEv);
  myFcn.End();
  FEApprox app(&myFcn);
  myFcn.AvErr("Before Fit");
  int ans =0;
  app.Test(); return 0;
  ans = app.Approx();
//  myFcn.ResetFitter();
//  ans = myFcn.Fit();
  myFcn.AvErr("After Fit");
  myFcn.DbSave();
  return (!ans)? 99:0;
}
//______________________________________________________________________________
void CalcInit()
{
   const char*  innOutNames[2]  ={"StvTpcInnerHitErrs"    ,"StvTpcOuterHitErrs"    };

   const double innOutPars[2][6]={{0.047,0.107,5e-5,1./12,0.0011, 0.0012}
                                 ,{0.035,0.077,5e-5,1./12,0.0011, 0.0012}};
   double TpcMiMax[2][2][2]={{{0.05,0.2},{0.05,0.2}},{{0.05,0.2},{0.05,0.2}}};


  myFcn.Clear();
  for (int io=0;io<2;io++) {
    StvHitErrCalculator *hec = new StvTpcHitErrCalculator(innOutNames[io]);
    hec->SetPars(innOutPars[io]);
    FECalcHolder *hold= new FETpcCalcHolder(hec,TpcMiMax[io]);
    myFcn.Add(hold);
  }
}
//______________________________________________________________________________
//______________________________________________________________________________
//______________________________________________________________________________
//______________________________________________________________________________


//______________________________________________________________________________
//______________________________________________________________________________
//______________________________________________________________________________
//______________________________________________________________________________
Poli2::Poli2(int npw):fP(npw+1),fB(npw+1),fA(npw+1,npw+1),fAi(npw+1,npw+1)
{
  fPw = npw;
  Clear();  
  
}
//______________________________________________________________________________
void Poli2::Clear()
{
  memset(fBeg,0,fEnd-fBeg+1);  
}
//______________________________________________________________________________
Poli2::Poli2(int npw,int N,const double *X,const double *Y,const double *W)
:fP(npw+1),fB(npw+1),fA(npw+1,npw+1),fAi(npw+1,npw+1)
{
  fPw = npw;
  Clear();  
  fN = N;
  int nb = N*sizeof(double);
  memcpy(fX,X,nb);
  memcpy(fY,Y,nb);
  memcpy(fW,W,nb);
}
//______________________________________________________________________________
void Poli2::Add(double x, double y, double w)
{ 
  fX[fN]=x; fY[fN]=y, fW[fN]=w; fN++;
  assert(fN<=100);
}
//______________________________________________________________________________
double Poli2::Fit()
{ 
  double Wt=0,Wx=0,Wy=0;
  for (int i=0;i<fN;i++) { Wt += fW[i]; Wx += fW[i]*fX[i];Wy += fW[i]*fY[i];}
  fX0 = Wx/Wt; fY0 = Wy/Wt;
  fX0 = 0; fY0=0;
  for (int i=0;i<fN;i++) { fX[i]-=fX0; fY[i]-=fY0;}

  double A[3][3]={{0}},B[3]={0};
  double x[3]={1};
  fXi2=0;fLiH=0;
  for (int i=0;i<fN;i++) {
    double w = fW[i];
    x[1] = fX[i]; x[2]=x[1]*x[1];
    double y = fY[i],y2=y*y;
    for (int j=0;j<=fPw;j++) { B[j]    +=w*x[j]*y;
    for (int k=0;k<=j  ;k++) { A[j][k] +=w*x[j]*x[k];}}
    fXi2 +=w*y2;
    fLiH += log(w);
  }
  for (int j=0;j<=fPw;j++){ fB[j] = B[j];
  for (int k=0;k<=j  ;k++){ fA(j,k) = A[j][k]; fA(k,j)=A[j][k];}}

  double det=0;
  fAi=fA;fAi.InvertFast(&det);
  fP=fAi*fB;
  fXi2 -= (fB*fP);
  return fXi2;
}
//______________________________________________________________________________
double Poli2::Fun( double x ) const
{
  x -= fX0;
  double xx[3]={1,x,x*x};
  TVectorD XX(fPw+1,xx);
  return fP*XX + fY0;
}
//______________________________________________________________________________
double Poli2::Xi2(int ipt) const
{
   double dy = Fun(fX[ipt]+fX0) - (fY[ipt]+fY0);
   return dy*dy*fW[ipt];
}
//______________________________________________________________________________
double Poli2::Res2(int ipt) const
{
   double dy = Fun(fX[ipt]+fX0) - (fY[ipt]+fY0);
   return dy*dy;
}
//______________________________________________________________________________
double Poli2::EvalXi2() const
{ 
  double sum=0;
  for (int ipt=0;ipt<fN;ipt++) {sum+=Xi2(ipt);}
  return sum;
}
//______________________________________________________________________________
double Poli2::dXi2dW( int ipt ) const
{
//   Xi2 = Y*Y*W -B*Ai*B
//  dXi2/dWk = Yk*Yk - (2*dBk*Ai*B - B*Ai*dAk*Ai*B)
//  dXi2/dWk = Yk*Yk - (2*dBk*Ai*B - P*dAk*P

   double der = fY[ipt]*fY[ipt];
   TVectorD dB(fPw+1);
   TMatrixD dA(fPw+1,fPw+1);
   double x[3]={1,fX[ipt],fX[ipt]*fX[ipt]};
   for (int j=0;j<=fPw;j++) { dB[j] = x[j]*fY[ipt];   
   for (int k=0;k<=fPw;k++) { dA[j][k] = x[j]*x[k]; }}  
   der -= (2*(dB*(fAi*fB))-(fP*(dA*fP)));
   return der;
}
#if 1
//______________________________________________________________________________
double Poli2::d2Xi2dW( int kpt ,int lpt) const
{
//   Xi2 = Y*Y*W -B*Ai*B
// dAI/dWk = - Ai*dAk*Ai
// d2Ai/dWk/dWl = -2* dAIl*dAk*Ai
// d2Ai/dWk/dWl = +2* Ai*dAl*Ai*dAk*Ai

//   dXi2/dWk = Yk*Yk-2dBk*Ai*B -B*dAIk*B
//   d2Xi2/dWk/dWl = -2dBk*Ail*B -2dBk*Ai*dBl-2dBl*dAIk*B-B*dAIkl*B


   double der = 0;
   TVectorD dBk(fPw+1),dBl(fPw+1);
   TMatrixD dAk(fPw+1,fPw+1),dAl(fPw+1,fPw+1);
   {
     double x[3]={1,fX[kpt],fX[kpt]*fX[kpt]};
     for (int j=0;j<=fPw;j++) { dBk[j] = x[j]*fY[kpt];   
     for (int k=0;k<=fPw;k++) { dAk[j][k] = x[j]*x[k]; }}  
   }
   {
     double x[3]={1,fX[lpt],fX[lpt]*fX[lpt]};
     for (int j=0;j<=fPw;j++) { dBl[j] = x[j]*fY[lpt];   
     for (int k=0;k<=fPw;k++) { dAl[j][k] = x[j]*x[k]; }}  
   }




   TMatrixD dAIk(fPw+1,fPw+1),dAIl(fPw+1,fPw+1),dAIkl(fPw+1,fPw+1);
   dAIk = -1.* fAi*dAk*fAi;
   dAIl = -1.* fAi*dAl*fAi;
   dAIkl = 2.* fAi*dAl*fAi*dAk*fAi;
   der = 2.*(dBk*(dAIl*fB) + dBk*(fAi*dBl)+dBl*(dAIk*fB))+fB*(dAIkl*fB);


   return -der;
}
#endif
//______________________________________________________________________________
double Poli2::dLiHdW( int ipt ) const
{
   return dXi2dW(ipt)-1./fW[ipt];
}
//______________________________________________________________________________
double Poli2::d2LiHdW( int kpt ,int lpt) const
{
   double qwe = 0;
   if (kpt==lpt) { qwe = 1./(fW[kpt]*fW[kpt])		;}
   return d2Xi2dW(kpt,lpt)+qwe;
}
//______________________________________________________________________________
//______________________________________________________________________________
double Poli2::Deriv( TVectorD &Di ) const
{
  Di.ResizeTo(fN);
  for (int ipt=0;ipt<fN;ipt++) {
    Di[ipt]= dLiHdW(ipt);
  }
  return fXi2;
}
//______________________________________________________________________________
double Poli2::D2riv( TMatrixD &Dik ) const
{
  Dik.ResizeTo(fN,fN);
  for (int ipt=0;ipt<fN;ipt++) {
    for (int kpt=0;kpt<=ipt;kpt++) {
      double qwe = d2LiHdW(ipt,kpt);
      Dik[ipt][kpt] = qwe; Dik[kpt][ipt] = qwe;}}
  return fXi2;
}

//______________________________________________________________________________
void Poli2::MyTest() const
{
  printf("Print B\n");
  fB.Print();
  printf("Print A\n");
  fA.Print();
  printf("Print Ai\n");
  fAi.Print();
  printf("Print A*Ai\n");
  TMatrixD tst(fPw+1,fPw+1);
  tst = fA*fAi;
  tst.Print();
}
//______________________________________________________________________________
void Poli2::Test()
{
  int npw=2;
  double X[20],Y[20],W[20],YY[20];
  for (int i=0;i<20;i++) {
    X[i]=i;
    Y[i]= 3+X[i]*(.02+.03*X[i]);
    W[i]= 1+10./Y[i];
    YY[i]=Y[i];
    Y[i]+=gRandom->Gaus(0,sqrt(1./W[i]));
  }
  Poli2 pp(npw,20,X,Y,W);
  pp.Fit(); 
//  pp.MyTest();
  double Xi2 = pp.Xi2();
  double Xi2Eva = pp.EvalXi2();
  printf ("Xi2 = %g == %g\n",Xi2,Xi2Eva);
//   for (int i=0; i<20; i++) {
//     printf(" %g %g : %g\n",X[i],YY[i],pp.Fun(X[i]));
//   }
// check d/dW
  printf("\n check d/dWi\n");
  double myDelta = 1e-3,delta,maxDif=0;
  for (int k=0;k<20;k++) {
    Poli2 ppp(npw);
    for (int i=0;i<20;i++) {
      double w = W[i];
      if (i==k) { delta = w*myDelta; w+=delta;}
      ppp.Add(X[i],Y[i],w);
    }
    ppp.Fit();
    double ana = pp.dXi2dW(k);
    double num = (ppp.Xi2()-pp.Xi2())/delta;
    double dif = 2*(num-ana)/(fabs(num+ana)+3e-33);
    if (maxDif<fabs(dif)) maxDif=fabs(dif);
    if (fabs(dif)<1e-3) continue;
    printf ("dXi2dW(%2d) \tana=%g \tnum = %g \tdif=%g\n",k,ana,num,dif);
  }
  printf ("Test dXi2dW(...) maxDif=%g\n",maxDif);
}
//______________________________________________________________________________
void Poli2::Test2()
{
  int npw=2;
  double X[20],Y[20],W[20],YY[20];
  for (int i=0;i<20;i++) {
    X[i]=i;
    Y[i]= 3+X[i]*(.02+.03*X[i]);
    W[i]= 1+10./Y[i];
    YY[i]=Y[i];
    Y[i]+=gRandom->Gaus(0,sqrt(1./W[i]));
  }
  Poli2 pp(npw,20,X,Y,W);
  pp.Fit(); 
//  pp.MyTest();
  TVectorD myDer(20),nyDer(20);
  pp.Deriv(myDer);
  printf("\n check d/dWi\n");
  double myDelta = 1e-3,delta,maxDif=0;
  for (int k=0;k<20;k++) {
    Poli2 ppp(npw);
    for (int i=0;i<20;i++) {
      double w = W[i];
      if (i==k) { delta = w*myDelta; w+=delta;}
      ppp.Add(X[i],Y[i],w);
    }
    ppp.Fit();
    ppp.Deriv(nyDer);
    for (int l=0;l<=k; l++) {

      double ana = 0.5*(pp.d2Xi2dW(k,l)+ppp.d2Xi2dW(k,l));
      double num = (nyDer(l)-myDer(l))/delta;
      double dif = 2*(num-ana)/(fabs(num+ana)+3e-33);
      if (fabs(dif)> maxDif) maxDif =fabs(dif);
      if (fabs(dif)<1e-3) continue;
      printf ("d2Xi2dW(%2d,%2d) \tana=%g \tnum = %g \tdif=%g\n",k,l,ana,num,dif);
    }
  }
  printf ("Test2 d2Xi2dW(...) maxDif=%g\n",maxDif);
  

}
//______________________________________________________________________________
void Poli2::TestIt() const
{
  TVectorD g,gT;
  Poli2 pp(*this);
  pp.Fit(); 
  double Xi2 = pp.Deriv(g);

  double delta = 1e-3;
  for (int k=0;k<fN;k++) {
    double sav = pp.fW[k];
    pp.fW[k]=sav+delta;
    pp.Fit(); 
    double Xi2T = pp.Deriv(gT);
    pp.fW[k]=sav;

    double ana = 0.5*(g[k]+gT[k]);
    double num = (Xi2T-Xi2)/delta;
    double dif = 2*(num-ana)/(fabs(num+ana)+1e-10);
    if (fabs(dif)>0.01)
    printf ("\ndXi2dW(%2d) \tana=%g \tnum = %g \tdif=%g\n\n",k,ana,num,dif);
  }


}
//______________________________________________________________________________
void poli2()
{
Poli2::Test();
Poli2::Test2();
}

//______________________________________________________________________________
FEEvent::FEEvent(TTreeIter &th):
  run 		( th("mRun")),
  evt 		( th("mEvt")),
  nGHits    	( th("mHitsG")),
  mCurv    	( th("mHitsG.mCurv")),
  mPt      	( th("mHitsG.mPt")),
  mTrackNumber 	( th("mHitsG.mTrackNumber")),
  nAllHits 	( th("mHitsG.nAllHits")),
  nTpcHits 	( th("mHitsG.nTpcHits")),
  nFtpcHits 	( th("mHitsG.nFtpcHits")),
  nSsdHits 	( th("mHitsG.nSsdHits")),
  nRndHits 	( th("mHitsG.nRndHits")),
  mDetector 	( th("mHitsG.mDetector")),
  lYHit 	( th("mHitsG.lYHit")),
  lZHit 	( th("mHitsG.lZHit")),
  lLen  	( th("mHitsG.lLen")),
  gPhiHP	( th("mHitsG.gPhiHP")),		
  gLamHP	( th("mHitsG.gLamHP")),
  gPsi  	( th("mHitsG.gPsi")),
  gDip  	( th("mHitsG.gDip")),
  gRFit    	( th("mHitsG.gRFit")),
  gPFit    	( th("mHitsG.gPFit")),
  gZFit    	( th("mHitsG.gZFit"))
{
 mLTrack=0;mRTrack=-1;

}
//______________________________________________________________________________
int FEEvent::NextTrack(int &jr)
{
  mLTrack = mRTrack+1;
  if (mLTrack>=nGHits) { jr=-1; return -1;}
  mRTrack=mLTrack;
  int tkNum= mTrackNumber[mLTrack];
  for (int j=mLTrack+1; j<nGHits && mTrackNumber[j]==tkNum;j++){mRTrack++;}
  jr = mRTrack;
  return mLTrack;
}
//______________________________________________________________________________
FERead::FERead(const char *file): TNamed(file,"")
{
  mTreeIter = new TTreeIter();
  mTreeIter->AddFile(file);
  mEvent = new FEEvent(*mTreeIter);
}
//______________________________________________________________________________
FEEvent* FERead::ReadEvent()
{
  mEvent->Reset();
  int nbytes = mTreeIter->Next();
  if (!nbytes) return 0;
  return mEvent;
}

//______________________________________________________________________________
FECalcHolder::FECalcHolder(int id,StvHitErrCalculator* calc
                          ,const double miMax[2][2])	
{  
  memset(mBeg,0,mEnd-mBeg+1);
  mId=id; mCalc=calc; 
  memcpy(mMiMax[0],miMax[0],sizeof(mMiMax));
}
//______________________________________________________________________________
 void FECalcHolder::Update(const double *a)	
 {
    double b[100];
    int n = mCalc->GetNPars();
    for (int i=0;i<n;i++) {
      b[i]=a[i+mOffset]; if (b[i]<1e-8) b[i]=1e-8;
    }
    mCalc->SetPars(b);
}
//______________________________________________________________________________
void FECalcHolder::DbLoad()
{
  gSystem->Load("libStDb_Tables.so");
  TString dbName(GetName());


  TString dbFile("StarDb/Calibrations/tracker/");
  dbFile += dbName; dbFile += ".C";
  int myN = mCalc->GetNPars();
  if (!gSystem->AccessPathName(dbFile)) {//file exists
    printf("FECalcHolder::DbLoad: %s\n",dbFile.Data());
    TString command (".L "); command += dbFile;
    gInterpreter->ProcessLine(command);
    mTab = (TTable *) gInterpreter->Calc("CreateTable()");
    command.ReplaceAll(".L ",".U "); 
    gInterpreter->ProcessLine(command);
    mCalc->SetPars((double*)mTab->GetArray());}

  else {				//file does not exist
    printf("FECalcHolder::DbLoad: %s NOT FOUND. Default is used)\n",dbFile.Data());
    mTab = (TTable *)gInterpreter->Calc("new St_StvHitErrs(\"someHitError\",1)"); 
    mTab->SetName(dbName);
    mTab->SetUsedRows(1);
    memcpy(mTab->GetArray(),mCalc->GetPars(),myN*sizeof(double));
  }

}
//______________________________________________________________________________
void FECalcHolder::DbSave()
{
  int myN = mCalc->GetNPars();
  memcpy(mTab->GetArray(),mCalc->GetPars(),myN*sizeof(double));
  TString dbFile("StarDb/Calibrations/tracker/");
  dbFile += GetName();
  dbFile += ".C";
  if (!gSystem->AccessPathName(dbFile)) {//file exists
    TString ts(dbFile);
    ts +=".BAK"; gSystem->Rename(dbFile,ts);
  }
  std::ofstream ofs(dbFile);
  mTab->SavePrimitive(ofs);
}
//______________________________________________________________________________
void FECalcHolder::AvInit()
{
   memset(mAve      ,0,sizeof(mAve   ));
   memset(mAveDer[0],0,sizeof(mAveDer));
}
//______________________________________________________________________________
void FECalcHolder::AvAdd(const double hRR[3])
{
  double der[kMaxPars][3];
  mAve[0]++;
  mAve[1]+=hRR[0];
  mAve[2]+=hRR[0]*hRR[0];
  mAve[3]+=hRR[2];
  mAve[4]+=hRR[2]*hRR[2];
  mCalc->CalcDcaDers(der);
  TCL::vadd(mAveDer[0],der[0],mAveDer[0],kMaxPars*3);
}
//______________________________________________________________________________
void FECalcHolder::AvEnd()
{
    for (int i=1;i<5;i++) {mAve[i]/=mAve[0];}
    for (int i=2;i<5;i+=2){mAve[i] -= pow(mAve[i-1],2);
                           mAve[i]  = sqrt(fabs(mAve[i]))   ;}

    printf(" %s\t yErr = %5.2g(+-%5.2g) \tzErr = %5.2g(+-%5.2g)  Hits=%g\n"
          ,GetName()
          ,mAve[1], mAve[2]   
          ,mAve[3], mAve[4], mAve[0]);  

    
    TCL::vscale(mAveDer[0],1./mAve[0],mAveDer[0],kMaxPars*3);
    int nPars = mCalc->GetNPars();
    double yy=0,zz=0;
    const double *par = mCalc->GetPars();
    for (int i=0;i<nPars;i++) {
      yy += par[i]*mAveDer[i][0];
      zz += par[i]*mAveDer[i][2];
    }
    printf("Again: YY = %g ZZ=%g\n",yy,zz);

}
//______________________________________________________________________________
StvHitErrCalculator *FETpcCalcHolder::GetCalc(const float x[3])
{
static const double Rinner =120.8;
static const double Dinner =120.8/cos(15./180*M_PI);
   int inOut = -1;
   if (strstr(mCalc->GetName(),"TpcInner")) inOut=0;;  
   if (strstr(mCalc->GetName(),"TpcOuter")) inOut=1;;  
   assert(inOut>=0);
   float rxy = x[0]*x[0]+x[1]*x[1];
   int jk=-1;
   if (rxy<Rinner*Rinner) jk=0;
   if (rxy>Dinner*Dinner) jk=1;
   if (jk!=-1) {return (inOut==jk)? mCalc:0;}
   float gphi = atan2(x[1],x[0])/M_PI*180;
   gphi = fmod(gphi+15,30.)-15;
   gphi = fmod(gphi+15,30.)-15;
   jk = (sqrt(rxy)*cos(gphi/180*M_PI) <Rinner)? 0:1;
   return (inOut==jk)? mCalc:0;
}
//______________________________________________________________________________
//______________________________________________________________________________
FEFcn::FEFcn()
{ 
  Clear();
  mgInst = this;
}
//______________________________________________________________________________
void FEFcn::Clear()
{
  memset(mFix,0,mEnd-mFix);
  mTks.clear();
  mCas.clear();
}
//______________________________________________________________________________
void FEFcn::FixPar(int ipar,int fix)
{
  assert(mFix[ipar]!=2);
  mFix[ipar]=fix;
  if (fix) {myFitter.FixParameter(ipar);mNFixd++;}
  else     {myFitter.Release(ipar)     ;mNFixd--;}
}
//______________________________________________________________________________
void FEFcn::Add(FECalcHolder* holder)
{ 
  holder->SetOffset(mNPars);
  mNPars+=holder->GetNPars();
  mCas.push_back(holder);
}
//______________________________________________________________________________
void FEFcn::InitFitter()
{
  myFitter.SetMaxIterations(2000);
  myFitter.SetPrintLevel(1);
  int parNo=0;
  for (int i=0;i<(int)mCas.size();i++) {
    StvHitErrCalculator *calc = mCas[i]->GetCalc();
    int nP = calc->GetNPars();
    const double *p = calc->GetPars();
    for (int ip=0;ip<nP;ip++) {
      TString ts(calc->GetName());ts+="_";ts+=ip;
      printf("Parameter[%d] %s\t %g\n",parNo,ts.Data(),p[ip]);
      double qwe = p[ip]; if (qwe<1e-8) qwe=1e-8;
      double stp = qwe*0.1; if (stp<1e-8) stp = 0.8e-6;
      myFitter.DefineParameter(parNo,ts.Data(), qwe, stp, 0, 0);
      mPars[parNo] = qwe;
      parNo++;
    }
  }
  printf("mCas[0]->GetName()=%s\n",mCas[0]->GetName());
  printf("mCas[1]->GetName()=%s\n",mCas[1]->GetName());
  assert(strstr(mCas[0]->GetName(),"TpcInner"));
  assert(strstr(mCas[1]->GetName(),"TpcOuter"));
  assert(myFitter.GetNumPars()==12);
  FixPar(StvHitErrCalculator::kThkDet+0,2);
  FixPar(StvHitErrCalculator::kThkDet+6,2);
  myFitter.SetFCN(&Fcn);
}
//______________________________________________________________________________
void FEFcn::DbLoad()
{
  for (int i=0;i<(int)mCas.size();i++) { mCas[i]->DbLoad(); }
}
//______________________________________________________________________________
void FEFcn::DbSave()
{
  for (int i=0;i<(int)mCas.size();i++) { mCas[i]->DbSave(); }
}

//______________________________________________________________________________
void FEFcn::ResetFitter()
{
  int parNo=0;
  for (int i=0;i<(int)mCas.size();i++) {
    StvHitErrCalculator *calc = mCas[i]->GetCalc();
    int nP = calc->GetNPars();
    const double *p = calc->GetPars();
    for (int ip=0;ip<nP;ip++) {
      TString ts(calc->GetName());ts+="_";ts+=ip;
      double qwe = p[ip]; if (qwe<1e-8) qwe=1e-8;
      double stp = qwe*0.1; if (stp<1e-8) stp = 0.8e-6;
      myFitter.DefineParameter(parNo,ts.Data(), qwe, stp, 0, 0);
      mPars[parNo] = qwe;
      parNo++;
    }
  }
}
void FEFcn::Update(const double *upd)
{
  for (int i=0;i<(int)mCas.size();i++) { 
    mCas[i]->Update(upd);
  }
  memcpy(mPars,upd,mNPars*sizeof(mPars[0]));
}
//______________________________________________________________________________
int FEFcn::Fit()
{
  int stat=0;
  stat=myFitter.Command("SET GRAD ");
  stat=myFitter.Command("SET GRAD 1");
  assert(!stat);
  stat=myFitter.Command("SET STRATEGY 0 ");
  assert(!stat);
  for (int it=0;it<10;it++) {  
    stat = myFitter.Migrad();
    printf("Migrad() == %d\n",stat);
    if (!stat) break;
    stat = myFitter.Command("SCAN");
    printf("Scan() == %d\n",stat);
  }
  return 0;

}
//______________________________________________________________________________
FECalcHolder *FEFcn::GetCalc(int id,const float hiPos[3])
{
    for (int i=0;i<(int)mCas.size();i++) {
      if (id!=mCas[i]->GetId()) continue;
      StvHitErrCalculator *calc = mCas[i]->GetCalc(hiPos);
      if (calc) return mCas[i];
    }
    assert(0 && "HitErrCalculator not found");
    return 0;
}

//______________________________________________________________________________
int FEFcn::Add(FEEvent* ev)
{ 
  if (mNTks > 1000000) return 99;
  mNEvs++;
  int jl,jr;
  FENode node;
  while ((jl=ev->NextTrack(jr))>-1) 
  {
    if (fabs(ev->mCurv[jl])>1./300) continue;
///    if (fabs(ev->mPt[jl])<0.5) continue;
    if (ev->nAllHits[jl] < 15) continue;
    assert(jr-jl+1>=15);
    int nNodes=0;
    int jN = mTks.size(); mTks.resize(jN+1);
    for (int j=jl;j<=jr;j++) {   
      double psi = ev->gPsi[j];
      double dip = ev->gDip[j];
      node.tkDir[0] = cos(dip)*cos(psi);
      node.tkDir[1] = cos(dip)*sin(psi);
      node.tkDir[2] = sin(dip);

      double phi = ev->gPFit[j];
      assert(fabs(phi)<7);
      double rxy = ev->gRFit[j];
      assert(rxy<300);
      node.hiPos[0] = rxy*cos(phi);
      node.hiPos[1] = rxy*sin(phi);
      node.hiPos[2] = ev->gZFit[j];
      assert(fabs(node.hiPos[2])<300);

      phi = ev->gPhiHP[j];
      dip = ev->gLamHP[j];
      node.hiDir[0][0] = cos(dip)*cos(phi);
      node.hiDir[0][1] = cos(dip)*sin(phi);
      node.hiDir[0][2] = sin(dip);

      node.hiDir[1][0] =-sin(phi);
      node.hiDir[1][1] = cos(phi);
      node.hiDir[1][2] = 0;

      node.hiDir[2][0] =-sin(dip)*cos(phi);
      node.hiDir[2][1] =-sin(dip)*sin(phi);
      node.hiDir[2][2] = cos(dip);

      node.s = ev->lLen[j];
      assert(node.s<300);
      node.yz[0] = ev->lYHit[j];
      node.yz[1] = ev->lZHit[j];
      node.detId = ev->mDetector[j];
      nNodes++;
      int n = mTks.size(); mTks.resize(n+sizeof(FENode)/sizeof(float));
      memcpy(&mTks[n],&node,sizeof(FENode));
    }    
    mTks[jN] = nNodes*sizeof(FENode)/sizeof(float)+1;
    mNHits += nNodes;
    mNTks++;
  }        
  if (mNTks>10000) return -1;
  return 0;
}
//______________________________________________________________________________
void FEFcn::Eval(int npar, double* gradp, double& fvalp, double* par, int flag)
{
   assert(npar<=mNPars);
   mNCall++;
   long double grad[100],fval=0;
   int myN=0;
   if (flag==2) { for (int i=0;i<mNPars;i++){grad[i]=0;}};

//	Update calc's params by current ones
   for (int i=0;i<(int)mCas.size();i++) { mCas[i]->Update(par);}
   Poli2 poliSY(2),poliSZ(1);
   float *a = &mTks[0];
   int siz = mTks.size();
   for (int i=1;i<siz;i+=a[i-1]) {//Loop over tracks 
     FENode *node = (FENode *)(a+i);
     int nNodes = ((int)a[i-1]*sizeof(float))/sizeof(FENode);
     poliSY.Clear(); poliSZ.Clear();
     FECalcHolder *hold[100];
     double hRR[3],dRR[10][3];
     for (int iNode=0;iNode<nNodes;iNode++) {//1st Loop over nodes
       FENode *n=node+iNode;
       hold[iNode] = GetCalc((int)n->detId,n->hiPos);
       StvHitErrCalculator *calc = hold[iNode]->GetCalc();
       calc->SetTrack(n->tkDir);
       calc->CalcDcaErrs(n->hiPos,n->hiDir,hRR);
       assert(hRR[0]>0);
       assert(hRR[2]>0);
       poliSY.Add(n->s,n->yz[0],1./hRR[0]); 
       poliSZ.Add(n->s,n->yz[1],1./hRR[2]); 
     } // end 1st Loop over nodes

     poliSY.Fit(); 
     poliSZ.Fit(); 
     fval += ((poliSY.LiH()+poliSZ.LiH()));

     myN++;

     if (flag==2) {
       for (int iNode=0;iNode<nNodes;iNode++) {//2nd Loop over nodes
	 FENode *n=node+iNode;
	 StvHitErrCalculator *calc = hold[iNode]->GetCalc();
	 calc->SetTrack(n->tkDir);
	 calc->CalcDcaErrs(n->hiPos,n->hiDir,hRR);
	 calc->CalcDcaDers(dRR);
  //		dLih/dW*dW/dErr2
	 double dLihdErrY = -poliSY.dLiHdW(iNode)/(hRR[0]*hRR[0]);
	 double dLihdErrZ = -poliSZ.dLiHdW(iNode)/(hRR[2]*hRR[2]);
	 int nPar=calc->GetNPars();
	 int offs=hold[iNode]->GetOffset();
	 for (int jPar=0;jPar<nPar;jPar++) {// Loop over Calc params
  //    		dErr2/dPar      
            double qwe =(dLihdErrY*dRR[jPar][0]+dLihdErrZ*dRR[jPar][2]);
            grad[offs+jPar]+=qwe;
 	 }// end Loop over Calc params

      }// end 2nd Loop over nodes

    }//endif flag==2
  }//End tracks
  if (!mN00) {
    mN00 = (int)(log(double(myN))/log(2.)); 
    mN00 = 1<<mN00; mVal00=fval/mN00;}

  fvalp = fval/mN00-mVal00;
  if (flag==2)   {for (int i=0;i<mNPars;i++){gradp[i]=grad[i]/mN00;}}
}
//______________________________________________________________________________
//______________________________________________________________________________
void FEFcn::Fcn(int &npar, double* grad, double& fval, double* par, int flag)
{
  mgInst->Eval(npar,grad,fval,par,flag);
}


//______________________________________________________________________________
FEApprox::FEApprox(FEFcn *fefcn)
{
  mFcn=fefcn;
  mNPars = mFcn->GetNPars();
  mG.ResizeTo(mNPars,mNPars);
  mGi.ResizeTo(mNPars,mNPars);
  mB.ResizeTo(mNPars);
  mP.ResizeTo(mNPars);
  mPrev.ResizeTo(mNPars);
  mPrev = TVectorD(mNPars,mFcn->GetPars());
}
//______________________________________________________________________________
int FEApprox::Prepare()
{
   assert(mNPars<100);
   long double myXi2=0,myB[100]={0},myG[100][100]={{0}};
   int myN=0;
   TMatrixD d2LdWWy,d2LdWWz,dSdPy,dSdPz;
   TMatrixD dWdSy,dWdSz,d2WdSSy,d2WdSSz;
   TVectorD dLdWy,dLdWz;

   Poli2 poliSY(2),poliSZ(1);
   const FETrak* trak = mFcn->GetTrak();
   for (;trak;trak=trak->Next()) {   
     int nNodes = trak->GetNNodes();
     poliSY.Clear(); poliSZ.Clear();
     FECalcHolder *hold[100];
     double hRR[3],dRR[10][3];
     for (int iNode=0;iNode<nNodes;iNode++) {//1st Loop over nodes
       const FENode *n = trak->GetNode(iNode);
       hold[iNode] = mFcn->GetCalc((int)n->detId,n->hiPos);
       StvHitErrCalculator *calc = hold[iNode]->GetCalc();
       calc->SetTrack(n->tkDir);
       calc->CalcDcaErrs(n->hiPos,n->hiDir,hRR);
       assert(hRR[0]>0);
       assert(hRR[2]>0);
       poliSY.Add(n->s,n->yz[0],1./hRR[0]); 
       poliSZ.Add(n->s,n->yz[1],1./hRR[2]); 
     } // end 1st Loop over nodes

     poliSY.Fit(); 
     poliSZ.Fit(); 
     myXi2 +=poliSY.LiH()+poliSZ.LiH();
     poliSY.Deriv(dLdWy); poliSY.D2riv(d2LdWWy);
     poliSZ.Deriv(dLdWz); poliSZ.D2riv(d2LdWWz);
     dWdSy.ResizeTo(nNodes,nNodes); dWdSy=0.;
     dWdSz.ResizeTo(nNodes,nNodes); dWdSz=0.;
     d2WdSSy.ResizeTo(nNodes,nNodes); d2WdSSy=0.;
     d2WdSSz.ResizeTo(nNodes,nNodes); d2WdSSz=0.;
     dSdPy.ResizeTo(mNPars,nNodes); dSdPy=0.;
     dSdPz.ResizeTo(mNPars,nNodes); dSdPz=0.;
     dSdPy.ResizeTo(mNPars,nNodes); dSdPy=0.;
     myN++;

     StvHitErrCalculator *calc=0;const FENode *n=0;
     for (int iNode=0;iNode<nNodes;iNode++) {//2nd Loop over nodes
       n=trak->GetNode(iNode);
       calc = hold[iNode]->GetCalc();
       calc->SetTrack(n->tkDir);
       calc->CalcDcaErrs(n->hiPos,n->hiDir,hRR);
       calc->CalcDcaDers(dRR);
       int offs=hold[iNode]->GetOffset();
       int nP = calc->GetNPars();
       for (int jp=0;jp<nP; jp++) {
         dWdSy[iNode][iNode]   = -1./(hRR[0]*hRR[0]);
         dWdSz[iNode][iNode]   = -1./(hRR[2]*hRR[2]);
         d2WdSSy[iNode][iNode] =  dLdWy[iNode]*2./(hRR[0]*hRR[0]*hRR[0]);
         d2WdSSz[iNode][iNode] =  dLdWz[iNode]*2./(hRR[2]*hRR[2]*hRR[2]);
         dSdPy[offs+jp][iNode] = dRR[jp][0];
         dSdPz[offs+jp][iNode] = dRR[jp][2];
       }
     }// end 2nd Loop over nodes
     
     TVectorD dLdPy(dSdPy*(dWdSy*dLdWy));
     TVectorD dLdPz(dSdPz*(dWdSz*dLdWz));
     dLdPz+=dLdPy;
     TMatrixD d2LdPPy(dSdPy*(dWdSy*d2LdWWy*dWdSy+d2WdSSy)*T(dSdPy));
     TMatrixD d2LdPPz(dSdPz*(dWdSz*d2LdWWz*dWdSz+d2WdSSz)*T(dSdPz));
     d2LdPPz+=d2LdPPy;

     for (int ip=0;ip<mNPars;ip++) {
       myB[ip]+=dLdPz[ip];
     for (int jp=0;jp<=ip;jp++) {
       myG[ip][jp] += d2LdPPz[ip][jp];
     } }


  }//End tracks
  myN = int(log(double(myN))/log(2.)); myN = 1<<myN;

  double spur=0;
  mXi2 = myXi2/myN;
  for (int i=0;i<mNPars;i++) {  
    mB[i] = myB[i]/myN;
    for (int j=0;j<=i;j++) { mG[i][j] = myG[i][j]/myN; mG[j][i]=mG[i][j];}
    spur+=mG[i][i];
  }
  spur*= 0.1/mNPars;
  //for (int i=0;i<mNPars;i++) { mG[i][i] += spur; }

//	Prepare inequalities

  int nCas = mFcn->mCas.size();  
  mC.ResizeTo(nCas*2,mNPars); mC = 0.;
  mClo.ResizeTo(nCas*2);
  mIclo.ResizeTo(nCas*2); mIclo = 1;
  mCup.ResizeTo(nCas*2);
  mIcup.ResizeTo(nCas*2); mIcup = 1;
  int iRow = 0;
  for (int ic=0;ic<nCas;ic++) {
    FECalcHolder *hold = mFcn->mCas[ic];
    StvHitErrCalculator *calc = hold->GetCalc();
    int iCol = hold->GetOffset();
    int nP = calc->GetNPars();
    for (int ip=0;ip<nP;ip++) {
      mC[iRow+0][iCol+ip] = hold->mAveDer[ip][0];
      mC[iRow+1][iCol+ip] = hold->mAveDer[ip][2];
    }
    mClo[iRow+0] = hold->mMiMax[0][0];
    mClo[iRow+1] = hold->mMiMax[1][0];
    mCup[iRow+0] = hold->mMiMax[0][1];
    mCup[iRow+1] = hold->mMiMax[1][1];
    iRow+=2;
  }
  return 0;
}

//______________________________________________________________________________
#include "Riostream.h"
#include "TMath.h"
#include "TSystem.h"

#include "TMatrixD.h"
#include "TMatrixDSym.h"
#include "TVectorD.h"
#include "TQpProbDens.h"
#include "TGondzioSolver.h"
#include "TMehrotraSolver.h"

//______________________________________________________________________________
int FEApprox::Test()
{
  mP = TVectorD(mNPars,mFcn->GetPars());
  Prepare(); 
//  mB.Print();
  TVectorD baseDer(mB);
  TMatrixD baseD2r(mG);
  double baseFcn = mXi2;
  double part = 3e-2,minStp=3e-4;
  for (int ip=0;ip<mNPars;ip++) {
    if (mFcn->IsFixed(ip)) continue;
    double eps = mP[ip]*part; if (eps <minStp) eps = minStp;
    double sav = mP[ip];
    mP[ip]+=eps;
    mFcn->Update(mP.GetMatrixArray());
    Prepare(); 
    double nowFcn = mXi2;
    double num = (nowFcn-baseFcn)/eps;
    double ana = mB[ip];
    double dif = 2*(num-ana)/(fabs(num+ana)+3e-33);
    printf ("dXi2dP(%2d) \tana=%g \tnum = %g \tdif=%g\n",ip,ana,num,dif);
    for (int jp=0;jp<=ip;jp++) {
      if (mFcn->IsFixed(jp)) continue;
      num = (mB[jp]-baseDer[jp])/eps;
      ana = (mG[ip][jp]+baseD2r[ip][jp])/2;
      dif = 2*(num-ana)/(fabs(num+ana)+3e-33);
      printf ("\td2Xi2dPP(%2d,%2d) \tana=%g \tnum = %g \tdif=%g\n",ip,jp,ana,num,dif);
    }
    mP[ip]=sav;
    mFcn->Update(mP.GetMatrixArray());
  }
  
  return 0;
}		
//______________________________________________________________________________
int FEApprox::Quadr()
{
const int nrVar=mNPars;
const int nrEqual   = mFcn->GetNFixd()+3;
const int nrInEqual = mC.GetNrows();
TVectorD    c = (-1.)*mB;
TMatrixDSym Q(nrVar,mG.GetMatrixArray());

 // equality equation
  TMatrixD A(nrEqual,nrVar); 
  TVectorD b(nrEqual);
  int iiEqual=0;
  for (int ipar=0;ipar<mNPars;ipar++) {
    if (!mFcn->IsFixed(ipar)) continue;
    A[iiEqual][ipar] = 1;
    b[iiEqual] 	     = 0;
    iiEqual++;
  }
  A[iiEqual][4]=1; A[iiEqual][4+6]=-1.;iiEqual++;
  A[iiEqual][5]=1; A[iiEqual][5+6]=-1.;iiEqual++;
  A[iiEqual][2]=1; A[iiEqual][2+6]=-1.;iiEqual++;


  // inequality equation
  //
  // - although not applicable in the current situatio since nrInEqual = 0, one
  //   has to specify not only clo and cup but also an index vector iclo and icup,
  //   whose values are either 0 or 1 . If iclo[j] = 1, the lower boundary condition 
  //   is active on x[j], etc. ...

//   TMatrixD C   (nrInEqual,nrVar);
//   TVectorD clo (nrInEqual);
//   TVectorD cup (nrInEqual);
//   TVectorD iclo(nrInEqual);
//   TVectorD icup(nrInEqual);

  // simple square boundary condition : 0 <= x_i, so only xlo is relevant .
  // Like for clo and cup above, we have to define an index vector ixlo and ixup .
  // Since each variable has the lower boundary, we can set the whole vector
  // ixlo = 1

  TVectorD xlo (nrVar); xlo  = 1e-8;
  TVectorD xup (nrVar); xup  = 10;
  for (int ipar=0;ipar<mNPars;ipar++) {
    xlo[ipar]=1e-8-mPrev[ipar];
  }

  TVectorD ixlo(nrVar); ixlo = 1;
  TVectorD ixup(nrVar); ixup = 1;
  
  // setup the quadratic programming problem . Since a small number of variables are
  // involved and "Q" has everywhere entries, we chose the dense version "TQpProbDens" .
  // In case of a sparse formulation, simply replace all "Dens" by "Sparse" below and
  // use TMatrixDSparse instead of TMatrixDSym and TMatrixD

  TQpProbDens *qp = new TQpProbDens(nrVar,nrEqual,nrInEqual);

  // stuff all the matrices/vectors defined above in the proper places

  TQpDataDens *prob = (TQpDataDens *)qp->MakeData(c,Q,xlo,ixlo,xup,ixup,A,b,mC,mClo,mIclo,mCup,mIcup);


  // setup the nrVar variables, vars->fX will contain the final solution

  TQpVar      *vars  = qp->MakeVariables(prob);
  TQpResidual *resid = qp->MakeResiduals(prob);
  
  // Now we have to choose the method of solving, either TGondzioSolver or TMehrotraSolver
  // The Gondzio method is more sophisticated and therefore numerically more involved
  // If one want the Mehrotra method, simply replace "Gondzio" by "Mehrotra" .

  TGondzioSolver  *s = new TGondzioSolver(qp,prob);
//TMehrotraSolver *s = new TMehrotraSolver(qp,prob);
  const Int_t status = s->Solve(prob,vars,resid);
  assert(!status);
  mP = vars->fX+mPrev;



  return 0;
}  

//______________________________________________________________________________
int FEApprox::Approx()
{
  int iter = 0;
  for (;iter<26;iter++)
  { 
    Prepare(); 
    int ans = Quadr();  if(ans){};
    double eps = 0,maxpar=0;int ips=-1;
    for (int ip=0;ip<mNPars;ip++) {
      if (maxpar<fabs(mP[ip]   )) maxpar=fabs(mP[ip]   );
      if (maxpar<fabs(mPrev[ip])) maxpar=fabs(mPrev[ip]);
    }

    for (int ip=0;ip<mNPars;ip++) {
      double dif = (fabs(mP[ip]-mPrev[ip]))/maxpar;
      if (eps<dif) {ips=ip;eps=dif;}
    }
    mP = 0.5*mP +0.5*mPrev;
    printf("Approx: iter=%d eps[%d]=%g Parameters:\n",iter,ips,eps);
    mP.Print();
    mPrev = mP;
    mFcn->Update(mP.GetMatrixArray());
    if (eps<0.03) break;
  }
// Now release all the parameters  
  for (int iPar=0;iPar<mNPars;iPar++) {
    if (mFcn->IsFixed(iPar)!=1) continue;
//    printf("    Approx:: release parameter %d\n",iPar);
    mFcn->FixPar(iPar,0);
  }
  
  return iter;
}		

//______________________________________________________________________________
void FEFcn::AvErr(const char *tit)
{
  for (int ih=0;ih<(int)mCas.size();ih++) 
  {
    FECalcHolder *hold = mCas[ih]; hold->AvInit();
  }
  const FETrak* trak = GetTrak();
  for (;trak;trak=trak->Next()) {   
    int nNodes = trak->GetNNodes();
    double hRR[3];
    for (int iNode=0;iNode<nNodes;iNode++) {//1st Loop over nodes
      const FENode *n = trak->GetNode(iNode);
      int detId = n->detId;
      FECalcHolder *hold = GetCalc(detId,n->hiPos);
      StvHitErrCalculator *calc = hold->GetCalc();
      calc->SetTrack(n->tkDir);
      calc->CalcDcaErrs(n->hiPos,n->hiDir,hRR);
      hold->AvAdd(hRR);
    } // end Loop over nodes
  }//End tracks


  printf("\n ====== AvErr(%s) Events=%d  Tracks=%d Hits=%d\n"
        ,tit,mNEvs,mNTks,mNHits);

  for (int ih=0;ih<(int)mCas.size();ih++) 
  {
    FECalcHolder *hold = mCas[ih];
    hold->AvEnd();
  }
  return;
}





#endif
