#!/usr/bin/env perl
use Env;
#if (defined($AFS)) {$File::Find::dont_use_nlink;}
require "find.pl";

# Added so it does not depend on soft-link but
# rather on afs/cons created tree structure.
#chomp($fs=`fs sysname`);
$SYSNM = $ENV{STAR_HOST_SYS};
if ( ! defined($SYSNM) ){
    chomp($SYSNM=`fs sysname`);
}

if($SYSNM ne ""){
    $SYSNM =~ s/(.*)\'(.*)\'/$2/;
    #print `pwd`."$SYSNM";
    if( -d ".$SYSNM"){
	# use @sys, we found it.
	$SYSNM = ".$SYSNM/";
    } else {
	# revert to default
	$SYSNM = "";
    }
}


my @dirs = ();
if ($#ARGV > -1) {
    push(@dirs, $ARGV[0]);
} else {
    push(@dirs,$SYSNM."obj"); 
    push(@dirs,$SYSNM."OBJ");
    push(@dirs,$SYSNM."IOBJ");
}

my $KEEP;
if( $^O eq "linux"){
    $KEEP = 1;
} else {
    $KEEP = 1;
}
if ($#ARGV > 0) {$KEEP = $ARGV[1];}

foreach my $dir (@dirs) {
  if (-l $dir) {
    $dir = readlink $dir;
  }
  if (-r $dir) {
    print "Run $0 in $dir keep = $KEEP\n";
    &File::Find::find (\&wanted_S,$dir);
  }
  sub wanted_S {
    ($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_);
    my $name = $File::Find::name;# print "name = $name\n";
    if (-e _ && /\.\d+$/) {#    print "Version $name\n";
      my $so = $_; $so =~ s/\.\d*$//; 
      my $link = $so; 
      if (-l $link) {
	my $file = readlink $link;#      print "Found Link = $link -> $file\n";
	my $vers = $file; $vers =~ s/$so\.//;# print "so = $so vers = $vers\n";
	#      chop ($file);
	$so .= ".*"; #print "so = $so\n";
	my @So = glob $so; #print "sos = @So\n";
	my $keep = 0;
	foreach my $s (@So) {
	  my $v = $s; $v =~ s/$so\.//;# print "s = $s v = $v vers = $vers\n";
	  next if !$v;
	  if ($vers == $v) {
	    #print "keep \t$file => \t$link\n";
	    next;
	  }
	  my $diff = $vers - $v - $KEEP;
	  if ($diff lt 0) {
	      #print "keep \t$file => \t$link / $s : $vers - $v - $KEEP = $diff < 0\n"; 
	      next;
	  }
	  print "Delete $s \n";
	  if ( ! unlink $s ){
	      print "Could not remove $s (check token or access)\n";
	      exit;
	  }
	}
      }
    }
  }
}
