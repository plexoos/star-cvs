#!/usr/bin/env perl
Import qw ( env CWD INCLUDE LIB BIN BUILD OBJ);
( my $build = $OBJ ) =~ s/\#//g;
$build =~ s/\\/\//g;                                    # print "OBJ = $OBJ build = $build\n";
                                                        # print "MAIN = $MAIN\n";
my $DirPath = DirPath '.';                              # print "DirPath = $DirPath\n";
( my $obj_dir = $DirPath ) =~ s/\\/\//g;                # print "obj_dir = $obj_dir\n";
( my $Dir = $obj_dir ) =~ s/$build\///g;                # print "Dir = $Dir\n";
my $ObjDir   = "#" . $obj_dir;                          # print "ObjDir = $ObjDir\n";
my $STAR_SYS     = $env->{ENV}->{STAR_SYS};
my $STAR_VERSION = $env->{ENV}->{STAR_VERSION};         # print "#####  $STAR_VER\n";
my $AFS_RHIC     = $env->{ENV}->{AFS_RHIC};

@Repo   = Repository_List unless $param::noRepository;#   print "Repositories = |@Repo|\n";


print "+-+-+- STAR=".$env->{ENV}->{STAR}."\n"  if $param::debug;
print "+-+-+- cwd=".$CWD."\n"                  if $param::debug;
my $IsDotDev = 0;
if ($env->{ENV}->{STAR} =~ /\.(dev|DEV)/) {$IsDotDev = 1;}
my $IsRepo = (stat($env->{ENV}->{STAR}."/."))[1] == (stat($CWD."/."))[1];

if ($param::debug) {
  if ( $IsRepo && ! $IsDotDev ){
    print "... REPOSITORY compilation  ...\n";
  } else {
    print "... USER area compilation   ...\n";
  }
}



my $SO_PKG  = "";
my $SO_PKG_lib = "";
my $SO_PKG_PLAIN = "";
my $SO_PKGT = "";
my $SO_MAP  = "";
my $SO_MAPT = "";
my $pkg;
my $PKG;
my @LinkDefs = ();
my @LinkDefsT = (); # for tables if any
my @PlainObj = ();
if ( ($Dir =~ m/StRoot.*Pool\// && $Dir !~ /StRoot.*Pool\/St/) ||
     ($Dir =~ m/StRoot.*Client\// && $Dir !~ /StRoot.*Client\/St/) ||
     ($Dir =~ m/StarVMC\/minicern/ )) {
    # Added 2003. In Construct, the logic is such
    # that the Pool directories have their sub-directories
    # set as targets (n sub-dir => n libraries). That's
    # fine ... apart from name clash we try to resolve
    # here.
    $pkg = $Dir;
    $pkg =~ s/StRoot\///;
    $pkg =~ s/Pool\//Pool/      if ($pkg =~ m/Pool/);
    $pkg =~ s/Client\//Client/  if ($pkg =~ m/Client/);
    $pkg = "StarMiniCern"       if ($pkg =~ m/minicern/);
    $PKG = $pkg;
    print "\t[".File::Basename::basename($Dir)."] (possible name clash) changed to $pkg\n";

} else {
    $pkg = File::Basename::basename($Dir);               # print "Run cons in $Dir for $PKG\n";
    $PKG = $pkg;
}
$env1 = $env->clone('Package'  => $pkg);
my $CXXFLAGS= $env1->{CXXFLAGS};
my $CFLAGS  = $env1->{CFLAGS};
my $FC      = $env1->{FC};
my $CC      = $env1->{CC};
my $FFLAGS  = $env1->{FFLAGS};
my $FCPATH  = $env1->{FCPATH};
my $FEXTEND = $env1->{FEXTEND};
my $FPPFLAGS= $env1->{FPPFLAGS};
my $FCCOM   = $env1->{FCCOM};
my $LIBS    = $env1->{LIBS};
my $LIBPATH = $env1->{LIBPATH};
my $STIC    = $env1->{STIC};
my $EXTRA_CPPFLAGS = $env1->{EXTRA_CPPFLAGS};
my $CPPFLAGS = $env1->{CPPFLAGS};
#my $ROOTCINT_CPPFLAGS = "";
my @idlL    = script::find_idl($Dir);
print "In Dir = $Dir idlL = @idlL\n" if $param::debug;
foreach my $Rep(@Repo) {
    my $RepDir = $Rep . "/" . $Dir;
    print "RepDir = $RepDir\n" if $param::debug;
    if ( -d $RepDir ) {
        my @idlR = script::find_idl($RepDir);
        foreach my $i(@idlR) { push @idlL, $i; }
    }
}
@idlL = script::sortu(@idlL);

my @idlML    = script::find_idlM($Dir);
my @srcL     = script::find_sources($Dir);
my @h_filesL = script::find_hfiles($Dir);
my @uiQT     = script::find_ui($Dir);
my @xpmQT    = script::find_xpm($Dir);
my @qrcQT    = script::find_qrc($Dir);


print "idlL = @idlL\n" if $param::debug;

my (@src, @h_files, @idlM);
my $CPPPATH = $env1->{CPPPATH};
#print "CPPPATH = $CPPPATH\n";
#my @RTS_pkgs = qw(SFS DAQ_TPX RTS_READER DAQ_TOF); #print "RTS_pkgs = @RTS_pkgs\n";
#foreach my $p (@RTS_pkgs) {
#  #  print "compare $p with pkg = $pkg\n";
#  if ($pkg eq $p) {
##    $CPPPATH = $main::PATH_SEPARATOR . "#online/RTS/include" . $main::PATH_SEPARATOR . "#online/RTS/trg/include" . $main::PATH_SEPARATOR . $CPPPATH;
#    $CPPPATH = $main::PATH_SEPARATOR . "#StRoot/RTS/include" . $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include" . $main::PATH_SEPARATOR . $CPPPATH;
#    #    print "new CPPPATH = $CPPPATH\n";
#    last;
#  }
#}
if ($pkg eq "RTS") {
#  $CPPFLAGS .= ' -DRTS_PROJECT_STAR -DTPXREADER -DRTS_LITTLE_ENDIAN -DEVP_VERSION="\"EVP_VERSION=2.0\""';
  $CPPFLAGS .= ' -DNEW_DAQ_READER -DRTS_PROJECT_STAR -DTPXREADER -DRTS_LITTLE_ENDIAN -DEVP_VERSION="\"EVP_VERSION=2.0\""';
  $CPPFLAGS =~ s/-D__ROOT__//;# print " ------------  CPPFLAGS ==== " .  $CPPFLAGS . "\n";
  $CFLAGS =~   s/-D__ROOT__//;# print " ------------  CFLAGS WHERE \"__ROOT__\" coming from ??? ==== " .  $CFLAGS . "\n";
  $CPPPATH = $main::PATH_SEPARATOR . "#StRoot/RTS/include" .
    $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include" .
      $main::PATH_SEPARATOR . "#StRoot/RTS/include/TPC" .
	$main::PATH_SEPARATOR . "#StRoot/RTS/src/SFS" .
	  $main::PATH_SEPARATOR . "#StRoot/RTS/src" .
	    $main::PATH_SEPARATOR . "#StRoot/RTS/src/EVP_READER" . $main::PATH_SEPARATOR . $CPPPATH;
  my @src = ();
#  print "srcL : @srcL\n";
#  print "skip /^src\/(DAQ_LEGACY|EVP_READER|RTS_READER)/\n";
  foreach my $s (@srcL) {
    next if $s =~ /^src\/(DAQ_LEGACY|EVP_READER|RTS_READER)/;
    push @src, $s;
  }
#  print "@src : @src\n";
  @srcL = @src;
  @src = ();
}
my @VF_daq_pkgs = qw(StDAQMaker  StTofHitMaker  StTpcHitMaker  OnlinePlots  StEmcRawMaker  StEEmcPoolmuEztPanitkin  StBEMCPlots Stl3RawReaderMaker );
my $RTS_READER_PATH =  $main::PATH_SEPARATOR . "#StRoot/RTS/src"
                     . $main::PATH_SEPARATOR . "#StRoot/RTS/include"
                     . $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include"
                     ;
foreach my $p (@VF_daq_pkgs) {
#  print "compare $p with pkg = $pkg\n";
  if ($pkg eq $p) {
    $CPPPATH = $RTS_READER_PATH . $main::PATH_SEPARATOR . $CPPPATH;
#    $ROOTCINT_CPPFLAGS = " -DNEW_DAQ_READER"; 
#    print "new CPPPATH = $CPPPATH\nfor $p\n";
    last;
  }
}
if ( $pkg eq "OnlinePlots") {
    $ONLINEPLOTPATH  =  $RTS_READER_PATH;
    $CPPPATH  .=  $ONLINEPLOTPATH
              .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/Infrastructure" 
              .   $main::PATH_SEPARATOR . "#StRoot/OnlinePlots/Infrastructure" 
              .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/HistogramGroups"
              .   $main::PATH_SEPARATOR . "#StRoot/OnlinePlots/HistogramGroups"
              .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/Infrastructure/EEmcDb"
              .   $main::PATH_SEPARATOR . "#StRoot/OnlinePlots/Infrastructure/EEmcDb"
              .   $main::PATH_SEPARATOR . "#OnlTools/OnlinePlots/QEvpClient"
              .   $main::PATH_SEPARATOR . "#StRoot/OnlinePlots/QEvpClient"
              .   $main::PATH_SEPARATOR . "#StRoot/RTS/EventTracker"
              .   $main::PATH_SEPARATOR .  $CPPPATH;
    $CPPFLAGS .= " -DQT_THREAD_SUPPORT -DQT_SHARED -DQT_NO_DEBUG ";
}
$CPPFLAGS .= " -DNEW_DAQ_READER"; 
if ($pkg eq "StDAQMaker") {
   $CPPFLAGS .= " -DNEW_EVP_READER"; # we should uncomment that later
   $LIBS = "-lStDaqLib -lRTS";
}
my ($i, $obj);
my $LIBPKG = ""; 
my @g77pkgs = qw(geometry gen sim tls minicern geant3); 
my $g77pkgs = join('|', @g77pkgs); print "FC = $FC pkg = $pkg DirPath = $DirPath\n" if $param::debug;
if($FC eq 'pgf77' and ($DirPath  =~ /$g77pkgs/ or $DirPath !~ /pams/)) {
  $FC       = $env1->{G77}; print "set FC => $FC ==============================\n" if $param::debug;
  $FFLAGS   = $env1->{G77FLAGS}; 
  $FEXTEND  = $env1->{G77EXTEND};
}
if(($FC eq 'g77' or $FC eq 'gfortran') and $DirPath =~ /pams/ and ($DirPath !~ /$g77pkgs/ or $DirPath =~ /crs/ or $DirPath =~ /g2t/ or $DirPath =~ /hij/)) {
  $FCCOM    = $env1->{FCviaAGETOFCOM};
}
if ( $pkg !~ /^sim$/ && $pkg !~ /^gen$/ ) {
  print "\t--- Regular case treatment (not gen not sim) ---\n" if $param::debug;
  
  if ($param::debug) {
    $i = 0;
    foreach my $s(@idlML) { print "i=", $i++, " idlM = ", $s, "\n"; }
    $i = 0;
    foreach my $s(@srcL) { print "i=", $i++, " src = ", $s, "\n"; }
    $i = 0;
    foreach my $s(@h_files) { print "i=", $i++, " h_files = ", $s, "\n"; }
  }
  
  
  foreach my $Rep(@Repo) {
    my $RepDir = $Rep . "/" . $Dir;
    print "RepDir = $RepDir\n" if $param::debug;
    
    if ( -d $RepDir and $pkg ne "RTS") {
      my @srcR =
	script::find_sources($RepDir);
      foreach my $i(@srcR) { push @srcL, $i; }
      my @idlMR = script::find_idlM($RepDir);
      
	    foreach my $i(@idlMR) { push @idlML, $i; }
      my @h_filesR = script::find_hfiles($RepDir);
      foreach my $i(@h_filesR) { push @h_filesL, $i; }
    }
  }
  @src     = script::sortu(@srcL);
  @h_files = script::sortu(@h_filesL);
  @idlM    = script::sortu(@idlML);
  #ui     /opt/star/sl305_gcc323/qt/bin/uic GeomBrowser.ui -i GeomBrowser.h -o .ui/GeomBrowser.cpp
  #xpm    /opt/star/sl305_gcc323/qt/bin/uic  -embed -o .ui/qmake_image_collection.cpp
  my $uic = $env->{Packages}->{QT}->{BINDIR} . "/uic";
  my $qt4 = ($env->{Packages}->{QT}->{QT_VERSION} == 4);
  my $rcc =$uic;
  $rcc =  $env->{Packages}->{QT}->{BINDIR} . "/rcc" if ($qt4);
  my @QtDefs = ();
  my @uih = ();#   print "h_files: @h_files\n";
  foreach my $h (@h_files) {
     if ((!$qt4 && ($h =~ /\.ui\.h$/)) || ($qt4 && ($h =~ /ui_.+\.h$/))) {
       push @uih, $h;
     }
  }
  # print "\$qt4 = $qt4 uih : @uih all: @h_files\n";
  foreach my $ui (@uiQT) {
     my $dir     = File::Basename::dirname( $ui );
     my $dirbase = $dir;
     $dirbase =~ s/$Dir//;
     my $stem    = File::Basename::basename( $ui, ".ui" );
     if ($dirbase) {
        $dirbase =~ s|^/||;
        $dirbase .= "/";
     }
     my $uilocal = $dirbase . File::Basename::basename( $ui );
     my @dep = ($uilocal, @uih);
     if ($qt4) {
       my $out = "$dirbase". "ui_". $stem . ".h"; # print "Qt4: out : $out ==> $uilocal\n"; # if $param::debug ;
       Command $env [$out], ($uilocal), qq(cd %1:d; $uic %1:f -o %>:f );
       push @QtDefs, $out; print "QtDefs from $ui  @QtDefs\n"; # if $param::debug;
     } else {
       my @out = ($dirbase . $stem . ".cxx", $dirbase . $stem . ".h") ; #   print "Qt3:$out[1]:d \n out @dep : @out ==> $uilocal\n";
       Command $env [$out[1]], @dep, qq(cd %1:d; $uic %1:f -o %>:f );
       Command $env [@out[0]], ($uilocal,$out[1]), qq(cd %1:d; $uic %1:f  -i %2:f -o %>:f);
       push @src, $out[0];
       push @QtDefs, $out[1]; # print "QtDefs from $ui  @QtDefs\n" if $param::debug;
     }
  }
  if ($#xpmQT >= 0) {
    my $out = $PKG . "_image_collection.cxx";
    my @xpm = map (File::Basename::basename( $_), @xpmQT);
    if ($qt4) {
	# create qt4 resource file
	my  $qrc = $out.".qrc";
	#Command $env [$qrc], @xpm, qq(cat >%>; );
	#Command $env [$out], $qrc, qq($uic -embed %< -o %> );

    } else {
	print "Command $uic -embed ".join(" ",@xpm)." -o $out \n";
	Command $env [$out], @xpm, qq($uic -embed %< -o %> );
	push @src, $out
    }
  }
  if ($qt4) {
    foreach my $qrc (@qrcQT) {
      my $dir     = File::Basename::dirname( $qrc );
      my $dirbase = $dir;
      $dirbase =~ s/$Dir//;
      my $stem    = File::Basename::basename( $qrc);
      if ($dirbase) {
        $dirbase =~ s|^/||;
       $dirbase .= "/";
      }
      my $qrclocal = $dirbase . File::Basename::basename( $qrc );
      my @xpm = map (File::Basename::basename( $_), @xpmQT);
      my @dep = ($qrclocal,@xpm );
      my $out = "$dirbase". "qrc_". $stem . ".cxx"; # print "Qt4:  ut : $out ==> $qrclocal\n"; # if $param::debug ;
      Command $env [$out], @dep, qq(cd %1:d; $rcc %1:f -o %>:f );
      push @src, $out
    }
  }
  $SO_PKG = $PKG . "." . $env1->{SUFSOLIB};
  $SO_PKG_PLAIN = $SO_PKG;
  if ( $#idlM > -1 and $PKG !~ "^St" ) { $PKG = "St_" . $PKG; @PlainObj = @src; $SO_PKG = $PKG . "." . $env1->{SUFSOLIB};}
  $SO_PKG_lib = "lib" . $SO_PKG;
  $SO_PKG_PLAIN_lib = "lib" . $SO_PKG_PLAIN;
  
  $obj = $ObjDir;
  print "obj = $obj\n" if $param::debug;
  print "SO_PKG = $SO_PKG\n" if $param::debug;
  
  $SO_MAP = $PKG . ".map";
  #+
  # Extraneous flag treatment for specific makers
  # Search path depth for Makers.
  #-
  print "-=-=-=-=- Will now test $pkg\n" if ($param::debug);
  if ( $pkg =~ m/^StEventDisplay/ || $#uiQT >= 0){
    # This make requires both ROOT Qt and QT libraries
    if ( defined($env1->{Packages}->{QT}->{DIR})) {# && (-r $ENV{ROOTSYS} . "/include/TQt.h" || -r $ENV{ROOTSYS} . "/include/TGQt.h")){
      #print "-=-=-=-=-=-=-=- QT is defined -=-=-=-=-=-=-=-=-=-=\n";
      $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{QT}->{INCDIR};
      $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{QT}->{LIBDIR}; 
      #$LIBS ... should come loaded from ROOT 
      $CXXFLAGS.= " " . $env1->{Packages}->{QT}->{FLAGS};
      #	    $LIBS .= " " . $env1->{Packages}->{QT}->{LIBS};
    }
  } elsif ( $pkg =~ m/^St.*Db/ or $pkg =~ m/^StStarLogger/ or $pkg =~ m/^StUCMApi/) {
    $CPPPATH .= $main::PATH_SEPARATOR .  $env1->{Packages}->{MYSQL}->{INCDIR};
    if ($pkg eq 'StDbLib') {
      $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{INCDIR};
      $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{XML}->{LIBDIR};
      $LIBS .=  " " . $env1->{Packages}->{XML}->{LIBS};
      if ($env1->{Packages}->{XML}->{CPP}) {
	$EXTRA_CPPFLAGS .= $env1->{Packages}->{XML}->{CPP};
      }
    }
    print "CPPPATH = $CPPPATH\n" if $param::debug;
    
  } elsif ( $pkg =~ m/^apythia$/ ) {
    my $CERN_ROOT = $env1->{ENV}->{CERN_ROOT};
    print "CERN_ROOT = $CERN_ROOT\n" if $param::debug;
    if ($LIBPATH) { $LIBPATH .= $main::PATH_SEPARATOR; }
    $LIBPATH .= $CERN_ROOT . "/lib";
    $LIBS .= " " . $env->{LDALL};
    foreach my $py ("pythia6205","pythia","pythia6152","pythia6136") {
      my $file = $CERN_ROOT . "/lib/lib" . $py . ".a";
      if (-f $file) {$LIBS .= " -l" . $py; last;}
    }
    foreach my $py ("pdflib804") {
      my $file = $CERN_ROOT . "/lib/lib" . $py . ".a";
      if (-f $file) {$LIBS .= " -l" . $py; last;}
    }
    $LIBS  .= " " . $env->{LDNONE};
  } elsif ( $pkg =~ m/^StTrsMaker$/ or $pkg =~ m/^pythia8/ ){
    $CPPPATH =
      "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/include";
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    print "CPPPATH = $CPPPATH\n" if $param::debug;
    
  } elsif ( $pkg =~ m/^StHbtMaker$/ ) {
    $CPPPATH = "#" . $Dir;
    foreach
      my $subdir( "Base", "Infrastructure", "Reader", "Cut",
		  "CorrFctn", "Fit", "ThCorrFctn")
	{
	  $CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/" . $subdir;
	}
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    print "CPPPATH = $CPPPATH\n" if $param::debug;
    
    
    # According to description, all client requirering this
    # should be added here.
  } elsif ( $pkg =~ m/^StRTSClient/ ) {
    my ($basep) = $Dir;
    $basep =~ s/Client\/.*/Client/;
    $CPPPATH =
      "#" . $Dir . $main::PATH_SEPARATOR ."#". $basep ."/include";
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    print "CPPPATH = $CPPPATH\n" if $param::debug;
    
    
    
    # This block can be used for ANY Maker or Pool having a 2 level
    # directory structure using auto-globbing for include purposes
  } elsif ( $pkg =~ m/^StAssociationMaker$/ ||
	    $pkg =~ m/EmcUtil$/             ||
	    $pkg =~ m/^StMuDSTMaker$/       ||
	    $pkg =~ m/^StJetMaker$/         ||
	    $pkg =~ m/^StEmcPool$/          ||
	    $pkg =~ m/^StEEmcPool$/         ||
	    $pkg =~ m/^StTofPool$/          ||
	    $pkg =~ m/^StRichPool$/         ||
	    $pkg =~ m/^StGeneri/            ||
	    $pkg =~ m/^St.*Utilities/       ||
	    $pkg =~ m/^Sti/           ) {
    $CPPPATH = "#" . $Dir;
    
    print "WARNING Package $pkg requires a glob() to be called\n" if $param::debug;
    
    foreach my $subdir ( glob("$Dir/*") ){
      if( -d $subdir && 
	  $subdir ne "$Dir/CVS"      &&
	  $subdir ne "$Dir/macros"   &&
	  $subdir ne "$Dir/examples" &&
	  $subdir ne "$Dir/doc" ){
	#print "Inserting $subdir\n";
	$CPPPATH  .= $main::PATH_SEPARATOR . "#"  . $subdir;
      }
    }
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    print "CPPPATH = $CPPPATH\n" if $param::debug;
    #$SO_PKG = $PKG . "." . $env1->{SUFSOLIB};
    
    #print "-=-=-=-=-=-= SO_PKG = $SO_PKG\n";
    
    
  } elsif ( $pkg =~ m/^StDaqLib$/ ) {
    $CPPPATH = "#" . $Dir;
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    print "CPPPATH = $CPPPATH\n" if $param::debug;
    
  } elsif ( $pkg =~ m/^gcalor$/ || $pkg =~ m/^geant321$/) {
    $LIBPKG = "lib" . $pkg . "." . $env1->{SUFLIB};
    $SO_PKG = "";
    $SO_MAP = "";
    $FCPATH = "#" . $Dir . "/../geant321" .
      $main::PATH_SEPARATOR . "#" . $Dir . "/../starsim/include" . 
	$main::PATH_SEPARATOR . "#" . $Dir . "/../gcalor/include" . 
	  $main::PATH_SEPARATOR . $env1->{FCPATH};
    $FPPFLAGS = " -DATLAS_UNIX -DCOMMONS_CONFIG_H -DCERNLIB_LINUX -DCPP_VERS=\"'W'\"";
  } elsif ( $pkg =~ m/^g2t/ || $pkg =~ m/^gstar/ || $pkg =~ m/^geometry/ ) {
    $SO_MAP  = "";
    $FCPATH  = $INCLUDE;
    $FCPATH .= $main::PATH_SEPARATOR . "#asps/Simulation/starsim/include";
    $FCPATH .= $main::PATH_SEPARATOR . "#asps/Simulation/geant321/include";
    $FCPATH .= $main::PATH_SEPARATOR . $env1->{ENV}->{CERN_ROOT} . "/include";
  } elsif ($pkg =~ m/TGeant3|StarVMCApplication|StVMCMaker/) {
    $CPPPATH =  $env1->{ENV}->{ROOT} . "/" .$env1->{ENV}->{ROOT_LEVEL} . "/geant3/TGeant3"
      . $main::PATH_SEPARATOR . $CPPPATH;
    #      } elsif ($pkg =~ m/geant3$/) { 
    #	$FCPATH = 
    #	  "#StarVMC/geant3" .
    #	  $main::PATH_SEPARATOR . "#StarVMC/minicern" .
    #	  $main::PATH_SEPARATOR .  $INCLUDE; #print "FCPATH: $FCPATH\n";
    
  } elsif ($pkg eq 'StarMiniCern') {
    $FPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{FPPFLAGS};
    $CPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{CPPFLAGS};
    $FCPATH = "#StarVMC/minicern" . $main::PATH_SEPARATOR . $INCLUDE;
    $CPPPATH .= $main::PATH_SEPARATOR . "#StarVMC/minicern";
    my @srcC = ();
    foreach my $s (@src) {
      my $dirL  = File::Basename::dirname($s);
      my $sdir = File::Basename::basename($dirL);
      #      print "s = $s dir = $dirL sdir = $sdir\n";
      #      next if $sdir ne $dirL;
      next if $s eq 'uset.F' and $STAR_SYS =~ /sun4x_/;
      next if $sdir eq 'hpxgs'; # hpux macos
      next if $sdir eq 'sungs'; # sun
      next if $sdir eq 'allgs';
      next if $sdir eq 'lnxgs';
      next if $sdir eq 'lnxppcgs';
      next if $sdir eq 'qutyinv';
      next if $sdir eq 'qutyz32';
      #      print "add $s\n";
      push @srcC, $s;
    }
    @src = @srcC;
    push @src, "lnxgs/rdmin.F"  if $STAR_SYS =~ /^rh/ or $STAR_SYS =~ /^i386/ or $STAR_SYS =~ /^sl/;
#    push @src, "lnxgs/ishftr.c" if $STAR_SYS =~ /^rh/ or $STAR_SYS =~ /^i386/ or $STAR_SYS =~ /^sl/ or $STAR_SYS =~ /_icc/;
    if ($FC eq 'g77') {
      $LIBS .= " -lg2c";
    }
  } elsif ($pkg eq 'geant3') { 
    $SO_PKG = "lib" . $SO_PKG; $SO_PKG_lib = $SO_PKG;
    $FPPFLAGS .= " " . $env1->{Packages}->{CERNLIB}->{FPPFLAGS};
    $FCPATH = "#StarVMC/geant3" . $main::PATH_SEPARATOR . "#StarVMC/minicern" . $main::PATH_SEPARATOR . $INCLUDE;
## added+  block+ cdf cgpack+ comad+ data doc erdecks+ erpremc+ examples
## fiface+ fluka+ gbase+ gcons+ gdraw+ geant321 geocad+ ggeom+ gheisha+ ghits+
## ghrout+ ghutils+ giface+ giopa+ gkine+ gparal+ gphys+ gscan+
## gstrag+ gtrak+ guser gxint gxuser matx55+ miface+ miguti+
## neutron+ peanut_ TGeant3
#    my @dirs = qw (added gbase gcons geocad ggeom gheisha ghits ghrout ghutils 
#		   giface giopa gkine gparal gphys gscan gstrag gtrak matx55 miface 
#		   miguti neutron peanut fiface cgpack fluka block comad erdecks erpremc 
#		   minicern gdraw TGeant3);
#    my $dirs = join '|', @dirs;
#    #	if ($STAR_SYS =~ /^rh/ or $STAR_SYS =~ /^i386/ or $STAR_SYS =~ /^sl/) {
#    my @srcC = ();
#    foreach my $s (@src) {
#      my $dirL = File::Basename::dirname($s);
#      #      print "dirL = $dirL dirs: @dirs\n";
#      next if $dirL !~ /$dirs/;
#      next if $s =~ /gtrak\/grndm.*\.F/;
##      if ($s =~ /gevkev/) {print "==================================";}
##      print "add $s\n";
#      push @srcC, $s;
#    }
#    @src = @srcC;
#    push @src, "gcinit.F";
  } elsif ( $Dir =~ m/StarVMC/ && $pkg =~ /ecal|Tpc|star/) {
    $CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/include";
  } elsif ( $pkg =~ m/^StBFChain$/ && (! $IsRepo || $IsDotDev) ) {print "\t add documentation for $pkg\n";
    Command $env ["#StRoot/StBFChain/doc/BFC.h"], qw(#StRoot/StBFChain/BigFullChain.h), qq (%CPP %< > %>);
    Command $env ["#StRoot/StBFChain/doc/BFC2.h"], qw(#StRoot/StBFChain/BigFullChain.h), qq (%CPP -D__BFC2__ %< > %>);
    Command $env [qw(#StRoot/StBFChain/doc/index.html #StRoot/StBFChain/doc/StBFChain.cxx_doc)],
      qw(#StRoot/StBFChain/StBFChain.cxx #StRoot/StBFChain/doc/BFC.h  #StRoot/StBFChain/doc/BFC2.h),
	qq(BFCOpt2Html.pl);
  }
  if ( $#idlM > -1 ) {
    $CPPPATH = $INCLUDE . "/" . $pkg . $main::PATH_SEPARATOR . $CPPPATH;
    print "CPPPATH = $CPPPATH\n" if $param::debug;
  } elsif ( $#idlL > -1 ) {
    $CPPPATH .= $main::PATH_SEPARATOR . $INCLUDE . "/tables" . $main::PATH_SEPARATOR . "#";;
    print "CPPPATH = $CPPPATH\n" if $param::debug;
  }
  if ( $LIBPKG && $Dir =~ /pams\// || $STAR_SYS =~ /^intel_wnt$/ ) {
    $LIBS .= " -l" . $pkg;    #"lib" . $pkg . "." . $env1->{SUFLIB};
  }
  if ($pkg =~ /^St_base$/) {
    if ( $STAR_SYS =~ /^hp_ux102$/) {
      $CPPPATH .= $main::PATH_SEPARATOR . "/usr/local/include";
    }
  }
  if (($pkg eq 'StHbtMaker' or $pkg eq 'StMuDSTMaker') and $CC ne 'gcc' and $CC ne 'icc') {
    # fight with __PRETTY_FUNCTION__
    $EXTRA_CPPFLAGS .= " -DDEBUGMESSAGE\\\(x\\\)=\"\"  -DDEBUGMESSAGE1\\\(x\\\)=\"\"  -DDEBUGMESSAGE2\\\(x\\\)=\"\"  -DDEBUGMESSAGE3\\\(x\\\)=\"\"  -DFORCEDDEBUGMESSAGE\\\(x\\\)=\"\"";
  }
  #print "_+_+_+_+_+ $CPPPATH $CXXFLAGS $LIBS $CPPPATH $LIBPATH _+_+_+_+_+\n";
  if ($pkg =~ /^StUCMApi$/ or $pkg =~ /^StStarLogger$/) {
    $EXTRA_CPPFLAGS .=" -D_UCMLOGGER_";
    $CPPPATH .= $main::PATH_SEPARATOR . "StRoot/StUCMApi/data/base"
              . $main::PATH_SEPARATOR . "StRoot/StUCMApi"
              . $main::PATH_SEPARATOR . "StRoot/StUCMApi/data"
              . $main::PATH_SEPARATOR . "StRoot/StUCMApi/data/modules";
    $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{INCDIR};
  }
  if ($pkg =~ /^StStarLogger$/) {
    $CPPPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{INCDIR};
    $LIBPATH .= $main::PATH_SEPARATOR . $env1->{Packages}->{Logger}->{LIBDIR};
    $LIBS    .= " " . $env1->{Packages}->{Logger}->{LIBS};
  }

  if ( $STAR_SYS =~ /^sun4x_5.$/ ) { $CXXFLAGS .= " -ptr" . $obj_dir; }
  if ( $STAR_SYS =~ /kcc$/ ) { $LIBPATH = ""; $LIBS = ""; }
  #    print "pkg = $pkg FPPFLAGS = $FPPFLAGS\n";
  my $libpath = $LIBPATH;
  if (! $LIBS) {$libpath = "";}
#  print "CPPPATH => $CPPPATH\n";
  $env2 = $env1->clone('Package'  => $pkg,
		       'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS,
		       'CPPPATH'  => $CPPPATH,
		       'CFLAGS'   => $CFLAGS,
		       'CXXFLAGS' => $CXXFLAGS,
		       'FC'       => $FC,
		       'FFLAGS'   => $FFLAGS,
		       'FCPATH'   => $FCPATH,
		       'FEXTEND'  => $FEXTEND,
		       'FPPFLAGS' => $FPPFLAGS,
		       'CPPFLAGS' => $CPPFLAGS,
		       'FCCOM'    => $FCCOM,
		       'LIBS'     => $LIBS,
		       'LIBPATH'  => $libpath,
		       'ObjDir'   => $obj_dir
		      );
  #    bless $env2, "cons"; #?
  #    if ($CC eq 'icc') {$EXTRA_CPPFLAGS .= " " . "-DR__NO_CLASS_TEMPLATE_SPECIALIZATION";}
  my $Cint_CPPPATH = $CPPPATH . $main::PATH_SEPARATOR . "#";
#  print "Cint_CPPPATH => $Cint_CPPPATH\n";
  $envCint = $env2->clone('DEBUG' => $env2->{NOOPT},
			  'CPPPATH'  => $Cint_CPPPATH,
			  'CPPFLAGS' => $CPPFLAGS,
			  'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS);
  
  print "LIBPATH = |", $env2->{LIBPATH}, "|\n LIBS = |", $env2->{LIBS},
    "|\n CPPPATH = |", $env2->{CPPPATH}, "|\n" if $param::debug;
					   
  print "LINKMODULECOM |", $env2->{LINKMODULECOM}, "|\n" if $param::debug;
  my $cscanner = find scan::cpp( $env2->{_cwd}, $env2->{CPPPATH} );
  my @cpps = split /$main::PATH_SEPARATOR/, $env2->{CPPPATH};
#  print "cpps => @cpps\n";# if $param::debug;
  my $ROOTCINT_CPP = "";
  my $STIC_CPP     = "";
					   
#  print "ROOTCINT_CPP => $ROOTCINT_CPP\n";
  foreach my $cpp( $Dir, @cpps ) {
    if ( $cpp =~ /cern/ || $cpp eq "/usr/include" || $cpp =~ /ospace/
	 || $cpp =~ /openwin/ )
      {
	next;
      }
    if ($ROOTCINT_CPP) { $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $cpp; }
    else { $ROOTCINT_CPP = $cpp; }
    if ( $cpp =~ /ROOT/ ) {next}
    if ($STIC_CPP) { $STIC_CPP .= $main::PATH_SEPARATOR . $cpp; }
    else { $STIC_CPP = $cpp; }
  }
#  print "ROOTCINT_CPP => $ROOTCINT_CPP\n";
  $cscanner = find scan::cpp( $env2->{_cwd}, $ROOTCINT_CPP );
  print "ROOTCINT_CPP = $ROOTCINT_CPP\n" if $param::debug;
  my $ROOTCINT_CPPPATH = $cscanner->iflags($env2);
  if ($env2->{EXTRA_CPPFLAGS}) {
    $ROOTCINT_CPPPATH .= " " . $env2->{EXTRA_CPPFLAGS}; # Requested By Frank Laue
  }
  print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n" if $param::debug;
  $cscanner = find scan::cpp( $env2->{_cwd}, $STIC_CPP );
  my $STIC_CPPPATH =
    $cscanner->iflags($env2);    # print "STIC_CPPPATH  = $STIC_CPPPATH\n";
  my $DIR = Cwd::cwd();
  print "DIR = $DIR\n" if $param::debug;
  my $line;
  my @Defs = ();
  if ( $#idlM > -1 ) {
    my $include = $INCLUDE . "/" . $pkg;
    print "include = $include\n" if $param::debug;
    foreach my $idl(@idlM) {
      my $stem = File::Basename::basename( $idl, ".idl" );
      print "idl = $idl  stem = $stem\n" if $param::debug;
      my $idm  = $stem . ".idl";
      my $idMM = $DIR . "/" . $Dir . "/" . $idl;
      print "idMM = $idMM\n" if $param::debug;
      my $idM = "#" . $Dir . "/" . $idl;
      print "idM = $idM\n" if $param::debug;
      my @idlS = ($idM);
      my $modh = $INCLUDE . "/" . $stem . ".h";
      my $modi = $INCLUDE . "/" . $stem . ".inc";
      my $modH = $include . "/" . "St_" . $stem . "_Module.h";
      print "modH = $modH\n" if $param::debug;
      my $modC = "St_" . $stem . "_Module.cxx";
      print "modC = $modC\n" if $param::debug;
      
      if ( $STAR_SYS !~ /^intel_wnt$/ ) {
	  $env2->{ENV}->{STICTMP} = "/tmp/$<$$";
	  my $stic_cmd = 
	      "test -d \$STICTMP && /bin/rm -rf \$STICTMP ; ".
	      "/bin/mkdir -m 777 \$STICTMP && cd \$STICTMP && ".
	      "$STIC -s -r $STIC_CPPPATH -q %<:a && /bin/mv %>:f %>:a && ".
	      "cd /tmp  &&  /bin/rm -rf \$STICTMP";
	Command $env2 [$modh], @idlS, qq($stic_cmd);
	Command $env2 [$modi], @idlS, qq($stic_cmd);
	Command $env2 [$modH], @idlS, qq($stic_cmd);
	Command $env2 [$modC], @idlS, qq($stic_cmd);
      }
      my @objmod = ($modC);
      print "Install @objmod in $ObjDir\n" if $param::debug;
      push @src, $modC;
      print "src + $mod: @src\n" if $param::debug;
      push @Defs, $modH;
    }
  } else {
    foreach $h(@h_files) {#print "h: $h\n";
      if ( $h =~ /LinkDef/) { push @LinkDefs, $h;}
      if ( $h =~ /LinkDef/ || $h =~ /Stypes/ ) { push @Defs, $h; next; }
#     if ( $h =~ /DetectorGroup/ || $h =~ /HitLoader/) { push @Defs, $h; next; }
      my $hh = $Dir . "/" . $h;
      if ( -r $hh ) {
	open( In, $hh ) or die "Can't open $hh";
	my $classDefFlag = 1;
	my $qtFlag       = 1;
	while ( $line = <In> ) {
	  if ( ( $line =~ /ClassDef/ || $line =~ /StCollectionDef/) ) {
	    push @Defs, $h; # print "$h <==========\n";
	    $classDefFlag = 0;
	  } elsif ( $line =~ /Q_OBJECT/ && defined($env1->{Packages}->{QT}->{BINDIR}) && $qtFlag ) {
	    
	    push @QtDefs, $h; print "QtDefs from Q_OBJECT  @QtDefs\n" if $param::debug;
	    $qtFlag = 0;
	  }
	  next if ( $classDefFlag + $qtFlag == 0 );
	}
	close(In);
	
      } else {
	
	foreach my $Rep(@Repo) {
	  my $RepDir = $Rep . "/" . $Dir;
	  print "RepDir = $RepDir\n" if $param::debug;
	  if ( -d $RepDir ) {
	    my $hh = $RepDir . "/" . $h;
	    if ( -r $hh ) {
	      open( In, $hh ) or die "Can't open $hh";
	      
	      while ( $line = <In> ) {
		if ( $line =~ /ClassDef/
		     || $line =~ /StCollectionDef/ )
		  {
		    push @Defs, $h;
		    goto ENDL;
		  }
	      }
	      close(In);
	    }
	  }
	}
      }
    ENDL:
    }
  }
  
  if ( $#Defs > -1 ) {
    my @CintFiles = ( $PKG . "_Cint.cxx", $PKG . "_Cint.h", "LinkDef.h" );
    @Defs = script::sortu(@Defs);
    my @defs = ();
    foreach my $def(@Defs) {    #print "def = $def OBJ = $OBJ\n";
      if ( $def =~ /^\#/ ) { push @defs, $def; }
      else { push @defs, "#" . $Dir . "/" . $def; }
    }
    foreach my $def (@LinkDefs) {
      open (In, $Dir . "/" . $def) or die "Can't open $def";
      while (my $line = <In>) {
	if (($line  =~ /^\/\/IncFile *=/))	{
	  my @words = split /(=)/, $line;
	  chomp(@words[2]);
	  my $h = $words[2];
     # remove the quotation surrounding the file name if any
     $h =~ s/^\"// ; $h =~ s/\"$// ; 
	  if (! -r $Dir . "/" . $h) {
	    $h = "#StRoot/" . $h;
	  }
	  print "Add $Dir ========= $h \n" if $param::debug;
	  if (! -r $h) {push @defs, $h;}
	}
      }
      close(in);
    }
    Depends $env2 [@CintFiles], @h_files;
    Depends $env2 [@CintFiles], ($env2->{Packages}->{ROOT}->{ROOTCINT});

    my $RCINTPL;

    # use local if available  
    if ( -e "mgr/RootCint.pl") {
	$RCINTPL = "mgr/RootCint.pl";
    } else {
	$RCINTPL = "RootCint.pl";
    }
	Command $env2 [@CintFiles], @defs,
	qq($RCINTPL "%>" "%<" "$ROOTCINT_CPPPATH" );
#	qq($RCINTPL "%>" "%<" "$ROOTCINT_CPPFLAGS $ROOTCINT_CPPPATH" );

      
#    if ($#LinkDefs < 0) { push @LinkDefs, "LinkDef.h";}
    @LinkDefs = ("LinkDef.h");
    my @objfiles = Objects $envCint ($CintFiles[0]);#
    #	push @src, $CintFiles[0];
    push @src, @objfiles[0];
    print "+==========add cint $CintFiles[0]\n" if $param::debug;
  }
  
  if ( $#QtDefs > -1 ) {
    my $mocheaders = join $main::PATH_SEPARATOR, @QtDefs;
    my @mocs = script::MakeMoc( $env2, $pkg, $done, $mocheaders);
    print "mocheaders: $mocheaders \tmocs: @mocs\n" if $param::debug;
    foreach $m(@mocs) { push @src, $m;}
  }
}
#____________________________________Tables____________________________
# Tables:

my @sourcesT = ();

if ( $#idlL > -1 ) {
  my @idlT = ();
  my $objT = $OBJ . "/pams/tables";
  ( my $objT_dir = $objT ) =~ s/^\#//g;
  print "objT_dir = $objT_dir\n" if $param::debug;
  my $includeT = $INCLUDE . "/tables";
  print "includeT = $includeT\n" if $param::debug;
  
  foreach my $idl(@idlL) {
    print "$idl\n" if $param::debug;
    my $IDL =
      "#" . $Dir . "/" . $idl;    # print "i=",$i++," idl = $idl IDL=$IDL\n";
    my $stem = File::Basename::basename( $IDL, ".idl" );
    print "stem = $stem\n" if $param::debug;
    my $idlt = $includeT . "/" . File::Basename::basename($idl);
    push @idlT, $IDL;
  }
  print "idlT = @idlT\n" if $param::debug;
  
  if ( $#idlT > -1 ) {
    $PKGT    = "lib" . $pkg . "_Tables";
    $SO_PKGT = $PKGT . "." . $env1->{SUFSOLIB};
    $SO_MAPT = $PKGT . ".map";
    print "SO_PKGT = $SO_PKGT\n" if $param::debug;
    my $LIBPKGT = $PKGT . "." . $env1->{SUFLIB};
    
    if ( $Dir =~ /StRoot\//  ||  $Dir =~ /OnlTools\//) {
      $SO_PKGT = $SO_PKG; 
      $SO_MAPT = $SO_MAP;
      $LIBPKGT = $LIBPKG;
    } else {
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir,
	      $PKGT )
	unless ($param::quiet);
    }
    #        Install $env $INCLUDE, @idlT;  # print "Install $env $INCLUDE, @idlT\n";
    
    #___________________________________
    my $ROOTCINT_CPP =
      $INCLUDE . $main::PATH_SEPARATOR . $INCLUDE . "/tables";
    $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $env1->{ENV}->{ROOTSRC};
    
    my $tobj_dir = $obj_dir . "/Tables";
    $CPPPATH = "";
    if ( $env1->{CPPPATH} ) { $CPPPATH .=  $main::PATH_SEPARATOR . $env1->{CPPPATH};}
    $CPPPATH .= $main::PATH_SEPARATOR . $INCLUDE . "/tables";
#    if ($#QtDefs >= 0) {$CPPPATH .= $main::PATH_SEPARATOR . $env->{ENV}->{QTDIR} . "/include";}
    $env3 = $env1->clone('DEBUG'   => $env1->{NOOPT},
			 'CPPPATH' => $CPPPATH,
			 'ObjDir'  => $tobj_dir,
			 'LIBPATH' => ''
			);
    my $cscanner =
      find scan::cpp( $env1->{_cwd}, $ROOTCINT_CPP );
    my $ROOTCINT_CPPPATH = $cscanner->iflags($env3); #print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n"; die;
    foreach my $idll(@idlT) {
      my $stem = File::Basename::basename( $idll, ".idl" );
      print "stem = $stem; idll: $idll\n" if $param::debug;
      my $dir = File::Basename::dirname($idll);
      print "dir = $dir\n" if $param::debug;
      my $idl  = File::Basename::basename($idll);
      my $idlh = $INCLUDE . "/" . $stem . ".h";
      print "idlh: $idlh\n" if $param::debug;
      my $idli = $INCLUDE . "/" . $stem . ".inc";
      print "idli: $idli\n" if $param::debug;
      my $idlH = $includeT . "/St_" . $stem . "_Table.h";
      print "idlH: $idlH\n" if $param::debug;
      my $idlC = "St_" . $stem . "_Table.cxx";
      print "idlC: $idlC\n" if $param::debug;
      my $LinkDef = $stem . "LinkDef.h";
      push @LinkDefsT, $LinkDef;
      print "LinkDef = $LinkDef\n" if $param::debug;
      my $idlCintH = "St_" . $stem . "_TableCint.h";
      print "idlCintH = $idlCintH\n" if $param::debug;
      my $idlCintC = "St_" . $stem . "_TableCint.cxx";
      print "idlCintC = $idlCintC\n" if $param::debug;
      ( my $IDL = $idll ) =~ s/^\#//g;
      print "IDL = $IDL\n" if $param::debug;
      
      if ( -r $IDL ) {
	my @Deps = ($idll);
	print "Deps: $Deps[0]\n" if $param::debug;
	if ( $STAR_SYS !~ /^intel_wnt$/ ) {
	    $env3->{ENV}->{STICTMP} = "/tmp/$<$$";
	    my $stic_cmd  = 
	      "test -d \$STICTMP && /bin/rm -rf \$STICTMP ; ".
		"/bin/mkdir -p -m 777 \$STICTMP && cd \$STICTMP && ".
		"$STIC -q %<:a && ".
		"(/bin/mv %>:f %>:a ; cd /tmp ; /bin/rm -rf \$STICTMP)";
	  Command $env3 [$idlh], @Deps, qq ($stic_cmd);
	  Command $env3 [$idli], @Deps, qq ($stic_cmd);
	  push @Deps, $idlh;
	  Command $env3 [$idlH], @Deps, qq (ConstructTable.pl %1 %>);
	  push @Deps, $idlH;
	  Command $env3 [$idlC], @Deps, qq (ConstructTable.pl %1 %>);
	  Command $env3 [$LinkDef], @Deps,
	    qq (ConstructTable.pl %1 %>);
	}
	@Deps = ();
	push @Deps, $idlH;
	push @Deps, $LinkDef;
	push @LinkDefs, $LinkDef;
	push @Deps, $idlh;
	push @Deps, $idli;
	
	if ( $STAR_SYS !~ /^intel_wnt$/ ) {
	  Command $env3 [ ($idlCintC , $idlCintH) ], @Deps,
	    qq (rootcint -f %> -c $ROOTCINT_CPPPATH -D__ROOT__ %1 %2);
	}
	push @Deps, $idlCintC;
	push @Deps, $idlCintH;
	push @Deps, $idlC;
	my @src = ( $idlC, $idlCintH, $idlCintC );
	#               Install $env3 $objT, @src; 
      }
      my $s;
      
      if ( $SO_PKGT eq $SO_PKG ) {
	push @src,$idlC;
	push @src, $idlCintC;
      } else {
	push @sourcesT, $idlC;
	push @sourcesT, $idlCintC;
      }
    }
    print "sourcesT = @sourcesT\n" if $param::debug;
  }
}

if ( $#sourcesT > -1 ) {
  script::Keep $SO_PKGT;
  LinkedModule $env3 $SO_PKGT, @sourcesT;
  Install $env3 $LIB, $SO_PKGT;
  if ($env3->{Packages}->{ROOT}->{RLIBMAP} and $SO_MAPT and $#LinkDefsT > -1) {
    Command $env3 [ $SO_MAPT ], ($LIB . "/" . $SO_PKGT, @LinkDefsT), 
      qq($env3->{Packages}->{ROOT}->{RLIBMAP} -r %> -l %1 -c %<); 
    Install $env3 $LIB, $SO_MAPT;
  }
}

if ( $#src > -1 ) {
  my  $envPlain = $env2;
  printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $PKG )
    unless ($param::quiet);
  if ($LIBPKG) {
    Library $env2 $LIBPKG, @src;
    Install $env2 $LIB,    $LIBPKG;
    print "Install $env2 $LIB, $LIBPKG\n" if $param::debug;
    if ($SO_PKG) {
      my $libpkg = $LIB . "/" . File::Basename::basename($LIBPKG);
      Depends $env2 $SO_PKG, $libpkg;
    }
  }
#  print "SO_PKG = $SO_PKG\n";
  if ($SO_PKG) {
    script::Keep $SO_PKG;
    if ($pkg =~ m/StarMagField/) {
      my @o = Objects $env2 (@src);
      @src = @o;
      @PlainObj = ();
      foreach my $s (@o) {
	if ($s !~ /Cint/) {push @PlainObj, $s;}
      }
      $SO_PKG_PLAIN = $pkg . "NoDict";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
    }
    if ($pkg =~ m/^geometry/) {
      $SO_PKG_PLAIN = $pkg . "NoField";
      printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $SO_PKG_PLAIN );
      $SO_PKG_PLAIN .= "." . $env2->{SUFSOLIB};
      my @ss = ();
      foreach my $s (@src) {
	if ($s !~ /mfldgeo/ ) {push @ss, $s}
      }
      @src = @ss;
      @PlainObj = Objects $env2 (@src);
      @src = @PlainObj;
      #      print "PlainObj = @PlainObj\n";
      my $libs = "-lStarMagFieldNoDict";
      $envg = $env2->clone('LIBPATH'  => $LIB, 'LIBS'     => $libs);
      $libs =~ s/-l/lib/;
      $libs = $LIB . "/" . $libs;
      $libs .= "." . $env2->{SUFSOLIB};
      Depends $envg, [($SO_PKG)], ($libs); #print "libs = $libs\n";
      $env2 = $envg;
    }
    LinkedModule $env2 $SO_PKG, @src;
    Install $env2 $LIB,         $SO_PKG;
    my $lib = $LIB . "/" . $SO_PKG;
    if ($SO_PKG ne $SO_PKG_lib) {
      $lib = $LIB . "/" . $SO_PKG_lib;
      InstallAs $env2 $lib, $SO_PKG;
    }
    #    print "SO_PKG = $SO_PKG SO_PKG_PLAIN = $SO_PKG_PLAIN $#PlainObj PlainObj = @PlainObj\n";
    if ($SO_PKG ne $SO_PKG_PLAIN and $#PlainObj > -1) {#print "============================\n";
      script::Keep $SO_PKG_PLAIN;
      LinkedModule $envPlain $SO_PKG_PLAIN, @PlainObj;
      Install $envPlain $LIB,         $SO_PKG_PLAIN;
      if ($SO_PKG_PLAIN !~ /^lib/) {
	my $lib = $LIB . "/lib" . $SO_PKG_PLAIN;
	InstallAs $envPlain $lib, $SO_PKG_PLAIN;
      }
    }
    if ($pkg eq "RTS" and -r "./StRoot/RTS/src/#RTS_READER/Reader.C" and -r "./StRoot/RTS/src/EVP_READER/special.C") {
      my $cppflags = "-DRTS_PROJECT_STAR -DTPXREADER -DRTS_LITTLE_ENDIAN";
      my $cpppath  = $main::PATH_SEPARATOR . "#StRoot/RTS/include" 
	. $main::PATH_SEPARATOR . "#StRoot/RTS/trg/include"
	  . $main::PATH_SEPARATOR . "#StRoot/RTS/include/TPC"
	    . $main::PATH_SEPARATOR . "#StRoot/RTS/src/SFS"
	      . $main::PATH_SEPARATOR . "#StRoot/RTS/src"
		. $main::PATH_SEPARATOR . "StRoot/RTS/src/EVP_READER";
      $envRTS = $env2->clone('Package'  => $pkg,
			     'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS,
			     'CPPPATH'  => $cpppath,
			     'CPPFLAGS' => $cppflags,
			     'LIBPATH'  => $LIB,
			     'LIBS'     => "-lRTS"
		      );
      my @programs = ("RTS_READER/Reader","EVP_READER/special");
      foreach my $progD (@programs) {
	my $prog = File::Basename::basename($progD);
	Program      $envRTS $prog, ("#StRoot/RTS/src/" . $progD . ".C");
	Install $envRTS $BIN, $prog;
      }
    }
  }
}
#_________________________________________________________________________________
sub script::MakeMoc {
  my $envQt  = shift;
  my $pkg  = shift;
  my $done = shift;
  my @includes = split $main::PATH_SEPARATOR,shift;
  my $Dir  = $envQt->{Dir};
  my $ROOTCINTFLAGS = "-I" . $Dir . "/inc";
  my @src      = ();
  my @Defs     = ();
  my $PLATFORM = $envQt->{PLATFORM};
  foreach my $header (@includes) {
    my $dd = $d;
    my $G__name = "moc_" . $header;
    $G__name =~ s/\.h$/\.cxx/; 
    my $moc = $envQt->{Packages}->{QT}->{BINDIR} . "/moc";
    Command $envQt ($G__name), ($header), qq($moc -o %>  %<);
    push @src, $G__name;
    print "+==========add moc file: $G__name\n" if $param::debug;
  }
  return @src;
}
#____________________________________________________________
sub script::alpha_arcom { # 
  my ($lib,$src) = @_;
  my $input = "input" . File::Basename::dirname($lib);
  open (OUTPUT, ">$input") or die "Can't open $input\n";
  print OUTPUT $src;
  close(OUTPUT);
  my $cmd = "ar $lib -input $input'; ranlib $lib"; print "$cmd\n";
  my $flag = `$cmd`; if ($?) {exit 2;}
  return 1;
}

#_________________________________________________________________________________

