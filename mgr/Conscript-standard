#!/opt/star/bin/perl
#use Env;
Import qw ( env INCLUDE LIB BIN  EXPORT BUILD OBJ);
(my $build = $OBJ) =~ s/\#//g;
$build =~ s/\\/\//g;# print "OBJ = $OBJ build = $build MAIN = $MAIN\n";
(my $ObjDir = DirPath '.') =~ s/\\/\//g;# print "ObjDir = $ObjDir\n";
(my $Dir = $ObjDir) =~ s/$build\///g; #print "Dir = $Dir\n";
$ObjDir = "#" . $ObjDir; #print "ObjDir = $ObjDir\n";
(my $obj_dir = $ObjDir) =~ s/^\#//g;# print "obj_dir = $obj_dir\n";
my $STAR_SYS = $env->{ENV}->{STAR_SYS};
my @dirs = ();
my $pkg  = basename($Dir);# print "Run cons in $Dir for $PKG\n";
my $PKG = $pkg;
my @idlM = find_idlM($Dir);   #  $i = 0; for my $s (@idlM) {print "i=",$i++," idlM = ",$s,"\n";}
if ($#idlM > -1) {$PKG = "St_" . $PKG;}
printf ("Run Conscript-standard in %-20s   \tfor %s",$Dir, $PKG) ;
my $obj  = $ObjDir;  #print "obj = $obj\n";
my $SO_PKG = $PKG . "." . $env->{SUFSOLIB}; #print "SO_PKG = $SO_PKG\n";
my $LIBPKG = $PKG . "." . $env->{SUFLIB};
my $SoLibs  = $env->{SoLibs};
if ($pkg =~ /^StDb/) {$SoLibs .= " -L/opt/star/lib/mysql/ -lmysqlclient";}
if ($pkg =~ /^pyth$/){
  if ($STAR_SYS =~ /^i386/) {$SoLibs .= " /cern/pro/lib/libpythia6115.a";}
  else                      {$SoLibs .= " /cern/pro/lib/libpythia6125.a";}
}
(my $share = $EXPORT .  "/" . $Dir) =~ s/\/pams//g;# print "new share $share\n";
$share =~ s/\/StRoot//g;
$share =~ s/\/(sim|gen)//g; 
my $CPPP = "$env->{CPPPATH}:$Dir";#:$share";# print "CPPP = $CPPP\n";
my $CPP  = "";
if ($PKG eq "StHbtMaker") {$CPP = ":#$Dir/Base:#$Dir/CorrFctn:#$Dir/Cut:#$Dir/Fit:#$Dir/Infrastructure:#$Dir/Reader";}
if ($PKG eq "StTrsMaker") {$CPP = ":#$Dir/include";}
$CPPP .= $CPP;  print " --- $CPP\n";
my $include = $INCLUDE . "/" . $pkg;
if ($Dir =~ /pams\//) {
  my $new_cpp = $include . ":" . $CPPP; 
  $CPPP = $new_cpp;# print "new CPPP = $CPPP\n";
}
my $CXXFLAGS = $env->{CXXFLAGS};
if ($STAR_SYS =~ /^sun4x_5/) {$CXXFLAGS .= " -ptr" . $obj_dir;}
$env2 = $env->clone('CPPPATH'      => $CPPP,
		    'CXXFLAGS'     => $CXXFLAGS,
                    'SoLibs'       => $SoLibs);
my $cscanner= find scan::cpp($env2->{_cwd}, $env2->{CPPPATH});
my $CPPPATH = $cscanner->iflags;#  print "CPPPATH = $CPPPATH\n";
my $STIC_CPPPATH = $CPPPATH;
my @cpps = split /:/,$env2->{CPPPATH};# print "@cpps\n";
my $ROOTCINT_CPP ="";
foreach my $cpp (@cpps) {
  if ($cpp =~ /cern/ ||
      $cpp eq "/usr/include"
     )  {next;}
  if ($ROOTCINT_CPP) {$ROOTCINT_CPP .= ":" . $cpp;}
  else               {$ROOTCINT_CPP .= $cpp;}
}
$cscanner= find scan::cpp($env2->{_cwd}, $ROOTCINT_CPP);# print "ROOTCINT_CPP = $ROOTCINT_CPP\n";
my $ROOTCINT_CPPPATH = $cscanner->iflags;# print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n";
my @CintFiles = ($share . "/"  . $PKG . "_Cint.cxx", $share . "/"  . $PKG . "_Cint.h", $share . "/"  . "LinkDef.h"); 
my @srcLL  = find_sources($Dir);#  my $i=0; for my $s (@src) {print "i=",$i++," src = ",$s,"\n";}
my @srcL = ();
#foreach my $i (@srcLL) {push @srcL, "#" . $Dir . "/" . $i;}
foreach my $i (@srcLL) {push @srcL, $i;}
my @h_filesL = find_hfiles($Dir);   #$i = 0; for my $s (@h_files) {print "i=",$i++," h_files = ",$s,"\n";}
my @Repo = Repository_List;# print "Repositories = |@Repo|\n";
foreach my $Rep (@Repo) {
  my $RepDir = $Rep . "/" . $Dir;# print "RepDir = $RepDir\n";
  if (-d $RepDir) {
    my @srcR = find_sources($RepDir);
    foreach my $i (@srcR) {
      #    push @srcL, "#" . $Dir . "/" . $i; 
      push @srcL,  $i; 
    }
    my @h_filesR = find_hfiles($RepDir);
    foreach my $i (@h_filesR) {
      push @h_filesL, $i; 
    }
  }
}
my @src = sortu (@srcL);# print "@src\n";
my @h_files = sortu (@h_filesL);
my $DIR = cwd(); #print "DIR = $DIR\n";
my $line;
my @Defs = ();
if ($Dir !~ /pams\//) {
foreach $h (@h_files) {
  if ($h =~ /LinkDef/ || $h =~ /Stypes/) {push @Defs, $h; next;}
  my $hh = $Dir . "/" . $h;
  open (In,$hh) or die "Can't open $hh";
  while ($line = <In>) {if ($line =~/ClassDef/) {push @Defs, $h; next;}}
  close(In);
}
}
else {
if ($#idlM > -1) {
  for $idl (@idlM) {
    my $stem = basename($idl,".idl"); #print "idl = $idl  stem = $stem\n";
    my $idm  = $stem . ".idl";
    my $idM  = $DIR . "/" . $Dir . "/" . $idl; #print "idM = $idM\n";
    my @idlS = ($idM);
    open (IN, "<$idM") or die  "Can't open $idM";
    while ($line = <IN>) {
      if ($line !~ "include") {next;}
      if ($line =~ "PAM")     {next;}
      my @words = split '"', $line; my $idt = $INCLUDE . "/" . $words[1]; #print "idt = $idt\n";
      push @idlS, $idt; 
    }
    close (IN);
    my $modh = $INCLUDE . "/"   . $stem . ".h";
    my $modi = $INCLUDE . "/"   . $stem . ".inc";
    my $modH = $include . "/"   . "St_" . $stem . "_Module.h"; 
    my $modC = $share . "/"   . "St_" . $stem . "_Module.cxx";# print "mod = $mod\n";
    my @Deps = ($modh,$modi,$modH,$modC);
    if ($STAR_SYS !~ /^intel_wnt$/) {
      Command $env2 [$modh], @idlS,  qq(stic.pl %> -r $STIC_CPPPATH -q %1);  
      Command $env2 [$modi], @idlS,  qq(stic.pl %> -r $STIC_CPPPATH -q %1);  
      Command $env2 [$modH], @idlS,  qq(stic.pl %> -r $STIC_CPPPATH -q %1);  
      Command $env2 [$modC], @idlS,  qq(stic.pl %> -r $STIC_CPPPATH -q %1);  
    }
#    
    my @objmod = ($modC);
    Install $env2 $ObjDir, @objmod;#  print "Install @objmod in $ObjDir\n";
    $mod =~  s/$share/$obj/g;
    push @src, $modC; #print "src: @src\n";
    push @Defs, $modH;
  }
}
}
if ($#Defs > -1) {
  if ($STAR_SYS !~ /^intel_wnt$/) {
#    if ($pkg !~ /St_base/) {push @Defs, $LIB . "/St_base." . $env2->{SUFSOLIB};}
#    if ($pkg !~ /StChain/) {push @Defs, $LIB . "/St_Tables." . $env2->{SUFSOLIB};}
#    push @Defs, $LIB . "/StChain." . $env2->{SUFSOLIB};
#    Install $env2 $share, @Defs;
    Command $env2 [@CintFiles], @Defs,  qq(RootCint.pl "%>" "%<" "$ROOTCINT_CPPPATH" );
  }
  my $linkdef = pop @CintFiles;# print "ObjDir and Cints: $ObjDir => @CintFiles\n";
  Install $env2 $ObjDir, @CintFiles;
  (my $cint =  $CintFiles[0]) =~ s/$share/$obj/g;
  push @src, $cint;# print "+==========add $cint\n"; 
}
if ($#src > -1) {
  if ($STAR_SYS =~ /^intel_wnt$/) {
    Library      $env2 $LIBPKG, @src;  
    Install $env2 $LIB, $LIBPKG;
  }
  LinkedModule $env2 $SO_PKG, @src;
  Install $env2 $LIB, $SO_PKG;
}  
