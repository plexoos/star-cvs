#!/usr/bin/env perl
Import qw ( env INCLUDE LIB BIN  EXPORT BUILD OBJ);
(my $build = $OBJ) =~ s/\#//g;
$build =~ s/\\/\//g;# print "OBJ = $OBJ build = $build MAIN = $MAIN\n";
my $DirPath = DirPath '.';# print "DirPath = $DirPath\n"; 
(my $ObjDir = $DirPath) =~ s/\\/\//g;# print "ObjDir = $ObjDir\n";
(my $Dir = $ObjDir) =~ s/$build\///g;# print "Dir = $Dir\n";
$ObjDir = "#" . $ObjDir; #print "ObjDir = $ObjDir\n";
(my $obj_dir = $ObjDir) =~ s/^\#//g;# print "obj_dir = $obj_dir\n";
my $STAR_SYS = $env->{ENV}->{STAR_SYS};
@Repo = Repository_List unless $param::noRepository; #print "Repositories = |@Repo|\n";
my $pkg  = basename($Dir);# print "Run cons in $Dir for $PKG\n";
my $PKG = $pkg;
my @idlL     = find_idl($Dir);  print "In Dir = $Dir idlL = @idlL\n"  if $param::debug;
foreach my $Rep (@Repo) {
  my $RepDir = $Rep . "/" . $Dir; print "RepDir = $RepDir\n" if $param::debug;
  if (-d $RepDir) {
    my @idlR = find_idl($RepDir);
    foreach my $i (@idlR) {push @idlL, $i;}
  }
}
my @idlL   = sortu (@idlL); print "idlL = @idlL\n" if $param::debug;
if ($pkg =~ /^sim$/ || $pkg =~ /^gen$/) {goto Tables;}
my $i;
my @idlML    = find_idlM($Dir);    
if ($param::debug){$i = 0; foreach my $s (@idlML) {print "i=",$i++," idlM = ",$s,"\n";}} 

my @srcL     = find_sources($Dir); 
if ($param::debug){$i = 0; foreach my $s (@srcL) {print "i=",$i++," src = ",$s,"\n";}}
my @h_filesL = find_hfiles($Dir);  
if ($param::debug){$i = 0; foreach my $s (@h_files) {print "i=",$i++," h_files = ",$s,"\n";}}
foreach my $Rep (@Repo) {
  my $RepDir = $Rep . "/" . $Dir; print "RepDir = $RepDir\n" if $param::debug;
  if (-d $RepDir) {
    my @srcR = find_sources($RepDir);# my $i=0; for my $s (@srcR) {print "i=",$i++," src = ",$s,"\n";}
    foreach my $i (@srcR) {push @srcL,  $i;}
    my @idlMR = find_idlM($RepDir); 
    foreach my $i (@idlMR) {push @idlML, $i;}
    my @h_filesR = find_hfiles($RepDir);
    foreach my $i (@h_filesR) {push @h_filesL, $i;}
  }
}
my @src     = sortu (@srcL);# print "src = @src\n";
my @h_files = sortu (@h_filesL);
my @idlM    = sortu (@idlML);# print "idlM = @idlM\n";
if ($#idlM > -1) {$PKG = "St_" . $PKG;}
my $obj  = $ObjDir;  print "obj = $obj\n" if $param::debug;
my $SO_PKG = $PKG . "." . $env->{SUFSOLIB}; print "SO_PKG = $SO_PKG\n" if $param::debug;
my $SO_PKGT = "";
my $LIBS  = $env->{LIBS};
my $LIBPATH = $env->{LIBPATH};
if ($pkg =~ /^StDb/ || $pkg =~ /^StTpcDb/) {
  if ($LIBPATH) { $LIBPATH .=":";}
  $LIBPATH .= "/opt/star/lib/mysql"; print "LIBPATH = $LIBPATH\n" if $param::debug;
  $LIBS .= " -lmysqlclient"; print "LIBS = $LIBS\n" if $param::debug;
}
if ($pkg =~ /^pyth$/){
  my $CERN_ROOT = $env->{ENV}->{CERN_ROOT}; print "CERN_ROOT = $CERN_ROOT\n" if $param::debug;
  if ($LIBPATH) { $LIBPATH .=":";}
  $LIBPATH .= $CERN_ROOT . "/lib";
  $LIBS    .= " -lpythia ";  
#  if ($STAR_SYS =~ /^i386/) {
#   $LIBPATH .=  ":/usr/local/lib/gcc-lib/i686-pc-linux-gnu/egcs-2.91.66";
#   $LIBS    .= " -lg2c";
# }
}
(my $share = $EXPORT .  "/" . $Dir) =~ s/\/pams//g; print "new share $share\n" if $param::debug;
$share =~ s/\/StRoot//g;
$share =~ s/\/(sim|gen)//g; 
my $CPPPATH = $env->{CPPPATH};
if ($pkg =~ /^StTrsMaker$/) {
  $CPPPATH = "#" . $Dir . ":#" . $Dir . "/include:" . $env->{CPPPATH}; print "CPPPATH = $CPPPATH\n" if $param::debug;
}
if ($pkg =~ /^StHbtMaker$/) {
  $CPPPATH = "#" . $Dir;
  foreach my $subdir ("Base","Infrastructure","Reader","Cut","CorrFctn","Fit") {
    $CPPPATH .= ":#" . $Dir . "/" . $subdir; 
  }
  $CPPPATH .= ":" . $env->{CPPPATH}; print "CPPPATH = $CPPPATH\n" if $param::debug;
}

if ($pkg =~ /^StDaqLib$/) {$CPPPATH = "#" . $Dir . ":" . $env->{CPPPATH}; print "CPPPATH = $CPPPATH\n"  if $param::debug;}
if ($Dir =~ /pams\//) {
  $CPPPATH = $INCLUDE . "/" . $pkg . ":" . $CPPPATH; print "CPPPATH = $CPPPATH\n" if $param::debug;
}
elsif ($#idlL > -1) {
  $CPPPATH .= ":" . $INCLUDE . "/tables"; print "CPPPATH = $CPPPATH\n" if $param::debug;
}
my $LIBPKG = "";
my @srco = @src;
if ($LIBPKG && $Dir =~ /pams\// || $STAR_SYS =~ /^intel_wnt$/) {
  $LIBS  .= " -l" . $pkg; #"lib" . $pkg . "." . $env->{SUFLIB};
}
if ($STAR_SYS =~ /^hp_ux102$/ && $pkg =~ /^St_base$/) {$CPPPATH .= ":/usr/local/include";}
my $CXXFLAGS = $env->{CXXFLAGS};
my $FCCOM    = $env->{FCCOM};
if ($STAR_SYS =~ /^sun4x_5.$/) {$CXXFLAGS .= " -ptr" . $obj_dir;}
if ($STAR_SYS =~ /kcc$/)  {$LIBPATH = ""; $LIBS = "";}
#if ($STAR_SYS =~ /^sun4x_56_CC5$/) {
#  if (!$LIBPATH) {$LIBPATH  = "/opt/WS5.0/SC5.0/lib";}
#  else           {$LIBPATH .= ":/opt/WS5.0/SC5.0/lib";}
#  $LIBS    .= " -lCstd -liostream";
#}
$env2 = $env->clone('CPPPATH'      => $CPPPATH,
		    'CXXFLAGS'     => $CXXFLAGS,
		    'FCCOM'        => $FCCOM,
                    'LIBPATH'      => $LIBPATH,
                    'LIBS'         => $LIBS,
		    'share'        => $share,
		    'ObjDir'       => $ObjDir
		   );
print "LIBPATH = |", $env2->{LIBPATH}, "|\n LIBS = |",$env2->{LIBS},"|\n"  if $param::debug;
print "LINKMODULECOM |",$env2->{LINKMODULECOM},"|\n"  if $param::debug;
my $cscanner= find scan::cpp($env2->{_cwd}, $env2->{CPPPATH});
my $CPPPATH = $cscanner->iflags($env2);  print "CPPPATH = $CPPPATH\n" if $param::debug;
my @cpps = split /:/,$env2->{CPPPATH}; print "@cpps\n" if $param::debug;
my $ROOTCINT_CPP ="";
my $STIC_CPP = "";
foreach my $cpp ($Dir,@cpps) {
  if ($cpp =~ /cern/ ||
      $cpp eq "/usr/include" ||
      $cpp =~ /ospace/ || 
      $cpp =~ /openwin/
     )  {next;}
  if ($ROOTCINT_CPP) {$ROOTCINT_CPP .= ":" . $cpp;}
  else               {$ROOTCINT_CPP  = $cpp;}
  if ($cpp =~ /ROOT/) {next};
  if ($STIC_CPP) {$STIC_CPP .= ":" . $cpp;}
  else           {$STIC_CPP = $cpp;}
}
$cscanner= find scan::cpp($env2->{_cwd}, $ROOTCINT_CPP); print "ROOTCINT_CPP = $ROOTCINT_CPP\n" if $param::debug;
my $ROOTCINT_CPPPATH = $cscanner->iflags($env2); 
#$ROOTCINT_CPPPATH .= " -I" . $env->{ENV}->{ROOTSYS} . "/root/cint/stl";
print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n" if $param::debug;
$cscanner= find scan::cpp($env2->{_cwd}, $STIC_CPP);
my $STIC_CPPPATH = $cscanner->iflags($env2);# print "STIC_CPPPATH  = $STIC_CPPPATH\n";
my $DIR = cwd(); print "DIR = $DIR\n" if $param::debug;
my $line;
my @Defs = ();
if ($#idlM > -1) {
  my $include = $INCLUDE . "/" . $pkg; print "include = $include\n" if $param::debug;
  foreach my $idl (@idlM) {
    my $stem = basename($idl,".idl"); print "idl = $idl  stem = $stem\n" if $param::debug;
    my $idm  = $stem . ".idl";
    my $idMM = $DIR . "/" . $Dir . "/" . $idl; print "idMM = $idMM\n" if $param::debug;
    my $idM  = "#" . $Dir . "/" . $idl; print "idM = $idM\n" if $param::debug;
    my @idlS = ($idM);
    my $modh = $INCLUDE . "/"   . $stem . ".h";
    my $modi = $INCLUDE . "/"   . $stem . ".inc";
    my $modH = $include . "/"   . "St_" . $stem . "_Module.h"; print "modH = $modH\n" if $param::debug;
    my $modC = $share . "/"   . "St_" . $stem . "_Module.cxx"; print "modC = $modC\n" if $param::debug;
    if ($STAR_SYS !~ /^intel_wnt$/) {
      Command $env2 [$modh], @idlS,  qq(stic.pl %> -s -r $STIC_CPPPATH -q %1);  
      Command $env2 [$modi], @idlS,  qq(stic.pl %> -s -r $STIC_CPPPATH -q %1);  
      Command $env2 [$modH], @idlS,  qq(stic.pl %> -s -r $STIC_CPPPATH -q %1);  
      Command $env2 [$modC], @idlS,  qq(stic.pl %> -s -r $STIC_CPPPATH -q %1);  
    }
    my @objmod = ($modC);
    Install $env2 $ObjDir, @objmod;  print "Install @objmod in $ObjDir\n" if $param::debug;
    (my $mod = $modC) =~  s/$share/$obj/g; 
    push @src, $mod; print "src + $mod: @src\n" if $param::debug;
    push @Defs, $modH;
  }
}
else {
  foreach $h (@h_files) {
    if ($h =~ /LinkDef/ || $h =~ /Stypes/) {push @Defs, $h; next;}
    my $hh = $Dir . "/" . $h;
    if (-r $hh) {
      open (In,$hh) or die "Can't open $hh";
      while ($line = <In>) {if ($line =~/ClassDef/ || $line =~ /StCollectionDef/) {push @Defs, $h; goto ENDL;}}
      close(In);
    }
    else {      
      foreach my $Rep (@Repo) {
	my $RepDir = $Rep . "/" . $Dir; print "RepDir = $RepDir\n" if $param::debug;
	if (-d $RepDir) {
	  my $hh = $RepDir . "/" . $h;
	  if (-r $hh) {
	    open (In,$hh) or die "Can't open $hh";
	    while ($line = <In>) {if ($line =~/ClassDef/ || $line =~ /StCollectionDef/) {push @Defs, $h; goto ENDL;}}
	    close(In);
	  }
	}
      }
    }
  ENDL:
  }
}
if ($#Defs > -1) {
  my @CintFiles = 
  ($share . "/"  . $PKG . "_Cint.cxx", $share . "/"  . $PKG . "_Cint.h");#, $share . "/"  . "LinkDef.h"); 
  Install $env2 $share, @Defs;
  my @defs = ();
  foreach my $def (@Defs) {#print "def = $def OBJ = $OBJ\n";
    if ($def =~ /^\#/) {push @defs, $def;}			   
    else               {push @defs, "#" . $Dir . "/" . $def;}
  }# print "defs = @defs\n";
  Command $env2 [@CintFiles], @defs,  qq(RootCint.pl "%>" "%<" "$ROOTCINT_CPPPATH" );
  Install $env2 $ObjDir, @CintFiles;
  (my $cint =  $CintFiles[0]) =~ s/$share/$obj/g;
  push @src, $cint; print "+==========add $cint\n" if $param::debug; 
}

#____________________________________Tables____________________________
Tables: 
my @sourcesT = (); 

if ($#idlL > -1) {
  my @idlT = ();
  my $objT = $OBJ . "/pams/tables";
  (my $objT_dir = $objT) =~ s/^\#//g; print "objT_dir = $objT_dir\n" if $param::debug;
  my $shareT  = "#.share/tables"; print "shareT = $shareT\n" if $param::debug;
  my $includeT = $INCLUDE . "/tables"; print "includeT = $includeT\n" if $param::debug;
  my $SHARET  = $DIR . "/.share/tables";
  foreach my $idl (@idlL) {  print "$idl\n" if $param::debug;
    my $IDL = "#" . $Dir . "/" . $idl;# print "i=",$i++," idl = $idl IDL=$IDL\n";
    my $stem = basename ($IDL, ".idl"); print "stem = $stem\n" if $param::debug;
    my $idlt = $includeT . "/" . basename($idl);
    push @idlT, $IDL; 
  }
  print "idlT = @idlT\n" if $param::debug;
  if ($#idlT > -1) {
    $PKGT = "lib" . $pkg . "_Tables";
    $SO_PKGT = $PKGT . "." . $env->{SUFSOLIB}; print "SO_PKGT = $SO_PKGT\n" if $param::debug;
    my $LIBPKGT = $PKGT . "." . $env->{SUFLIB};
    if ($Dir =~ /StRoot\//) {
      $SO_PKGT = $SO_PKG;
      $LIBPKGT = $LIBPKG;
    }
    else {
      printf ("Run Conscript-standard in %-30s  for %-20s\n",$Dir, $PKGT) unless ($param::quiet);
    }
    Install $env $INCLUDE, @idlT;# print "Install $env $INCLUDE, @idlT\n";
    #___________________________________
    my $ROOTCINT_CPP = $INCLUDE . ":" . $INCLUDE . "/tables:" . $shareT . ":" . $env->{ENV}->{ROOTSRC};
    my $CXXFLAGS = $env->{CXXFLAGS};
    my $LINKMODULECOM = $env->{LINKMODULECOM};
    if ($STAR_SYS =~ /^sun4x_5.$/) {
      $CXXFLAGS .= " -ptr" . $obj_dir . "/Tables" ;
      $LINKMODULECOM = "%SO %DEBUG %SOFLAGS %SoOUT%> %< %>:d/Tables/Templates.DB/*.o %_LDIRS %LIBS";
    }
    if ($SO_PKGT eq $SO_PKG) {
      $CPPPATH = $env2->{CPPPATH} . ":" . $INCLUDE . "/tables";
      $env3 = $env->clone(
			  'CPPPATH'    => $CPPPATH
			 );
    }
    else {
      $env3 = $env->clone(
			  'DEBUG'      => ' ',
			  'CPPPATH'    =>$ROOTCINT_CPP,
			  'CXXFLAGS'   => $CXXFLAGS,
			  'LINKMODULECOM'=> $LINKMODULECOM
			 );
    }
    my $cscanner= find scan::cpp($env->{_cwd}, $ROOTCINT_CPP);# print "ROOTCINT_CPP = $ROOTCINT_CPP\n";
    my $ROOTCINT_CPPPATH = $cscanner->iflags($env3);# print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n";
    
    foreach my $idll (@idlT) { 
      my $stem     = basename ($idll, ".idl"); print "stem = $stem; idll: $idll\n" if $param::debug;
      my $dir      = dirname ($idll); print "dir = $dir\n" if $param::debug;
      my $idl      = basename ($idll);
      my $idlh     = $INCLUDE . "/"    . $stem . ".h";             print "idlh: $idlh\n" if $param::debug;
      my $idli     = $INCLUDE . "/"    . $stem . ".inc";           print "idli: $idli\n" if $param::debug;
      my $idlH     = $includeT . "/St_" . $stem . "_Table.h";      print "idlH: $idlH\n" if $param::debug;
      my $idlC     = $shareT   . "/St_" . $stem . "_Table.cxx";    print "idlC: $idlC\n" if $param::debug;
      my $LinkDef  = $shareT   . "/"    . $stem . "LinkDef.h";     print "LinkDef = $LinkDef\n" if $param::debug;
      my $idlCintH = $shareT   . "/St_" . $stem . "_TableCint.h";  print "idlCintH = $idlCintH\n" if $param::debug;
      my $idlCintC = $shareT   . "/St_" . $stem . "_TableCint.cxx";print "idlCintC = $idlCintC\n" if $param::debug;
      (my $IDL = $idll) =~ s/^\#//g; print "IDL = $IDL\n" if $param::debug;
      if (-r $IDL) { 
	my @Deps = ($idll); print "Deps: $Deps[0]\n" if $param::debug;
	if ($STAR_SYS !~ /^intel_wnt$/) {
	  Command $env3 [$idlh],        @Deps, qq (stic.pl %>  -q %1 );
	  Command $env3 [$idli],        @Deps, qq (stic.pl %>  -q %1 );
	  push @Deps, $idlh;
	  Command $env3 [$idlH],        @Deps, qq (ConstructTable.pl %1 %>);
	  push @Deps, $idlH;
	  Command $env3 [$idlC],        @Deps, qq (ConstructTable.pl %1 %>);
	  Command $env3 [$LinkDef],     @Deps, qq (ConstructTable.pl %1 %>);
#	  Install $env $share, @Deps; print "Install $env3 $share, @Deps;\n";
	}
	@Deps = ();
	push @Deps, $idlH;
	push @Deps, $LinkDef;
	push @Deps, $idlh;
	push @Deps, $idli;
#	push @Deps, $INCLUDE . "/Stypes.h";
#	push @Deps, $INCLUDE . "/St_Table.h";
#	push @Deps, $INCLUDE . "/St_DataSet.h";
#	push @Deps, $INCLUDE . "/tableDescriptor.h";
#	Depends $env3 [$idlCintH,$idlCintC], $LinkDef;
	if ($STAR_SYS !~ /^intel_wnt$/) {
	  Command $env3 [$idlCintC, $idlCintH], @Deps,  
	  qq (rootcint.pl %>:d -f %>:f -c  "$ROOTCINT_CPPPATH -D__ROOT__" %1:f %2:f);
	}
	push @Deps, $idlCintC;
	push @Deps, $idlCintH;
	push @Deps, $idlC;
	my @src  = ($idlC,$idlCintH,$idlCintC);
	Install $env3 $objT, @src; #print "Install $env3 $objT, @src\n";
      }
      my $s;
      
      if ($SO_PKGT eq $SO_PKG) {
	($s = $idlC)     =~  s/$shareT/$objT/g; push @src, $s;
	($s = $idlCintC) =~  s/$shareT/$objT/g; push @src, $s;
      }
      else {
	($s = $idlC)     =~  s/$shareT/$objT/g; push @sourcesT, $s;
	($s = $idlCintC) =~  s/$shareT/$objT/g; push @sourcesT, $s;
      }
    } print "sourcesT = @sourcesT\n" if $param::debug;
  }
}
if ($#sourcesT > -1) {
  LinkedModule $env3 $SO_PKGT, @sourcesT;
  Install $env3 $LIB, $SO_PKGT;
}
if ($#src > -1) {
  printf ("Run Conscript-standard in %-30s  for %-20s\n",$Dir, $PKG) unless ($param::quiet);
  if ($LIBPKG) {
    Library      $env2 $LIBPKG, @src;  
    Install $env2 $LIB, $LIBPKG; print "Install $env2 $LIB, $LIBPKG\n" if $param::debug;
    my $libpkg = $LIB . "/" . basename($LIBPKG);
    Depends $env2 $SO_PKG, $libpkg;
  }
  LinkedModule $env2 $SO_PKG, @src;
  Install $env2 $LIB, $SO_PKG;
  if ($pkg eq "Star2Root"   or
      $pkg eq "St_base"     or 
      $pkg eq "StUtilities"
     ) {my $lib = $LIB . "/lib" . $SO_PKG; InstallAs $env2 $lib, $SO_PKG;}
}

#________________________________________________________________________________
  
  
