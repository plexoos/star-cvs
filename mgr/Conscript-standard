#!/opt/star/bin/perl
#use Env;
Import qw ( env INCLUDE LIB BIN  EXPORT BUILD OBJ);
(my $build = $OBJ) =~ s/\#//g;
$build =~ s/\\/\//g; #print "OBJ = $OBJ build = $build MAIN = $MAIN\n";
(my $ObjDir = DirPath '.') =~ s/\\/\//g; #print "ObjDir = $ObjDir\n";
(my $Dir = $ObjDir) =~ s/$build\///g; #print "Dir = $Dir\n";
my @DirList = ( "ctf","db","ebye","emc","ftpc","geometry","global","l3","mwc",
		"strange","svt","tpc","trg","vpd",
		"gen/crs","gen/fri","gen/g2x","gen/hij","gen/mev","gen/par","gen/pyth","gen/ven",
		"sim/control","sim/dig","sim/g2r","sim/gstar");

my @dirs = ();
my @incs = ();
my @source = ();
my $PKG  = basename($Dir); print "Run cons in $Dir for $PKG\n";
if ($PKG eq "StRoot") {
#         ________________
  @sources = find_sources($PKG); 
#  my $i=0; for my $s (@sources) {print "i=",$i++," sources = ",$s,"\n";}
  my $dirlist = "";
  for $src (@sources) {
    (my $dir = $src) =~ s/\/\S*/$1/g; #print "$src => $dir\n";
    if (grep (/$dir/,$dirlist)) {next;}
    if (!grep (/StEvent/,$dir))  {next;}
    if (grep (/StTpcDb/,$dir))  {next;}
    $dirlist .= $dir . ": "; #print "dirlist = $dirlist\n";
  }
  $dirlist =~ s/$pwd\///g; #print "dirlist = $dirlist\n";
  $dirlist =~ s/\:/\/Conscript/g;# print "dirlist = $dirlist\n";
  my @dirs = split ' ',$dirlist;
  Build @dirs;
}
elsif ($PKG eq "pams") {
  #          ___________
  
  @sources = find_sources($PKG);
  @incs = find_inc ($PKG);
  Install $env $INCLUDE, @incs;
  for my $dir  (@DirList) {
    my $DirName = $PKG . "/" . $dir; #print "Dir = $Dir\n";
    if (-d $DirName) {push @dirs, $dir;}
  }
  my @Targets = ();
  for my $dir (@dirs) {
    my $Cons = $dir . "/Conscript";# print "Cons = $Cons\n";
    push @Targets, $Cons;
  } 
  Build @Targets;
}
else {
  my($cscanner) = find scan::cpp($env->{_cwd}, $env->{CPPPATH});
  my $CPPPATH = $cscanner->iflags;#  print "CPPPATH = $CPPPATH\n";
  if ($Dir =~ /^pams/) {$PKG = "St_" . $PKG;}#  print "Run Conscript-standard in $Dir for $PKG\n";
  my $SO_PKG = $PKG . "." . $env->{SUFSOLIB};# print "SO_PKG = $SO_PKG\n";
  my @CintFiles = ($PKG . "_Cint.cxx", $PKG . "_Cint.h", "LinkDef.h"); 
  my @src  = find_sources($Dir);  #my $i=0; for my $s (@src) {print "i=",$i++," src = ",$s,"\n";}
  my @Defs = find_hfiles($Dir);   #$i = 0; for my $s (@Defs) {print "i=",$i++," Defs = ",$s,"\n";}
  my @idlM = find_idlM($Dir);     #$i = 0; for my $s (@idlM) {print "i=",$i++," idlM = ",$s,"\n";}
  my $DIR = $OBJ . "/" . $Dir . "/";
  (my $dir = $DIR) =~ s/\#//g;
  my $line;
  
  if ($#idlM > -1) {
    for $idl (@idlM) {
      my $stem = basename($idl,".idl");# print "stem = $stem\n";
      my $idm  = $stem . ".idl";
      my $idM = $Dir . "/" . $idl; 
      my @idlS = ($idl);
      open (IN, "<$idM") or die  "Can't open $idM";
      while ($line = <IN>) {
	if ($line !~ "include") {next;}
	if ($line =~ "PAM")     {next;}
	my @words = split '"', $line; my $idt = $EXPORT . "/tables/" . $words[1]; #print "idt = $idt\n";
	push @idlS, $idt; 
      }
      close (IN);
      my @Deps = ();
      push @Deps,$DIR . $stem . ".h";
      push @Deps,$DIR . $stem . ".inc";
      push @Deps,$DIR . "St_" . $stem . "_Module.h";
      push @Deps,$DIR . "St_" . $stem . "_Module.cxx";#    print "@Deps\n";
      my $cmd = "cd $dir &&  stic -r $CPPPATH -q $idl";# print "stic cmd: $cmd\n";
      Command $env [@Deps], @idlS, 
      qq(
	 $cmd
	);  
      my @incs = ($Deps[0],$Deps[1]); 
      Install $env $INCLUDE, @incs;  #print "Install incs = @incs in $INCLUDE\n";
      (my $share = $EXPORT .  "/" . $Dir) =~ s/\/pams//g; ; #print "new share $share\n";
      $share =~ s/\/(sim|gen)//g; 
      Install $env $share, $Deps[2];
      push @src, $Deps[3]; #print "src: @src\n";
      push @Defs, $Deps[2];
    }
  }
  if ($#Defs > -1) {
#    Command $env [@CintFiles], @Defs,  qq(perl mgr/RootCint.pl "%>" "%<" "$CPPPATH" );
    Command $env [@CintFiles], @Defs,  qq(RootCint.pl "%>" "%<" "$CPPPATH" );
    push @src, $CintFiles[0]; #print "+==========add $CintFiles[0]\n"; 
  }
  LinkedModule $env $SO_PKG, @src;
  Install $env $LIB, $SO_PKG;
}
