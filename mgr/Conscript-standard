#!/usr/bin/env perl
Import qw ( env INCLUDE LIB BIN BUILD OBJ);
( my $build = $OBJ ) =~ s/\#//g;
$build =~ s/\\/\//g;                                    # print "OBJ = $OBJ build = $build\n";
                                                        # print "MAIN = $MAIN\n";
my $DirPath = DirPath '.';                              # print "DirPath = $DirPath\n";
( my $obj_dir = $DirPath ) =~ s/\\/\//g;                # print "obj_dir = $obj_dir\n";
( my $Dir = $obj_dir ) =~ s/$build\///g;                # print "Dir = $Dir\n";
my $ObjDir   = "#" . $obj_dir;                          # print "ObjDir = $ObjDir\n";
my $STAR_SYS     = $env->{ENV}->{STAR_SYS};
my $STAR_VERSION = $env->{ENV}->{STAR_VERSION};         # print "#####  $STAR_VER\n";
my $AFS_RHIC     = $env->{ENV}->{AFS_RHIC};  

@Repo   = Repository_List unless $param::noRepository;  # print "Repositories = |@Repo|\n";nv

my $SO_PKG  = "";
my $SO_PKGT = "";
my $pkg;
my $PKG;

if ( ($Dir =~ m/StRoot.*Pool\// && $Dir !~ /StRoot.*Pool\/St/) ||
     ($Dir =~ m/StRoot.*Client\// && $Dir !~ /StRoot.*Client\/St/)  ){
    # Added 2003. In Construct, the logic is such
    # that the Pool directories have their sub-directories
    # set as targets (n sub-dir => n libraries). That's
    # fine ... apart from name clash we try to resolve
    # here.
    $pkg = $Dir;
    $pkg =~ s/StRoot\///;
    $pkg =~ s/Pool\//Pool/      if ($pkg =~ m/Pool/);
    $pkg =~ s/Client\//Client/  if ($pkg =~ m/Client/);
    $PKG = $pkg;
    print "\t[".File::Basename::basename($Dir)."] (possible name clash) changed to $pkg\n";

} else {
    $pkg = File::Basename::basename($Dir);               # print "Run cons in $Dir for $PKG\n";
    $PKG = $pkg;
}

my @idlL    = script::find_idl($Dir);
print "In Dir = $Dir idlL = @idlL\n" if $param::debug;
foreach my $Rep(@Repo) {
    my $RepDir = $Rep . "/" . $Dir;
    print "RepDir = $RepDir\n" if $param::debug;
    if ( -d $RepDir ) {
        my @idlR = script::find_idl($RepDir);
        foreach my $i(@idlR) { push @idlL, $i; }
    }
}
@idlL = script::sortu(@idlL);

my @idlML    = script::find_idlM($Dir);
my @srcL     = script::find_sources($Dir);
my @h_filesL = script::find_hfiles($Dir);

print "idlL = @idlL\n" if $param::debug;

my (@src, @h_files, @idlM);
my $CPPPATH = $env->{CPPPATH};
my $CXXFLAGS= $env->{CXXFLAGS};
my $FC      = $env->{FC};
my $CC      = $env->{CC};
my $FFLAGS  = $env->{FFLAGS};
my $FCPATH  = $env->{FCPATH};
my $FEXTEND = $env->{FEXTEND};
my $FPPFLAGS= $env->{FPPFLAGS};
my $FCCOM   = $env->{FCCOM};
my $LIBS    = $env->{LIBS};
my $LIBPATH = $env->{LIBPATH};
my $EXTRA_CPPFLAGS = $env->{EXTRA_CPPFLAGS};
my ($i, $obj);
my $LIBPKG = "";
my @g77pkgs = qw(gcalor geant321 agetof StBichsel Bichsel geometry gen sim StEeFit); 
my $g77pkgs = join('|', @g77pkgs);
if ($FC eq 'pgf77' && $pkg =~ /$g77pkgs/) {
  $FC       = $env->{G77}; print "set FC => $FC ==============================\n" if $param::debug;
  $FFLAGS   = $env->{G77FLAGS}; 
  $FEXTEND  = $env->{G77EXTEND};
} 
if ($FC eq 'g77' and ($pkg eq 'gen' or $pkg eq 'sim' or  $DirPath =~ /pams|StRoot/ and ! ($pkg =~ /$g77pkgs/))) {
  $FCCOM    = $env->{FCviaAGETOFCOM};
}

if ( $pkg !~ /^sim$/ && $pkg !~ /^gen$/ ) {
    print "\t--- Regular case treatment (not gen not sim) ---\n" if $param::debug;

    if ($param::debug) {
	$i = 0;
	foreach my $s(@idlML) { print "i=", $i++, " idlM = ", $s, "\n"; }
	$i = 0;
	foreach my $s(@srcL) { print "i=", $i++, " src = ", $s, "\n"; }
	$i = 0;
	foreach my $s(@h_files) { print "i=", $i++, " h_files = ", $s, "\n"; }
    }


    foreach my $Rep(@Repo) {
	my $RepDir = $Rep . "/" . $Dir;
	print "RepDir = $RepDir\n" if $param::debug;

	if ( -d $RepDir ) {
	    my @srcR =
		script::find_sources($RepDir);
	    foreach my $i(@srcR) { push @srcL, $i; }
	    my @idlMR = script::find_idlM($RepDir);

	    foreach my $i(@idlMR) { push @idlML, $i; }
	    my @h_filesR = script::find_hfiles($RepDir);
	    foreach my $i(@h_filesR) { push @h_filesL, $i; }
	}
    }
    @src     = script::sortu(@srcL);
    @h_files = script::sortu(@h_filesL);
    @idlM    = script::sortu(@idlML);
    if ( $#idlM > -1 and $PKG !~ "^St" ) { $PKG = "St_" . $PKG; }

    $obj = $ObjDir;
    print "obj = $obj\n" if $param::debug;
    $SO_PKG = $PKG . "." . $env->{SUFSOLIB};
    print "SO_PKG = $SO_PKG\n" if $param::debug;

    #+
    # Extraneous flag treatment for specific makers
    # Search path depth for Makers.
    #-
    print "-=-=-=-=- Will now test $pkg\n" if ($param::debug);
    if ( $pkg =~ m/^StEventDisplay/){
	# This make requires both ROOT Qt and QT libraries
	if ( defined($env->{Packages}->{QT}->{DIR}) && (-r $ENV{ROOTSYS} . "/include/TQt.h" || -r $ENV{ROOTSYS} . "/include/TGQt.h")){
	    #print "-=-=-=-=-=-=-=- QT is defined -=-=-=-=-=-=-=-=-=-=\n";
	    $CPPPATH .= $main::PATH_SEPARATOR . $env->{Packages}->{QT}->{INCDIR};
	    $LIBPATH .= $main::PATH_SEPARATOR . $env->{Packages}->{QT}->{LIBDIR}; 
	    #$LIBS ... should come loaded from ROOT 
	    $CXXFLAGS.= " " . $env->{Packages}->{QT}->{FLAGS}; 
	}
    } elsif ( $pkg =~ m/^St.*Db/ ) {
	$CPPPATH .= $main::PATH_SEPARATOR .  $env->{Packages}->{MYSQL}->{INCDIR};
	print "CPPPATH = $CPPPATH\n" if $param::debug;
	
    } elsif ( $pkg =~ m/^pyth$/ ) {
	my $CERN_ROOT = $env->{ENV}->{CERN_ROOT};
	print "CERN_ROOT = $CERN_ROOT\n" if $param::debug;
	if ($LIBPATH) { $LIBPATH .= $main::PATH_SEPARATOR; }
	$LIBPATH .= $CERN_ROOT . "/lib";
	foreach my $py ("pythia","pythia6152","pythia6136") {
	    my $file = $CERN_ROOT . "/lib/lib" . $py . ".a";
	    if (-f $file) {$LIBS .= " -l" . $py; last;}
	}

    } elsif ( $pkg =~ m/^StTrsMaker$/ ){
	$CPPPATH =
	    "#" . $Dir . $main::PATH_SEPARATOR . "#" . $Dir . "/include"
	    . $main::PATH_SEPARATOR . $env->{CPPPATH};
	print "CPPPATH = $CPPPATH\n" if $param::debug;

    } elsif ( $pkg =~ m/^StHbtMaker$/ ) {
	$CPPPATH = "#" . $Dir;
	foreach
	    my $subdir( "Base", "Infrastructure", "Reader", "Cut",
			"CorrFctn", "Fit", "ThCorrFctn")
	{
	    $CPPPATH .= $main::PATH_SEPARATOR . "#" . $Dir . "/" . $subdir;
	}
	$CPPPATH .= $main::PATH_SEPARATOR . $env->{CPPPATH};
	print "CPPPATH = $CPPPATH\n" if $param::debug;


	# According to description, all client requirering this
	# should be added here.
    } elsif ( $pkg =~ m/^StRTSClient/ ) {
	my ($basep) = $Dir;
	$basep =~ s/Client\/.*/Client/;
	$CPPPATH =
	    "#" . $Dir . $main::PATH_SEPARATOR ."#". $basep ."/include" 
	    . $main::PATH_SEPARATOR . $env->{CPPPATH};
	print "CPPPATH = $CPPPATH\n" if $param::debug;

	

	# This block can be used for ANY Maker or Pool having a 2 level
	# directory structure using auto-globbing for include purposes
    } elsif ( $pkg =~ m/^StAssociationMaker$/ ||
	      $pkg =~ m/EmcUtil$/             ||
	      $pkg =~ m/^StMuDSTMaker$/       ||
	      $pkg =~ m/^StEEmcPool$/         ||
	      $pkg =~ m/^StTofPool$/          ||
	      $pkg =~ m/^StRichPool$/         ||
	      $pkg =~ m/^Sti/           ) {
	$CPPPATH = "#" . $Dir;

	print "WARNING Package $pkg requires a glob() to be called\n" if $param::debug;

	foreach my $subdir ( glob("$Dir/*") ){
	    if( -d $subdir && 
		$subdir ne "$Dir/CVS"      &&
		$subdir ne "$Dir/macros"   &&
		$subdir ne "$Dir/examples" &&
		$subdir ne "$Dir/doc" ){
		#print "Inserting $subdir\n";
		$CPPPATH  .= $main::PATH_SEPARATOR . "#"  . $subdir;
	    }
	}
	$CPPPATH .= $main::PATH_SEPARATOR . $env->{CPPPATH};
	print "CPPPATH = $CPPPATH\n" if $param::debug;
	#$SO_PKG = $PKG . "." . $env->{SUFSOLIB};

	#print "-=-=-=-=-=-= SO_PKG = $SO_PKG\n";


    } elsif ( $pkg =~ m/^StDaqLib$/ ) {
	$CPPPATH = "#" . $Dir . $main::PATH_SEPARATOR . $env->{CPPPATH};
	print "CPPPATH = $CPPPATH\n" if $param::debug;
    } elsif ( $pkg =~ m/^gcalor$/ || $pkg =~ m/^geant321$/) {
        $LIBPKG = "lib" . $pkg . "." . $env->{SUFLIB};
	$SO_PKG = "";
	$FCPATH = "#" . $Dir . "/../geant321" .
	  $main::PATH_SEPARATOR . "#" . $Dir . "/../starsim/include" . 
	    $main::PATH_SEPARATOR . "#" . $Dir . "/../gcalor/include" . 
	      $main::PATH_SEPARATOR . $env->{FCPATH};
	$FPPFLAGS = " -DCOMMONS_CONFIG_H -DCERNLIB_LINUX -DCPP_VERS=\"'W'\"";
      } elsif ( $pkg =~ m/^g2t/ || $pkg =~ m/^gstar/ || $pkg =~ m/^geometry/ ) {
	$FCPATH .=  $main::PATH_SEPARATOR . "#asps/Simulation/starsim/include/atlsim";
      }
    if ( $#idlM > -1 ) {
	$CPPPATH = $INCLUDE . "/" . $pkg . $main::PATH_SEPARATOR . $CPPPATH;
	print "CPPPATH = $CPPPATH\n" if $param::debug;

    } elsif ( $#idlL > -1 ) {
	$CPPPATH .= $main::PATH_SEPARATOR . $INCLUDE . "/tables" . $main::PATH_SEPARATOR . "#";;
	print "CPPPATH = $CPPPATH\n" if $param::debug;
    }


    if ( $LIBPKG && $Dir =~ /pams\// || $STAR_SYS =~ /^intel_wnt$/ ) {
	$LIBS .= " -l" . $pkg;    #"lib" . $pkg . "." . $env->{SUFLIB};
    }
    if ($pkg =~ /^St_base$/) {
	if ( $STAR_SYS =~ /^hp_ux102$/) {
	    $CPPPATH .= $main::PATH_SEPARATOR . "/usr/local/include";
	}
    }
    if (($pkg eq 'StHbtMaker' or $pkg eq 'StMuDSTMaker') and $CC ne 'gcc' and $CC ne 'icc') {
# fight with __PRETTY_FUNCTION__
      $EXTRA_CPPFLAGS .= " -DDEBUGMESSAGE\\\(x\\\)=\"\"  -DDEBUGMESSAGE1\\\(x\\\)=\"\"  -DDEBUGMESSAGE2\\\(x\\\)=\"\"  -DDEBUGMESSAGE3\\\(x\\\)=\"\"  -DFORCEDDEBUGMESSAGE\\\(x\\\)=\"\"";
}
    #print "_+_+_+_+_+ $CPPPATH $CXXFLAGS $LIBS $CPPPATH $LIBPATH _+_+_+_+_+\n";

    if ( $STAR_SYS =~ /^sun4x_5.$/ ) { $CXXFLAGS .= " -ptr" . $obj_dir; }
    if ( $STAR_SYS =~ /kcc$/ ) { $LIBPATH = ""; $LIBS = ""; }
    $env2 = $env->clone('EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS,
			'CPPPATH'  => $CPPPATH,
			'CXXFLAGS' => $CXXFLAGS,
			'FC'       => $FC,
			'FFLAGS'   => $FFLAGS,
			'FCPATH'   => $FCPATH,
			'FEXTEND'  => $FEXTEND,
			'FPPFLAGS' => $FPPFLAGS,
			'FCCOM'    => $FCCOM,
			'LIBS'     => $LIBS,
			'LIBPATH'  => $LIBPATH,
			'ObjDir'   => $obj_dir
			);
#    bless $env2, "cons"; #?
#    if ($CC eq 'icc') {$EXTRA_CPPFLAGS .= " " . "-DR__NO_CLASS_TEMPLATE_SPECIALIZATION";}
    my $Cint_CPPPATH = $CPPPATH . $main::PATH_SEPARATOR . "#";
    $envCint = $env2->clone('DEBUG' => $env2->{NOOPT},
			    'CPPPATH'  => $Cint_CPPPATH,
			    'EXTRA_CPPFLAGS' => $EXTRA_CPPFLAGS);
    
    print "LIBPATH = |", $env2->{LIBPATH}, "|\n LIBS = |", $env2->{LIBS},
    "|\n CPPPATH = |", $env2->{CPPPATH}, "|\n" if $param::debug;

    print "LINKMODULECOM |", $env2->{LINKMODULECOM}, "|\n" if $param::debug;
    my $cscanner = find scan::cpp( $env2->{_cwd}, $env2->{CPPPATH} );
    my @cpps = split /$main::PATH_SEPARATOR/, $env2->{CPPPATH};

    print "@cpps\n" if $param::debug;
    my $ROOTCINT_CPP = "";
    my $STIC_CPP     = "";

    foreach my $cpp( $Dir, @cpps ) {
	if ( $cpp =~ /cern/ || $cpp eq "/usr/include" || $cpp =~ /ospace/
	     || $cpp =~ /openwin/ )
	{
	    next;
	}
	if ($ROOTCINT_CPP) { $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $cpp; }
	else { $ROOTCINT_CPP = $cpp; }
	if ( $cpp =~ /ROOT/ ) {next}
	if ($STIC_CPP) { $STIC_CPP .= $main::PATH_SEPARATOR . $cpp; }
	else { $STIC_CPP = $cpp; }
    }
    $cscanner = find scan::cpp( $env2->{_cwd}, $ROOTCINT_CPP );
    print "ROOTCINT_CPP = $ROOTCINT_CPP\n" if $param::debug;
    my $ROOTCINT_CPPPATH = $cscanner->iflags($env2);
    if ($env2->{EXTRA_CPPFLAGS}) {
      $ROOTCINT_CPPPATH .= " " . $env2->{EXTRA_CPPFLAGS}; # Requested By Frank Laue
    }
    print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n" if $param::debug;
    $cscanner = find scan::cpp( $env2->{_cwd}, $STIC_CPP );
    my $STIC_CPPPATH =
	$cscanner->iflags($env2);    # print "STIC_CPPPATH  = $STIC_CPPPATH\n";
    my $DIR = Cwd::cwd();
    print "DIR = $DIR\n" if $param::debug;
    my $line;
    my @Defs = ();
    my @QtDefs = ();

    if ( $#idlM > -1 ) {
	my $include = $INCLUDE . "/" . $pkg;
	print "include = $include\n" if $param::debug;
	foreach my $idl(@idlM) {
	    my $stem = File::Basename::basename( $idl, ".idl" );
	    print "idl = $idl  stem = $stem\n" if $param::debug;
	    my $idm  = $stem . ".idl";
	    my $idMM = $DIR . "/" . $Dir . "/" . $idl;
	    print "idMM = $idMM\n" if $param::debug;
	    my $idM = "#" . $Dir . "/" . $idl;
	    print "idM = $idM\n" if $param::debug;
	    my @idlS = ($idM);
	    my $modh = $INCLUDE . "/" . $stem . ".h";
	    my $modi = $INCLUDE . "/" . $stem . ".inc";
	    my $modH = $include . "/" . "St_" . $stem . "_Module.h";
	    print "modH = $modH\n" if $param::debug;
	    my $modC = "St_" . $stem . "_Module.cxx";
	    print "modC = $modC\n" if $param::debug;

	    if ( $STAR_SYS !~ /^intel_wnt$/ ) {
	      my $stic_cmd = 
		  "mkdir /tmp/\$\$ && cd /tmp/\$\$ && ".
		  "stic -s -r $STIC_CPPPATH -q %<:a && mv %>:f %>:a && ".
		  "cd /tmp  &&  rm -rf /tmp/\$\$";
	      Command $env2 [$modh], @idlS, qq($stic_cmd);
	      Command $env2 [$modi], @idlS, qq($stic_cmd);
	      Command $env2 [$modH], @idlS, qq($stic_cmd);
	      Command $env2 [$modC], @idlS, qq($stic_cmd);
	    }
	    my @objmod = ($modC);
	    print "Install @objmod in $ObjDir\n" if $param::debug;
	    push @src, $modC;
	    print "src + $mod: @src\n" if $param::debug;
	    push @Defs, $modH;
	}
    } else {
	foreach $h(@h_files) {
	    if ( $h =~ /LinkDef/ || $h =~ /Stypes/ ) { push @Defs, $h; next; }
	    my $hh = $Dir . "/" . $h;
	    if ( -r $hh ) {
		open( In, $hh ) or die "Can't open $hh";
		my $classDefFlag = 1;
		my $qtFlag       = 1;
		while ( $line = <In> ) {
		    if ( ( $line =~ /ClassDef/ || $line =~ /StCollectionDef/) ) {
			push @Defs, $h; # print "$h <==========\n";
			$classDefFlag = 0;
		    } elsif ( $line =~ /Q_OBJECT/ && defined($env->{Packages}->{QT}->{BINDIR}) ) {
			push @QtDefs, $h;
			$qtFlag = 0;
		    }
		    next if ( $classDefFlag + $qtFlag == 0 );
		}
		close(In);
		
	    } else {
		
		foreach my $Rep(@Repo) {
		    my $RepDir = $Rep . "/" . $Dir;
		    print "RepDir = $RepDir\n" if $param::debug;
		    if ( -d $RepDir ) {
			my $hh = $RepDir . "/" . $h;
			if ( -r $hh ) {
			    open( In, $hh ) or die "Can't open $hh";
			    
			    while ( $line = <In> ) {
				if ( $line =~ /ClassDef/
				     || $line =~ /StCollectionDef/ )
				{
				    push @Defs, $h;
				    goto ENDL;
				}
			    }
			    close(In);
			}
		    }
		}
	    }
	  ENDL:
	}
    }

    if ( $#Defs > -1 ) {
	my @CintFiles = ( $PKG . "_Cint.cxx", $PKG . "_Cint.h" );
	@Defs = script::sortu(@Defs);
	my @defs = ();
	foreach my $def(@Defs) {    #print "def = $def OBJ = $OBJ\n";
	    if ( $def =~ /^\#/ ) { push @defs, $def; }
	    else { push @defs, "#" . $Dir . "/" . $def; }
	}
	Command $env2 [@CintFiles], @defs,
	  qq(RootCint.pl "%>" "%<" "$ROOTCINT_CPPPATH" );
	my @objfiles = Objects $envCint ($CintFiles[0]);#
#	push @src, $CintFiles[0];
	push @src, @objfiles[0];
	print "+==========add $cint\n" if $param::debug;
    }

    if ( $#QtDefs > -1 ) {
	my $mocheaders = join $main::PATH_SEPARATOR, @QtDefs;
	my @mocs = script::MakeMoc( $env2, $pkg, $done, $mocheaders);
	foreach $m(@mocs) { push @src, $m;}
    }
}
#____________________________________Tables____________________________
# Tables:

my @sourcesT = ();

if ( $#idlL > -1 ) {
    my @idlT = ();
    my $objT = $OBJ . "/pams/tables";
    ( my $objT_dir = $objT ) =~ s/^\#//g;
    print "objT_dir = $objT_dir\n" if $param::debug;
    my $includeT = $INCLUDE . "/tables";
    print "includeT = $includeT\n" if $param::debug;

    foreach my $idl(@idlL) {
        print "$idl\n" if $param::debug;
        my $IDL =
          "#" . $Dir . "/" . $idl;    # print "i=",$i++," idl = $idl IDL=$IDL\n";
        my $stem = File::Basename::basename( $IDL, ".idl" );
        print "stem = $stem\n" if $param::debug;
        my $idlt = $includeT . "/" . File::Basename::basename($idl);
        push @idlT, $IDL;
    }
    print "idlT = @idlT\n" if $param::debug;

    if ( $#idlT > -1 ) {
        $PKGT    = "lib" . $pkg . "_Tables";
        $SO_PKGT = $PKGT . "." . $env->{SUFSOLIB};
        print "SO_PKGT = $SO_PKGT\n" if $param::debug;
        my $LIBPKGT = $PKGT . "." . $env->{SUFLIB};

        if ( $Dir =~ /StRoot\// ) {
            $SO_PKGT = $SO_PKG;
            $LIBPKGT = $LIBPKG;
        } else {
            printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir,
		    $PKGT )
		unless ($param::quiet);
        }
#        Install $env $INCLUDE, @idlT;  # print "Install $env $INCLUDE, @idlT\n";

        #___________________________________
        my $ROOTCINT_CPP =
	    $INCLUDE . $main::PATH_SEPARATOR . $INCLUDE . "/tables";
        $ROOTCINT_CPP .= $main::PATH_SEPARATOR . $env->{ENV}->{ROOTSRC};

        my $tobj_dir = $obj_dir . "/Tables";
        $CPPPATH =
	    $env->{CPPPATH} . $main::PATH_SEPARATOR . $INCLUDE . "/tables" . $main::PATH_SEPARATOR . "#";
        $env3 = $env->clone('DEBUG'   => $env->{NOOPT},
			    'CPPPATH' => $CPPPATH,
			    'ObjDir'  => $tobj_dir
         );
       my $cscanner =
	    find scan::cpp( $env->{_cwd}, $ROOTCINT_CPP );
        my $ROOTCINT_CPPPATH = $cscanner->iflags($env3); #print "ROOTCINT_CPPPATH = $ROOTCINT_CPPPATH\n"; die;
        foreach my $idll(@idlT) {
            my $stem = File::Basename::basename( $idll, ".idl" );
            print "stem = $stem; idll: $idll\n" if $param::debug;
            my $dir = File::Basename::dirname($idll);
            print "dir = $dir\n" if $param::debug;
            my $idl  = File::Basename::basename($idll);
            my $idlh = $INCLUDE . "/" . $stem . ".h";
            print "idlh: $idlh\n" if $param::debug;
            my $idli = $INCLUDE . "/" . $stem . ".inc";
            print "idli: $idli\n" if $param::debug;
            my $idlH = $includeT . "/St_" . $stem . "_Table.h";
            print "idlH: $idlH\n" if $param::debug;
            my $idlC = "St_" . $stem . "_Table.cxx";
            print "idlC: $idlC\n" if $param::debug;
            my $LinkDef = $stem . "LinkDef.h";
            print "LinkDef = $LinkDef\n" if $param::debug;
            my $idlCintH = "St_" . $stem . "_TableCint.h";
            print "idlCintH = $idlCintH\n" if $param::debug;
            my $idlCintC = "St_" . $stem . "_TableCint.cxx";
            print "idlCintC = $idlCintC\n" if $param::debug;
            ( my $IDL = $idll ) =~ s/^\#//g;
            print "IDL = $IDL\n" if $param::debug;

            if ( -r $IDL ) {
                my @Deps = ($idll);
                print "Deps: $Deps[0]\n" if $param::debug;
                if ( $STAR_SYS !~ /^intel_wnt$/ ) {
		    my $stic_cmd  = 
			"mkdir -p /tmp/\$\$ && cd /tmp/\$\$ && ".
			"stic -q %<:a && ".
			"(mv %>:f %>:a ; cd /tmp ; rm -rf /tmp/\$\$)";
                    Command $env3 [$idlh], @Deps, qq ($stic_cmd);
                    Command $env3 [$idli], @Deps, qq ($stic_cmd);
                    push @Deps, $idlh;
                    Command $env3 [$idlH], @Deps, qq (ConstructTable.pl %1 %>);
                    push @Deps, $idlH;
                    Command $env3 [$idlC], @Deps, qq (ConstructTable.pl %1 %>);
                    Command $env3 [$LinkDef], @Deps,
                      qq (ConstructTable.pl %1 %>);
                }
                @Deps = ();
                push @Deps, $idlH;
                push @Deps, $LinkDef;
                push @Deps, $idlh;
                push @Deps, $idli;

                if ( $STAR_SYS !~ /^intel_wnt$/ ) {
                    Command $env3 [ ($idlCintC , $idlCintH) ], @Deps,
		    qq (rootcint -f %> -c $ROOTCINT_CPPPATH -D__ROOT__ %1 %2);
                }
                push @Deps, $idlCintC;
                push @Deps, $idlCintH;
                push @Deps, $idlC;
                my @src = ( $idlC, $idlCintH, $idlCintC );
                Install $env3 $objT, @src; 
            }
            my $s;

            if ( $SO_PKGT eq $SO_PKG ) {
	       push @src,$idlC;
	       push @src, $idlCintC;
            } else {
	      push @sourcesT, $idlC;
	      push @sourcesT, $idlCintC;
            }
        }
        print "sourcesT = @sourcesT\n" if $param::debug;
    }
}

if ( $#sourcesT > -1 ) {
    script::Keep $SO_PKGT;
    LinkedModule $env3 $SO_PKGT, @sourcesT;
    Install $env3 $LIB, $SO_PKGT;
}

if ( $#src > -1 ) {
    printf( "Run Conscript-standard in %-30s  for %-20s\n", $Dir, $PKG )
      unless ($param::quiet);
    if ($LIBPKG) {
        Library $env2 $LIBPKG, @src;
        Install $env2 $LIB,    $LIBPKG;
        print "Install $env2 $LIB, $LIBPKG\n" if $param::debug;
	if ($SO_PKG) {
	  my $libpkg = $LIB . "/" . File::Basename::basename($LIBPKG);
	  Depends $env2 $SO_PKG, $libpkg;
	}
    }
    if ($SO_PKG) {
      script::Keep $SO_PKG;
      LinkedModule $env2 $SO_PKG, @src;
      Install $env2 $LIB,         $SO_PKG;
    }
    if ( $pkg eq "Star2Root" or $pkg eq "St_base" or $pkg eq "StUtilities" ) {
        my $lib = $LIB . "/lib" . $SO_PKG;
        InstallAs $env2 $lib, $SO_PKG;
    }
}

#_________________________________________________________________________________
sub script::MakeMoc {
    my $env  = shift;
    my $pkg  = shift;
    my $done = shift;
    my @includes = split $main::PATH_SEPARATOR,shift;
    my $Dir  = $env->{Dir};
    my $ROOTCINTFLAGS = "-I" . $Dir . "/inc";
    my @src      = ();
    my @Defs     = ();
    my $PLATFORM = $env->{PLATFORM};
    foreach my $header (@includes) {
	my $dd = $d;
	my $G__name = "moc_" . $header;
	$G__name =~ s/\.h$/\.cxx/; 
	my $moc = $env->{Packages}->{QT}->{BINDIR} . "/moc";
	Command $env ($G__name), ($header), qq($moc -o %>  %<);
	push @src, $G__name;
	print "+==========add moc file: $G__name\n" if $param::debug;
    }
    return @src;
}
#____________________________________________________________
sub script::alpha_arcom { # 
  my ($lib,$src) = @_;
  my $input = "input" . File::Basename::dirname($lib);
  open (OUTPUT, ">$input") or die "Can't open $input\n";
  print OUTPUT $src;
  close(OUTPUT);
  my $cmd = "ar $lib -input $input'; ranlib $lib"; print "$cmd\n";
  my $flag = `$cmd`; if ($?) {exit 2;}
  return 1;
}

#_________________________________________________________________________________
		     
